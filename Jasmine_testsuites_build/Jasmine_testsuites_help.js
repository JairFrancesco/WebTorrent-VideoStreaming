(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
window.OakStreaming = require('./OakStreaming');
window.http = require('http');
window.WebTorrent = require('webtorrent');


document.body = document.createElement("body");

var para = document.createElement("video");
para.id = "myVideo";
para.style.display = "none";
document.body.appendChild(para);

para = document.createElement("p");
para.id = "WebTorrent-received";
para.style.display = "none";
document.body.appendChild(para);

window.myStreamingA = new OakStreaming("myStreamingA");
window.myStreamingB = new OakStreaming("myStreamingB");
window.myStreamingC = new OakStreaming("myStreamingC");
},{"./OakStreaming":2,"http":99,"webtorrent":130}],2:[function(require,module,exports){
var http = require('http');
var MultiStream = require('multistream');
var util = require('util');
var readableStream = require('readable-stream');
var Videostream = require('videostream');
var ut_pex = require('ut_pex');
var WebTorrent = require('webtorrent');
var SimplePeer = require('simple-peer');
var parseTorrent = require('parse-torrent');


 /**
 * @module FVSL
 */
module.exports = FVSL;


 /**
 * Creates a new FVSL instance which has the methods streamVideo, loadVideo, createSignalingData, createSignalingDataResponse, processSignalingResponse and several simple get methods  
 * @constructor
 */ 
function FVSL(OakName){
   var self = this;
   (function(){
      var peerId = Math.floor(Math.random() * Math.pow(10,300) + 1);   
      console.log("Version: Headhunter   In OakStreaming constructor. this.name: " + OakName);
      var OakName = OakName || "NoName FVSL instance";
      
      // Only methods should be part of the API, i.e. only methods should be publically accessible.
      // Every method should have access to these variables. Therefore they are definied at this high scope.
      var simplePeerCreationCounter = 0;
      var connectionsWaitingForSignalingData = [];
      var theTorrent = null;
      var peersToAdd = [];
      var bytesReceivedFromServer = 0;
      var notificationsBecauseNewWires = 0;
      var SIZE_OF_VIDEO_FILE = -42;
      
      self.streamVideo = streamVideo;
      self.loadVideo = loadVideo;
      self.forTesting_connectedToNewWebTorrentPeer = null;
                
      self.getNumberOfBytesDownloadedFromServer = function(){
         return bytesReceivedFromServer;
      };
      
      self.getNumberOfBystesDownloadedP2P = function(){
         if(theTorrent){
            return theTorrent.downloaded;
         } else {
            return 0;
         }
      };
      
      self.getNumberOfBytesUploadedP2P = function(){
         if(theTorrent){
            return theTorrent.uploaded;
         } else {
            return 0;
         }
      };
      
      self.getPercentageDownloadedTorrent = function(){
         if(theTorrent){
            return theTorrent.progress;
         } else {
            return 0;
         }
      };
      
      self.getFileSize = function(){
         return SIZE_OF_VIDEO_FILE;
      };
      
      self.createSignalingData = function (callback){
         var alreadyCalledCallback = false;
         var oakNumber = simplePeerCreationCounter;
         console.log("In createSignalingData for oakNumber: " + oakNumber);
         connectionsWaitingForSignalingData[oakNumber] = new SimplePeer({initiator: true, tickle: false});
         simplePeerCreationCounter++;
         
         connectionsWaitingForSignalingData[oakNumber].on('signal', function (signalingData){
            if(!alreadyCalledCallback){
               alreadyCalledCallback = true;
               signalingData.oakNumber = oakNumber;
               callback(signalingData);
            }
         });
      };
      
      self.createSignalingDataResponse = function (signalingData, callback){
         var oakNumber = signalingData.oakNumber;
         console.log("In createSignalingDataResponse. In the beginning oakNumber: " + oakNumber);
         delete signalingData.oakNumber;
         
         var myPeer = new SimplePeer({initiator: false, tickle: false});
         var index = simplePeerCreationCounter;
         connectionsWaitingForSignalingData[index] = myPeer;
         simplePeerCreationCounter++;
         
         myPeer.on('signal', function (answerSignalingData){
            console.log("In createSignalingDataResponse, after onSignal oakNumber: " + oakNumber);
            answerSignalingData.oakNumber = oakNumber;
            console.log("In createSignalingDataResponse,  object that is returned with callback: " + JSON.stringify(answerSignalingData));
            callback(answerSignalingData);
         });
         myPeer.signal(signalingData);
         
         var self = this;
         myPeer.on('connect', function(){
            self.addSimplePeerInstance(connectionsWaitingForSignalingData[index], {}, function(){console.log("addSimplePeerInstance ended");});
         });
      };
      
      self.processSignalingResponse = function (signalingData, callback){
         console.log("In processSignalingResponse,  signalingData paramter: " + JSON.stringify(signalingData));
         var oakNumber = signalingData.oakNumber;
         delete signalingData.oakNumber;
         console.log("In processSignalingResponse,  oakNumber: " + oakNumber);
         console.log("connectionsWaitingForSignalingData: " + connectionsWaitingForSignalingData);
         var self = this;
         (connectionsWaitingForSignalingData[oakNumber]).on('connect', function (){
            console.log('Established a simple-peer connection');
            self.addSimplePeerInstance(connectionsWaitingForSignalingData[oakNumber]);
            connectionsWaitingForSignalingData[oakNumber] = undefined;
            callback();
         });
         console.log("In processSignalingResponse,  object that is passed to .signal(): " + JSON.stringify(signalingData));
         connectionsWaitingForSignalingData[oakNumber].signal(signalingData);
      };
       
       /**
       * @typedef StreamInformationObject
       * @type {object}
       * @property {string} magnetURI - Magnet URI of the torrent. If this property is undefined, no video data will be requested from the WebTorrent network.
       * @property {number} videoFileSize - The size in byte of the video file that was passed as an argument.
       * @property {string} XHRPath - The file path (e.g. /example.mp4 or /videos/example2.mp4) that will be used for the XML HTTP Requests to the Web server. Via these XML HTTP Requests, video data will be requested from the Web sever. If this property is undefined, no video data will be requested from the Web server.
       */
       
      /**
       * @callback OakStreaming~streamVideoFinished
       * @param {StreamInformationObject} streamInformationObject - An object that other clients/peers can pass as an argument to their loadVideo method to download the video from other clients/peers and/or the Web Server.
       */ 

      /**
       * Streams a video file to all other clients/peers.
       * @param {object} video_file - The video file that should be streamed to the other clients/peers. This paramter can either be a {@link https://developer.mozilla.org/en-US/docs/Web/API/File|W3C File object}, a {@link https://developer.mozilla.org/en-US/docs/Web/API/FileList|W3C FileList}, a {@link https://nodejs.org/api/buffer.html|Node Buffer object} or a {@link https://nodejs.org/api/stream.html#stream_class_stream_readable|Readable stream object}.
       * @param {object} [options] - Options for the creation of the StreamInformationObject, that gets passed as an argument to the callback function.
       * @param {string} options.path_to_file_on_XHR_server - The path that will be used for the XML HTTP Request (XHR). A valid path would be, for example, "/videos/aVideoFile.mp4". It is not necessary to set both the pathToFileOnXHRServer and the hashValue paramter for successfull XHR requests. If this property and the hashValue property is undefined, no video data will be requested from the server.
       * @param {string} options.hash_value - Hash value of the video file that should by requested from the SVSL WebServer. It is not necessary to set both the pathToFileOnXHRServer and the hashValue paramter for successfull XHR requests. If this property and the hashValue property is undefined, no video data will be requested from the server. 
       * @param {string} options.XHR_server_URL - URL of a XHR server that can serve the video file. If this property is not set, XHR will be send to the Web server that served the Web page.
            * @param {string} options.XHR_port - Port that will be used when communicating with the XHR server that was specified in the XHRServerURL property. This property should only be set when the XHRServerURL property is set too. The default value is 80.
                   * @param {string} options.download_from_p2p_time_range - How many seconds of video playback must be buffered in advance such that no more data streams are requested from the WebTorrent network. The default value is 20 seconds.
                   * @param {string} options.create_readStream_request_size - The size of the byte range requests to the WebTorrent network. The default value is 5000000 bytes.
                         
       * @param {OakStreaming~streamVideoFinished} callback - This callback function gets called with the generated StreamInformationObject at the end of the execution of streamVideo.
       */
      function streamVideo(video_file, options, callback, returnTorrent, destroyTorrent){ 
         var webTorrentClient = new WebTorrent();
         //console.log("streamVideo is executed");
         //console.log("videoFile: " + videoFile);
         //console.log("options: " + options);
         //console.log("callback: " + callback);

         var DOWNLOAD_FROM_P2P_TIME_RANGE = streamInformationObject.downloadFromP2PTimeRange || 20; // how much seconds must be buffered in advance such that no more data streams are requested from the P2P network                  Old Describtion: This is the minomum byte range that the WebTorrent client will download in advance (regarding the current playback position) with a sequential chunk selection strategy. This means the video buffer size in byte
         var CREATE_READSTREAM_REQUEST_SIZE = streamInformationObject.createReadstreamRequestSize || 5000000; // The size of the createReadstream WebTorrent requests in bytes. 
         
         var DOWNLOAD_FROM_SERVER_TIME_RANGE = streamInformationObject.downloadFromServerTimeRange || 5; // in seconds
         var UPLOAD_LIMIT = streamInformationObject.uploadLimit || 2; // multiplied by number of downloaded bytes
         var ADDITION_TO_UPLOAD_LIMIT = streamInformationObject.additionToUploadLimit || 500000; // amount of byte added to upload limit
         
          
         var streamInformationObject = {};
         streamInformationObject.downloadFromP2PTimeRange = options.downloadFromP2PTimeRange;
         streamInformationObject.pathToFileOnXHRServer = options.pathToFileOnXHRServer;
         streamInformationObject.XHRPort = options.XHRPort;
         streamInformationObject.hashValue = options.hashValue; 
         
         //var SIZE_OF_VIDEO_FILE = streamInformationObject.sizeOfVideoFile;
             
         if(videoFile){
            var seedingOptions = {};
            if(options.webTorrentTrackers){
               seedingOptions.announceList = options.webTorrentTrackers;
               //seedingOptions.announce = options.webTorrentTrackers; // nur zum test
            }
            
            var self = this; 
            webTorrentClient.seed(videoFile, seedingOptions, function(torrent){
               console.log("torrent file is seeded");
               
               var torrentFileAsBlobURL = torrent.torrentFileBlobURL;
               var xhr = new XMLHttpRequest();
               var XHROrMethodEndHappend = false;
               xhr.open('GET', torrentFileAsBlobURL, true);
               xhr.responseType = 'blob';
               xhr.onload = function(e) {
                 if (this.status == 200) {
                   streamInformationObject.torrentAsBlob = this.response;
                   if(XHROrMethodEndHappend){
                      callback(streamInformationObject);
                   } else {
                      XHROrMethodEndHappend = true;
                   }
                   // myBlob is now the blob that the object URL pointed to.
                 }
               };
               xhr.send();
               streamInformationObject.videoFileSize = torrent.files[0].length;
               //streamInformationObject.torrentFile = torrent.torrentFile;
               //console.log("Buffer.isBuffer(streamInformationObject.torrentFile): " + Buffer.isBuffer(streamInformationObject.torrentFile));
               //console.log("streamInformationObject.torrentFile  stringified: \n" + JSON.stringify(streamInformationObject.torrentFile));
               //console.log("parseTorrent(streamInformationObject.torrentFile): \n" + parseTorrent(streamInformationObject.torrentFile));
               streamInformationObject.parsedTorrent =  parseTorrent(torrent.torrentFile);
               console.log(JSON.stringify(streamInformationObject.parsedTorrent));
               //console.log("THE_RECEIVED_TORRENT_FILE\n" + parseTorrent(THE_RECEIVED_TORRENT_FILE));
               var bufferTorrent = parseTorrent(streamInformationObject.parsedTorrent); 
               streamInformationObject.pathToFileToSeed = options.pathToFileToSeed;
               
               //if(options.webTorrentTrackers){ Schauen ob es auch ohne if block drum herum läuft
                  streamInformationObject.magnetURI = torrent.magnetURI;
                  streamInformationObject.webTorrentTrackers = options.webTorrentTrackers;
               //}
               
               console.log("In streamVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets created");
               self.forTesting_connectedToNewWebTorrentPeer = function(callback){
                  console.log("In streamVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets executed");
                  if(notificationsBecauseNewWires <= 0){
                     notificationsBecauseNewWires--;
                     var callbackCalled = false;
                     
                     torrent.on('wire', function(wire){
                        if(!callbackCalled){
                           callback();
                           callbackCalled = true;
                        }
                     });
                  } else {
                     notificationsBecauseNewWires--;            
                     callback();
                  }
               };
               
               torrent.on('wire', function (wire){
                  notificationsBecauseNewWires++;  
               });          
                        
               console.log("Creaded streamInformationObject:\n" + JSON.stringify(streamInformationObject));
               if(returnTorrent === "It's a test"){
                  if(destroyTorrent){
                     notificationsBecauseNewWires = 0;
                     torrent.destroy();
                     delete webTorrentClient;
                  }
                  callback(streamInformationObject, torrent);
               } else {
                  callback(streamInformationObject);
                  return streamInformationObject;
               }
            });
         } else {
            if(XHROrMethodEndHappend){
               callback(streamInformationObject);
            } else {
                XHROrMethodEndHappend = true;
            }
         }  
      }


      /**
       * @callback OakStreaming~loadedVideoFinished
       */ 
       
      /**
       * Streams a video file to all other clients/peers.
       * @param {StreamInformationObject} streamInformationObject - This object contains all data that is needed to initiate loading the video from other peers and/or a Web server. StreamInformationObjects can be created by the {@link streamVideo|streamVideo} method.
       * @param {OakStreaming~loadedVideoFinished} callback - This callback gets called when the video has been loaded entirely into the buffer of the video player.
       */
      function loadVideo(streamInformationObject, callback, endIfVideoLoaded){         
         console.log("loadVideo is called");
         //////console.log("option paramter:\n" + JSON.stringify(streamInformationObject));
         var deliveryByServer = (streamInformationObject.pathToFileOnXHRServer || streamInformationObject.hashValue) ? true : false;
         var deliveryByWebtorrent = streamInformationObject.parsedTorrent ? true : false;
         var XHRServerURL = streamInformationObject.XHRServerURL || false;
         //console.log("streamInformationObject.XHRServerURL: " + streamInformationObject.XHRServerURL);
         var XHR_PORT = streamInformationObject.XHRPort || 80;
         var pathToFileOnXHRServer = streamInformationObject.pathToFileOnXHRServer;       
         var hashValue = streamInformationObject.hashValue;
         var webTorrentTrackers = streamInformationObject.webTorrentTrackers;
         //var deliveryByWebtorrent = streamInformationObject.magnetURI ? true : false;
         var MAGNET_URI = streamInformationObject.magnetURI;
         //console.log("Buffer.isBuffer(streamInformationObject.torrentFile.data): " + Buffer.isBuffer(streamInformationObject.torrentFile.data));
         //console.log("streamInformationObject.torrentFile:\n" + JSON.stringify(streamInformationObject.torrentFile));
         var THE_RECEIVED_TORRENT_FILE = streamInformationObject.parsedTorrent;
         
         //console.log("THE_RECEIVED_TORRENT_FILE:\n" + JSON.stringify(THE_RECEIVED_TORRENT_FILE));
         //console.log("Buffer.isBuffer(THE_RECEIVED_TORRENT_FILE): " + Buffer.isBuffer(THE_RECEIVED_TORRENT_FILE));
         
         //console.log("THE_RECEIVED_TORRENT_FILE\n" + parseTorrent(THE_RECEIVED_TORRENT_FILE));
         var SIZE_OF_VIDEO_FILE = streamInformationObject.sizeOfVideoFile;

         var DOWNLOAD_FROM_P2P_TIME_RANGE = streamInformationObject.downloadFromP2PTimeRange || 20; // how much seconds must be buffered in advance such that no more data streams are requested from the P2P network                  Old Describtion: This is the minomum byte range that the WebTorrent client will download in advance (regarding the current playback position) with a sequential chunk selection strategy. This means the video buffer size in byte
         var CREATE_READSTREAM_REQUEST_SIZE = streamInformationObject.createReadstreamRequestSize || 50000000; // The size of the createReadstream WebTorrent requests in bytes. 
         
         var DOWNLOAD_FROM_SERVER_TIME_RANGE = streamInformationObject.downloadFromServerTimeRange || 5; // in seconds
         var UPLOAD_LIMIT = streamInformationObject.uploadLimit || 2; // multiplied by number of downloaded bytes
         var ADDITION_TO_UPLOAD_LIMIT = streamInformationObject.additionToUploadLimit || 500000; // amount of byte added to upload limit
         
         
         var XHR_REQUEST_SIZE = streamInformationObject.xhrRequestSize || 50000; // in byte
         var THRESHOLD_FOR_RETURNING_OF_ANSWER_STREAM = streamInformationObject.thresholdForReturningAnswerStream || 50000; // in byte

         var CHECK_IF_BUFFER_FULL_ENOUGH_INTERVAL = streamInformationObject.checkIfBufferFullEnoughInterval || 300; // in miliseconds
         var CHECK_IF_ANSWERSTREAM_READY_INTERVAL = streamInformationObject.checkIfAnswerstreamReadyInterval || 200; // in miliseconds
         var UPDATE_CHART_INTERVAL = streamInformationObject.updateChartInterval || 1000; // in miliseconds
         var CHOKE_IF_NECESSARY_INTERVAL = streamInformationObject.chokeIfNecessaryInterval || 500; // in miliseconds
         var CHECK_IF_NEW_CREATE_READSTREAM_NECESSARY_INTERVAL = streamInformationObject.checkIfNewCreateReadstreamInterval || 500 ;
         
         var self = this;
         var endStreaming = false;
         var webTorrentClient = null;
         var wires = [];
         var consoleCounter = 0;
         var globalvideostreamRequestNumber = 0;
         bytesReceivedFromServer = 0;
         var webTorrentFile;
         var videostreamRequestHandlers = [];
         var inCritical = true;
         var videoCompletelyLoaded = false;
         var bytesTakenFromWebTorrent = 0;
         var bytesTakenFromServer = 0;   
         
         
         var myVideo = document.querySelector('video');
         myVideo.addEventListener('error', function (err){
            console.error(myVideo.error);
         });
         
         function MyReadableStream(options){
            readableStream.Readable.call(this, options);
         }
         util.inherits(MyReadableStream, readableStream.Readable);
         MyReadableStream.prototype._read = function(size){};
         
        
         if(deliveryByWebtorrent){
            console.log("entered if(deliveryByWebtorrent)");
            webTorrentClient = new WebTorrent();
                
            //THE_RECEIVED_TORRENT_FILE 
           
            var webTorrentOptions = {};
            /* Weiß nicht mehr warum das hier steht
            if(streamInformationObject.pathToFileToSeed){
               webTorrentOptions.path = streamInformationObject.pathToFileToSeed;
            }
            */
            var url = URL.createObjectURL(streamInformationObject.torrentAsBlob);
            
            webTorrentClient.add(url, webTorrentOptions, function (torrent){              
               console.log("webTorrentClient.add   torrent meta data ready");         
               theTorrent = torrent;
               webTorrentFile = torrent.files[0];
               
               for(var j=0; j< peersToAdd.length; j++){
                  theTorrent.addPeer(peersToAdd[j][0]);
                  if(peersToAdd[j][1]){
                     (peersToAdd[j][1])();
                  }
               } 
                            
               //console.log("In loadVideo typeof webTorrentFile after assignment: " + typeof webTorrentFile);

               console.log("In loadVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets created");
               self.forTesting_connectedToNewWebTorrentPeer = function(callback){
                  console.log("In loadVideo     " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer   gets called");
                  if(notificationsBecauseNewWires <= 0){
                     notificationsBecauseNewWires--;
                     var callbackCalled = false;
                     
                     torrent.on('wire', function(wire){
                        if(!callbackCalled){
                           callback();
                           callbackCalled = true;
                        }
                     });
                  } else {
                     notificationsBecauseNewWires--;            
                     callback();
                  }
               };
               
               torrent.on('wire', function (wire){
                  console.log("torrent.on('wire', ..) is fired");
                  wires.push(wire);
                  if(!window.firstWire){
                     window.firstWire = wire;
                  }
                  notificationsBecauseNewWires++;
                  
                  
                  wire.use(ut_pex());
                  //wire.ut_pex.start();
                  
                  /*
                  wire.ut_pex.on('peer', function (peer){
                     theTorrent.addPeer(peer);
                     // got a peer
                     // probably add it to peer connections queue
                  });
                  */
               });

               for(var i=0, length=videostreamRequestHandlers.length; i<length; i++){
                  var thisRequest = videostreamRequestHandlers[i];
                  if(thisRequest.currentCB !== null){
                     //console.log("In onTorrent nachträglich webtorrent stream erzeugen  thisRequest.start: " + thisRequest.start);
                     //console.log("In onTorrent  webTorrentFile.length: " + webTorrentFile.length);
                                 
                     var endCreateReadStream;
                     if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE > webTorrentFile.length-1){
                        endCreateReadStream = webTorrentFile.length-1;
                     } else {
                        endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                     }
                         
                     thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                     /*
                     thisRequest.on('end', function(){
                        if(thisRequest.currentCB !== null && thisRequest.start > thisRequest.lastEndCreateReadStream && thisRequest.start < thisRequest.videoFileSize){
                           var endCreateReadStream;
                           if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                              endCreateReadStream = webTorrentFile.length-1;
                           } else {
                              endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                           }                
                           thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                           thisRequest.oldStartWebTorrent = thisRequest.start;
                           thisRequest.webTorrentStream.unpipe();
                           thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                        }             
                     });
                     */
                     thisRequest.oldStartWebTorrent = thisRequest.start;
                     thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                  }
               }
            });
         }
         
         
         
         var fileLikeObject = function (pathToFileOnXHRServer){
            this.pathToFileOnXHRServer = pathToFileOnXHRServer;
         };
         fileLikeObject.prototype.createReadStream = function (opts){
            if(opts.start > SIZE_OF_VIDEO_FILE){
               //console.log("opts.start > SIZE_OF_VIDEO_FILE there cb(null,null) every time");
               return (new MultiStream(function (cb){cb(null, null);}));
            }
            inCritical = true;
            //console.log(consoleCounter++ + " called createreadStream ");
            //console.log(consoleCounter++ + " opts.start: " + opts.start);
            //console.log(consoleCounter++ + " opts.end: " + opts.end);

            var thisRequest = new VideostreamRequestHandler(++globalvideostreamRequestNumber, opts, this);
           
            if(opts.end && !isNaN(opts.end)){
               thisRequest.end = opts.end + 1;
            } else {
               thisRequest.end = SIZE_OF_VIDEO_FILE;
            }
            
            var MyWriteableStream = function(highWaterMark){
               readableStream.Writable.call(this, highWaterMark);
            };
            util.inherits(MyWriteableStream, readableStream.Writable);
            MyWriteableStream.prototype._write = function(chunk, encoding, done){
               //console.log("MyWriteableStream _write is called");       
               if(thisRequest.start-thisRequest.oldStartWebTorrent < chunk.length){
                  ////////console.log("MyWriteableStream _write: pushing received data in answerStream")
                  bytesTakenFromWebTorrent += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
                  var streamHasMemoryLeft = thisRequest.answerStream.push(chunk.slice(thisRequest.start-thisRequest.oldStartWebTorrent, chunk.length));
                  thisRequest.bytesInAnswerStream += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
                  
                  if(streamHasMemoryLeft){            
                     if(thisRequest.currentCB !== null && thisRequest.start >= thisRequest.end){
                        var theCallbackFunction = thisRequest.currentCB;
                        thisRequest.currentCB = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                        theCallbackFunction(null, res);
                     }
                  } else {
                     if(thisRequest.currentCB === null){
                        if(thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                        thisRequest.noMoreData = true;
                     } else {
                        var theCallbackFunction = thisRequest.currentCB;
                        thisRequest.currentCB = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                        theCallbackFunction(null, res);
                     }
                  }
                     thisRequest.start += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
               }
               //ceckIfAnswerStreamReady(thisRequest);
               thisRequest.oldStartWebTorrent += chunk.length;
               done();
            };
            thisRequest.collectorStreamForWebtorrent = new MyWriteableStream({highWaterMark: 50000000});
            videostreamRequestHandlers.push(thisRequest);

            if(webTorrentFile && theTorrent.uploaded <= UPLOAD_LIMIT * theTorrent.downloaded + ADDITION_TO_UPLOAD_LIMIT){
               ////////console.log("after new videostreamRequest creating a corresponding webtorrent stream");
               ////console.log("opts.start: " + opts.start);
               ////console.log("webTorrentFile.length: " + webTorrentFile.length);
                
               var endCreateReadStream;
               if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                  endCreateReadStream = webTorrentFile.length-1;
               } else {
                  endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
               }
               thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
               thisRequest.lastEndCreateReadStream = endCreateReadStream;
               thisRequest.oldStartWebTorrent = thisRequest.start;
               
               thisRequest.webTorrentStream.unpipe();
               thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
            }

            var multi = new MultiStream(function (cb){
               //console.log("ReadableStream request number " + thisRequest.readStreamNumber + "    does a cb request");
              
               if(thisRequest.end >= 0 && thisRequest.start >= thisRequest.end){
                  //console.log("called cb(null,null) from " + thisRequest.readStreamNumber); 
                  thisRequest.req = null;
                  return cb(null, null);
               }
              
               thisRequest.CBNumber++;
               if(consoleCounter<20){
                  //////console.log(consoleCounter++ + "    " + thisRequest.CBNumber + ". call of function(cb) from " + videostreamRequestNumber);
                  ////////console.log(consoleCounter++ + "    start: " + thisRequest.start);
               }
               thisRequest.currentCB = cb;
               thisRequest.noMoreData = false;
            
               if(!ceckIfAnswerStreamReady(thisRequest)){
                  if(thisRequest.webTorrentStream){
                     thisRequest.webTorrentStream.resume();
                  } else if(webTorrentFile){
                     ////////console.log("New cb function was called and I subsequently create a new torrentStream for it because non existed before for this videostreamRequest");
                     ////console.log("After new Multistream. thisRequest.start: " + thisRequest.start);
                     ////console.log("webTorrentFile.length: " + webTorrentFile.length);
                     var endCreateReadStream;
                     if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                        endCreateReadStream = webTorrentFile.length-1;
                     } else {
                        endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                     }
                     thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                     thisRequest.lastEndCreateReadStream = endCreateReadStream;
                     thisRequest.oldStartWebTorrent = thisRequest.start;
                     
                     thisRequest.webTorrentStream.unpipe();
                     thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                  }

                  if(deliveryByServer && inCritical && !thisRequest.XHRConducted){
                     conductXHR(thisRequest);
                  }
               }
            });
            ////////console.log(consoleCounter++ + " terminate createReadStream");
            var destroy = multi.destroy;
            multi.destroy = function(){
               if (thisRequest.req) {
                  thisRequest.req.destroy();
               }
               destroy.call(multi);
            };
            return multi;
         };
        
         
            
         function frequentlyCheckIfNewCreateReadStreamNecessary(){
               if(videoCompletelyLoaded){
                  return;
               }        
               if(myVideo.duration){
                  var timeRanges = myVideo.buffered;          
                  for (var i = 0, length = timeRanges.length; i < length; i++){
                     if (myVideo.currentTime >= timeRanges.start(i) && myVideo.currentTime <= timeRanges.end(i)+3) {
                        if (timeRanges.end(i) - myVideo.currentTime <= DOWNLOAD_FROM_P2P_TIME_RANGE) {
                           for (var i = 0, length = videostreamRequestHandlers.length; i < length; i++) {
                              var thisRequest = videostreamRequestHandlers[i];
                              
                              if(thisRequest.currentCB !== null && thisRequest.start > thisRequest.lastEndCreateReadStream && thisRequest.start < thisRequest.videoFileSize){
                                 var endCreateReadStream;
                                 if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                                    endCreateReadStream = webTorrentFile.length-1;
                                 } else {
                                    endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                                 }                
                                 thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                                 thisRequest.oldStartWebTorrent = thisRequest.start;
                                 thisRequest.webTorrentStream.unpipe();
                                 thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                              }
                           }
                        }
                     }
                  }
                  setTimeout(frequentlyCheckIfNewCreateReadStreamNecessary, CHECK_IF_NEW_CREATE_READSTREAM_NECESSARY_INTERVAL);
               }
            }   
         
         
         function ceckIfAnswerStreamReady(thisRequest){
            ////////console.log("At the beginning of thisRequest.bytesInAnswerStream: " + thisRequest.bytesInAnswerStream);
            ////////console.log("In ceckIfAnswerStreamReady of videostreamRequest number " + thisRequest.readStreamNumber +  ". thisRequest.bytesInAnswerStream: " + thisRequest.bytesInAnswerStream + "     thisRequest.currentCB: " + thisRequest.currentCB);
            if (thisRequest.currentCB && ((thisRequest.bytesInAnswerStream >= THRESHOLD_FOR_RETURNING_OF_ANSWER_STREAM) || (thisRequest.start >= SIZE_OF_VIDEO_FILE))){
               ////////console.log("answerStream from videostream Request number " + thisRequest.readStreamNumber + " and CB number " + thisRequest.CBNumber + " gets returned");
               // //////console.log("Returing answerStream out of ceckIfAnswerStreamReady()");
               var theCallbackFunction = thisRequest.currentCB;
               thisRequest.currentCB = null;
               thisRequest.answerStream.push(null);
               if (thisRequest.webTorrentStream){
                  thisRequest.webTorrentStream.pause();
               }
               thisRequest.bytesInAnswerStream = 0;
               var res = thisRequest.answerStream;
               thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
               //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
               theCallbackFunction(null, res);
               return true;
            }
            return false;
         }

         function chokeIfNecessary(){
               if (theTorrent && theTorrent.uploaded >= theTorrent.downloaded * UPLOAD_LIMIT + ADDITION_TO_UPLOAD_LIMIT) {
                  /* mache ich schon in einer anderen frequent methode
                  if(videoCompletelyLoaded){
                     theTorrent.destroy();
                     delete webTorrentClient;
                     endStreaming = true;
                     return;
                  }
                  */
                  for (var i = 0, length = wires.length; i < length; i++){
                     //console.log("I choked a peer");
                     wires[i].choke();
                  }
               }
               setTimeout(chokeIfNecessary, CHOKE_IF_NECESSARY_INTERVAL);
            }

         function updateChart(){
               if(endStreaming){
                  return;
               }
               if(theTorrent && webTorrentFile){
                  document.getElementById("WebTorrent-received").innerHTML = "webTorrentFile.length: " + webTorrentFile.length + "\n torrent.downloaded: " + theTorrent.downloaded + "\n torrent.uploaded: " + theTorrent.uploaded + "\n torrent.progress: " + theTorrent.progress + "\n Bytes received from server: " + bytesReceivedFromServer + "\n Bytes taken from server delivery: " + bytesTakenFromServer + "\n Bytes taken from WebTorrent delivery: " + bytesTakenFromWebTorrent;
               }
               setTimeout(updateChart, UPDATE_CHART_INTERVAL);
         }
          
         function VideostreamRequestHandler(readStreamNumber, opts, self) {
            this.readStreamNumber = readStreamNumber;
            this.opts = opts;
            this.start = opts.start || 0;
            this.oldStartWebTorrent = -42;
            this.oldStartServer = -42;
            this.currentCB = null;
            this.CBNumber = 0;
            this.webTorrentStream = null;
            this.answerStream = new MyReadableStream({highWaterMark: 5000000});
            this.bytesInAnswerStream = 0;
            this.collectorStreamForWebtorrent = null;
            this.XHRConducted = false;
            this.end = -42;
            this.self = self;
            this.bytesTakenFromWebTorrent = 0;
            this.bytesTakenFromServer = 0;
            this.noMoreData = false;
            this.req = null;
            this.lastEndCreateReadStream = -42;
         }

         function frequentlyCeckIfAnswerStreamReady(){
               if(videoCompletelyLoaded){
                  return;
               }
               for (var i = 0, length = videostreamRequestHandlers.length; i < length; i++) {
                  ceckIfAnswerStreamReady(videostreamRequestHandlers[i]);
               }
               setTimeout(frequentlyCeckIfAnswerStreamReady, CHECK_IF_ANSWERSTREAM_READY_INTERVAL);
         }

         function checkIfBufferFullEnough(){
               //console.log("checkIfBufferFullEnough is called");
               if(videoCompletelyLoaded){
                  return;
               }
               //console.log("video.duration: " + myVideo.duration);
               if(myVideo.duration){
                  var timeRanges = myVideo.buffered;
                  if(timeRanges.length >= 1){
                     //console.log("timeRanges.start(0): " + timeRanges.start(0));
                     //console.log("timeRanges.end(0): " + timeRanges.end(0));
                     
                     if(timeRanges.start(0) == 0 && timeRanges.end(0) == myVideo.duration){
                       // console.log("In checkIfBufferFullEnough: callback should be called");
                        videoCompletelyLoaded = true;
                        if(callback){
                           if(endIfVideoLoaded){
                              callback();
                           } else {
                              callback(theTorrent);
                           }
                        }
                        if(endIfVideoLoaded){
                           if(theTorrent){
                              theTorrent.destroy();
                              delete webTorrentClient;
                           }
                           endStreaming = true;
                           return;                 
                        } 
                     }
                  }
                  inCritical = true;              
                  for (var i = 0, length = timeRanges.length; i < length; i++) {
                     ////////console.log("Time range number " + i + ": start(" + timeRanges.start(i) + ") end(" + timeRanges.end(i) + ")");
                     if (myVideo.currentTime >= timeRanges.start(i) && myVideo.currentTime <= timeRanges.end(i)) {
                        if (timeRanges.end(i) - myVideo.currentTime >= DOWNLOAD_FROM_SERVER_TIME_RANGE) {
                           inCritical = false;
                           ////////console.log("I set inCritical to false");
                        }
                     }
                  }
                  if (deliveryByServer && inCritical) {
                     for (var j = 0, length = videostreamRequestHandlers.length; j < length; j++) {
                        if (videostreamRequestHandlers[j].currentCB !== null && videostreamRequestHandlers[j].XHRConducted === false) {
                           conductXHR(videostreamRequestHandlers[j]);
                        }
                     }
                  }
               }
               setTimeout(checkIfBufferFullEnough, CHECK_IF_BUFFER_FULL_ENOUGH_INTERVAL);
            }

         function conductXHR(thisRequest) {
            if(thisRequest.currentCB === null){
               return;
            }
            thisRequest.XHRConducted = true;
            var reqStart = thisRequest.start;
            var reqEnd = reqStart + XHR_REQUEST_SIZE;

            if (thisRequest.end >= 0 && reqEnd > thisRequest.end) {
               reqEnd = thisRequest.end;
            }
            if (reqStart >= reqEnd) {
               thisRequest.req = null;
               //console.log("called cb(null,null)");
               return thisRequest.currentCB(null, null);
            }

            /* glaube ich unnötiger und/oder gefährlicher müll
            if (reqStart >= reqEnd) {
            req = null;
            return thisRequest.currentCB(null, null);
            }
            */
            if (consoleCounter < 10000000) {
               //////////console.log(consoleCounter++ + "  videoStream " + thisRequest.readStreamNumber + "  CB number " + thisRequest.CBNumber + "    reqStart: " + reqStart);
               //////////console.log(consoleCounter++ + "  Multistream " + thisRequest.readStreamNumber + "   CB number " + thisRequest.CBNumber + "    reqEnd: " + reqEnd);
            }

            var XHRDataHandler = function (chunk){
               bytesReceivedFromServer += chunk.length;
               //console.log("ReadableStream request number " + thisRequest.readStreamNumber + " received a chunk of length " + chunk.length);
               if(thisRequest.noMoreData){
                  thisRequest.oldStartServer += chunk.length;
                  return;
               }
               if (thisRequest.start - thisRequest.oldStartServer < chunk.length){         
                  bytesTakenFromServer += chunk.length - (thisRequest.start - thisRequest.oldStartServer);
                  thisRequest.bytesInAnswerStream += chunk.length - (thisRequest.start - thisRequest.oldStartServer);
                  var myBuffer = chunk.slice(thisRequest.start - thisRequest.oldStartServer, chunk.length);
                  //console.log("In XHRDataHandler   myBuffer.length: " + myBuffer.length);
                  var StreamHasMemoryLeft = thisRequest.answerStream.push(myBuffer);         
                  if(!StreamHasMemoryLeft){
                     if(thisRequest.currentCB !== null){
                        var theCallbackFunction = thisRequest.currentCB;
                        thisRequest.currentCB = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                        theCallbackFunction(null, res); 
                     } else {
                        thisRequest.noMoreData = true;
                        if(thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                     }
                  } else {
                     if (thisRequest.start >= SIZE_OF_VIDEO_FILE && thisRequest.currentCB !== null){
                        var theCallbackFunction = thisRequest.currentCB;
                        thisRequest.currentCB = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                        theCallbackFunction(null, res);
                     }
                  } 
                  thisRequest.start += chunk.length - (thisRequest.start - thisRequest.oldStartServer);            
               }
               thisRequest.oldStartServer += chunk.length;
            }

            var XHREnd = function (){
               //console.log("ReadableStream request number " + thisRequest.readStreamNumber + " XHREnd");
               if (consoleCounter < 1000000000000){
                  //////////console.log("XHREnd from videostreamRequest number " + thisRequest.readStreamNumber);
               }
               if(thisRequest.bytesInAnswerStream > 0 && thisRequest.currentCB !== null){
                  thisRequest.answerStream.push(null);
                  thisRequest.bytesInAnswerStream = 0;
                  var res = thisRequest.answerStream;
                  thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                  var theCallbackFunction = thisRequest.currentCB;
                  thisRequest.currentCB = null;
                  //console.log("XHREnd: called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                  theCallbackFunction(null, res);
               }
               thisRequest.XHRConducted = false;
            }  
            
            thisRequest.oldStartServer = reqStart;
            
            //console.log("At htto.get   reqStart: " + reqStart + "     reqEnd: " + reqEnd);

                  
            var XHROptionObject = {
               path: thisRequest.self.pathToFileOnXHRServer,
               headers: {
                  range: 'bytes=' + reqStart + '-' + (reqEnd-1)
               }
            };
            if(XHRServerURL){
               XHROptionObject.hostname = XHRServerURL;
               XHROptionObject.port = XHR_PORT;
            }
            
            thisRequest.req = http.get(XHROptionObject, function (res){
                  var contentRange = res.headers['content-range'];
                  if (contentRange) {
                     thisRequest.fileSize = parseInt(contentRange.split('/')[1], 10);
                  }
                  //////////console.log("I return currentCB with http response stream");
                  ////////////console.log("function(res) is executed from readstream number " + createReadStreamCounter + " and CB number " + thisCBNumber);
                  res.on('end', XHREnd);
                  res.on('data', XHRDataHandler);
               }
            );
         }
         frequentlyCheckIfNewCreateReadStreamNecessary();
         chokeIfNecessary();
         updateChart();
         frequentlyCeckIfAnswerStreamReady();
         checkIfBufferFullEnough();

         //////console.log("I call Videostream constructor");
         if(hashValue){
            Videostream(new fileLikeObject(hashValue), myVideo);
         } else {
            Videostream(new fileLikeObject(pathToFileOnXHRServer), myVideo);
         }
      }


      function addSimplePeerInstance(simplePeerInstance, options, callback){
         // The method add a simplePeer to the WebTorrent swarm instance
         if(theTorrent){
            if(theTorrent.infoHash){
               theTorrent.addPeer(simplePeerInstance);
               if(callback){
                  callback();
               }
            } else {
               theTorrent.on('infoHash', function() {theTorrent.addPeer(simplePeerInstance); if(callback){callback()}});
            }
         } else {
            var pair = [];
            pair.push(simplePeerInstance);
            pair.push(callback);
            peersToAdd.push(pair);
         }
      }
   })();
}
},{"http":99,"multistream":61,"parse-torrent":69,"readable-stream":86,"simple-peer":95,"ut_pex":120,"util":127,"videostream":129,"webtorrent":130}],3:[function(require,module,exports){
var ADDR_RE = /^\[?([^\]]+)\]?:(\d+)$/ // ipv4/ipv6/hostname + port

var cache = {}

// reset cache when it gets to 100,000 elements (~ 600KB of ipv4 addresses)
// so it will not grow to consume all memory in long-running processes
var size = 0

module.exports = function addrToIPPort (addr) {
  if (size === 100000) module.exports.reset()
  if (!cache[addr]) {
    var m = ADDR_RE.exec(addr)
    if (!m) throw new Error('invalid addr: ' + addr)
    cache[addr] = [ m[1], Number(m[2]) ]
    size += 1
  }
  return cache[addr]
}

module.exports.reset = function reset () {
  cache = {}
  size = 0
}

},{}],4:[function(require,module,exports){
'use strict'

exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){
(function (Buffer){
/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode (data, start, end, encoding) {
  if (typeof start !== 'number' && encoding == null) {
    encoding = start
    start = undefined
  }

  if (typeof end !== 'number' && encoding == null) {
    encoding = end
    end = undefined
  }

  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !(Buffer.isBuffer(data))
    ? new Buffer(data)
    : data.slice(start, end)

  decode.bytes = decode.data.length

  return decode.next()
}

decode.bytes = 0
decode.position = 0
decode.data = null
decode.encoding = null

decode.next = function () {
  switch (decode.data[decode.position]) {
    case 0x64:
      return decode.dictionary()
    case 0x6C:
      return decode.list()
    case 0x69:
      return decode.integer()
    default:
      return decode.buffer()
  }
}

decode.find = function (chr) {
  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while (i < c) {
    if (d[i] === chr) return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode(chr) + '" [0x' +
    chr.toString(16) + ']'
  )
}

decode.dictionary = function () {
  decode.position++

  var dict = {}

  while (decode.data[decode.position] !== 0x65) {
    dict[decode.buffer()] = decode.next()
  }

  decode.position++

  return dict
}

decode.list = function () {
  decode.position++

  var lst = []

  while (decode.data[decode.position] !== 0x65) {
    lst.push(decode.next())
  }

  decode.position++

  return lst
}

decode.integer = function () {
  var end = decode.find(0x65)
  var number = decode.data.toString('ascii', decode.position + 1, end)

  decode.position += end + 1 - decode.position

  return parseInt(number, 10)
}

decode.buffer = function () {
  var sep = decode.find(0x3A)
  var length = parseInt(decode.data.toString('ascii', decode.position, sep), 10)
  var end = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString(decode.encoding, sep, end)
    : decode.data.slice(sep, end)
}

module.exports = decode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],6:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode (data, buffer, offset) {
  var buffers = []
  var result = null

  encode._encode(buffers, data)
  result = Buffer.concat(buffers)
  encode.bytes = result.length

  if (Buffer.isBuffer(buffer)) {
    result.copy(buffer, offset)
    return buffer
  }

  return result
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function (buffers, data) {
  if (Buffer.isBuffer(data)) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return
  }

  switch (typeof data) {
    case 'string':
      encode.buffer(buffers, data)
      break
    case 'number':
      encode.number(buffers, data)
      break
    case 'object':
      data.constructor === Array
        ? encode.list(buffers, data)
        : encode.dict(buffers, data)
      break
    case 'boolean':
      encode.number(buffers, data ? 1 : 0)
      break
  }
}

var buffE = new Buffer('e')
var buffD = new Buffer('d')
var buffL = new Buffer('l')

encode.buffer = function (buffers, data) {
  buffers.push(new Buffer(Buffer.byteLength(data) + ':' + data))
}

encode.number = function (buffers, data) {
  var maxLo = 0x80000000
  var hi = (data / maxLo) << 0
  var lo = (data % maxLo) << 0
  var val = hi * maxLo + lo

  buffers.push(new Buffer('i' + val + 'e'))

  if (val !== data && !encode._floatConversionDetected) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "' + data + '":',
      'Bencoding only defines support for integers, value was converted to "' + val + '"'
    )
    console.trace()
  }
}

encode.dict = function (buffers, data) {
  buffers.push(buffD)

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys(data).sort()
  var kl = keys.length

  for (; j < kl; j++) {
    k = keys[j]
    encode.buffer(buffers, k)
    encode._encode(buffers, data[k])
  }

  buffers.push(buffE)
}

encode.list = function (buffers, data) {
  var i = 0
  var c = data.length
  buffers.push(buffL)

  for (; i < c; i++) {
    encode._encode(buffers, data[i])
  }

  buffers.push(buffE)
}

module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],7:[function(require,module,exports){
var bencode = module.exports

bencode.encode = require('./encode')
bencode.decode = require('./decode')

/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */
bencode.byteLength = bencode.encodingLength = function (value) {
  return bencode.encode(value).length
}

},{"./decode":5,"./encode":6}],8:[function(require,module,exports){
module.exports = function(haystack, needle, comparator, low, high) {
  var mid, cmp;

  if(low === undefined)
    low = 0;

  else {
    low = low|0;
    if(low < 0 || low >= haystack.length)
      throw new RangeError("invalid lower bound");
  }

  if(high === undefined)
    high = haystack.length - 1;

  else {
    high = high|0;
    if(high < low || high >= haystack.length)
      throw new RangeError("invalid upper bound");
  }

  while(low <= high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle, mid, haystack);

    /* Too low. */
    if(cmp < 0.0)
      low  = mid + 1;

    /* Too high. */
    else if(cmp > 0.0)
      high = mid - 1;

    /* Key found. */
    else
      return mid;
  }

  /* Key not found. */
  return ~low;
}

},{}],9:[function(require,module,exports){
(function (Buffer){
var Container = typeof Buffer !== "undefined" ? Buffer //in node, use buffers
		: typeof Int8Array !== "undefined" ? Int8Array //in newer browsers, use webgl int8arrays
		: function(l){ var a = new Array(l); for(var i = 0; i < l; i++) a[i]=0; }; //else, do something similar

function BitField(data, opts){
	if(!(this instanceof BitField)) {
		return new BitField(data, opts);
	}

	if(arguments.length === 0){
		data = 0;
	}

	this.grow = opts && (isFinite(opts.grow) && getByteSize(opts.grow) || opts.grow) || 0;

	if(typeof data === "number" || data === undefined){
		data = new Container(getByteSize(data));
		if(data.fill && !data._isBuffer) data.fill(0); // clear node buffers of garbage
	}
	this.buffer = data;
}

function getByteSize(num){
	var out = num >> 3;
	if(num % 8 !== 0) out++;
	return out;
}

BitField.prototype.get = function(i){
	var j = i >> 3;
	return (j < this.buffer.length) &&
		!!(this.buffer[j] & (128 >> (i % 8)));
};

BitField.prototype.set = function(i, b){
	var j = i >> 3;
	if (b || arguments.length === 1){
		if (this.buffer.length < j + 1) this._grow(Math.max(j + 1, Math.min(2 * this.buffer.length, this.grow)));
		// Set
		this.buffer[j] |= 128 >> (i % 8);
	} else if (j < this.buffer.length) {
		/// Clear
		this.buffer[j] &= ~(128 >> (i % 8));
	}
};

BitField.prototype._grow = function(length) {
	if (this.buffer.length < length && length <= this.grow) {
		var newBuffer = new Container(length);
		if (newBuffer.fill) newBuffer.fill(0);
		if (this.buffer.copy) this.buffer.copy(newBuffer, 0);
		else {
			for(var i = 0; i < this.buffer.length; i++) {
				newBuffer[i] = this.buffer[i];
			}
		}
		this.buffer = newBuffer;
	}
};

if(typeof module !== "undefined") module.exports = BitField;

}).call(this,require("buffer").Buffer)

},{"buffer":20}],10:[function(require,module,exports){
module.exports = Wire

var bencode = require('bencode')
var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('bittorrent-protocol')
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var speedometer = require('speedometer')
var stream = require('readable-stream')

var BITFIELD_GROW = 400000
var KEEP_ALIVE_TIMEOUT = 55000

var MESSAGE_PROTOCOL = Buffer.from('\u0013BitTorrent protocol')
var MESSAGE_KEEP_ALIVE = Buffer.from([0x00, 0x00, 0x00, 0x00])
var MESSAGE_CHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x00])
var MESSAGE_UNCHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x01])
var MESSAGE_INTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x02])
var MESSAGE_UNINTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x03])

var MESSAGE_RESERVED = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
var MESSAGE_PORT = [0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00]

function Request (piece, offset, length, callback) {
  this.piece = piece
  this.offset = offset
  this.length = length
  this.callback = callback
}

inherits(Wire, stream.Duplex)

function Wire () {
  if (!(this instanceof Wire)) return new Wire()
  stream.Duplex.call(this)

  this._debugId = hat(32)
  this._debug('new wire')

  this.peerId = null // remote peer id (hex string)
  this.peerIdBuffer = null // remote peer id (buffer)
  this.type = null // connection type ('webrtc', 'tcpIncoming', 'tcpOutgoing', 'webSeed')

  this.amChoking = true // are we choking the peer?
  this.amInterested = false // are we interested in the peer?

  this.peerChoking = true // is the peer choking us?
  this.peerInterested = false // is the peer interested in us?

  // The largest torrent that I know of (the Geocities archive) is ~641 GB and has
  // ~41,000 pieces. Therefore, cap bitfield to 10x larger (400,000 bits) to support all
  // possible torrents but prevent malicious peers from growing bitfield to fill memory.
  this.peerPieces = new BitField(0, { grow: BITFIELD_GROW })

  this.peerExtensions = {}

  this.requests = [] // outgoing
  this.peerRequests = [] // incoming

  this.extendedMapping = {} // number -> string, ex: 1 -> 'ut_metadata'
  this.peerExtendedMapping = {} // string -> number, ex: 9 -> 'ut_metadata'

  // The extended handshake to send, minus the "m" field, which gets automatically
  // filled from `this.extendedMapping`
  this.extendedHandshake = {}

  this.peerExtendedHandshake = {} // remote peer's extended handshake

  this._ext = {}  // string -> function, ex 'ut_metadata' -> ut_metadata()
  this._nextExt = 1

  this.uploaded = 0
  this.downloaded = 0
  this.uploadSpeed = speedometer()
  this.downloadSpeed = speedometer()

  this._keepAliveInterval = null
  this._timeout = null
  this._timeoutMs = 0

  this.destroyed = false // was the wire ended by calling `destroy`?
  this._finished = false

  this._parserSize = 0 // number of needed bytes to parse next message from remote peer
  this._parser = null // function to call once `this._parserSize` bytes are available

  this._buffer = [] // incomplete message data
  this._bufferSize = 0 // cached total length of buffers in `this._buffer`

  this.on('finish', this._onFinish)

  this._parseHandshake()
}

/**
 * Set whether to send a "keep-alive" ping (sent every 55s)
 * @param {boolean} enable
 */
Wire.prototype.setKeepAlive = function (enable) {
  var self = this
  self._debug('setKeepAlive %s', enable)
  clearInterval(self._keepAliveInterval)
  if (enable === false) return
  self._keepAliveInterval = setInterval(function () {
    self.keepAlive()
  }, KEEP_ALIVE_TIMEOUT)
}

/**
 * Set the amount of time to wait before considering a request to be "timed out"
 * @param {number} ms
 * @param {boolean=} unref (should the timer be unref'd? default: false)
 */
Wire.prototype.setTimeout = function (ms, unref) {
  this._debug('setTimeout ms=%d unref=%s', ms, unref)
  this._clearTimeout()
  this._timeoutMs = ms
  this._timeoutUnref = !!unref
  this._updateTimeout()
}

Wire.prototype.destroy = function () {
  if (this.destroyed) return
  this.destroyed = true
  this._debug('destroy')
  this.emit('close')
  this.end()
}

Wire.prototype.end = function () {
  this._debug('end')
  this._onUninterested()
  this._onChoke()
  stream.Duplex.prototype.end.apply(this, arguments)
}

/**
 * Use the specified protocol extension.
 * @param  {function} Extension
 */
Wire.prototype.use = function (Extension) {
  var name = Extension.prototype.name
  if (!name) {
    throw new Error('Extension class requires a "name" property on the prototype')
  }
  this._debug('use extension.name=%s', name)

  var ext = this._nextExt
  var handler = new Extension(this)

  function noop () {}

  if (typeof handler.onHandshake !== 'function') {
    handler.onHandshake = noop
  }
  if (typeof handler.onExtendedHandshake !== 'function') {
    handler.onExtendedHandshake = noop
  }
  if (typeof handler.onMessage !== 'function') {
    handler.onMessage = noop
  }

  this.extendedMapping[ext] = name
  this._ext[name] = handler
  this[name] = handler

  this._nextExt += 1
}

//
// OUTGOING MESSAGES
//

/**
 * Message "keep-alive": <len=0000>
 */
Wire.prototype.keepAlive = function () {
  this._debug('keep-alive')
  this._push(MESSAGE_KEEP_ALIVE)
}

/**
 * Message: "handshake" <pstrlen><pstr><reserved><info_hash><peer_id>
 * @param  {Buffer|string} infoHash (as Buffer or *hex* string)
 * @param  {Buffer|string} peerId
 * @param  {Object} extensions
 */
Wire.prototype.handshake = function (infoHash, peerId, extensions) {
  var infoHashBuffer, peerIdBuffer
  if (typeof infoHash === 'string') {
    infoHashBuffer = Buffer.from(infoHash, 'hex')
  } else {
    infoHashBuffer = infoHash
    infoHash = infoHashBuffer.toString('hex')
  }
  if (typeof peerId === 'string') {
    peerIdBuffer = Buffer.from(peerId, 'hex')
  } else {
    peerIdBuffer = peerId
    peerId = peerIdBuffer.toString('hex')
  }

  if (infoHashBuffer.length !== 20 || peerIdBuffer.length !== 20) {
    throw new Error('infoHash and peerId MUST have length 20')
  }

  this._debug('handshake i=%s p=%s exts=%o', infoHash, peerId, extensions)

  var reserved = Buffer.from(MESSAGE_RESERVED)

  // enable extended message
  reserved[5] |= 0x10

  if (extensions && extensions.dht) reserved[7] |= 1

  this._push(Buffer.concat([MESSAGE_PROTOCOL, reserved, infoHashBuffer, peerIdBuffer]))
  this._handshakeSent = true

  if (this.peerExtensions.extended && !this._extendedHandshakeSent) {
    // Peer's handshake indicated support already
    // (incoming connection)
    this._sendExtendedHandshake()
  }
}

/* Peer supports BEP-0010, send extended handshake.
 *
 * This comes after the 'handshake' event to give the user a chance to populate
 * `this.extendedHandshake` and `this.extendedMapping` before the extended handshake
 * is sent to the remote peer.
 */
Wire.prototype._sendExtendedHandshake = function () {
  // Create extended message object from registered extensions
  var msg = extend(this.extendedHandshake)
  msg.m = {}
  for (var ext in this.extendedMapping) {
    var name = this.extendedMapping[ext]
    msg.m[name] = Number(ext)
  }

  // Send extended handshake
  this.extended(0, bencode.encode(msg))
  this._extendedHandshakeSent = true
}

/**
 * Message "choke": <len=0001><id=0>
 */
Wire.prototype.choke = function () {
  if (this.amChoking) return
  this.amChoking = true
  this._debug('choke')
  this.peerRequests.splice(0, this.peerRequests.length)
  this._push(MESSAGE_CHOKE)
}

/**
 * Message "unchoke": <len=0001><id=1>
 */
Wire.prototype.unchoke = function () {
  if (!this.amChoking) return
  this.amChoking = false
  this._debug('unchoke')
  this._push(MESSAGE_UNCHOKE)
}

/**
 * Message "interested": <len=0001><id=2>
 */
Wire.prototype.interested = function () {
  if (this.amInterested) return
  this.amInterested = true
  this._debug('interested')
  this._push(MESSAGE_INTERESTED)
}

/**
 * Message "uninterested": <len=0001><id=3>
 */
Wire.prototype.uninterested = function () {
  if (!this.amInterested) return
  this.amInterested = false
  this._debug('uninterested')
  this._push(MESSAGE_UNINTERESTED)
}

/**
 * Message "have": <len=0005><id=4><piece index>
 * @param  {number} index
 */
Wire.prototype.have = function (index) {
  this._debug('have %d', index)
  this._message(4, [index], null)
}

/**
 * Message "bitfield": <len=0001+X><id=5><bitfield>
 * @param  {BitField|Buffer} bitfield
 */
Wire.prototype.bitfield = function (bitfield) {
  this._debug('bitfield')
  if (!Buffer.isBuffer(bitfield)) bitfield = bitfield.buffer
  this._message(5, [], bitfield)
}

/**
 * Message "request": <len=0013><id=6><index><begin><length>
 * @param  {number}   index
 * @param  {number}   offset
 * @param  {number}   length
 * @param  {function} cb
 */
Wire.prototype.request = function (index, offset, length, cb) {
  if (!cb) cb = function () {}
  if (this._finished) return cb(new Error('wire is closed'))
  if (this.peerChoking) return cb(new Error('peer is choking'))

  this._debug('request index=%d offset=%d length=%d', index, offset, length)

  this.requests.push(new Request(index, offset, length, cb))
  this._updateTimeout()
  this._message(6, [index, offset, length], null)
}

/**
 * Message "piece": <len=0009+X><id=7><index><begin><block>
 * @param  {number} index
 * @param  {number} offset
 * @param  {Buffer} buffer
 */
Wire.prototype.piece = function (index, offset, buffer) {
  this._debug('piece index=%d offset=%d', index, offset)
  this.uploaded += buffer.length
  this.uploadSpeed(buffer.length)
  this.emit('upload', buffer.length)
  this._message(7, [index, offset], buffer)
}

/**
 * Message "cancel": <len=0013><id=8><index><begin><length>
 * @param  {number} index
 * @param  {number} offset
 * @param  {number} length
 */
Wire.prototype.cancel = function (index, offset, length) {
  this._debug('cancel index=%d offset=%d length=%d', index, offset, length)
  this._callback(
    pull(this.requests, index, offset, length),
    new Error('request was cancelled'),
    null
  )
  this._message(8, [index, offset, length], null)
}

/**
 * Message: "port" <len=0003><id=9><listen-port>
 * @param {Number} port
 */
Wire.prototype.port = function (port) {
  this._debug('port %d', port)
  var message = Buffer.from(MESSAGE_PORT)
  message.writeUInt16BE(port, 5)
  this._push(message)
}

/**
 * Message: "extended" <len=0005+X><id=20><ext-number><payload>
 * @param  {number|string} ext
 * @param  {Object} obj
 */
Wire.prototype.extended = function (ext, obj) {
  this._debug('extended ext=%s', ext)
  if (typeof ext === 'string' && this.peerExtendedMapping[ext]) {
    ext = this.peerExtendedMapping[ext]
  }
  if (typeof ext === 'number') {
    var extId = Buffer.from([ext])
    var buf = Buffer.isBuffer(obj) ? obj : bencode.encode(obj)

    this._message(20, [], Buffer.concat([extId, buf]))
  } else {
    throw new Error('Unrecognized extension: ' + ext)
  }
}

/**
 * Duplex stream method. Called whenever the remote peer stream wants data. No-op
 * since we'll just push data whenever we get it.
 */
Wire.prototype._read = function () {}

/**
 * Send a message to the remote peer.
 */
Wire.prototype._message = function (id, numbers, data) {
  var dataLength = data ? data.length : 0
  var buffer = Buffer.allocUnsafe(5 + 4 * numbers.length)

  buffer.writeUInt32BE(buffer.length + dataLength - 4, 0)
  buffer[4] = id
  for (var i = 0; i < numbers.length; i++) {
    buffer.writeUInt32BE(numbers[i], 5 + 4 * i)
  }

  this._push(buffer)
  if (data) this._push(data)
}

Wire.prototype._push = function (data) {
  if (this._finished) return
  return this.push(data)
}

//
// INCOMING MESSAGES
//

Wire.prototype._onKeepAlive = function () {
  this._debug('got keep-alive')
  this.emit('keep-alive')
}

Wire.prototype._onHandshake = function (infoHashBuffer, peerIdBuffer, extensions) {
  var infoHash = infoHashBuffer.toString('hex')
  var peerId = peerIdBuffer.toString('hex')

  this._debug('got handshake i=%s p=%s exts=%o', infoHash, peerId, extensions)

  this.peerId = peerId
  this.peerIdBuffer = peerIdBuffer
  this.peerExtensions = extensions

  this.emit('handshake', infoHash, peerId, extensions)

  var name
  for (name in this._ext) {
    this._ext[name].onHandshake(infoHash, peerId, extensions)
  }

  if (extensions.extended && this._handshakeSent &&
      !this._extendedHandshakeSent) {
    // outgoing connection
    this._sendExtendedHandshake()
  }
}

Wire.prototype._onChoke = function () {
  this.peerChoking = true
  this._debug('got choke')
  this.emit('choke')
  while (this.requests.length) {
    this._callback(this.requests.shift(), new Error('peer is choking'), null)
  }
}

Wire.prototype._onUnchoke = function () {
  this.peerChoking = false
  this._debug('got unchoke')
  this.emit('unchoke')
}

Wire.prototype._onInterested = function () {
  this.peerInterested = true
  this._debug('got interested')
  this.emit('interested')
}

Wire.prototype._onUninterested = function () {
  this.peerInterested = false
  this._debug('got uninterested')
  this.emit('uninterested')
}

Wire.prototype._onHave = function (index) {
  if (this.peerPieces.get(index)) return
  this._debug('got have %d', index)

  this.peerPieces.set(index, true)
  this.emit('have', index)
}

Wire.prototype._onBitField = function (buffer) {
  this.peerPieces = new BitField(buffer)
  this._debug('got bitfield')
  this.emit('bitfield', this.peerPieces)
}

Wire.prototype._onRequest = function (index, offset, length) {
  var self = this
  if (self.amChoking) return
  self._debug('got request index=%d offset=%d length=%d', index, offset, length)

  var respond = function (err, buffer) {
    if (request !== pull(self.peerRequests, index, offset, length)) return
    if (err) return self._debug('error satisfying request index=%d offset=%d length=%d (%s)', index, offset, length, err.message)
    self.piece(index, offset, buffer)
  }

  var request = new Request(index, offset, length, respond)
  self.peerRequests.push(request)
  self.emit('request', index, offset, length, respond)
}

Wire.prototype._onPiece = function (index, offset, buffer) {
  this._debug('got piece index=%d offset=%d', index, offset)
  this._callback(pull(this.requests, index, offset, buffer.length), null, buffer)
  this.downloaded += buffer.length
  this.downloadSpeed(buffer.length)
  this.emit('download', buffer.length)
  this.emit('piece', index, offset, buffer)
}

Wire.prototype._onCancel = function (index, offset, length) {
  this._debug('got cancel index=%d offset=%d length=%d', index, offset, length)
  pull(this.peerRequests, index, offset, length)
  this.emit('cancel', index, offset, length)
}

Wire.prototype._onPort = function (port) {
  this._debug('got port %d', port)
  this.emit('port', port)
}

Wire.prototype._onExtended = function (ext, buf) {
  if (ext === 0) {
    var info
    try {
      info = bencode.decode(buf)
    } catch (err) {
      this._debug('ignoring invalid extended handshake: %s', err.message || err)
    }

    if (!info) return
    this.peerExtendedHandshake = info

    var name
    if (typeof info.m === 'object') {
      for (name in info.m) {
        this.peerExtendedMapping[name] = Number(info.m[name].toString())
      }
    }
    for (name in this._ext) {
      if (this.peerExtendedMapping[name]) {
        this._ext[name].onExtendedHandshake(this.peerExtendedHandshake)
      }
    }
    this._debug('got extended handshake')
    this.emit('extended', 'handshake', this.peerExtendedHandshake)
  } else {
    if (this.extendedMapping[ext]) {
      ext = this.extendedMapping[ext] // friendly name for extension
      if (this._ext[ext]) {
        // there is an registered extension handler, so call it
        this._ext[ext].onMessage(buf)
      }
    }
    this._debug('got extended message ext=%s', ext)
    this.emit('extended', ext, buf)
  }
}

Wire.prototype._onTimeout = function () {
  this._debug('request timed out')
  this._callback(this.requests.shift(), new Error('request has timed out'), null)
  this.emit('timeout')
}

/**
 * Duplex stream method. Called whenever the remote peer has data for us. Data that the
 * remote peer sends gets buffered (i.e. not actually processed) until the right number
 * of bytes have arrived, determined by the last call to `this._parse(number, callback)`.
 * Once enough bytes have arrived to process the message, the callback function
 * (i.e. `this._parser`) gets called with the full buffer of data.
 * @param  {Buffer} data
 * @param  {string} encoding
 * @param  {function} cb
 */
Wire.prototype._write = function (data, encoding, cb) {
  this._bufferSize += data.length
  this._buffer.push(data)

  while (this._bufferSize >= this._parserSize) {
    var buffer = (this._buffer.length === 1)
      ? this._buffer[0]
      : Buffer.concat(this._buffer)
    this._bufferSize -= this._parserSize
    this._buffer = this._bufferSize
      ? [buffer.slice(this._parserSize)]
      : []
    this._parser(buffer.slice(0, this._parserSize))
  }

  cb(null) // Signal that we're ready for more data
}

Wire.prototype._callback = function (request, err, buffer) {
  if (!request) return

  this._clearTimeout()

  if (!this.peerChoking && !this._finished) this._updateTimeout()
  request.callback(err, buffer)
}

Wire.prototype._clearTimeout = function () {
  if (!this._timeout) return

  clearTimeout(this._timeout)
  this._timeout = null
}

Wire.prototype._updateTimeout = function () {
  var self = this
  if (!self._timeoutMs || !self.requests.length || self._timeout) return

  self._timeout = setTimeout(function () {
    self._onTimeout()
  }, self._timeoutMs)
  if (self._timeoutUnref && self._timeout.unref) self._timeout.unref()
}

/**
 * Takes a number of bytes that the local peer is waiting to receive from the remote peer
 * in order to parse a complete message, and a callback function to be called once enough
 * bytes have arrived.
 * @param  {number} size
 * @param  {function} parser
 */
Wire.prototype._parse = function (size, parser) {
  this._parserSize = size
  this._parser = parser
}

/**
 * Handle the first 4 bytes of a message, to determine the length of bytes that must be
 * waited for in order to have the whole message.
 * @param  {Buffer} buffer
 */
Wire.prototype._onMessageLength = function (buffer) {
  var length = buffer.readUInt32BE(0)
  if (length > 0) {
    this._parse(length, this._onMessage)
  } else {
    this._onKeepAlive()
    this._parse(4, this._onMessageLength)
  }
}

/**
 * Handle a message from the remote peer.
 * @param  {Buffer} buffer
 */
Wire.prototype._onMessage = function (buffer) {
  this._parse(4, this._onMessageLength)
  switch (buffer[0]) {
    case 0:
      return this._onChoke()
    case 1:
      return this._onUnchoke()
    case 2:
      return this._onInterested()
    case 3:
      return this._onUninterested()
    case 4:
      return this._onHave(buffer.readUInt32BE(1))
    case 5:
      return this._onBitField(buffer.slice(1))
    case 6:
      return this._onRequest(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.readUInt32BE(9))
    case 7:
      return this._onPiece(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.slice(9))
    case 8:
      return this._onCancel(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.readUInt32BE(9))
    case 9:
      return this._onPort(buffer.readUInt16BE(1))
    case 20:
      return this._onExtended(buffer.readUInt8(1), buffer.slice(2))
    default:
      this._debug('got unknown message')
      return this.emit('unknownmessage', buffer)
  }
}

Wire.prototype._parseHandshake = function () {
  var self = this
  self._parse(1, function (buffer) {
    var pstrlen = buffer.readUInt8(0)
    self._parse(pstrlen + 48, function (handshake) {
      var protocol = handshake.slice(0, pstrlen)
      if (protocol.toString() !== 'BitTorrent protocol') {
        self._debug('Error: wire not speaking BitTorrent protocol (%s)', protocol.toString())
        self.end()
        return
      }
      handshake = handshake.slice(pstrlen)
      self._onHandshake(handshake.slice(8, 28), handshake.slice(28, 48), {
        dht: !!(handshake[7] & 0x01), // see bep_0005
        extended: !!(handshake[5] & 0x10) // see bep_0010
      })
      self._parse(4, self._onMessageLength)
    })
  })
}

Wire.prototype._onFinish = function () {
  this._finished = true

  this.push(null) // stream cannot be half open, so signal the end of it
  while (this.read()) {} // consume and discard the rest of the stream data

  clearInterval(this._keepAliveInterval)
  this._parse(Number.MAX_VALUE, function () {})
  this.peerRequests = []
  while (this.requests.length) {
    this._callback(this.requests.shift(), new Error('wire was closed'), null)
  }
}

Wire.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}

function pull (requests, piece, offset, length) {
  for (var i = 0; i < requests.length; i++) {
    var req = requests[i]
    if (req.piece !== piece || req.offset !== offset || req.length !== length) continue

    if (i === 0) requests.shift()
    else requests.splice(i, 1)

    return req
  }
  return null
}

},{"bencode":7,"bitfield":9,"debug":31,"hat":39,"inherits":43,"readable-stream":86,"safe-buffer":92,"speedometer":98,"xtend":139}],11:[function(require,module,exports){
(function (process){
module.exports = Client

var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('bittorrent-tracker')
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var inherits = require('inherits')
var once = require('once')
var parallel = require('run-parallel')
var Peer = require('simple-peer')
var uniq = require('uniq')
var url = require('url')

var common = require('./lib/common')
var HTTPTracker = require('./lib/client/http-tracker') // empty object in browser
var UDPTracker = require('./lib/client/udp-tracker') // empty object in browser
var WebSocketTracker = require('./lib/client/websocket-tracker')

inherits(Client, EventEmitter)

/**
 * BitTorrent tracker client.
 *
 * Find torrent peers, to help a torrent client participate in a torrent swarm.
 *
 * @param {Object} opts                          options object
 * @param {string|Buffer} opts.infoHash          torrent info hash
 * @param {string|Buffer} opts.peerId            peer id
 * @param {string|Array.<string>} opts.announce  announce
 * @param {number} opts.port                     torrent client listening port
 * @param {function} opts.getAnnounceOpts        callback to provide data to tracker
 * @param {number} opts.rtcConfig                RTCPeerConnection configuration object
 * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)
 */
function Client (opts) {
  var self = this
  if (!(self instanceof Client)) return new Client(opts)
  EventEmitter.call(self)
  if (!opts) opts = {}

  if (!opts.peerId) throw new Error('Option `peerId` is required')
  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!opts.announce) throw new Error('Option `announce` is required')
  if (!process.browser && !opts.port) throw new Error('Option `port` is required')

  // required
  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : opts.peerId.toString('hex')
  self._peerIdBuffer = Buffer.from(self.peerId, 'hex')
  self._peerIdBinary = self._peerIdBuffer.toString('binary')

  self.infoHash = typeof opts.infoHash === 'string'
    ? opts.infoHash
    : opts.infoHash.toString('hex')
  self._infoHashBuffer = Buffer.from(self.infoHash, 'hex')
  self._infoHashBinary = self._infoHashBuffer.toString('binary')

  self._port = opts.port

  self.destroyed = false

  self._rtcConfig = opts.rtcConfig
  self._wrtc = opts.wrtc
  self._getAnnounceOpts = opts.getAnnounceOpts

  debug('new client %s', self.infoHash)

  var webrtcSupport = self._wrtc !== false && (!!self._wrtc || Peer.WEBRTC_SUPPORT)

  var announce = (typeof opts.announce === 'string')
    ? [ opts.announce ]
    : opts.announce == null
      ? []
      : opts.announce

  announce = announce.map(function (announceUrl) {
    announceUrl = announceUrl.toString()
    if (announceUrl[announceUrl.length - 1] === '/') {
      // remove trailing slash from trackers to catch duplicates
      announceUrl = announceUrl.substring(0, announceUrl.length - 1)
    }
    return announceUrl
  })

  announce = uniq(announce)

  self._trackers = announce
    .map(function (announceUrl) {
      var protocol = url.parse(announceUrl).protocol
      if ((protocol === 'http:' || protocol === 'https:') &&
          typeof HTTPTracker === 'function') {
        return new HTTPTracker(self, announceUrl)
      } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {
        return new UDPTracker(self, announceUrl)
      } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {
        // Skip ws:// trackers on https:// sites because they throw SecurityError
        if (protocol === 'ws:' && typeof window !== 'undefined' &&
            window.location.protocol === 'https:') {
          nextTickWarn(new Error('Unsupported tracker protocol: ' + announceUrl))
          return null
        }
        return new WebSocketTracker(self, announceUrl)
      } else {
        nextTickWarn(new Error('Unsupported tracker protocol: ' + announceUrl))
        return null
      }
    })
    .filter(Boolean)

  function nextTickWarn (err) {
    process.nextTick(function () {
      self.emit('warning', err)
    })
  }
}

/**
 * Simple convenience function to scrape a tracker for an info hash without needing to
 * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple
 * torrents at the same time.
 * @params {Object} opts
 * @param  {string|Array.<string>} opts.infoHash
 * @param  {string} opts.announce
 * @param  {function} cb
 */
Client.scrape = function (opts, cb) {
  cb = once(cb)

  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!opts.announce) throw new Error('Option `announce` is required')

  var clientOpts = extend(opts, {
    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,
    peerId: Buffer.from('01234567890123456789'), // dummy value
    port: 6881 // dummy value
  })

  var client = new Client(clientOpts)
  client.once('error', cb)

  var len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1
  var results = {}
  client.on('scrape', function (data) {
    len -= 1
    results[data.infoHash] = data
    if (len === 0) {
      client.destroy()
      var keys = Object.keys(results)
      if (keys.length === 1) {
        cb(null, results[keys[0]])
      } else {
        cb(null, results)
      }
    }
  })

  opts.infoHash = Array.isArray(opts.infoHash)
    ? opts.infoHash.map(function (infoHash) {
      return Buffer.from(infoHash, 'hex')
    })
    : Buffer.from(opts.infoHash, 'hex')
  client.scrape({ infoHash: opts.infoHash })
  return client
}

/**
 * Send a `start` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.start = function (opts) {
  var self = this
  debug('send `start`')
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'started'
  self._announce(opts)

  // start announcing on intervals
  self._trackers.forEach(function (tracker) {
    tracker.setInterval()
  })
}

/**
 * Send a `stop` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.stop = function (opts) {
  var self = this
  debug('send `stop`')
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'stopped'
  self._announce(opts)
}

/**
 * Send a `complete` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.complete = function (opts) {
  var self = this
  debug('send `complete`')
  if (!opts) opts = {}
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'completed'
  self._announce(opts)
}

/**
 * Send a `update` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.update = function (opts) {
  var self = this
  debug('send `update`')
  opts = self._defaultAnnounceOpts(opts)
  if (opts.event) delete opts.event
  self._announce(opts)
}

Client.prototype._announce = function (opts) {
  var self = this
  self._trackers.forEach(function (tracker) {
    // tracker should not modify `opts` object, it's passed to all trackers
    tracker.announce(opts)
  })
}

/**
 * Send a scrape request to the trackers.
 * @param {Object} opts
 */
Client.prototype.scrape = function (opts) {
  var self = this
  debug('send `scrape`')
  if (!opts) opts = {}
  self._trackers.forEach(function (tracker) {
    // tracker should not modify `opts` object, it's passed to all trackers
    tracker.scrape(opts)
  })
}

Client.prototype.setInterval = function (intervalMs) {
  var self = this
  debug('setInterval %d', intervalMs)
  self._trackers.forEach(function (tracker) {
    tracker.setInterval(intervalMs)
  })
}

Client.prototype.destroy = function (cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  debug('destroy')

  var tasks = self._trackers.map(function (tracker) {
    return function (cb) {
      tracker.destroy(cb)
    }
  })

  parallel(tasks, cb)

  self._trackers = []
  self._getAnnounceOpts = null
}

Client.prototype._defaultAnnounceOpts = function (opts) {
  var self = this
  if (!opts) opts = {}

  if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS

  if (opts.uploaded == null) opts.uploaded = 0
  if (opts.downloaded == null) opts.downloaded = 0

  if (self._getAnnounceOpts) opts = extend(opts, self._getAnnounceOpts())
  return opts
}

}).call(this,require('_process'))

},{"./lib/client/http-tracker":17,"./lib/client/udp-tracker":17,"./lib/client/websocket-tracker":13,"./lib/common":14,"_process":73,"debug":31,"events":35,"inherits":43,"once":63,"run-parallel":90,"safe-buffer":92,"simple-peer":95,"uniq":115,"url":117,"xtend":139}],12:[function(require,module,exports){
module.exports = Tracker

var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')

inherits(Tracker, EventEmitter)

function Tracker (client, announceUrl) {
  var self = this
  EventEmitter.call(self)
  self.client = client
  self.announceUrl = announceUrl

  self.interval = null
  self.destroyed = false
}

Tracker.prototype.setInterval = function (intervalMs) {
  var self = this
  if (intervalMs == null) intervalMs = self.DEFAULT_ANNOUNCE_INTERVAL

  clearInterval(self.interval)

  if (intervalMs) {
    self.interval = setInterval(function () {
      self.announce(self.client._defaultAnnounceOpts())
    }, intervalMs)
    if (self.interval.unref) self.interval.unref()
  }
}

},{"events":35,"inherits":43}],13:[function(require,module,exports){
module.exports = WebSocketTracker

var debug = require('debug')('bittorrent-tracker:websocket-tracker')
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var Peer = require('simple-peer')
var Socket = require('simple-websocket')

var common = require('../common')
var Tracker = require('./tracker')

// Use a socket pool, so tracker clients share WebSocket objects for the same server.
// In practice, WebSockets are pretty slow to establish, so this gives a nice performance
// boost, and saves browser resources.
var socketPool = {}

var RECONNECT_MINIMUM = 15 * 1000
var RECONNECT_MAXIMUM = 30 * 60 * 1000
var RECONNECT_VARIANCE = 30 * 1000
var OFFER_TIMEOUT = 50 * 1000

inherits(WebSocketTracker, Tracker)

function WebSocketTracker (client, announceUrl, opts) {
  var self = this
  Tracker.call(self, client, announceUrl)
  debug('new websocket tracker %s', announceUrl)

  self.peers = {} // peers (offer id -> peer)
  self.socket = null

  self.reconnecting = false
  self.retries = 0
  self.reconnectTimer = null

  self._openSocket()
}

WebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1000 // 30 seconds

WebSocketTracker.prototype.announce = function (opts) {
  var self = this
  if (self.destroyed || self.reconnecting) return
  if (!self.socket.connected) {
    self.socket.once('connect', function () {
      self.announce(opts)
    })
    return
  }

  var params = extend(opts, {
    action: 'announce',
    info_hash: self.client._infoHashBinary,
    peer_id: self.client._peerIdBinary
  })
  if (self._trackerId) params.trackerid = self._trackerId

  if (opts.event === 'stopped') {
    // Don't include offers with 'stopped' event
    self._send(params)
  } else {
    // Limit the number of offers that are generated, since it can be slow
    var numwant = Math.min(opts.numwant, 5)

    self._generateOffers(numwant, function (offers) {
      params.numwant = numwant
      params.offers = offers
      self._send(params)
    })
  }
}

WebSocketTracker.prototype.scrape = function (opts) {
  var self = this
  if (self.destroyed || self.reconnecting) return
  if (!self.socket.connected) {
    self.socket.once('connect', function () {
      self.scrape(opts)
    })
    return
  }

  var infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)
    ? opts.infoHash.map(function (infoHash) {
      return infoHash.toString('binary')
    })
    : (opts.infoHash && opts.infoHash.toString('binary')) || self.client._infoHashBinary
  var params = {
    action: 'scrape',
    info_hash: infoHashes
  }

  self._send(params)
}

WebSocketTracker.prototype.destroy = function (cb) {
  var self = this
  if (!cb) cb = noop
  if (self.destroyed) return cb(null)

  self.destroyed = true

  clearInterval(self.interval)
  clearTimeout(self.reconnectTimer)

  if (self.socket) {
    self.socket.removeListener('connect', self._onSocketConnectBound)
    self.socket.removeListener('data', self._onSocketDataBound)
    self.socket.removeListener('close', self._onSocketCloseBound)
    self.socket.removeListener('error', self._onSocketErrorBound)
  }

  self._onSocketConnectBound = null
  self._onSocketErrorBound = null
  self._onSocketDataBound = null
  self._onSocketCloseBound = null

  // Destroy peers
  for (var peerId in self.peers) {
    var peer = self.peers[peerId]
    clearTimeout(peer.trackerTimeout)
    peer.destroy()
  }
  self.peers = null

  if (socketPool[self.announceUrl]) {
    socketPool[self.announceUrl].consumers -= 1
  }

  if (socketPool[self.announceUrl].consumers === 0) {
    delete socketPool[self.announceUrl]

    try {
      self.socket.on('error', noop) // ignore all future errors
      self.socket.destroy(cb)
    } catch (err) {
      cb(null)
    }
  } else {
    cb(null)
  }

  self.socket = null
}

WebSocketTracker.prototype._openSocket = function () {
  var self = this
  self.destroyed = false

  if (!self.peers) self.peers = {}

  self._onSocketConnectBound = function () {
    self._onSocketConnect()
  }
  self._onSocketErrorBound = function (err) {
    self._onSocketError(err)
  }
  self._onSocketDataBound = function (data) {
    self._onSocketData(data)
  }
  self._onSocketCloseBound = function () {
    self._onSocketClose()
  }

  self.socket = socketPool[self.announceUrl]
  if (self.socket) {
    socketPool[self.announceUrl].consumers += 1
  } else {
    self.socket = socketPool[self.announceUrl] = new Socket(self.announceUrl)
    self.socket.consumers = 1
    self.socket.on('connect', self._onSocketConnectBound)
  }

  self.socket.on('data', self._onSocketDataBound)
  self.socket.on('close', self._onSocketCloseBound)
  self.socket.on('error', self._onSocketErrorBound)
}

WebSocketTracker.prototype._onSocketConnect = function () {
  var self = this
  if (self.destroyed) return

  if (self.reconnecting) {
    self.reconnecting = false
    self.retries = 0
    self.announce(self.client._defaultAnnounceOpts())
  }
}

WebSocketTracker.prototype._onSocketData = function (data) {
  var self = this
  if (self.destroyed) return

  try {
    data = JSON.parse(data)
  } catch (err) {
    self.client.emit('warning', new Error('Invalid tracker response'))
    return
  }

  if (data.action === 'announce') {
    self._onAnnounceResponse(data)
  } else if (data.action === 'scrape') {
    self._onScrapeResponse(data)
  } else {
    self._onSocketError(new Error('invalid action in WS response: ' + data.action))
  }
}

WebSocketTracker.prototype._onAnnounceResponse = function (data) {
  var self = this

  if (data.info_hash !== self.client._infoHashBinary) {
    debug(
      'ignoring websocket data from %s for %s (looking for %s: reused socket)',
      self.announceUrl, common.binaryToHex(data.info_hash), self.client.infoHash
    )
    return
  }

  if (data.peer_id && data.peer_id === self.client._peerIdBinary) {
    // ignore offers/answers from this client
    return
  }

  debug(
    'received %s from %s for %s',
    JSON.stringify(data), self.announceUrl, self.client.infoHash
  )

  var failure = data['failure reason']
  if (failure) return self.client.emit('warning', new Error(failure))

  var warning = data['warning message']
  if (warning) self.client.emit('warning', new Error(warning))

  var interval = data.interval || data['min interval']
  if (interval) self.setInterval(interval * 1000)

  var trackerId = data['tracker id']
  if (trackerId) {
    // If absent, do not discard previous trackerId value
    self._trackerId = trackerId
  }

  if (data.complete != null) {
    self.client.emit('update', {
      announce: self.announceUrl,
      complete: data.complete,
      incomplete: data.incomplete
    })
  }

  var peer
  if (data.offer && data.peer_id) {
    debug('creating peer (from remote offer)')
    peer = new Peer({
      trickle: false,
      config: self.client._rtcConfig,
      wrtc: self.client._wrtc
    })
    peer.id = common.binaryToHex(data.peer_id)
    peer.once('signal', function (answer) {
      var params = {
        action: 'announce',
        info_hash: self.client._infoHashBinary,
        peer_id: self.client._peerIdBinary,
        to_peer_id: data.peer_id,
        answer: answer,
        offer_id: data.offer_id
      }
      if (self._trackerId) params.trackerid = self._trackerId
      self._send(params)
    })
    peer.signal(data.offer)
    self.client.emit('peer', peer)
  }

  if (data.answer && data.peer_id) {
    var offerId = common.binaryToHex(data.offer_id)
    peer = self.peers[offerId]
    if (peer) {
      peer.id = common.binaryToHex(data.peer_id)
      peer.signal(data.answer)
      self.client.emit('peer', peer)

      clearTimeout(peer.trackerTimeout)
      peer.trackerTimeout = null
      delete self.peers[offerId]
    } else {
      debug('got unexpected answer: ' + JSON.stringify(data.answer))
    }
  }
}

WebSocketTracker.prototype._onScrapeResponse = function (data) {
  var self = this
  data = data.files || {}

  var keys = Object.keys(data)
  if (keys.length === 0) {
    self.client.emit('warning', new Error('invalid scrape response'))
    return
  }

  keys.forEach(function (infoHash) {
    var response = data[infoHash]
    // TODO: optionally handle data.flags.min_request_interval
    // (separate from announce interval)
    self.client.emit('scrape', {
      announce: self.announceUrl,
      infoHash: common.binaryToHex(infoHash),
      complete: response.complete,
      incomplete: response.incomplete,
      downloaded: response.downloaded
    })
  })
}

WebSocketTracker.prototype._onSocketClose = function () {
  var self = this
  if (self.destroyed) return
  self.destroy()
  self._startReconnectTimer()
}

WebSocketTracker.prototype._onSocketError = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroy()
  // errors will often happen if a tracker is offline, so don't treat it as fatal
  self.client.emit('warning', err)
  self._startReconnectTimer()
}

WebSocketTracker.prototype._startReconnectTimer = function () {
  var self = this
  var ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, self.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)

  self.reconnecting = true
  clearTimeout(self.reconnectTimer)
  self.reconnectTimer = setTimeout(function () {
    self.retries++
    self._openSocket()
  }, ms)
  if (self.reconnectTimer.unref) self.reconnectTimer.unref()

  debug('reconnecting socket in %s ms', ms)
}

WebSocketTracker.prototype._send = function (params) {
  var self = this
  if (self.destroyed) return

  var message = JSON.stringify(params)
  debug('send %s', message)
  self.socket.send(message)
}

WebSocketTracker.prototype._generateOffers = function (numwant, cb) {
  var self = this
  var offers = []
  debug('generating %s offers', numwant)

  for (var i = 0; i < numwant; ++i) {
    generateOffer()
  }
  checkDone()

  function generateOffer () {
    var offerId = hat(160)
    debug('creating peer (from _generateOffers)')
    var peer = self.peers[offerId] = new Peer({
      initiator: true,
      trickle: false,
      config: self.client._rtcConfig,
      wrtc: self.client._wrtc
    })
    peer.once('signal', function (offer) {
      offers.push({
        offer: offer,
        offer_id: common.hexToBinary(offerId)
      })
      checkDone()
    })
    peer.trackerTimeout = setTimeout(function () {
      debug('tracker timeout: destroying peer')
      peer.trackerTimeout = null
      delete self.peers[offerId]
      peer.destroy()
    }, OFFER_TIMEOUT)
    if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()
  }

  function checkDone () {
    if (offers.length === numwant) {
      debug('generated %s offers', numwant)
      cb(offers)
    }
  }
}

function noop () {}

},{"../common":14,"./tracker":12,"debug":31,"hat":39,"inherits":43,"simple-peer":95,"simple-websocket":97,"xtend":139}],14:[function(require,module,exports){
/**
 * Functions/constants needed by both the client and server.
 */

var Buffer = require('safe-buffer').Buffer
var extend = require('xtend/mutable')

exports.DEFAULT_ANNOUNCE_PEERS = 50
exports.MAX_ANNOUNCE_PEERS = 82

exports.binaryToHex = function (str) {
  if (typeof str !== 'string') {
    str = String(str)
  }
  return Buffer.from(str, 'binary').toString('hex')
}

exports.hexToBinary = function (str) {
  if (typeof str !== 'string') {
    str = String(str)
  }
  return Buffer.from(str, 'hex').toString('binary')
}

var config = require('./common-node')
extend(exports, config)

},{"./common-node":17,"safe-buffer":92,"xtend/mutable":140}],15:[function(require,module,exports){
(function (Buffer){
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  var reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, new Buffer(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this,require("buffer").Buffer)

},{"buffer":20}],16:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits');
var Transform = require('readable-stream').Transform;
var defined = require('defined');

module.exports = Block;
inherits(Block, Transform);

function Block (size, opts) {
    if (!(this instanceof Block)) return new Block(size, opts);
    Transform.call(this);
    if (!opts) opts = {};
    if (typeof size === 'object') {
        opts = size;
        size = opts.size;
    }
    this.size = size || 512;
    
    if (opts.nopad) this._zeroPadding = false;
    else this._zeroPadding = defined(opts.zeroPadding, true);
    
    this._buffered = [];
    this._bufferedBytes = 0;
}

Block.prototype._transform = function (buf, enc, next) {
    this._bufferedBytes += buf.length;
    this._buffered.push(buf);
    
    while (this._bufferedBytes >= this.size) {
        var b = Buffer.concat(this._buffered);
        this._bufferedBytes -= this.size;
        this.push(b.slice(0, this.size));
        this._buffered = [ b.slice(this.size, b.length) ];
    }
    next();
};

Block.prototype._flush = function () {
    if (this._bufferedBytes && this._zeroPadding) {
        var zeroes = new Buffer(this.size - this._bufferedBytes);
        zeroes.fill(0);
        this._buffered.push(zeroes);
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
    }
    else if (this._bufferedBytes) {
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
    }
    this.push(null);
};

}).call(this,require("buffer").Buffer)

},{"buffer":20,"defined":33,"inherits":43,"readable-stream":86}],17:[function(require,module,exports){

},{}],18:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],19:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":20}],20:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; i++) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  that.write(string, encoding)
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

function arrayIndexOf (arr, val, byteOffset, encoding) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var foundIndex = -1
  for (var i = 0; byteOffset + i < arrLength; i++) {
    if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
      if (foundIndex === -1) foundIndex = i
      if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize
    } else {
      if (foundIndex !== -1) i -= i - foundIndex
      foundIndex = -1
    }
  }
  return -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  if (Buffer.isBuffer(val)) {
    // special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(this, val, byteOffset, encoding)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset, encoding)
  }

  throw new TypeError('val must be string, number or Buffer')
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; i++) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; i++) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":4,"ieee754":41,"isarray":49}],21:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],22:[function(require,module,exports){
module.exports = ChunkStoreWriteStream

var BlockStream = require('block-stream2')
var inherits = require('inherits')
var stream = require('readable-stream')

inherits(ChunkStoreWriteStream, stream.Writable)

function ChunkStoreWriteStream (store, chunkLength, opts) {
  var self = this
  if (!(self instanceof ChunkStoreWriteStream)) {
    return new ChunkStoreWriteStream(store, chunkLength, opts)
  }
  stream.Writable.call(self, opts)
  if (!opts) opts = {}

  if (!store || !store.put || !store.get) {
    throw new Error('First argument must be an abstract-chunk-store compliant store')
  }
  chunkLength = Number(chunkLength)
  if (!chunkLength) throw new Error('Second argument must be a chunk length')

  self._blockstream = new BlockStream(chunkLength, { zeroPadding: false })

  self._blockstream
    .on('data', onData)
    .on('error', function (err) { self.destroy(err) })

  var index = 0
  function onData (chunk) {
    if (self.destroyed) return
    store.put(index, chunk)
    index += 1
  }

  self.on('finish', function () { this._blockstream.end() })
}

ChunkStoreWriteStream.prototype._write = function (chunk, encoding, callback) {
  this._blockstream.write(chunk, encoding, callback)
}

ChunkStoreWriteStream.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
}

},{"block-stream2":16,"inherits":43,"readable-stream":86}],23:[function(require,module,exports){
module.exports = function(target, numbers) {
  var closest = Infinity
  var difference = 0
  var winner = null

  numbers.sort(function(a, b) {
    return a - b
  })

  for (var i = 0, l = numbers.length; i < l; i++) {  
    difference = Math.abs(target - numbers[i])
    if (difference >= closest) {
      break
    }
    closest = difference
    winner = numbers[i]
  }

  return winner
}

},{}],24:[function(require,module,exports){
var ipaddr = require('ipaddr.js');

module.exports = compact2string = function (buf) {
  switch(buf.length) {
  case 6:
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3] + ":" + buf.readUInt16BE(4);
    break;
  case 18:
    var hexGroups = [];
    for(var i = 0; i < 8; i++) {
      hexGroups.push(buf.readUInt16BE(i * 2).toString(16));
    }
    var host = ipaddr.parse(hexGroups.join(":")).toString();
    return "[" + host + "]:" + buf.readUInt16BE(16);
  default:
    throw new Error("Invalid Compact IP/PORT, It should contain 6 or 18 bytes");
  }
};

compact2string.multi = function (buf) {
  if(buf.length % 6 !== 0)
    throw new Error("buf length isn't multiple of compact IP/PORTs (6 bytes)");

  var output = [];
  for (var i = 0; i <= buf.length - 1; i = i + 6) {
    output.push(compact2string(buf.slice(i, i + 6)));
  }

  return output;
};

compact2string.multi6 = function (buf) {
  if(buf.length % 18 !== 0)
    throw new Error("buf length isn't multiple of compact IP6/PORTs (18 bytes)");

  var output = [];
  for (var i = 0; i <= buf.length - 1; i = i + 18) {
    output.push(compact2string(buf.slice(i, i + 18)));
  }

  return output;
};

},{"ipaddr.js":44}],25:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":46}],26:[function(require,module,exports){
(function (process,global,Buffer){
module.exports = createTorrent
module.exports.parseInput = parseInput

module.exports.announceList = [
  [ 'udp://tracker.openbittorrent.com:80' ],
  [ 'udp://tracker.internetwarriors.net:1337' ],
  [ 'udp://tracker.leechers-paradise.org:6969' ],
  [ 'udp://tracker.coppersurfer.tk:6969' ],
  [ 'udp://exodus.desync.com:6969' ],
  [ 'wss://tracker.webtorrent.io' ],
  [ 'wss://tracker.btorrent.xyz' ],
  [ 'wss://tracker.openwebtorrent.com' ],
  [ 'wss://tracker.fastcast.nz' ]
]

var bencode = require('bencode')
var BlockStream = require('block-stream2')
var calcPieceLength = require('piece-length')
var corePath = require('path')
var extend = require('xtend')
var FileReadStream = require('filestream/read')
var flatten = require('flatten')
var fs = require('fs')
var isFile = require('is-file')
var junk = require('junk')
var MultiStream = require('multistream')
var once = require('once')
var parallel = require('run-parallel')
var sha1 = require('simple-sha1')
var stream = require('readable-stream')

/**
 * Create a torrent.
 * @param  {string|File|FileList|Buffer|Stream|Array.<string|File|Buffer|Stream>} input
 * @param  {Object} opts
 * @param  {string=} opts.name
 * @param  {Date=} opts.creationDate
 * @param  {string=} opts.comment
 * @param  {string=} opts.createdBy
 * @param  {boolean|number=} opts.private
 * @param  {number=} opts.pieceLength
 * @param  {Array.<Array.<string>>=} opts.announceList
 * @param  {Array.<string>=} opts.urlList
 * @param  {function} cb
 * @return {Buffer} buffer of .torrent file data
 */
function createTorrent (input, opts, cb) {
  if (typeof opts === 'function') return createTorrent(input, null, opts)
  opts = opts ? extend(opts) : {}

  _parseInput(input, opts, function (err, files, singleFileTorrent) {
    if (err) return cb(err)
    opts.singleFileTorrent = singleFileTorrent
    onFiles(files, opts, cb)
  })
}

function parseInput (input, opts, cb) {
  if (typeof opts === 'function') return parseInput(input, null, opts)
  opts = opts ? extend(opts) : {}
  _parseInput(input, opts, cb)
}

/**
 * Parse input file and return file information.
 */
function _parseInput (input, opts, cb) {
  if (Array.isArray(input) && input.length === 0) throw new Error('invalid input type')

  if (isFileList(input)) input = Array.prototype.slice.call(input)
  if (!Array.isArray(input)) input = [ input ]

  // In Electron, use the true file path
  input = input.map(function (item) {
    if (isBlob(item) && typeof item.path === 'string') return item.path
    return item
  })

  // If there's just one file, allow the name to be set by `opts.name`
  if (input.length === 1 && typeof input[0] !== 'string' && !input[0].name) input[0].name = opts.name

  var commonPrefix = null
  input.forEach(function (item, i) {
    if (typeof item === 'string') {
      return
    }

    var path = item.fullPath || item.name
    if (!path) {
      path = 'Unknown File ' + (i + 1)
      item.unknownName = true
    }

    item.path = path.split('/')

    // Remove initial slash
    if (!item.path[0]) {
      item.path.shift()
    }

    if (item.path.length < 2) { // No real prefix
      commonPrefix = null
    } else if (i === 0 && input.length > 1) { // The first file has a prefix
      commonPrefix = item.path[0]
    } else if (item.path[0] !== commonPrefix) { // The prefix doesn't match
      commonPrefix = null
    }
  })

  // remove junk files
  input = input.filter(function (item) {
    if (typeof item === 'string') {
      return true
    }
    var filename = item.path[item.path.length - 1]
    return notHidden(filename) && junk.not(filename)
  })

  if (commonPrefix) {
    input.forEach(function (item) {
      var pathless = (Buffer.isBuffer(item) || isReadable(item)) && !item.path
      if (typeof item === 'string' || pathless) return
      item.path.shift()
    })
  }

  if (!opts.name && commonPrefix) {
    opts.name = commonPrefix
  }

  if (!opts.name) {
    // use first user-set file name
    input.some(function (item) {
      if (typeof item === 'string') {
        opts.name = corePath.basename(item)
        return true
      } else if (!item.unknownName) {
        opts.name = item.path[item.path.length - 1]
        return true
      }
    })
  }

  if (!opts.name) {
    opts.name = 'Unnamed Torrent ' + Date.now()
  }

  var numPaths = input.reduce(function (sum, item) {
    return sum + Number(typeof item === 'string')
  }, 0)

  var isSingleFileTorrent = (input.length === 1)

  if (input.length === 1 && typeof input[0] === 'string') {
    if (typeof fs.stat !== 'function') {
      throw new Error('filesystem paths do not work in the browser')
    }
    // If there's a single path, verify it's a file before deciding this is a single
    // file torrent
    isFile(input[0], function (err, pathIsFile) {
      if (err) return cb(err)
      isSingleFileTorrent = pathIsFile
      processInput()
    })
  } else {
    process.nextTick(function () {
      processInput()
    })
  }

  function processInput () {
    parallel(input.map(function (item) {
      return function (cb) {
        var file = {}

        if (isBlob(item)) {
          file.getStream = getBlobStream(item)
          file.length = item.size
        } else if (Buffer.isBuffer(item)) {
          file.getStream = getBufferStream(item)
          file.length = item.length
        } else if (isReadable(item)) {
          file.getStream = getStreamStream(item, file)
          file.length = 0
        } else if (typeof item === 'string') {
          if (typeof fs.stat !== 'function') {
            throw new Error('filesystem paths do not work in the browser')
          }
          var keepRoot = numPaths > 1 || isSingleFileTorrent
          getFiles(item, keepRoot, cb)
          return // early return!
        } else {
          throw new Error('invalid input type')
        }
        file.path = item.path
        cb(null, file)
      }
    }), function (err, files) {
      if (err) return cb(err)
      files = flatten(files)
      cb(null, files, isSingleFileTorrent)
    })
  }
}

function getFiles (path, keepRoot, cb) {
  traversePath(path, getFileInfo, function (err, files) {
    if (err) return cb(err)

    if (Array.isArray(files)) files = flatten(files)
    else files = [ files ]

    path = corePath.normalize(path)
    if (keepRoot) {
      path = path.slice(0, path.lastIndexOf(corePath.sep) + 1)
    }
    if (path[path.length - 1] !== corePath.sep) path += corePath.sep

    files.forEach(function (file) {
      file.getStream = getFilePathStream(file.path)
      file.path = file.path.replace(path, '').split(corePath.sep)
    })
    cb(null, files)
  })
}

function getFileInfo (path, cb) {
  cb = once(cb)
  fs.stat(path, function (err, stat) {
    if (err) return cb(err)
    var info = {
      length: stat.size,
      path: path
    }
    cb(null, info)
  })
}

function traversePath (path, fn, cb) {
  fs.readdir(path, function (err, entries) {
    if (err && err.code === 'ENOTDIR') {
      // this is a file
      fn(path, cb)
    } else if (err) {
      // real error
      cb(err)
    } else {
      // this is a folder
      parallel(entries.filter(notHidden).filter(junk.not).map(function (entry) {
        return function (cb) {
          traversePath(corePath.join(path, entry), fn, cb)
        }
      }), cb)
    }
  })
}

function notHidden (file) {
  return file[0] !== '.'
}

function getPieceList (files, pieceLength, cb) {
  cb = once(cb)
  var pieces = []
  var length = 0

  var streams = files.map(function (file) {
    return file.getStream
  })

  var remainingHashes = 0
  var pieceNum = 0
  var ended = false

  var multistream = new MultiStream(streams)
  var blockstream = new BlockStream(pieceLength, { zeroPadding: false })

  multistream.on('error', onError)

  multistream
    .pipe(blockstream)
    .on('data', onData)
    .on('end', onEnd)
    .on('error', onError)

  function onData (chunk) {
    length += chunk.length

    var i = pieceNum
    sha1(chunk, function (hash) {
      pieces[i] = hash
      remainingHashes -= 1
      maybeDone()
    })
    remainingHashes += 1
    pieceNum += 1
  }

  function onEnd () {
    ended = true
    maybeDone()
  }

  function onError (err) {
    cleanup()
    cb(err)
  }

  function cleanup () {
    multistream.removeListener('error', onError)
    blockstream.removeListener('data', onData)
    blockstream.removeListener('end', onEnd)
    blockstream.removeListener('error', onError)
  }

  function maybeDone () {
    if (ended && remainingHashes === 0) {
      cleanup()
      cb(null, new Buffer(pieces.join(''), 'hex'), length)
    }
  }
}

function onFiles (files, opts, cb) {
  var announceList = opts.announceList

  if (!announceList) {
    if (typeof opts.announce === 'string') announceList = [ [ opts.announce ] ]
    else if (Array.isArray(opts.announce)) {
      announceList = opts.announce.map(function (u) { return [ u ] })
    }
  }

  if (!announceList) announceList = []

  if (global.WEBTORRENT_ANNOUNCE) {
    if (typeof global.WEBTORRENT_ANNOUNCE === 'string') {
      announceList.push([ [ global.WEBTORRENT_ANNOUNCE ] ])
    } else if (Array.isArray(global.WEBTORRENT_ANNOUNCE)) {
      announceList = announceList.concat(global.WEBTORRENT_ANNOUNCE.map(function (u) {
        return [ u ]
      }))
    }
  }

  // When no trackers specified, use some reasonable defaults
  if (opts.announce === undefined && opts.announceList === undefined) {
    announceList = announceList.concat(module.exports.announceList)
  }

  if (typeof opts.urlList === 'string') opts.urlList = [ opts.urlList ]

  var torrent = {
    info: {
      name: opts.name
    },
    'creation date': Math.ceil((Number(opts.creationDate) || Date.now()) / 1000),
    encoding: 'UTF-8'
  }

  if (announceList.length !== 0) {
    torrent.announce = announceList[0][0]
    torrent['announce-list'] = announceList
  }

  if (opts.comment !== undefined) torrent.comment = opts.comment

  if (opts.createdBy !== undefined) torrent['created by'] = opts.createdBy

  if (opts.private !== undefined) torrent.info.private = Number(opts.private)

  // "ssl-cert" key is for SSL torrents, see:
  //   - http://blog.libtorrent.org/2012/01/bittorrent-over-ssl/
  //   - http://www.libtorrent.org/manual-ref.html#ssl-torrents
  //   - http://www.libtorrent.org/reference-Create_Torrents.html
  if (opts.sslCert !== undefined) torrent.info['ssl-cert'] = opts.sslCert

  if (opts.urlList !== undefined) torrent['url-list'] = opts.urlList

  var pieceLength = opts.pieceLength || calcPieceLength(files.reduce(sumLength, 0))
  torrent.info['piece length'] = pieceLength

  getPieceList(files, pieceLength, function (err, pieces, torrentLength) {
    if (err) return cb(err)
    torrent.info.pieces = pieces

    files.forEach(function (file) {
      delete file.getStream
    })

    if (opts.singleFileTorrent) {
      torrent.info.length = torrentLength
    } else {
      torrent.info.files = files
    }

    cb(null, bencode.encode(torrent))
  })
}

/**
 * Accumulator to sum file lengths
 * @param  {number} sum
 * @param  {Object} file
 * @return {number}
 */
function sumLength (sum, file) {
  return sum + file.length
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

/**
 * Check if `obj` is a W3C `FileList` object
 * @param  {*} obj
 * @return {boolean}
 */
function isFileList (obj) {
  return typeof FileList === 'function' && obj instanceof FileList
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'
}

/**
 * Convert a `File` to a lazy readable stream.
 * @param  {File|Blob} file
 * @return {function}
 */
function getBlobStream (file) {
  return function () {
    return new FileReadStream(file)
  }
}

/**
 * Convert a `Buffer` to a lazy readable stream.
 * @param  {Buffer} buffer
 * @return {function}
 */
function getBufferStream (buffer) {
  return function () {
    var s = new stream.PassThrough()
    s.end(buffer)
    return s
  }
}

/**
 * Convert a file path to a lazy readable stream.
 * @param  {string} path
 * @return {function}
 */
function getFilePathStream (path) {
  return function () {
    return fs.createReadStream(path)
  }
}

/**
 * Convert a readable stream to a lazy readable stream. Adds instrumentation to track
 * the number of bytes in the stream and set `file.length`.
 *
 * @param  {Stream} stream
 * @param  {Object} file
 * @return {function}
 */
function getStreamStream (readable, file) {
  return function () {
    var counter = new stream.Transform()
    counter._transform = function (buf, enc, done) {
      file.length += buf.length
      this.push(buf)
      done()
    }
    readable.pipe(counter)
    return counter
  }
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":73,"bencode":27,"block-stream2":16,"buffer":20,"filestream/read":36,"flatten":37,"fs":18,"is-file":47,"junk":50,"multistream":61,"once":63,"path":70,"piece-length":71,"readable-stream":86,"run-parallel":90,"simple-sha1":96,"xtend":139}],27:[function(require,module,exports){
var bencode = module.exports

bencode.encode = require( './lib/encode' )
bencode.decode = require( './lib/decode' )

/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */
bencode.byteLength = bencode.encodingLength = function( value ) {
  return bencode.encode( value ).length
}

},{"./lib/decode":28,"./lib/encode":30}],28:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":29,"buffer":20}],29:[function(require,module,exports){
var Dict = module.exports = function Dict() {
  Object.defineProperty(this, "_keys", {
    enumerable: false,
    value: [],
  })
}

Dict.prototype.binaryKeys = function binaryKeys() {
  return this._keys.slice()
}

Dict.prototype.binarySet = function binarySet(key, value) {
  this._keys.push(key)

  this[key] = value
}

},{}],30:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],31:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":32}],32:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":60}],33:[function(require,module,exports){
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],34:[function(require,module,exports){
var once = require('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback();
	};

	var onend = function() {
		readable = false;
		if (!writable) callback();
	};

	var onexit = function(exitCode) {
		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', callback);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', callback);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;
},{"once":63}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],36:[function(require,module,exports){
var Readable = require('readable-stream').Readable;
var inherits = require('inherits');
var reExtension = /^.*\.(\w+)$/;
var toBuffer = require('typedarray-to-buffer');

function FileReadStream(file, opts) {
  var readStream = this;
  if (! (this instanceof FileReadStream)) {
    return new FileReadStream(file, opts);
  }
  opts = opts || {};

  // inherit readable
  Readable.call(this, opts);

  // save the read offset
  this._offset = 0;
  this._ready = false;
  this._file = file;
  this._size = file.size;
  this._chunkSize = opts.chunkSize || Math.max(this._size / 1000, 200 * 1024);

  // create the reader
  this.reader = new FileReader();

  // generate the header blocks that we will send as part of the initial payload
  this._generateHeaderBlocks(file, opts, function(err, blocks) {
    // if we encountered an error, emit it
    if (err) {
      return readStream.emit('error', err);
    }

    // push the header blocks out to the stream
    if (Array.isArray(blocks)) {
      blocks.forEach(function (block) {
        readStream.push(block);
      });
    }

    readStream._ready = true;
    readStream.emit('_ready');
  });
}

inherits(FileReadStream, Readable);
module.exports = FileReadStream;

FileReadStream.prototype._generateHeaderBlocks = function(file, opts, callback) {
  callback(null, []);
};

FileReadStream.prototype._read = function() {
  if (!this._ready) {
    this.once('_ready', this._read.bind(this));
    return;
  }
  var readStream = this;
  var reader = this.reader;

  var startOffset = this._offset;
  var endOffset = this._offset + this._chunkSize;
  if (endOffset > this._size) endOffset = this._size;

  if (startOffset === this._size) {
    this.destroy();
    this.push(null);
    return;
  }

  reader.onload = function() {
    // update the stream offset
    readStream._offset = endOffset;

    // get the data chunk
    readStream.push(toBuffer(reader.result));
  }
  reader.onerror = function() {
    readStream.emit('error', reader.error);
  }

  reader.readAsArrayBuffer(this._file.slice(startOffset, endOffset));
};

FileReadStream.prototype.destroy = function() {
  this._file = null;
  if (this.reader) {
    this.reader.onload = null;
    this.reader.onerror = null;
    try { this.reader.abort(); } catch (e) {};
  }
  this.reader = null;
}

},{"inherits":43,"readable-stream":86,"typedarray-to-buffer":113}],37:[function(require,module,exports){
module.exports = function flatten(list, depth) {
  depth = (typeof depth == 'number') ? depth : Infinity;

  if (!depth) {
    if (Array.isArray(list)) {
      return list.map(function(i) { return i; });
    }
    return list;
  }

  return _flatten(list, 1);

  function _flatten(list, d) {
    return list.reduce(function (acc, item) {
      if (Array.isArray(item) && d < depth) {
        return acc.concat(_flatten(item, d + 1));
      }
      else {
        return acc.concat(item);
      }
    }, []);
  }
};

},{}],38:[function(require,module,exports){
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof window === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection ||
      window.webkitRTCPeerConnection,
    RTCSessionDescription: window.RTCSessionDescription ||
      window.mozRTCSessionDescription || window.webkitRTCSessionDescription,
    RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate ||
      window.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],39:[function(require,module,exports){
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};

},{}],40:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":99}],41:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],42:[function(require,module,exports){
(function (process){
module.exports = ImmediateStore

function ImmediateStore (store) {
  if (!(this instanceof ImmediateStore)) return new ImmediateStore(store)

  this.store = store
  this.chunkLength = store.chunkLength

  if (!this.store || !this.store.get || !this.store.put) {
    throw new Error('First argument must be abstract-chunk-store compliant')
  }

  this.mem = []
}

ImmediateStore.prototype.put = function (index, buf, cb) {
  var self = this
  self.mem[index] = buf
  self.store.put(index, buf, function (err) {
    self.mem[index] = null
    if (cb) cb(err)
  })
}

ImmediateStore.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)

  var start = (opts && opts.offset) || 0
  var end = opts && opts.length && (start + opts.length)

  var buf = this.mem[index]
  if (buf) return nextTick(cb, null, opts ? buf.slice(start, end) : buf)

  this.store.get(index, opts, cb)
}

ImmediateStore.prototype.close = function (cb) {
  this.store.close(cb)
}

ImmediateStore.prototype.destroy = function (cb) {
  this.store.destroy(cb)
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    if (cb) cb(err, val)
  })
}

}).call(this,require('_process'))

},{"_process":73}],43:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],44:[function(require,module,exports){
(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

  ipaddr = {};

  root = this;

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var rangeName, rangeSubnets, subnet, _i, _len;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
        subnet = rangeSubnets[_i];
        if (address.match.apply(address, subnet)) {
          return rangeName;
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var octet, _i, _len;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (_i = 0, _len = octets.length; _i < _len; _i++) {
        octet = octets[_i];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var _ref;
      if (cidrRange === void 0) {
        _ref = other, other = _ref[0], cidrRange = _ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, octet, stop, zeros, zerotable, _i;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = _i = 3; _i >= 0; i = _i += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var _i, _len, _ref, _results;
        _ref = match.slice(1, 6);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(parseIntAuto(part));
        }
        return _results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var _i, _results;
        _results = [];
        for (shift = _i = 0; _i <= 24; shift = _i += 8) {
          _results.push((value >> shift) & 0xff);
        }
        return _results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts) {
      var i, part, _i, _j, _len, _ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = _i = 0; _i <= 14; i = _i += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      _ref = this.parts;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        part = _ref[_j];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      var compactStringParts, part, pushPart, state, stringParts, _i, _len;
      stringParts = (function() {
        var _i, _len, _ref, _results;
        _ref = this.parts;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(16));
        }
        return _results;
      }).call(this);
      compactStringParts = [];
      pushPart = function(part) {
        return compactStringParts.push(part);
      };
      state = 0;
      for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
        part = stringParts[_i];
        switch (state) {
          case 0:
            if (part === '0') {
              pushPart('');
            } else {
              pushPart(part);
            }
            state = 1;
            break;
          case 1:
            if (part === '0') {
              state = 2;
            } else {
              pushPart(part);
            }
            break;
          case 2:
            if (part !== '0') {
              pushPart('');
              pushPart(part);
              state = 3;
            }
            break;
          case 3:
            pushPart(part);
        }
      }
      if (state === 2) {
        pushPart('');
        pushPart('');
      }
      return compactStringParts.join(":");
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, part, _i, _len, _ref;
      bytes = [];
      _ref = this.parts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var part;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.parts;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(16));
        }
        return _results;
      }).call(this)).join(":");
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var _ref;
      if (cidrRange === void 0) {
        _ref = other, other = _ref[0], cidrRange = _ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, _ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  ipv6Regexes = {
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    return (function() {
      var _i, _len, _ref, _results;
      _ref = string.split(":");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        _results.push(parseInt(part, 16));
      }
      return _results;
    })();
  };

  ipaddr.IPv6.parser = function(string) {
    var match, octet, octets, parts, _i, _len;
    if (string.match(ipv6Regexes['native'])) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      parts = expandIPv6(match[1].slice(0, -1), 6);
      if (parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (_i = 0, _len = octets.length; _i < _len; _i++) {
          octet = octets[_i];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        parts.push(octets[0] << 8 | octets[1]);
        parts.push(octets[2] << 8 | octets[3]);
        return parts;
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      new this(this.parser(string));
      return true;
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (_error) {
      e = _error;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (_error) {
        e = _error;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);

},{}],45:[function(require,module,exports){
/* (c) 2016 Ari Porad (@ariporad) <http://ariporad.com>. License: ariporad.mit-license.org */

// Partially from http://stackoverflow.com/a/94049/1928484, and from another SO answer, which told me that the highest
// char code that's ascii is 127, but I can't find the link for. Sorry.

var MAX_ASCII_CHAR_CODE = 127;

module.exports = function isAscii(str) {
  for (var i = 0, strLen = str.length; i < strLen; ++i) {
    if (str.charCodeAt(i) > MAX_ASCII_CHAR_CODE) return false;
  }
  return true;
};

},{}],46:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],47:[function(require,module,exports){
'use strict';

var fs = require('fs');

module.exports = function isFile(path, cb){
  if(!cb)return isFileSync(path);

  fs.stat(path, function(err, stats){
    if(err)return cb(err);
    return cb(null, stats.isFile());
  });
};

module.exports.sync = isFileSync;

function isFileSync(path){
  return fs.existsSync(path) && fs.statSync(path).isFile();
}

},{"fs":18}],48:[function(require,module,exports){
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

},{}],49:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],50:[function(require,module,exports){
'use strict';

// // All
// /^npm-debug\.log$/,   // npm error log
// /^\..*\.swp$/,        // vim state
// // OS X
// /^\.DS_Store$/,       // stores custom folder attributes
// /^\.AppleDouble$/,    // stores additional file resources
// /^\.LSOverride$/,     // contains the absolute path to the app to be used
// /^Icon[\r\?]?/,       // custom Finder icon
// /^\._.*/,             // thumbnail
// /^\.Spotlight-V100$/,  // file that might appear on external disk
// /\.Trashes/,          // file that might appear on external disk
// /^__MACOSX$/,         // resource fork
// // Linux
// /~$/,                 // backup file
// // Windows
// /^Thumbs\.db$/,       // image file cache
// /^ehthumbs\.db$/,     // folder config file
// /^Desktop\.ini$/      // stores custom folder attributes

exports.re = /^npm-debug\.log$|^\..*\.swp$|^\.DS_Store$|^\.AppleDouble$|^\.LSOverride$|^Icon[\r\?]?|^\._.*|^\.Spotlight-V100$|\.Trashes|^__MACOSX$|~$|^Thumbs\.db$|^ehthumbs\.db$|^Desktop\.ini$/;

exports.is = function (filename) {
	return exports.re.test(filename);
};

exports.not = exports.isnt = function (filename) {
	return !exports.is(filename);
};

},{}],51:[function(require,module,exports){
(function (Buffer){
module.exports = magnetURIDecode
module.exports.decode = magnetURIDecode
module.exports.encode = magnetURIEncode

var base32 = require('thirty-two')
var extend = require('xtend')
var uniq = require('uniq')

/**
 * Parse a magnet URI and return an object of keys/values
 *
 * @param  {string} uri
 * @return {Object} parsed uri
 */
function magnetURIDecode (uri) {
  var result = {}

  // Support 'magnet:' and 'stream-magnet:' uris
  var data = uri.split('magnet:?')[1]

  var params = (data && data.length >= 0)
    ? data.split('&')
    : []

  params.forEach(function (param) {
    var keyval = param.split('=')

    // This keyval is invalid, skip it
    if (keyval.length !== 2) return

    var key = keyval[0]
    var val = keyval[1]

    // Clean up torrent name
    if (key === 'dn') val = decodeURIComponent(val).replace(/\+/g, ' ')

    // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded
    // URIs, so decode them
    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
      val = decodeURIComponent(val)
    }

    // Return keywords as an array
    if (key === 'kt') val = decodeURIComponent(val).split('+')

    // If there are repeated parameters, return an array of values
    if (result[key]) {
      if (Array.isArray(result[key])) {
        result[key].push(val)
      } else {
        var old = result[key]
        result[key] = [old, val]
      }
    } else {
      result[key] = val
    }
  })

  // Convenience properties for parity with `parse-torrent-file` module
  var m
  if (result.xt) {
    var xts = Array.isArray(result.xt) ? result.xt : [ result.xt ]
    xts.forEach(function (xt) {
      if ((m = xt.match(/^urn:btih:(.{40})/))) {
        result.infoHash = m[1].toLowerCase()
      } else if ((m = xt.match(/^urn:btih:(.{32})/))) {
        var decodedStr = base32.decode(m[1])
        result.infoHash = new Buffer(decodedStr, 'binary').toString('hex')
      }
    })
  }
  if (result.infoHash) result.infoHashBuffer = new Buffer(result.infoHash, 'hex')

  if (result.dn) result.name = result.dn
  if (result.kt) result.keywords = result.kt

  if (typeof result.tr === 'string') result.announce = [ result.tr ]
  else if (Array.isArray(result.tr)) result.announce = result.tr
  else result.announce = []

  result.urlList = []
  if (typeof result.as === 'string' || Array.isArray(result.as)) {
    result.urlList = result.urlList.concat(result.as)
  }
  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {
    result.urlList = result.urlList.concat(result.ws)
  }

  uniq(result.announce)
  uniq(result.urlList)

  return result
}

function magnetURIEncode (obj) {
  obj = extend(obj) // clone obj, so we can mutate it

  // support using convenience names, in addition to spec names
  // (example: `infoHash` for `xt`, `name` for `dn`)
  if (obj.infoHashBuffer) obj.xt = 'urn:btih:' + obj.infoHashBuffer.toString('hex')
  if (obj.infoHash) obj.xt = 'urn:btih:' + obj.infoHash
  if (obj.name) obj.dn = obj.name
  if (obj.keywords) obj.kt = obj.keywords
  if (obj.announce) obj.tr = obj.announce
  if (obj.urlList) {
    obj.ws = obj.urlList
    delete obj.as
  }

  var result = 'magnet:?'
  Object.keys(obj)
    .filter(function (key) {
      return key.length === 2
    })
    .forEach(function (key, i) {
      var values = Array.isArray(obj[key]) ? obj[key] : [ obj[key] ]
      values.forEach(function (val, j) {
        if ((i > 0 || j > 0) && (key !== 'kt' || j === 0)) result += '&'

        if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+')
        if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
          val = encodeURIComponent(val)
        }
        if (key === 'kt') val = encodeURIComponent(val)

        if (key === 'kt' && j > 0) result += '+' + val
        else result += key + '=' + val
      })
    })

  return result
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"thirty-two":108,"uniq":115,"xtend":139}],52:[function(require,module,exports){
module.exports = MediaElementWrapper

var inherits = require('inherits')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var MediaSource = typeof window !== 'undefined' && window.MediaSource

var DEFAULT_BUFFER_DURATION = 60 // seconds

function MediaElementWrapper (elem, opts) {
  var self = this
  if (!(self instanceof MediaElementWrapper)) return new MediaElementWrapper(elem, opts)

  if (!MediaSource) throw new Error('web browser lacks MediaSource support')

  if (!opts) opts = {}
  self._bufferDuration = opts.bufferDuration || DEFAULT_BUFFER_DURATION
  self._elem = elem
  self._mediaSource = new MediaSource()
  self._streams = []
  self.detailedError = null

  self._errorHandler = function () {
    self._elem.removeEventListener('error', self._errorHandler)
    var streams = self._streams.slice()
    streams.forEach(function (stream) {
      stream.destroy(self._elem.error)
    })
  }
  self._elem.addEventListener('error', self._errorHandler)

  self._elem.src = window.URL.createObjectURL(self._mediaSource)
}

/*
 * `obj` can be a previous value returned by this function
 * or a string
 */
MediaElementWrapper.prototype.createWriteStream = function (obj) {
  var self = this

  return new MediaSourceStream(self, obj)
}

/*
 * Use to trigger an error on the underlying media element
 */
MediaElementWrapper.prototype.error = function (err) {
  var self = this

  // be careful not to overwrite any existing detailedError values
  if (!self.detailedError) {
    self.detailedError = err
  }
  try {
    self._mediaSource.endOfStream('decode')
  } catch (err) {}
}

inherits(MediaSourceStream, stream.Writable)

function MediaSourceStream (wrapper, obj) {
  var self = this
  stream.Writable.call(self)

  self._wrapper = wrapper
  self._elem = wrapper._elem
  self._mediaSource = wrapper._mediaSource
  self._allStreams = wrapper._streams
  self._allStreams.push(self)
  self._bufferDuration = wrapper._bufferDuration
  self._sourceBuffer = null

  self._openHandler = function () {
    self._onSourceOpen()
  }
  self._flowHandler = function () {
    self._flow()
  }

  if (typeof obj === 'string') {
    self._type = obj
    // Need to create a new sourceBuffer
    if (self._mediaSource.readyState === 'open') {
      self._createSourceBuffer()
    } else {
      self._mediaSource.addEventListener('sourceopen', self._openHandler)
    }
  } else if (obj._sourceBuffer === null) {
    obj.destroy()
    self._type = obj._type // The old stream was created but hasn't finished initializing
    self._mediaSource.addEventListener('sourceopen', self._openHandler)
  } else if (obj._sourceBuffer) {
    obj.destroy()
    self._type = obj._type
    self._sourceBuffer = obj._sourceBuffer // Copy over the old sourceBuffer
    self._sourceBuffer.addEventListener('updateend', self._flowHandler)
  } else {
    throw new Error('The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function')
  }

  self._elem.addEventListener('timeupdate', self._flowHandler)

  self.on('error', function (err) {
    self._wrapper.error(err)
  })

  self.on('finish', function () {
    if (self.destroyed) return
    self._finished = true
    if (self._allStreams.every(function (other) { return other._finished })) {
      try {
        self._mediaSource.endOfStream()
      } catch (err) {}
    }
  })
}

MediaSourceStream.prototype._onSourceOpen = function () {
  var self = this
  if (self.destroyed) return

  self._mediaSource.removeEventListener('sourceopen', self._openHandler)
  self._createSourceBuffer()
}

MediaSourceStream.prototype.destroy = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true

  // Remove from allStreams
  self._allStreams.splice(self._allStreams.indexOf(self), 1)

  self._mediaSource.removeEventListener('sourceopen', self._openHandler)
  self._elem.removeEventListener('timeupdate', self._flowHandler)
  if (self._sourceBuffer) {
    self._sourceBuffer.removeEventListener('updateend', self._flowHandler)
    if (self._mediaSource.readyState === 'open') {
      self._sourceBuffer.abort()
    }
  }

  if (err) self.emit('error', err)
  self.emit('close')
}

MediaSourceStream.prototype._createSourceBuffer = function () {
  var self = this
  if (self.destroyed) return

  if (MediaSource.isTypeSupported(self._type)) {
    self._sourceBuffer = self._mediaSource.addSourceBuffer(self._type)
    self._sourceBuffer.addEventListener('updateend', self._flowHandler)
    if (self._cb) {
      var cb = self._cb
      self._cb = null
      cb()
    }
  } else {
    self.destroy(new Error('The provided type is not supported'))
  }
}

MediaSourceStream.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return
  if (!self._sourceBuffer) {
    self._cb = function (err) {
      if (err) return cb(err)
      self._write(chunk, encoding, cb)
    }
    return
  }

  if (self._sourceBuffer.updating) {
    return cb(new Error('Cannot append buffer while source buffer updating'))
  }

  try {
    self._sourceBuffer.appendBuffer(toArrayBuffer(chunk))
  } catch (err) {
    // appendBuffer can throw for a number of reasons, most notably when the data
    // being appended is invalid or if appendBuffer is called after another error
    // already occurred on the media element. In Chrome, there may be useful debugging
    // info in chrome://media-internals
    self.destroy(err)
    return
  }
  self._cb = cb
}

MediaSourceStream.prototype._flow = function () {
  var self = this

  if (self.destroyed || !self._sourceBuffer || self._sourceBuffer.updating) {
    return
  }

  if (self._mediaSource.readyState === 'open') {
    // check buffer size
    if (self._getBufferDuration() > self._bufferDuration) {
      return
    }
  }

  if (self._cb) {
    var cb = self._cb
    self._cb = null
    cb()
  }
}

// TODO: if zero actually works in all browsers, remove the logic associated with this below
var EPSILON = 0

MediaSourceStream.prototype._getBufferDuration = function () {
  var self = this

  var buffered = self._sourceBuffer.buffered
  var currentTime = self._elem.currentTime
  var bufferEnd = -1 // end of the buffer
  // This is a little over complex because some browsers seem to separate the
  // buffered region into multiple sections with slight gaps.
  for (var i = 0; i < buffered.length; i++) {
    var start = buffered.start(i)
    var end = buffered.end(i) + EPSILON

    if (start > currentTime) {
      // Reached past the joined buffer
      break
    } else if (bufferEnd >= 0 || currentTime <= end) {
      // Found the start/continuation of the joined buffer
      bufferEnd = end
    }
  }

  var bufferedTime = bufferEnd - currentTime
  if (bufferedTime < 0) {
    bufferedTime = 0
  }

  return bufferedTime
}

},{"inherits":43,"readable-stream":86,"to-arraybuffer":110}],53:[function(require,module,exports){
(function (process){
module.exports = Storage

function Storage (chunkLength, opts) {
  if (!(this instanceof Storage)) return new Storage(chunkLength, opts)
  if (!opts) opts = {}

  this.chunkLength = Number(chunkLength)
  if (!this.chunkLength) throw new Error('First argument must be a chunk length')

  this.chunks = []
  this.closed = false
  this.length = Number(opts.length) || Infinity

  if (this.length !== Infinity) {
    this.lastChunkLength = (this.length % this.chunkLength) || this.chunkLength
    this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1
  }
}

Storage.prototype.put = function (index, buf, cb) {
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))

  var isLastChunk = (index === this.lastChunkIndex)
  if (isLastChunk && buf.length !== this.lastChunkLength) {
    return nextTick(cb, new Error('Last chunk length must be ' + this.lastChunkLength))
  }
  if (!isLastChunk && buf.length !== this.chunkLength) {
    return nextTick(cb, new Error('Chunk length must be ' + this.chunkLength))
  }
  this.chunks[index] = buf
  nextTick(cb, null)
}

Storage.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))
  var buf = this.chunks[index]
  if (!buf) return nextTick(cb, new Error('Chunk not found'))
  if (!opts) return nextTick(cb, null, buf)
  var offset = opts.offset || 0
  var len = opts.length || (buf.length - offset)
  nextTick(cb, null, buf.slice(offset, len + offset))
}

Storage.prototype.close = Storage.prototype.destroy = function (cb) {
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))
  this.closed = true
  this.chunks = null
  nextTick(cb, null)
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    if (cb) cb(err, val)
  })
}

}).call(this,require('_process'))

},{"_process":73}],54:[function(require,module,exports){
(function (Buffer){
// This is an intentionally recursive require. I don't like it either.
var Box = require('./index')
var Descriptor = require('./descriptor')

var TIME_OFFSET = 2082844800000

/*
TODO:
test these
add new box versions
*/

// These have 'version' and 'flags' fields in the headers
exports.fullBoxes = {}
var fullBoxes = [
  'mvhd',
  'tkhd',
  'mdhd',
  'vmhd',
  'smhd',
  'stsd',
  'esds',
  'stsz',
  'stco',
  'stss',
  'stts',
  'ctts',
  'stsc',
  'dref',
  'elst',
  'hdlr',
  'mehd',
  'trex',
  'mfhd',
  'tfhd',
  'tfdt',
  'trun'
]
fullBoxes.forEach(function (type) {
  exports.fullBoxes[type] = true
})

exports.ftyp = {}
exports.ftyp.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.ftyp.encodingLength(box))
  var brands = box.compatibleBrands || []
  buf.write(box.brand, 0, 4, 'ascii')
  buf.writeUInt32BE(box.brandVersion, 4)
  for (var i = 0; i < brands.length; i++) buf.write(brands[i], 8 + (i * 4), 4, 'ascii')
  exports.ftyp.encode.bytes = 8 + brands.length * 4
  return buf
}
exports.ftyp.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var brand = buf.toString('ascii', 0, 4)
  var version = buf.readUInt32BE(4)
  var compatibleBrands = []
  for (var i = 8; i < buf.length; i += 4) compatibleBrands.push(buf.toString('ascii', i, i + 4))
  return {
    brand: brand,
    brandVersion: version,
    compatibleBrands: compatibleBrands
  }
}
exports.ftyp.encodingLength = function (box) {
  return 8 + (box.compatibleBrands || []).length * 4
}

exports.mvhd = {}
exports.mvhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(96)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.timeScale || 0, 8)
  buf.writeUInt32BE(box.duration || 0, 12)
  writeFixed32(box.preferredRate || 0, buf, 16)
  writeFixed16(box.preferredVolume || 0, buf, 20)
  writeReserved(buf, 22, 32)
  writeMatrix(box.matrix, buf, 32)
  buf.writeUInt32BE(box.previewTime || 0, 68)
  buf.writeUInt32BE(box.previewDuration || 0, 72)
  buf.writeUInt32BE(box.posterTime || 0, 76)
  buf.writeUInt32BE(box.selectionTime || 0, 80)
  buf.writeUInt32BE(box.selectionDuration || 0, 84)
  buf.writeUInt32BE(box.currentTime || 0, 88)
  buf.writeUInt32BE(box.nextTrackId || 0, 92)
  exports.mvhd.encode.bytes = 96
  return buf
}
exports.mvhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    preferredRate: readFixed32(buf, 16),
    preferredVolume: readFixed16(buf, 20),
    matrix: readMatrix(buf.slice(32, 68)),
    previewTime: buf.readUInt32BE(68),
    previewDuration: buf.readUInt32BE(72),
    posterTime: buf.readUInt32BE(76),
    selectionTime: buf.readUInt32BE(80),
    selectionDuration: buf.readUInt32BE(84),
    currentTime: buf.readUInt32BE(88),
    nextTrackId: buf.readUInt32BE(92)
  }
}
exports.mvhd.encodingLength = function (box) {
  return 96
}

exports.tkhd = {}
exports.tkhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(80)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.trackId || 0, 8)
  writeReserved(buf, 12, 16)
  buf.writeUInt32BE(box.duration || 0, 16)
  writeReserved(buf, 20, 28)
  buf.writeUInt16BE(box.layer || 0, 28)
  buf.writeUInt16BE(box.alternateGroup || 0, 30)
  buf.writeUInt16BE(box.volume || 0, 32)
  writeMatrix(box.matrix, buf, 36)
  buf.writeUInt32BE(box.trackWidth || 0, 72)
  buf.writeUInt32BE(box.trackHeight || 0, 76)
  exports.tkhd.encode.bytes = 80
  return buf
}
exports.tkhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    trackId: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(16),
    layer: buf.readUInt16BE(28),
    alternateGroup: buf.readUInt16BE(30),
    volume: buf.readUInt16BE(32),
    matrix: readMatrix(buf.slice(36, 72)),
    trackWidth: buf.readUInt32BE(72),
    trackHeight: buf.readUInt32BE(76)
  }
}
exports.tkhd.encodingLength = function (box) {
  return 80
}

exports.mdhd = {}
exports.mdhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(20)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.timeScale || 0, 8)
  buf.writeUInt32BE(box.duration || 0, 12)
  buf.writeUInt16BE(box.language || 0, 16)
  buf.writeUInt16BE(box.quality || 0, 18)
  exports.mdhd.encode.bytes = 20
  return buf
}
exports.mdhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    language: buf.readUInt16BE(16),
    quality: buf.readUInt16BE(18)
  }
}
exports.mdhd.encodingLength = function (box) {
  return 20
}

exports.vmhd = {}
exports.vmhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(8)
  buf.writeUInt16BE(box.graphicsMode || 0, 0)
  var opcolor = box.opcolor || [0, 0, 0]
  buf.writeUInt16BE(opcolor[0], 2)
  buf.writeUInt16BE(opcolor[1], 4)
  buf.writeUInt16BE(opcolor[2], 6)
  exports.vmhd.encode.bytes = 8
  return buf
}
exports.vmhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    graphicsMode: buf.readUInt16BE(0),
    opcolor: [buf.readUInt16BE(2), buf.readUInt16BE(4), buf.readUInt16BE(6)]
  }
}
exports.vmhd.encodingLength = function (box) {
  return 8
}

exports.smhd = {}
exports.smhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)
  buf.writeUInt16BE(box.balance || 0, 0)
  writeReserved(buf, 2, 4)
  exports.smhd.encode.bytes = 4
  return buf
}
exports.smhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    balance: buf.readUInt16BE(0)
  }
}
exports.smhd.encodingLength = function (box) {
  return 4
}

exports.stsd = {}
exports.stsd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.stsd.encodingLength(box))
  var entries = box.entries || []

  buf.writeUInt32BE(entries.length, 0)

  var ptr = 4
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i]
    Box.encode(entry, buf, ptr)
    ptr += Box.encode.bytes
  }

  exports.stsd.encode.bytes = ptr
  return buf
}
exports.stsd.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)
  var ptr = 4

  for (var i = 0; i < num; i++) {
    var entry = Box.decode(buf, ptr, end)
    entries[i] = entry
    ptr += entry.length
  }

  return {
    entries: entries
  }
}
exports.stsd.encodingLength = function (box) {
  var totalSize = 4
  if (!box.entries) return totalSize
  for (var i = 0; i < box.entries.length; i++) {
    totalSize += Box.encodingLength(box.entries[i])
  }
  return totalSize
}

exports.avc1 = exports.VisualSampleEntry = {}
exports.VisualSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.VisualSampleEntry.encodingLength(box))

  writeReserved(buf, 0, 6)
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6)
  writeReserved(buf, 8, 24)
  buf.writeUInt16BE(box.width || 0, 24)
  buf.writeUInt16BE(box.height || 0, 26)
  buf.writeUInt32BE(box.hResolution || 0x480000, 28)
  buf.writeUInt32BE(box.vResolution || 0x480000, 32)
  writeReserved(buf, 36, 40)
  buf.writeUInt16BE(box.frameCount || 1, 40)
  var compressorName = box.compressorName || ''
  var nameLen = Math.min(compressorName.length, 31)
  buf.writeUInt8(nameLen, 42)
  buf.write(compressorName, 43, nameLen, 'utf8')
  buf.writeUInt16BE(box.depth || 0x18, 74)
  buf.writeInt16BE(-1, 76)

  var ptr = 78
  var children = box.children || []
  children.forEach(function (child) {
    Box.encode(child, buf, ptr)
    ptr += Box.encode.bytes
  })
  exports.VisualSampleEntry.encode.bytes = ptr
}
exports.VisualSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  var length = end - offset
  var nameLen = Math.min(buf.readUInt8(42), 31)
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    width: buf.readUInt16BE(24),
    height: buf.readUInt16BE(26),
    hResolution: buf.readUInt32BE(28),
    vResolution: buf.readUInt32BE(32),
    frameCount: buf.readUInt16BE(40),
    compressorName: buf.toString('utf8', 43, 43 + nameLen),
    depth: buf.readUInt16BE(74),
    children: []
  }

  var ptr = 78
  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length)
    box.children.push(child)
    box[child.type] = child
    ptr += child.length
  }

  return box
}
exports.VisualSampleEntry.encodingLength = function (box) {
  var len = 78
  var children = box.children || []
  children.forEach(function (child) {
    len += Box.encodingLength(child)
  })
  return len
}

exports.avcC = {}
exports.avcC.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer(box.buffer.length)

  box.buffer.copy(buf)
  exports.avcC.encode.bytes = box.buffer.length
}
exports.avcC.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)

  return {
    mimeCodec: buf.toString('hex', 1, 4),
    buffer: new Buffer(buf)
  }
}
exports.avcC.encodingLength = function (box) {
  return box.buffer.length
}

exports.mp4a = exports.AudioSampleEntry = {}
exports.AudioSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.AudioSampleEntry.encodingLength(box))

  writeReserved(buf, 0, 6)
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6)
  writeReserved(buf, 8, 16)
  buf.writeUInt16BE(box.channelCount || 2, 16)
  buf.writeUInt16BE(box.sampleSize || 16, 18)
  writeReserved(buf, 20, 24)
  buf.writeUInt32BE(box.sampleRate || 0, 24)

  var ptr = 28
  var children = box.children || []
  children.forEach(function (child) {
    Box.encode(child, buf, ptr)
    ptr += Box.encode.bytes
  })
  exports.AudioSampleEntry.encode.bytes = ptr
}
exports.AudioSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)
  var length = end - offset
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    channelCount: buf.readUInt16BE(16),
    sampleSize: buf.readUInt16BE(18),
    sampleRate: buf.readUInt32BE(24),
    children: []
  }

  var ptr = 28
  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length)
    box.children.push(child)
    box[child.type] = child
    ptr += child.length
  }

  return box
}
exports.AudioSampleEntry.encodingLength = function (box) {
  var len = 28
  var children = box.children || []
  children.forEach(function (child) {
    len += Box.encodingLength(child)
  })
  return len
}

exports.esds = {}
exports.esds.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer(box.buffer.length)

  box.buffer.copy(buf, 0)
  exports.esds.encode.bytes = box.buffer.length
}
exports.esds.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)

  var desc = Descriptor.Descriptor.decode(buf, 0, buf.length)
  var esd = (desc.tagName === 'ESDescriptor') ? desc : {}
  var dcd = esd.DecoderConfigDescriptor || {}
  var oti = dcd.oti || 0
  var dsi = dcd.DecoderSpecificInfo
  var audioConfig = dsi ? (dsi.buffer.readUInt8(0) & 0xf8) >> 3 : 0

  var mimeCodec = null
  if (oti) {
    mimeCodec = oti.toString(16)
    if (audioConfig) {
      mimeCodec += '.' + audioConfig
    }
  }

  return {
    mimeCodec: mimeCodec,
    buffer: new Buffer(buf.slice(0))
  }
}
exports.esds.encodingLength = function (box) {
  return box.buffer.length
}

// TODO: integrate the two versions in a saner way
exports.stsz = {}
exports.stsz.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : Buffer(exports.stsz.encodingLength(box))

  buf.writeUInt32BE(0, 0)
  buf.writeUInt32BE(entries.length, 4)

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 8)
  }

  exports.stsz.encode.bytes = 8 + entries.length * 4
  return buf
}
exports.stsz.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var size = buf.readUInt32BE(0)
  var num = buf.readUInt32BE(4)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    if (size === 0) {
      entries[i] = buf.readUInt32BE(i * 4 + 8)
    } else {
      entries[i] = size
    }
  }

  return {
    entries: entries
  }
}
exports.stsz.encodingLength = function (box) {
  return 8 + box.entries.length * 4
}

exports.stss =
exports.stco = {}
exports.stco.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stco.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 4)
  }

  exports.stco.encode.bytes = 4 + entries.length * 4
  return buf
}
exports.stco.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    entries[i] = buf.readUInt32BE(i * 4 + 4)
  }

  return {
    entries: entries
  }
}
exports.stco.encodingLength = function (box) {
  return 4 + box.entries.length * 4
}

exports.stts = {}
exports.stts.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stts.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4
    buf.writeUInt32BE(entries[i].count || 0, ptr)
    buf.writeUInt32BE(entries[i].duration || 0, ptr + 4)
  }

  exports.stts.encode.bytes = 4 + box.entries.length * 8
  return buf
}
exports.stts.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      duration: buf.readUInt32BE(ptr + 4)
    }
  }

  return {
    entries: entries
  }
}
exports.stts.encodingLength = function (box) {
  return 4 + box.entries.length * 8
}

exports.ctts = {}
exports.ctts.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.ctts.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4
    buf.writeUInt32BE(entries[i].count || 0, ptr)
    buf.writeUInt32BE(entries[i].compositionOffset || 0, ptr + 4)
  }

  exports.ctts.encode.bytes = 4 + entries.length * 8
  return buf
}
exports.ctts.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      compositionOffset: buf.readInt32BE(ptr + 4)
    }
  }

  return {
    entries: entries
  }
}
exports.ctts.encodingLength = function (box) {
  return 4 + box.entries.length * 8
}

exports.stsc = {}
exports.stsc.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stsc.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4
    buf.writeUInt32BE(entries[i].firstChunk || 0, ptr)
    buf.writeUInt32BE(entries[i].samplesPerChunk || 0, ptr + 4)
    buf.writeUInt32BE(entries[i].sampleDescriptionId || 0, ptr + 8)
  }

  exports.stsc.encode.bytes = 4 + entries.length * 12
  return buf
}
exports.stsc.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4
    entries[i] = {
      firstChunk: buf.readUInt32BE(ptr),
      samplesPerChunk: buf.readUInt32BE(ptr + 4),
      sampleDescriptionId: buf.readUInt32BE(ptr + 8)
    }
  }

  return {
    entries: entries
  }
}
exports.stsc.encodingLength = function (box) {
  return 4 + box.entries.length * 12
}

exports.dref = {}
exports.dref.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.dref.encodingLength(box))
  var entries = box.entries || []

  buf.writeUInt32BE(entries.length, 0)

  var ptr = 4
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i]
    var size = (entry.buf ? entry.buf.length : 0) + 4 + 4

    buf.writeUInt32BE(size, ptr)
    ptr += 4

    buf.write(entry.type, ptr, 4, 'ascii')
    ptr += 4

    if (entry.buf) {
      entry.buf.copy(buf, ptr)
      ptr += entry.buf.length
    }
  }

  exports.dref.encode.bytes = ptr
  return buf
}
exports.dref.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)
  var ptr = 4

  for (var i = 0; i < num; i++) {
    var size = buf.readUInt32BE(ptr)
    var type = buf.toString('ascii', ptr + 4, ptr + 8)
    var tmp = buf.slice(ptr + 8, ptr + size)
    ptr += size

    entries[i] = {
      type: type,
      buf: tmp
    }
  }

  return {
    entries: entries
  }
}
exports.dref.encodingLength = function (box) {
  var totalSize = 4
  if (!box.entries) return totalSize
  for (var i = 0; i < box.entries.length; i++) {
    var buf = box.entries[i].buf
    totalSize += (buf ? buf.length : 0) + 4 + 4
  }
  return totalSize
}

exports.elst = {}
exports.elst.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.elst.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4
    buf.writeUInt32BE(entries[i].trackDuration || 0, ptr)
    buf.writeUInt32BE(entries[i].mediaTime || 0, ptr + 4)
    writeFixed32(entries[i].mediaRate || 0, buf, ptr + 8)
  }

  exports.elst.encode.bytes = 4 + entries.length * 12
  return buf
}
exports.elst.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4
    entries[i] = {
      trackDuration: buf.readUInt32BE(ptr),
      mediaTime: buf.readInt32BE(ptr + 4),
      mediaRate: readFixed32(buf, ptr + 8)
    }
  }

  return {
    entries: entries
  }
}
exports.elst.encodingLength = function (box) {
  return 4 + box.entries.length * 12
}

exports.hdlr = {}
exports.hdlr.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.hdlr.encodingLength(box))

  var len = 21 + (box.name || '').length
  buf.fill(0, 0, len)

  buf.write(box.handlerType || '', 4, 4, 'ascii')
  writeString(box.name || '', buf, 20)

  exports.hdlr.encode.bytes = len
  return buf
}
exports.hdlr.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  return {
    handlerType: buf.toString('ascii', 4, 8),
    name: readString(buf, 20, end)
  }
}
exports.hdlr.encodingLength = function (box) {
  return 21 + (box.name || '').length
}

exports.mehd = {}
exports.mehd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.fragmentDuration || 0, 0)
  exports.mehd.encode.bytes = 4
  return buf
}
exports.mehd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    fragmentDuration: buf.readUInt32BE(0)
  }
}
exports.mehd.encodingLength = function (box) {
  return 4
}

exports.trex = {}
exports.trex.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(20)

  buf.writeUInt32BE(box.trackId || 0, 0)
  buf.writeUInt32BE(box.defaultSampleDescriptionIndex || 0, 4)
  buf.writeUInt32BE(box.defaultSampleDuration || 0, 8)
  buf.writeUInt32BE(box.defaultSampleSize || 0, 12)
  buf.writeUInt32BE(box.defaultSampleFlags || 0, 16)
  exports.trex.encode.bytes = 20
  return buf
}
exports.trex.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    trackId: buf.readUInt32BE(0),
    defaultSampleDescriptionIndex: buf.readUInt32BE(4),
    defaultSampleDuration: buf.readUInt32BE(8),
    defaultSampleSize: buf.readUInt32BE(12),
    defaultSampleFlags: buf.readUInt32BE(16)
  }
}
exports.trex.encodingLength = function (box) {
  return 20
}

exports.mfhd = {}
exports.mfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.sequenceNumber || 0, 0)
  exports.mfhd.encode.bytes = 4
  return buf
}
exports.mfhd.decode = function (buf, offset) {
  return {
    sequenceNumber: buf.readUint32BE(0)
  }
}
exports.mfhd.encodingLength = function (box) {
  return 4
}

exports.tfhd = {}
exports.tfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)
  buf.writeUInt32BE(box.trackId, 0)
  exports.tfhd.encode.bytes = 4
  return buf
}
exports.tfhd.decode = function (buf, offset) {
  // TODO: this
}
exports.tfhd.encodingLength = function (box) {
  // TODO: this is wrong!
  return 4
}

exports.tfdt = {}
exports.tfdt.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.baseMediaDecodeTime || 0, 0)
  exports.tfdt.encode.bytes = 4
  return buf
}
exports.tfdt.decode = function (buf, offset) {
  // TODO: this
}
exports.tfdt.encodingLength = function (box) {
  return 4
}

exports.trun = {}
exports.trun.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(8 + box.entries.length * 16)

  // TODO: this is wrong
  buf.writeUInt32BE(box.entries.length, 0)
  buf.writeInt32BE(box.dataOffset, 4)
  var ptr = 8
  for (var i = 0; i < box.entries.length; i++) {
    var entry = box.entries[i]
    buf.writeUInt32BE(entry.sampleDuration, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleSize, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleFlags, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleCompositionTimeOffset, ptr)
    ptr += 4
  }
  exports.trun.encode.bytes = ptr
}
exports.trun.decode = function (buf, offset) {
  // TODO: this
}
exports.trun.encodingLength = function (box) {
  // TODO: this is wrong
  return 8 + box.entries.length * 16
}

exports.mdat = {}
exports.mdat.encode = function (box, buf, offset) {
  if (box.buffer) {
    box.buffer.copy(buf, offset)
    exports.mdat.encode.bytes = box.buffer.length
  } else {
    exports.mdat.encode.bytes = exports.mdat.encodingLength(box)
  }
}
exports.mdat.decode = function (buf, start, end) {
  return {
    buffer: new Buffer(buf.slice(start, end))
  }
}
exports.mdat.encodingLength = function (box) {
  return box.buffer ? box.buffer.length : box.contentLength
}

function writeReserved (buf, offset, end) {
  for (var i = offset; i < end; i++) buf[i] = 0
}

function writeDate (date, buf, offset) {
  buf.writeUInt32BE(Math.floor((date.getTime() + TIME_OFFSET) / 1000), offset)
}

// TODO: think something is wrong here
function writeFixed32 (num, buf, offset) {
  buf.writeUInt16BE(Math.floor(num) % (256 * 256), offset)
  buf.writeUInt16BE(Math.floor(num * 256 * 256) % (256 * 256), offset + 2)
}

function writeFixed16 (num, buf, offset) {
  buf[offset] = Math.floor(num) % 256
  buf[offset + 1] = Math.floor(num * 256) % 256
}

function writeMatrix (list, buf, offset) {
  if (!list) list = [0, 0, 0, 0, 0, 0, 0, 0, 0]
  for (var i = 0; i < list.length; i++) {
    writeFixed32(list[i], buf, offset + i * 4)
  }
}

function writeString (str, buf, offset) {
  var strBuffer = new Buffer(str, 'utf8')
  strBuffer.copy(buf, offset)
  buf[offset + strBuffer.length] = 0
}

function readMatrix (buf) {
  var list = new Array(buf.length / 4)
  for (var i = 0; i < list.length; i++) list[i] = readFixed32(buf, i * 4)
  return list
}

function readDate (buf, offset) {
  return new Date(buf.readUInt32BE(offset) * 1000 - TIME_OFFSET)
}

function readFixed32 (buf, offset) {
  return buf.readUInt16BE(offset) + buf.readUInt16BE(offset + 2) / (256 * 256)
}

function readFixed16 (buf, offset) {
  return buf[offset] + buf[offset + 1] / 256
}

function readString (buf, offset, length) {
  var i
  for (i = 0; i < length; i++) {
    if (buf[offset + i] === 0) {
      break
    }
  }
  return buf.toString('utf8', offset, offset + i)
}

}).call(this,require("buffer").Buffer)

},{"./descriptor":55,"./index":56,"buffer":20}],55:[function(require,module,exports){
(function (Buffer){
var tagToName = {
  0x03: 'ESDescriptor',
  0x04: 'DecoderConfigDescriptor',
  0x05: 'DecoderSpecificInfo',
  0x06: 'SLConfigDescriptor'
}

exports.Descriptor = {}
exports.Descriptor.decode = function (buf, start, end) {
  var tag = buf.readUInt8(start)
  var ptr = start + 1
  var lenByte
  var len = 0
  do {
    lenByte = buf.readUInt8(ptr++)
    len = (len << 7) | (lenByte & 0x7f)
  } while (lenByte & 0x80)

  var obj
  var tagName = tagToName[tag] // May be undefined; that's ok
  if (exports[tagName]) {
    obj = exports[tagName].decode(buf, ptr, end)
  } else {
    obj = {
      buffer: new Buffer(buf.slice(ptr, ptr + len))
    }
  }

  obj.tag = tag
  obj.tagName = tagName
  obj.length = (ptr - start) + len
  obj.contentsLen = len
  return obj
}

exports.DescriptorArray = {}
exports.DescriptorArray.decode = function (buf, start, end) {
  var ptr = start
  var obj = {}
  while (ptr + 2 <= end) {
    var descriptor = exports.Descriptor.decode(buf, ptr, end)
    ptr += descriptor.length
    var tagName = tagToName[descriptor.tag] || ('Descriptor' + descriptor.tag)
    obj[tagName] = descriptor
  }
  return obj
}

exports.ESDescriptor = {}
exports.ESDescriptor.decode = function (buf, start, end) {
  var flags = buf.readUInt8(start + 2)
  var ptr = start + 3
  if (flags & 0x80) {
    ptr += 2
  }
  if (flags & 0x40) {
    var len = buf.readUInt8(ptr)
    ptr += len + 1
  }
  if (flags & 0x20) {
    ptr += 2
  }
  return exports.DescriptorArray.decode(buf, ptr, end)
}

exports.DecoderConfigDescriptor = {}
exports.DecoderConfigDescriptor.decode = function (buf, start, end) {
  var oti = buf.readUInt8(start)
  var obj = exports.DescriptorArray.decode(buf, start + 13, end)
  obj.oti = oti
  return obj
}

}).call(this,require("buffer").Buffer)

},{"buffer":20}],56:[function(require,module,exports){
(function (Buffer){
// var assert = require('assert')
var uint64be = require('uint64be')

var boxes = require('./boxes')

var UINT32_MAX = 4294967295

var Box = exports

/*
 * Lists the proper order for boxes inside containers.
 * Five-character names ending in 's' indicate arrays instead of single elements.
 */
var containers = exports.containers = {
  'moov': ['mvhd', 'meta', 'traks', 'mvex'],
  'trak': ['tkhd', 'tref', 'trgr', 'edts', 'meta', 'mdia', 'udta'],
  'edts': ['elst'],
  'mdia': ['mdhd', 'hdlr', 'elng', 'minf'],
  'minf': ['vmhd', 'smhd', 'hmhd', 'sthd', 'nmhd', 'dinf', 'stbl'],
  'dinf': ['dref'],
  'stbl': ['stsd', 'stts', 'ctts', 'cslg', 'stsc', 'stsz', 'stz2', 'stco', 'co64', 'stss', 'stsh', 'padb', 'stdp', 'sdtp', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios'],
  'mvex': ['mehd', 'trexs', 'leva'],
  'moof': ['mfhd', 'meta', 'trafs'],
  'traf': ['tfhd', 'trun', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios', 'tfdt', 'meta']
}

Box.encode = function (obj, buffer, offset) {
  Box.encodingLength(obj) // sets every level appropriately
  offset = offset || 0
  buffer = buffer || new Buffer(obj.length)
  return Box._encode(obj, buffer, offset)
}

Box._encode = function (obj, buffer, offset) {
  var type = obj.type
  var len = obj.length
  if (len > UINT32_MAX) {
    len = 1
  }
  buffer.writeUInt32BE(len, offset)
  buffer.write(obj.type, offset + 4, 4, 'ascii')
  var ptr = offset + 8
  if (len === 1) {
    uint64be.encode(obj.length, buffer, ptr)
    ptr += 8
  }
  if (boxes.fullBoxes[type]) {
    buffer.writeUInt32BE(obj.flags || 0, ptr)
    buffer.writeUInt8(obj.version || 0, ptr)
    ptr += 4
  }

  if (containers[type]) {
    var contents = containers[type]
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || []
        childType = childType.substr(0, 4)
        entry.forEach(function (child) {
          Box._encode(child, buffer, ptr)
          ptr += Box.encode.bytes
        })
      } else if (obj[childType]) {
        Box._encode(obj[childType], buffer, ptr)
        ptr += Box.encode.bytes
      }
    })
    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        Box._encode(child, buffer, ptr)
        ptr += Box.encode.bytes
      })
    }
  } else if (boxes[type]) {
    var encode = boxes[type].encode
    encode(obj, buffer, ptr)
    ptr += encode.bytes
  } else if (obj.buffer) {
    var buf = obj.buffer
    buf.copy(buffer, ptr)
    ptr += obj.buffer.length
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set')
  }

  Box.encode.bytes = ptr - offset
  // assert.equal(ptr - offset, obj.length, 'Error encoding \'' + type + '\': wrote ' + ptr - offset + ' bytes, expecting ' + obj.length)
  return buffer
}

/*
 * Returns an object with `type` and `size` fields,
 * or if there isn't enough data, returns the total
 * number of bytes needed to read the headers
 */
Box.readHeaders = function (buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  if (end - start < 8) {
    return 8
  }

  var len = buffer.readUInt32BE(start)
  var type = buffer.toString('ascii', start + 4, start + 8)
  var ptr = start + 8

  if (len === 1) {
    if (end - start < 16) {
      return 16
    }

    len = uint64be.decode(buffer, ptr)
    ptr += 8
  }

  var version
  var flags
  if (boxes.fullBoxes[type]) {
    version = buffer.readUInt8(ptr)
    flags = buffer.readUInt32BE(ptr) & 0xffffff
    ptr += 4
  }

  return {
    length: len,
    headersLen: ptr - start,
    contentLen: len - (ptr - start),
    type: type,
    version: version,
    flags: flags
  }
}

Box.decode = function (buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  var headers = Box.readHeaders(buffer, start, end)
  if (!headers || headers.length > end - start) {
    throw new Error('Data too short')
  }

  return Box.decodeWithoutHeaders(headers, buffer, start + headers.headersLen, start + headers.length)
}

Box.decodeWithoutHeaders = function (headers, buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  var type = headers.type
  var obj = {}
  if (containers[type]) {
    obj.otherBoxes = []
    var contents = containers[type]
    var ptr = start
    while (end - ptr >= 8) {
      var child = Box.decode(buffer, ptr, end)
      ptr += child.length
      if (contents.indexOf(child.type) >= 0) {
        obj[child.type] = child
      } else if (contents.indexOf(child.type + 's') >= 0) {
        var childType = child.type + 's'
        var entry = obj[childType] = obj[childType] || []
        entry.push(child)
      } else {
        obj.otherBoxes.push(child)
      }
    }
  } else if (boxes[type]) {
    var decode = boxes[type].decode
    obj = decode(buffer, start, end)
  } else {
    obj.buffer = new Buffer(buffer.slice(start, end))
  }

  obj.length = headers.length
  obj.contentLen = headers.contentLen
  obj.type = headers.type
  obj.version = headers.version
  obj.flags = headers.flags
  return obj
}

Box.encodingLength = function (obj) {
  var type = obj.type

  var len = 8
  if (boxes.fullBoxes[type]) {
    len += 4
  }

  if (containers[type]) {
    var contents = containers[type]
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || []
        childType = childType.substr(0, 4)
        entry.forEach(function (child) {
          child.type = childType
          len += Box.encodingLength(child)
        })
      } else if (obj[childType]) {
        var child = obj[childType]
        child.type = childType
        len += Box.encodingLength(child)
      }
    })
    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        len += Box.encodingLength(child)
      })
    }
  } else if (boxes[type]) {
    len += boxes[type].encodingLength(obj)
  } else if (obj.buffer) {
    len += obj.buffer.length
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set')
  }

  if (len > UINT32_MAX) {
    len += 8
  }

  obj.length = len
  return len
}

}).call(this,require("buffer").Buffer)

},{"./boxes":54,"buffer":20,"uint64be":114}],57:[function(require,module,exports){
(function (Buffer){
var stream = require('readable-stream')
var inherits = require('inherits')
var nextEvent = require('next-event')
var Box = require('mp4-box-encoding')

var EMPTY = new Buffer(0)

module.exports = Decoder

function Decoder () {
  if (!(this instanceof Decoder)) return new Decoder()
  stream.Writable.call(this)

  this.destroyed = false

  this._pending = 0
  this._missing = 0
  this._buf = null
  this._str = null
  this._cb = null
  this._ondrain = null
  this._writeBuffer = null
  this._writeCb = null

  this._ondrain = null
  this._kick()
}

inherits(Decoder, stream.Writable)

Decoder.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  if (err) this.emit('error', err)
  this.emit('close')
}

Decoder.prototype._write = function (data, enc, next) {
  if (this.destroyed) return
  var drained = !this._str || !this._str._writableState.needDrain

  while (data.length && !this.destroyed) {
    if (!this._missing) {
      this._writeBuffer = data
      this._writeCb = next
      return
    }

    var consumed = data.length < this._missing ? data.length : this._missing
    if (this._buf) data.copy(this._buf, this._buf.length - this._missing)
    else if (this._str) drained = this._str.write(consumed === data.length ? data : data.slice(0, consumed))

    this._missing -= consumed

    if (!this._missing) {
      var buf = this._buf
      var cb = this._cb
      var stream = this._str

      this._buf = this._cb = this._str = this._ondrain = null
      drained = true

      if (stream) stream.end()
      if (cb) cb(buf)
    }

    data = consumed === data.length ? EMPTY : data.slice(consumed)
  }

  if (this._pending && !this._missing) {
    this._writeBuffer = data
    this._writeCb = next
    return
  }

  if (drained) next()
  else this._ondrain(next)
}

Decoder.prototype._buffer = function (size, cb) {
  this._missing = size
  this._buf = new Buffer(size)
  this._cb = cb
}

Decoder.prototype._stream = function (size, cb) {
  var self = this
  this._missing = size
  this._str = new MediaData(this)
  this._ondrain = nextEvent(this._str, 'drain')
  this._pending++
  this._str.on('end', function () {
    self._pending--
    self._kick()
  })
  this._cb = cb
  return this._str
}

Decoder.prototype._readBox = function () {
  var self = this
  bufferHeaders(8)

  function bufferHeaders (len, buf) {
    self._buffer(len, function (additionalBuf) {
      if (buf) {
        buf = Buffer.concat(buf, additionalBuf)
      } else {
        buf = additionalBuf
      }
      var headers = Box.readHeaders(buf)
      if (typeof headers === 'number') {
        bufferHeaders(headers - buf.length, buf)
      } else {
        self._pending++
        self._headers = headers
        self.emit('box', headers)
      }
    })
  }
}

Decoder.prototype.stream = function () {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  return self._stream(headers.contentLen, null)
}

Decoder.prototype.decode = function (cb) {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  self._buffer(headers.contentLen, function (buf) {
    var box = Box.decodeWithoutHeaders(headers, buf)
    cb(box)
    self._pending--
    self._kick()
  })
}

Decoder.prototype.ignore = function () {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  this._missing = headers.contentLen
  this._cb = function () {
    self._pending--
    self._kick()
  }
}

Decoder.prototype._kick = function () {
  if (this._pending) return
  if (!this._buf && !this._str) this._readBox()
  if (this._writeBuffer) {
    var next = this._writeCb
    var buffer = this._writeBuffer
    this._writeBuffer = null
    this._writeCb = null
    this._write(buffer, null, next)
  }
}

function MediaData (parent) {
  this._parent = parent
  this.destroyed = false
  stream.PassThrough.call(this)
}

inherits(MediaData, stream.PassThrough)

MediaData.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  this._parent.destroy(err)
  if (err) this.emit('error', err)
  this.emit('close')
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"inherits":43,"mp4-box-encoding":56,"next-event":62,"readable-stream":86}],58:[function(require,module,exports){
(function (process,Buffer){
var stream = require('readable-stream')
var inherits = require('inherits')
var Box = require('mp4-box-encoding')

module.exports = Encoder

function noop () {}

function Encoder () {
  if (!(this instanceof Encoder)) return new Encoder()
  stream.Readable.call(this)

  this.destroyed = false

  this._reading = false
  this._stream = null
  this._drain = null
  this._want = false
  this._onreadable = onreadable
  this._onend = onend

  var self = this

  function onreadable () {
    if (!self._want) return
    self._want = false
    self._read()
  }

  function onend () {
    self._stream = null
  }
}

inherits(Encoder, stream.Readable)

Encoder.prototype.mediaData =
Encoder.prototype.mdat = function (size, cb) {
  var stream = new MediaData(this)
  this.box({type: 'mdat', contentLength: size, encodeBufferLen: 8, stream: stream}, cb)
  return stream
}

Encoder.prototype.box = function (box, cb) {
  if (!cb) cb = noop
  if (this.destroyed) return cb(new Error('Encoder is destroyed'))

  var buf
  if (box.encodeBufferLen) {
    buf = new Buffer(box.encodeBufferLen)
  }
  if (box.stream) {
    box.buffer = null
    buf = Box.encode(box, buf)
    this.push(buf)
    this._stream = box.stream
    this._stream.on('readable', this._onreadable)
    this._stream.on('end', this._onend)
    this._stream.on('end', cb)
    this._forward()
  } else {
    buf = Box.encode(box, buf)
    var drained = this.push(buf)
    if (drained) return process.nextTick(cb)
    this._drain = cb
  }
}

Encoder.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  if (this._stream && this._stream.destroy) this._stream.destroy()
  this._stream = null
  if (this._drain) {
    var cb = this._drain
    this._drain = null
    cb(err)
  }
  if (err) this.emit('error', err)
  this.emit('close')
}

Encoder.prototype.finalize = function () {
  this.push(null)
}

Encoder.prototype._forward = function () {
  if (!this._stream) return

  while (!this.destroyed) {
    var buf = this._stream.read()

    if (!buf) {
      this._want = !!this._stream
      return
    }

    if (!this.push(buf)) return
  }
}

Encoder.prototype._read = function () {
  if (this._reading || this.destroyed) return
  this._reading = true

  if (this._stream) this._forward()
  if (this._drain) {
    var drain = this._drain
    this._drain = null
    drain()
  }

  this._reading = false
}

function MediaData (parent) {
  this._parent = parent
  this.destroyed = false
  stream.PassThrough.call(this)
}

inherits(MediaData, stream.PassThrough)

MediaData.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  this._parent.destroy(err)
  if (err) this.emit('error', err)
  this.emit('close')
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":73,"buffer":20,"inherits":43,"mp4-box-encoding":56,"readable-stream":86}],59:[function(require,module,exports){
exports.decode = require('./decode')
exports.encode = require('./encode')

},{"./decode":57,"./encode":58}],60:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],61:[function(require,module,exports){
module.exports = MultiStream

var inherits = require('inherits')
var stream = require('readable-stream')

inherits(MultiStream, stream.Readable)

function MultiStream (streams, opts) {
  if (!(this instanceof MultiStream)) return new MultiStream(streams, opts)
  stream.Readable.call(this, opts)

  this.destroyed = false

  this._drained = false
  this._forwarding = false
  this._current = null
  this._queue = (typeof streams === 'function' ? streams : streams.map(toStreams2))

  this._next()
}

MultiStream.obj = function (streams) {
  return new MultiStream(streams, { objectMode: true, highWaterMark: 16 })
}

MultiStream.prototype._read = function () {
  this._drained = true
  this._forward()
}

MultiStream.prototype._forward = function () {
  if (this._forwarding || !this._drained || !this._current) return
  this._forwarding = true

  var chunk
  while ((chunk = this._current.read()) !== null) {
    this._drained = this.push(chunk)
  }

  this._forwarding = false
}

MultiStream.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true

  if (this._current && this._current.destroy) this._current.destroy()
  if (typeof this._queue !== 'function') {
    this._queue.forEach(function (stream) {
      if (stream.destroy) stream.destroy()
    })
  }

  if (err) this.emit('error', err)
  this.emit('close')
}

MultiStream.prototype._next = function () {
  var self = this
  self._current = null

  if (typeof self._queue === 'function') {
    self._queue(function (err, stream) {
      if (err) return self.destroy(err)
      self._gotNextStream(toStreams2(stream))
    })
  } else {
    var stream = self._queue.shift()
    if (typeof stream === 'function') stream = toStreams2(stream())
    self._gotNextStream(stream)
  }
}

MultiStream.prototype._gotNextStream = function (stream) {
  var self = this

  if (!stream) {
    self.push(null)
    self.destroy()
    return
  }

  self._current = stream
  self._forward()

  stream.on('readable', onReadable)
  stream.on('end', onEnd)
  stream.on('error', onError)
  stream.on('close', onClose)

  function onReadable () {
    self._forward()
  }

  function onClose () {
    if (!stream._readableState.ended) {
      self.destroy()
    }
  }

  function onEnd () {
    self._current = null
    stream.removeListener('readable', onReadable)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onError)
    stream.removeListener('close', onClose)
    self._next()
  }

  function onError (err) {
    self.destroy(err)
  }
}

function toStreams2 (s) {
  if (!s || typeof s === 'function' || s._readableState) return s

  var wrap = new stream.Readable().wrap(s)
  if (s.destroy) {
    wrap.destroy = s.destroy.bind(s)
  }
  return wrap
}

},{"inherits":43,"readable-stream":86}],62:[function(require,module,exports){
module.exports = nextEvent

function nextEvent (emitter, name) {
  var next = null
  emitter.on(name, function (data) {
    if (!next) return
    var fn = next
    next = null
    fn(data)
  })

  return function (once) {
    next = once
  }
}

},{}],63:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},{"wrappy":138}],64:[function(require,module,exports){
(function (Buffer){
module.exports = decodeTorrentFile
module.exports.decode = decodeTorrentFile
module.exports.encode = encodeTorrentFile

var bencode = require('bencode')
var path = require('path')
var sha1 = require('simple-sha1')
var uniq = require('uniq')

/**
 * Parse a torrent. Throws an exception if the torrent is missing required fields.
 * @param  {Buffer|Object} torrent
 * @return {Object}        parsed torrent
 */
function decodeTorrentFile (torrent) {
  if (Buffer.isBuffer(torrent)) {
    torrent = bencode.decode(torrent)
  }

  // sanity check
  ensure(torrent.info, 'info')
  ensure(torrent.info['name.utf-8'] || torrent.info.name, 'info.name')
  ensure(torrent.info['piece length'], 'info[\'piece length\']')
  ensure(torrent.info.pieces, 'info.pieces')

  if (torrent.info.files) {
    torrent.info.files.forEach(function (file) {
      ensure(typeof file.length === 'number', 'info.files[0].length')
      ensure(file['path.utf-8'] || file.path, 'info.files[0].path')
    })
  } else {
    ensure(typeof torrent.info.length === 'number', 'info.length')
  }

  var result = {}
  result.info = torrent.info
  result.infoBuffer = bencode.encode(torrent.info)
  result.infoHash = sha1.sync(result.infoBuffer)
  result.infoHashBuffer = new Buffer(result.infoHash, 'hex')

  result.name = (torrent.info['name.utf-8'] || torrent.info.name).toString()

  if (torrent.info.private !== undefined) result.private = !!torrent.info.private

  if (torrent['creation date']) result.created = new Date(torrent['creation date'] * 1000)
  if (torrent['created by']) result.createdBy = torrent['created by'].toString()

  if (Buffer.isBuffer(torrent.comment)) result.comment = torrent.comment.toString()

  // announce and announce-list will be missing if metadata fetched via ut_metadata
  result.announce = []
  if (torrent['announce-list'] && torrent['announce-list'].length) {
    torrent['announce-list'].forEach(function (urls) {
      urls.forEach(function (url) {
        result.announce.push(url.toString())
      })
    })
  } else if (torrent.announce) {
    result.announce.push(torrent.announce.toString())
  }

  // handle url-list (BEP19 / web seeding)
  if (Buffer.isBuffer(torrent['url-list'])) {
    // some clients set url-list to empty string
    torrent['url-list'] = torrent['url-list'].length > 0
      ? [ torrent['url-list'] ]
      : []
  }
  result.urlList = (torrent['url-list'] || []).map(function (url) {
    return url.toString()
  })

  uniq(result.announce)
  uniq(result.urlList)

  var files = torrent.info.files || [ torrent.info ]
  result.files = files.map(function (file, i) {
    var parts = [].concat(result.name, file['path.utf-8'] || file.path || []).map(function (p) {
      return p.toString()
    })
    return {
      path: path.join.apply(null, [path.sep].concat(parts)).slice(1),
      name: parts[parts.length - 1],
      length: file.length,
      offset: files.slice(0, i).reduce(sumLength, 0)
    }
  })

  result.length = files.reduce(sumLength, 0)

  var lastFile = result.files[result.files.length - 1]

  result.pieceLength = torrent.info['piece length']
  result.lastPieceLength = ((lastFile.offset + lastFile.length) % result.pieceLength) || result.pieceLength
  result.pieces = splitPieces(torrent.info.pieces)

  return result
}

/**
 * Convert a parsed torrent object back into a .torrent file buffer.
 * @param  {Object} parsed parsed torrent
 * @return {Buffer}
 */
function encodeTorrentFile (parsed) {
  var torrent = {
    info: parsed.info
  }

  torrent['announce-list'] = (parsed.announce || []).map(function (url) {
    if (!torrent.announce) torrent.announce = url
    url = new Buffer(url, 'utf8')
    return [ url ]
  })

  torrent['url-list'] = parsed.urlList || []

  if (parsed.created) {
    torrent['creation date'] = (parsed.created.getTime() / 1000) | 0
  }

  if (parsed.createdBy) {
    torrent['created by'] = parsed.createdBy
  }

  if (parsed.comment) {
    torrent.comment = parsed.comment
  }

  return bencode.encode(torrent)
}

function sumLength (sum, file) {
  return sum + file.length
}

function splitPieces (buf) {
  var pieces = []
  for (var i = 0; i < buf.length; i += 20) {
    pieces.push(buf.slice(i, i + 20).toString('hex'))
  }
  return pieces
}

function ensure (bool, fieldName) {
  if (!bool) throw new Error('Torrent is missing required field: ' + fieldName)
}

}).call(this,require("buffer").Buffer)

},{"bencode":65,"buffer":20,"path":70,"simple-sha1":96,"uniq":115}],65:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./lib/decode":66,"./lib/encode":68,"dup":27}],66:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":67,"buffer":20}],67:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],68:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],69:[function(require,module,exports){
(function (process,Buffer){
/* global Blob */

module.exports = parseTorrent
module.exports.remote = parseTorrentRemote

var blobToBuffer = require('blob-to-buffer')
var fs = require('fs') // browser exclude
var get = require('simple-get')
var magnet = require('magnet-uri')
var parseTorrentFile = require('parse-torrent-file')

module.exports.toMagnetURI = magnet.encode
module.exports.toTorrentFile = parseTorrentFile.encode

/**
 * Parse a torrent identifier (magnet uri, .torrent file, info hash)
 * @param  {string|Buffer|Object} torrentId
 * @return {Object}
 */
function parseTorrent (torrentId) {
  if (typeof torrentId === 'string' && /^(stream-)?magnet:/.test(torrentId)) {
    // magnet uri (string)
    return magnet(torrentId)
  } else if (typeof torrentId === 'string' && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
    // info hash (hex/base-32 string)
    return magnet('magnet:?xt=urn:btih:' + torrentId)
  } else if (Buffer.isBuffer(torrentId) && torrentId.length === 20) {
    // info hash (buffer)
    return magnet('magnet:?xt=urn:btih:' + torrentId.toString('hex'))
  } else if (Buffer.isBuffer(torrentId)) {
    // .torrent file (buffer)
    return parseTorrentFile(torrentId) // might throw
  } else if (torrentId && torrentId.infoHash) {
    // parsed torrent (from `parse-torrent`, `parse-torrent-file`, or `magnet-uri`)
    if (!torrentId.announce) torrentId.announce = []
    if (typeof torrentId.announce === 'string') {
      torrentId.announce = [ torrentId.announce ]
    }
    if (!torrentId.urlList) torrentId.urlList = []
    return torrentId
  } else {
    throw new Error('Invalid torrent identifier')
  }
}

function parseTorrentRemote (torrentId, cb) {
  var parsedTorrent
  if (typeof cb !== 'function') throw new Error('second argument must be a Function')

  try {
    parsedTorrent = parseTorrent(torrentId)
  } catch (err) {
    // If torrent fails to parse, it could be a Blob, http/https URL or
    // filesystem path, so don't consider it an error yet.
  }

  if (parsedTorrent && parsedTorrent.infoHash) {
    process.nextTick(function () {
      cb(null, parsedTorrent)
    })
  } else if (isBlob(torrentId)) {
    blobToBuffer(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error('Error converting Blob: ' + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof get === 'function' && /^https?:/.test(torrentId)) {
    // http, or https url to torrent file
    get.concat({
      url: torrentId,
      headers: { 'user-agent': 'WebTorrent (http://webtorrent.io)' }
    }, function (err, res, torrentBuf) {
      if (err) return cb(new Error('Error downloading torrent: ' + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof fs.readFile === 'function' && typeof torrentId === 'string') {
    // assume it's a filesystem path
    fs.readFile(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error('Invalid torrent identifier'))
      parseOrThrow(torrentBuf)
    })
  } else {
    process.nextTick(function () {
      cb(new Error('Invalid torrent identifier'))
    })
  }

  function parseOrThrow (torrentBuf) {
    try {
      parsedTorrent = parseTorrent(torrentBuf)
    } catch (err) {
      return cb(err)
    }
    if (parsedTorrent && parsedTorrent.infoHash) cb(null, parsedTorrent)
    else cb(new Error('Invalid torrent identifier'))
  }
}

/**
 * Check if `obj` is a W3C `Blob` or `File` object
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

// Workaround Browserify v13 bug
// https://github.com/substack/node-browserify/issues/1483
;(function () { Buffer(0) })()

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":73,"blob-to-buffer":15,"buffer":20,"fs":18,"magnet-uri":51,"parse-torrent-file":64,"simple-get":94}],70:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":73}],71:[function(require,module,exports){
var closest = require('closest-to')

// Create a range from 16kb–4mb
var sizes = []
for (var i = 14; i <= 22; i++) {
  sizes.push(Math.pow(2, i))
}

module.exports = function(size) {
  return closest(
    size / Math.pow(2, 10), sizes 
  )
}

},{"closest-to":23}],72:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":73}],73:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],74:[function(require,module,exports){
var once = require('once')
var eos = require('end-of-stream')
var fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close() // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump

},{"end-of-stream":34,"fs":18,"once":63}],75:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],76:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],77:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],78:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":76,"./encode":77}],79:[function(require,module,exports){
var iterate = function (list) {
  var offset = 0
  return function () {
    if (offset === list.length) return null

    var len = list.length - offset
    var i = (Math.random() * len) | 0
    var el = list[offset + i]

    var tmp = list[offset]
    list[offset] = el
    list[offset + i] = tmp
    offset++

    return el
  }
}

module.exports = iterate

},{}],80:[function(require,module,exports){
/*
Instance of writable stream.

call .get(length) or .discard(length) to get a stream (relative to the last end)

emits 'stalled' once everything is written


*/
var inherits = require('inherits')
var stream = require('readable-stream')

module.exports = RangeSliceStream

inherits(RangeSliceStream, stream.Writable)

function RangeSliceStream (offset) {
	var self = this
	if (!(self instanceof RangeSliceStream)) return new RangeSliceStream(offset)
	stream.Writable.call(self)

	self.destroyed = false
	self._queue = []
	self._position = offset || 0
	self._cb = null
	self._buffer = null
	self._out = null
}

RangeSliceStream.prototype._write = function (chunk, encoding, cb) {
	var self = this

	var drained = true

	while (true) {
		if (self.destroyed) {
			return
		}

		// Wait for more queue entries
		if (self._queue.length === 0) {
			self._buffer = chunk
			self._cb = cb
			return
		}

		self._buffer = null
		var currRange = self._queue[0]
		// Relative to the start of chunk, what data do we need?
		var writeStart = Math.max(currRange.start - self._position, 0)
		var writeEnd = currRange.end - self._position

		// Check if we need to throw it all away
		if (writeStart >= chunk.length) {
			self._position += chunk.length
			return cb(null)
		}

		// Check if we need to use it all
		var toWrite
		if (writeEnd > chunk.length) {
			self._position += chunk.length
			if (writeStart === 0) {
				toWrite = chunk
			} else {
				toWrite = chunk.slice(writeStart)
			}
			drained = currRange.stream.write(toWrite) && drained
			break
		}

		self._position += writeEnd
		if (writeStart === 0 && writeEnd === chunk.length) {
			toWrite = chunk
		} else {
			toWrite = chunk.slice(writeStart, writeEnd)
		}
		drained = currRange.stream.write(toWrite) && drained
		if (currRange.last) {
			currRange.stream.end()
		}
		chunk = chunk.slice(writeEnd)
		self._queue.shift()
	}

	if (drained) {
		cb(null)
	} else {
		currRange.stream.once('drain', cb.bind(null, null))
	}
}

RangeSliceStream.prototype.slice = function (ranges) {
	var self = this

	if (self.destroyed) return null

	if (!(ranges instanceof Array)) {
		ranges = [ranges]
	}

	var str = new stream.PassThrough()

	ranges.forEach(function (range, i) {
		self._queue.push({
			start: range.start,
			end: range.end,
			stream: str,
			last: i === (ranges.length - 1)
		})
	})
	if (self._buffer) {
		self._write(self._buffer, null, self._cb)
	}

	return str
}

RangeSliceStream.prototype.destroy = function (err) {
	var self = this
	if (self.destroyed) return
	self.destroyed = true

	if (err) self.emit('error', err)
}

},{"inherits":43,"readable-stream":86}],81:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":83,"./_stream_writable":85,"core-util-is":25,"inherits":43,"process-nextick-args":72}],82:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":84,"core-util-is":25,"inherits":43}],83:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var hasPrependListener = typeof EE.prototype.prependListener === 'function';

function prependListener(emitter, event, fn) {
  if (hasPrependListener) return emitter.prependListener(event, fn);

  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS. This is here
  // only because this code needs to continue to work with older versions
  // of Node.js that do not include the prependListener() method. The goal
  // is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var _buf = list[0];
        var cpy = Math.min(n - c, _buf.length);

        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);

        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":81,"_process":73,"buffer":20,"buffer-shims":19,"core-util-is":25,"events":35,"inherits":43,"isarray":49,"process-nextick-args":72,"string_decoder/":107,"util":17}],84:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":81,"core-util-is":25,"inherits":43}],85:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":81,"_process":73,"buffer":20,"buffer-shims":19,"core-util-is":25,"events":35,"inherits":43,"process-nextick-args":72,"util-deprecate":125}],86:[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))

},{"./lib/_stream_duplex.js":81,"./lib/_stream_passthrough.js":82,"./lib/_stream_readable.js":83,"./lib/_stream_transform.js":84,"./lib/_stream_writable.js":85,"_process":73}],87:[function(require,module,exports){
exports.render = render
exports.append = append
var mime = exports.mime = require('./lib/mime.json')

var debug = require('debug')('render-media')
var isAscii = require('is-ascii')
var MediaElementWrapper = require('mediasource')
var path = require('path')
var streamToBlobURL = require('stream-to-blob-url')
var videostream = require('videostream')

var VIDEOSTREAM_EXTS = [ '.mp4', '.m4v', '.m4a' ]

var MEDIASOURCE_VIDEO_EXTS = [ '.mp4', '.m4v', '.webm', '.mkv' ]
var MEDIASOURCE_AUDIO_EXTS = [ '.m4a', '.mp3' ]
var MEDIASOURCE_EXTS = MEDIASOURCE_VIDEO_EXTS.concat(MEDIASOURCE_AUDIO_EXTS)

var AUDIO_EXTS = [ '.wav', '.aac', '.ogg', '.oga' ]
var IMAGE_EXTS = [ '.jpg', '.jpeg', '.png', '.gif', '.bmp' ]
var IFRAME_EXTS = [ '.css', '.html', '.js', '.md', '.pdf', '.txt' ]

var MediaSource = typeof window !== 'undefined' && window.MediaSource

function render (file, elem, cb) {
  validateFile(file)
  if (typeof elem === 'string') elem = document.querySelector(elem)

  renderMedia(file, function (tagName) {
    if (elem.nodeName !== tagName.toUpperCase()) {
      var extname = path.extname(file.name).toLowerCase()

      throw new Error(
        'Cannot render "' + extname + '" inside a "' +
        elem.nodeName.toLowerCase() + '" element, expected "' + tagName + '"'
      )
    }

    return elem
  }, cb)
}

function append (file, rootElem, cb) {
  if (!cb) cb = function () {}
  validateFile(file)
  if (typeof rootElem === 'string') rootElem = document.querySelector(rootElem)

  if (rootElem && (rootElem.nodeName === 'VIDEO' || rootElem.nodeName === 'AUDIO')) {
    throw new Error(
      'Invalid video/audio node argument. Argument must be root element that ' +
      'video/audio tag will be appended to.'
    )
  }

  renderMedia(file, function (tagName) {
    if (tagName === 'video' || tagName === 'audio') return createMedia(tagName)
    else return createElem(tagName)
  }, function (err, elem) {
    if (err && elem) elem.remove()
    cb(err, elem)
  })

  function createMedia (tagName) {
    var elem = createElem(tagName)
    elem.controls = true
    elem.autoplay = true
    rootElem.appendChild(elem)
    return elem
  }

  function createElem (tagName) {
    var elem = document.createElement(tagName)
    rootElem.appendChild(elem)
    return elem
  }
}

function renderMedia (file, getElem, cb) {
  if (!cb) cb = function () {}
  var extname = path.extname(file.name).toLowerCase()
  var currentTime = 0
  var elem

  if (MEDIASOURCE_EXTS.indexOf(extname) >= 0) {
    renderMediaSource()
  } else if (AUDIO_EXTS.indexOf(extname) >= 0) {
    renderAudio()
  } else if (IMAGE_EXTS.indexOf(extname) >= 0) {
    renderImage()
  } else if (IFRAME_EXTS.indexOf(extname) >= 0) {
    renderIframe()
  } else {
    tryRenderIframe()
  }

  function renderMediaSource () {
    var tagName = MEDIASOURCE_VIDEO_EXTS.indexOf(extname) >= 0 ? 'video' : 'audio'

    if (MediaSource) {
      if (VIDEOSTREAM_EXTS.indexOf(extname) >= 0) {
        useVideostream()
      } else {
        useMediaSource()
      }
    } else {
      useBlobURL()
    }

    function useVideostream () {
      debug('Use `videostream` package for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fallbackToMediaSource)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      videostream(file, elem)
    }

    function useMediaSource () {
      debug('Use MediaSource API for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fallbackToBlobURL)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)

      var wrapper = new MediaElementWrapper(elem)
      var writable = wrapper.createWriteStream(getCodec(file.name))
      file.createReadStream().pipe(writable)

      if (currentTime) elem.currentTime = currentTime
    }

    function useBlobURL () {
      debug('Use Blob URL for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fatalError)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      getBlobURL(file, function (err, url) {
        if (err) return fatalError(err)
        elem.src = url
        if (currentTime) elem.currentTime = currentTime
      })
    }

    function fallbackToMediaSource (err) {
      debug('videostream error: fallback to MediaSource API: %o', err.message || err)
      elem.removeEventListener('error', fallbackToMediaSource)
      elem.removeEventListener('canplay', onCanPlay)

      useMediaSource()
    }

    function fallbackToBlobURL (err) {
      debug('MediaSource API error: fallback to Blob URL: %o', err.message || err)
      elem.removeEventListener('error', fallbackToBlobURL)
      elem.removeEventListener('canplay', onCanPlay)

      useBlobURL()
    }

    function prepareElem () {
      if (!elem) {
        elem = getElem(tagName)

        elem.addEventListener('progress', function () {
          currentTime = elem.currentTime
        })
      }
    }
  }

  function renderAudio () {
    elem = getElem('audio')
    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.addEventListener('error', fatalError)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      elem.src = url
    })
  }

  function onLoadStart () {
    elem.removeEventListener('loadstart', onLoadStart)
    elem.play()
  }

  function onCanPlay () {
    elem.removeEventListener('canplay', onCanPlay)
    cb(null, elem)
  }

  function renderImage () {
    elem = getElem('img')
    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.src = url
      elem.alt = file.name
      cb(null, elem)
    })
  }

  function renderIframe () {
    elem = getElem('iframe')

    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.src = url
      if (extname !== '.pdf') elem.sandbox = 'allow-forms allow-scripts'
      cb(null, elem)
    })
  }

  function tryRenderIframe () {
    debug('Unknown file extension "%s" - will attempt to render into iframe', extname)

    var str = ''
    file.createReadStream({ start: 0, end: 1000 })
      .setEncoding('utf8')
      .on('data', function (chunk) {
        str += chunk
      })
      .on('end', done)
      .on('error', cb)

    function done () {
      if (isAscii(str)) {
        debug('File extension "%s" appears ascii, so will render.', extname)
        renderIframe()
      } else {
        debug('File extension "%s" appears non-ascii, will not render.', extname)
        cb(new Error('Unsupported file type "' + extname + '": Cannot append to DOM'))
      }
    }
  }

  function fatalError (err) {
    err.message = 'Error rendering file "' + file.name + '": ' + err.message
    debug(err.message)
    cb(err)
  }
}

function getBlobURL (file, cb) {
  var extname = path.extname(file.name).toLowerCase()
  streamToBlobURL(file.createReadStream(), mime[extname], cb)
}

function validateFile (file) {
  if (file == null) {
    throw new Error('file cannot be null or undefined')
  }
  if (typeof file.name !== 'string') {
    throw new Error('missing or invalid file.name property')
  }
  if (typeof file.createReadStream !== 'function') {
    throw new Error('missing or invalid file.createReadStream property')
  }
}

function getCodec (name) {
  var extname = path.extname(name).toLowerCase()
  return {
    '.m4a': 'audio/mp4; codecs="mp4a.40.5"',
    '.m4v': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.mkv': 'video/webm; codecs="avc1.640029, mp4a.40.5"',
    '.mp3': 'audio/mpeg',
    '.mp4': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.webm': 'video/webm; codecs="vorbis, vp8"'
  }[extname]
}

},{"./lib/mime.json":88,"debug":31,"is-ascii":45,"mediasource":52,"path":70,"stream-to-blob-url":103,"videostream":129}],88:[function(require,module,exports){
module.exports={
  ".3gp": "video/3gpp",
  ".aac": "audio/aac",
  ".aif": "audio/x-aiff",
  ".aiff": "audio/x-aiff",
  ".atom": "application/atom+xml",
  ".avi": "video/x-msvideo",
  ".bmp": "image/bmp",
  ".bz2": "application/x-bzip2",
  ".conf": "text/plain",
  ".css": "text/css",
  ".csv": "text/csv",
  ".diff": "text/x-diff",
  ".doc": "application/msword",
  ".flv": "video/x-flv",
  ".gif": "image/gif",
  ".gz": "application/x-gzip",
  ".htm": "text/html",
  ".html": "text/html",
  ".ico": "image/vnd.microsoft.icon",
  ".ics": "text/calendar",
  ".iso": "application/octet-stream",
  ".jar": "application/java-archive",
  ".jpeg": "image/jpeg",
  ".jpg": "image/jpeg",
  ".js": "application/javascript",
  ".json": "application/json",
  ".less": "text/css",
  ".log": "text/plain",
  ".m3u": "audio/x-mpegurl",
  ".m4a": "audio/mp4",
  ".m4v": "video/mp4",
  ".manifest": "text/cache-manifest",
  ".markdown": "text/x-markdown",
  ".mathml": "application/mathml+xml",
  ".md": "text/x-markdown",
  ".mid": "audio/midi",
  ".midi": "audio/midi",
  ".mov": "video/quicktime",
  ".mp3": "audio/mpeg",
  ".mp4": "video/mp4",
  ".mp4v": "video/mp4",
  ".mpeg": "video/mpeg",
  ".mpg": "video/mpeg",
  ".odp": "application/vnd.oasis.opendocument.presentation",
  ".ods": "application/vnd.oasis.opendocument.spreadsheet",
  ".odt": "application/vnd.oasis.opendocument.text",
  ".oga": "audio/ogg",
  ".ogg": "application/ogg",
  ".pdf": "application/pdf",
  ".png": "image/png",
  ".pps": "application/vnd.ms-powerpoint",
  ".ppt": "application/vnd.ms-powerpoint",
  ".ps": "application/postscript",
  ".psd": "image/vnd.adobe.photoshop",
  ".qt": "video/quicktime",
  ".rar": "application/x-rar-compressed",
  ".rdf": "application/rdf+xml",
  ".rss": "application/rss+xml",
  ".rtf": "application/rtf",
  ".svg": "image/svg+xml",
  ".svgz": "image/svg+xml",
  ".swf": "application/x-shockwave-flash",
  ".tar": "application/x-tar",
  ".tbz": "application/x-bzip-compressed-tar",
  ".text": "text/plain",
  ".tif": "image/tiff",
  ".tiff": "image/tiff",
  ".torrent": "application/x-bittorrent",
  ".ttf": "application/x-font-ttf",
  ".txt": "text/plain",
  ".wav": "audio/wav",
  ".webm": "video/webm",
  ".wma": "audio/x-ms-wma",
  ".wmv": "video/x-ms-wmv",
  ".xls": "application/vnd.ms-excel",
  ".xml": "application/xml",
  ".yaml": "text/yaml",
  ".yml": "text/yaml",
  ".zip": "application/zip"
}

},{}],89:[function(require,module,exports){
(function (process){
module.exports = function (tasks, limit, cb) {
  if (typeof limit !== 'number') throw new Error('second argument must be a Number')
  var results, len, pending, keys, isErrored
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = len = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = len = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (err) isErrored = true
    if (--pending === 0 || err) {
      done(err)
    } else if (!isErrored && next < len) {
      var key
      if (keys) {
        key = keys[next]
        next += 1
        tasks[key](function (err, result) { each(key, err, result) })
      } else {
        key = next
        next += 1
        tasks[key](function (err, result) { each(key, err, result) })
      }
    }
  }

  var next = limit
  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.some(function (key, i) {
      tasks[key](function (err, result) { each(key, err, result) })
      if (i === limit - 1) return true // early return
    })
  } else {
    // array
    tasks.some(function (task, i) {
      task(function (err, result) { each(i, err, result) })
      if (i === limit - 1) return true // early return
    })
  }

  isSync = false
}

}).call(this,require('_process'))

},{"_process":73}],90:[function(require,module,exports){
(function (process){
module.exports = function (tasks, cb) {
  var results, pending, keys
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}

}).call(this,require('_process'))

},{"_process":73}],91:[function(require,module,exports){
(function (global){
/*
 * Rusha, a JavaScript implementation of the Secure Hash Algorithm, SHA-1,
 * as defined in FIPS PUB 180-1, tuned for high performance with large inputs.
 * (http://github.com/srijs/rusha)
 *
 * Inspired by Paul Johnstons implementation (http://pajhome.org.uk/crypt/md5).
 *
 * Copyright (c) 2013 Sam Rijs (http://awesam.de).
 * Released under the terms of the MIT license as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
(function () {
    var util = {
            getDataType: function (data) {
                if (typeof data === 'string') {
                    return 'string';
                }
                if (data instanceof Array) {
                    return 'array';
                }
                if (typeof global !== 'undefined' && global.Buffer && global.Buffer.isBuffer(data)) {
                    return 'buffer';
                }
                if (data instanceof ArrayBuffer) {
                    return 'arraybuffer';
                }
                if (data.buffer instanceof ArrayBuffer) {
                    return 'view';
                }
                if (data instanceof Blob) {
                    return 'blob';
                }
                throw new Error('Unsupported data type.');
            }
        };
    // The Rusha object is a wrapper around the low-level RushaCore.
    // It provides means of converting different inputs to the
    // format accepted by RushaCore as well as other utility methods.
    function Rusha(chunkSize) {
        'use strict';
        // Private object structure.
        var self$2 = { fill: 0 };
        // Calculate the length of buffer that the sha1 routine uses
        // including the padding.
        var padlen = function (len) {
            for (len += 9; len % 64 > 0; len += 1);
            return len;
        };
        var padZeroes = function (bin, len) {
            for (var i = len >> 2; i < bin.length; i++)
                bin[i] = 0;
        };
        var padData = function (bin, chunkLen, msgLen) {
            bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
            bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen >> 29;
            bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
        };
        // Convert a binary string and write it to the heap.
        // A binary string is expected to only contain char codes < 256.
        var convStr = function (H8, H32, start, len, off) {
            var str = this, i, om = off % 4, lm = len % 4, j = len - lm;
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = str.charCodeAt(start);
                case 1:
                    H8[off + 2 | 0] = str.charCodeAt(start + 1);
                case 2:
                    H8[off + 1 | 0] = str.charCodeAt(start + 2);
                case 3:
                    H8[off | 0] = str.charCodeAt(start + 3);
                }
            }
            for (i = om; i < j; i = i + 4 | 0) {
                H32[off + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
            case 2:
                H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
            case 1:
                H8[off + j + 3 | 0] = str.charCodeAt(start + j);
            }
        };
        // Convert a buffer or array and write it to the heap.
        // The buffer or array is expected to only contain elements < 256.
        var convBuf = function (H8, H32, start, len, off) {
            var buf = this, i, om = off % 4, lm = len % 4, j = len - lm;
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = buf[start];
                case 1:
                    H8[off + 2 | 0] = buf[start + 1];
                case 2:
                    H8[off + 1 | 0] = buf[start + 2];
                case 3:
                    H8[off | 0] = buf[start + 3];
                }
            }
            for (i = 4 - om; i < j; i = i += 4 | 0) {
                H32[off + i >> 2] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[start + j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[start + j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[start + j];
            }
        };
        var convBlob = function (H8, H32, start, len, off) {
            var blob = this, i, om = off % 4, lm = len % 4, j = len - lm;
            var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = buf[0];
                case 1:
                    H8[off + 2 | 0] = buf[1];
                case 2:
                    H8[off + 1 | 0] = buf[2];
                case 3:
                    H8[off | 0] = buf[3];
                }
            }
            for (i = 4 - om; i < j; i = i += 4 | 0) {
                H32[off + i >> 2] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[j];
            }
        };
        var convFn = function (data) {
            switch (util.getDataType(data)) {
            case 'string':
                return convStr.bind(data);
            case 'array':
                return convBuf.bind(data);
            case 'buffer':
                return convBuf.bind(data);
            case 'arraybuffer':
                return convBuf.bind(new Uint8Array(data));
            case 'view':
                return convBuf.bind(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            case 'blob':
                return convBlob.bind(data);
            }
        };
        var slice = function (data, offset) {
            switch (util.getDataType(data)) {
            case 'string':
                return data.slice(offset);
            case 'array':
                return data.slice(offset);
            case 'buffer':
                return data.slice(offset);
            case 'arraybuffer':
                return data.slice(offset);
            case 'view':
                return data.buffer.slice(offset);
            }
        };
        // Convert an ArrayBuffer into its hexadecimal string representation.
        var hex = function (arrayBuffer) {
            var i, x, hex_tab = '0123456789abcdef', res = [], binarray = new Uint8Array(arrayBuffer);
            for (i = 0; i < binarray.length; i++) {
                x = binarray[i];
                res[i] = hex_tab.charAt(x >> 4 & 15) + hex_tab.charAt(x >> 0 & 15);
            }
            return res.join('');
        };
        var ceilHeapSize = function (v) {
            // The asm.js spec says:
            // The heap object's byteLength must be either
            // 2^n for n in [12, 24) or 2^24 * n for n ≥ 1.
            // Also, byteLengths smaller than 2^16 are deprecated.
            var p;
            // If v is smaller than 2^16, the smallest possible solution
            // is 2^16.
            if (v <= 65536)
                return 65536;
            // If v < 2^24, we round up to 2^n,
            // otherwise we round up to 2^24 * n.
            if (v < 16777216) {
                for (p = 1; p < v; p = p << 1);
            } else {
                for (p = 16777216; p < v; p += 16777216);
            }
            return p;
        };
        // Initialize the internal data structures to a new capacity.
        var init = function (size) {
            if (size % 64 > 0) {
                throw new Error('Chunk size must be a multiple of 128 bit');
            }
            self$2.maxChunkLen = size;
            self$2.padMaxChunkLen = padlen(size);
            // The size of the heap is the sum of:
            // 1. The padded input message size
            // 2. The extended space the algorithm needs (320 byte)
            // 3. The 160 bit state the algoritm uses
            self$2.heap = new ArrayBuffer(ceilHeapSize(self$2.padMaxChunkLen + 320 + 20));
            self$2.h32 = new Int32Array(self$2.heap);
            self$2.h8 = new Int8Array(self$2.heap);
            self$2.core = new Rusha._core({
                Int32Array: Int32Array,
                DataView: DataView
            }, {}, self$2.heap);
            self$2.buffer = null;
        };
        // Iinitializethe datastructures according
        // to a chunk siyze.
        init(chunkSize || 64 * 1024);
        var initState = function (heap, padMsgLen) {
            var io = new Int32Array(heap, padMsgLen + 320, 5);
            io[0] = 1732584193;
            io[1] = -271733879;
            io[2] = -1732584194;
            io[3] = 271733878;
            io[4] = -1009589776;
        };
        var padChunk = function (chunkLen, msgLen) {
            var padChunkLen = padlen(chunkLen);
            var view = new Int32Array(self$2.heap, 0, padChunkLen >> 2);
            padZeroes(view, chunkLen);
            padData(view, chunkLen, msgLen);
            return padChunkLen;
        };
        // Write data to the heap.
        var write = function (data, chunkOffset, chunkLen) {
            convFn(data)(self$2.h8, self$2.h32, chunkOffset, chunkLen, 0);
        };
        // Initialize and call the RushaCore,
        // assuming an input buffer of length len * 4.
        var coreCall = function (data, chunkOffset, chunkLen, msgLen, finalize) {
            var padChunkLen = chunkLen;
            if (finalize) {
                padChunkLen = padChunk(chunkLen, msgLen);
            }
            write(data, chunkOffset, chunkLen);
            self$2.core.hash(padChunkLen, self$2.padMaxChunkLen);
        };
        var getRawDigest = function (heap, padMaxChunkLen) {
            var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
            var out = new Int32Array(5);
            var arr = new DataView(out.buffer);
            arr.setInt32(0, io[0], false);
            arr.setInt32(4, io[1], false);
            arr.setInt32(8, io[2], false);
            arr.setInt32(12, io[3], false);
            arr.setInt32(16, io[4], false);
            return out;
        };
        // Calculate the hash digest as an array of 5 32bit integers.
        var rawDigest = this.rawDigest = function (str) {
                var msgLen = str.byteLength || str.length || str.size || 0;
                initState(self$2.heap, self$2.padMaxChunkLen);
                var chunkOffset = 0, chunkLen = self$2.maxChunkLen, last;
                for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                    coreCall(str, chunkOffset, chunkLen, msgLen, false);
                }
                coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
                return getRawDigest(self$2.heap, self$2.padMaxChunkLen);
            };
        // The digest and digestFrom* interface returns the hash digest
        // as a hex string.
        this.digest = this.digestFromString = this.digestFromBuffer = this.digestFromArrayBuffer = function (str) {
            return hex(rawDigest(str).buffer);
        };
    }
    ;
    // The low-level RushCore module provides the heart of Rusha,
    // a high-speed sha1 implementation working on an Int32Array heap.
    // At first glance, the implementation seems complicated, however
    // with the SHA1 spec at hand, it is obvious this almost a textbook
    // implementation that has a few functions hand-inlined and a few loops
    // hand-unrolled.
    Rusha._core = function RushaCore(stdlib, foreign, heap) {
        'use asm';
        var H = new stdlib.Int32Array(heap);
        function hash(k, x) {
            // k in bytes
            k = k | 0;
            x = x | 0;
            var i = 0, j = 0, y0 = 0, z0 = 0, y1 = 0, z1 = 0, y2 = 0, z2 = 0, y3 = 0, z3 = 0, y4 = 0, z4 = 0, t0 = 0, t1 = 0;
            y0 = H[x + 320 >> 2] | 0;
            y1 = H[x + 324 >> 2] | 0;
            y2 = H[x + 328 >> 2] | 0;
            y3 = H[x + 332 >> 2] | 0;
            y4 = H[x + 336 >> 2] | 0;
            for (i = 0; (i | 0) < (k | 0); i = i + 64 | 0) {
                z0 = y0;
                z1 = y1;
                z2 = y2;
                z3 = y3;
                z4 = y4;
                for (j = 0; (j | 0) < 64; j = j + 4 | 0) {
                    t1 = H[i + j >> 2] | 0;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[k + j >> 2] = t1;
                }
                for (j = k + 64 | 0; (j | 0) < (k + 80 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 80 | 0; (j | 0) < (k + 160 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) + 1859775393 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 160 | 0; (j | 0) < (k + 240 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | y1 & y3 | y2 & y3) | 0) + ((t1 + y4 | 0) - 1894007588 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 240 | 0; (j | 0) < (k + 320 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) - 899497514 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                y0 = y0 + z0 | 0;
                y1 = y1 + z1 | 0;
                y2 = y2 + z2 | 0;
                y3 = y3 + z3 | 0;
                y4 = y4 + z4 | 0;
            }
            H[x + 320 >> 2] = y0;
            H[x + 324 >> 2] = y1;
            H[x + 328 >> 2] = y2;
            H[x + 332 >> 2] = y3;
            H[x + 336 >> 2] = y4;
        }
        return { hash: hash };
    };
    // If we'e running in Node.JS, export a module.
    if (typeof module !== 'undefined') {
        module.exports = Rusha;
    } else if (typeof window !== 'undefined') {
        window.Rusha = Rusha;
    }
    // If we're running in a webworker, accept
    // messages containing a jobid and a buffer
    // or blob object, and return the hash result.
    if (typeof FileReaderSync !== 'undefined') {
        var reader = new FileReaderSync(), hasher = new Rusha(4 * 1024 * 1024);
        self.onmessage = function onMessage(event) {
            var hash, data = event.data.data;
            try {
                hash = hasher.digest(data);
                self.postMessage({
                    id: event.data.id,
                    hash: hash
                });
            } catch (e) {
                self.postMessage({
                    id: event.data.id,
                    error: e.name
                });
            }
        };
    }
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],92:[function(require,module,exports){
module.exports = require('buffer')

},{"buffer":20}],93:[function(require,module,exports){
(function (Buffer){
module.exports = function (stream, cb) {
  var chunks = []
  stream.on('data', function (chunk) {
    chunks.push(chunk)
  })
  stream.once('end', function () {
    if (cb) cb(null, Buffer.concat(chunks))
    cb = null
  })
  stream.once('error', function (err) {
    if (cb) cb(err)
    cb = null
  })
}

}).call(this,require("buffer").Buffer)

},{"buffer":20}],94:[function(require,module,exports){
(function (Buffer){
module.exports = simpleGet

var extend = require('xtend')
var http = require('http')
var https = require('https')
var once = require('once')
var unzipResponse = require('unzip-response') // excluded from browser build
var url = require('url')

function simpleGet (opts, cb) {
  opts = typeof opts === 'string' ? { url: opts } : extend(opts)
  cb = once(cb)

  if (opts.url) parseOptsUrl(opts)
  if (opts.headers == null) opts.headers = {}
  if (opts.maxRedirects == null) opts.maxRedirects = 10

  var body = opts.body
  opts.body = undefined
  if (body && !opts.method) opts.method = 'POST'

  // Request gzip/deflate
  var customAcceptEncoding = Object.keys(opts.headers).some(function (h) {
    return h.toLowerCase() === 'accept-encoding'
  })
  if (!customAcceptEncoding) opts.headers['accept-encoding'] = 'gzip, deflate'

  // Support http: and https: urls
  var protocol = opts.protocol === 'https:' ? https : http
  var req = protocol.request(opts, function (res) {
    // Follow 3xx redirects
    if (res.statusCode >= 300 && res.statusCode < 400 && 'location' in res.headers) {
      opts.url = res.headers.location
      parseOptsUrl(opts)
      res.resume() // Discard response

      opts.maxRedirects -= 1
      if (opts.maxRedirects > 0) simpleGet(opts, cb)
      else cb(new Error('too many redirects'))

      return
    }

    cb(null, typeof unzipResponse === 'function' ? unzipResponse(res) : res)
  })
  req.on('error', cb)
  req.end(body)
  return req
}

module.exports.concat = function (opts, cb) {
  return simpleGet(opts, function (err, res) {
    if (err) return cb(err)
    var chunks = []
    res.on('data', function (chunk) {
      chunks.push(chunk)
    })
    res.on('end', function () {
      cb(null, res, Buffer.concat(chunks))
    })
  })
}

;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(function (method) {
  module.exports[method] = function (opts, cb) {
    if (typeof opts === 'string') opts = { url: opts }
    opts.method = method.toUpperCase()
    return simpleGet(opts, cb)
  }
})

function parseOptsUrl (opts) {
  var loc = url.parse(opts.url)
  if (loc.hostname) opts.hostname = loc.hostname
  if (loc.port) opts.port = loc.port
  if (loc.protocol) opts.protocol = loc.protocol
  if (loc.auth) opts.auth = loc.auth
  opts.path = loc.path
  delete opts.url
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"http":99,"https":40,"once":63,"unzip-response":17,"url":117,"xtend":139}],95:[function(require,module,exports){
(function (Buffer){
module.exports = Peer

var debug = require('debug')('simple-peer')
var getBrowserRTC = require('get-browser-rtc')
var hat = require('hat')
var inherits = require('inherits')
var once = require('once')
var stream = require('readable-stream')

inherits(Peer, stream.Duplex)

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
function Peer (opts) {
  var self = this
  if (!(self instanceof Peer)) return new Peer(opts)
  self._debug('new peer %o', opts)

  if (!opts) opts = {}
  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.initiator = opts.initiator || false
  self.channelConfig = opts.channelConfig || Peer.channelConfig
  self.channelName = opts.initiator ? (opts.channelName || hat(160)) : null
  self.config = opts.config || Peer.config
  self.constraints = opts.constraints || Peer.constraints
  self.offerConstraints = opts.offerConstraints
  self.answerConstraints = opts.answerConstraints
  self.reconnectTimer = opts.reconnectTimer || false
  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }
  self.stream = opts.stream || false
  self.trickle = opts.trickle !== undefined ? opts.trickle : true

  self.destroyed = false
  self.connected = false

  // so Peer object always has same shape (V8 optimization)
  self.remoteAddress = undefined
  self.remoteFamily = undefined
  self.remotePort = undefined
  self.localAddress = undefined
  self.localPort = undefined

  self._isWrtc = !!opts.wrtc // HACK: to fix `wrtc` bug. See issue: #60
  self._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
    ? opts.wrtc
    : getBrowserRTC()
  if (!self._wrtc) {
    if (typeof window === 'undefined') {
      throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment')
    } else {
      throw new Error('No WebRTC support: Not a supported browser')
    }
  }

  self._maxBufferedAmount = opts.highWaterMark
  self._pcReady = false
  self._channelReady = false
  self._iceComplete = false // ice candidate trickle done (got null candidate)
  self._channel = null
  self._pendingCandidates = []

  self._chunk = null
  self._cb = null
  self._interval = null
  self._reconnectTimeout = null

  self._pc = new (self._wrtc.RTCPeerConnection)(self.config, self.constraints)
  self._pc.oniceconnectionstatechange = function () {
    self._onIceConnectionStateChange()
  }
  self._pc.onsignalingstatechange = function () {
    self._onSignalingStateChange()
  }
  self._pc.onicecandidate = function (event) {
    self._onIceCandidate(event)
  }

  if (self.stream) self._pc.addStream(self.stream)
  self._pc.onaddstream = function (event) {
    self._onAddStream(event)
  }

  if (self.initiator) {
    self._setupData({
      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)
    })
    self._pc.onnegotiationneeded = once(function () {
      self._createOffer()
    })
    // Only Chrome triggers "negotiationneeded"; this is a workaround for other
    // implementations
    if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {
      self._pc.onnegotiationneeded()
    }
  } else {
    self._pc.ondatachannel = function (event) {
      self._setupData(event)
    }
  }

  self.on('finish', function () {
    if (self.connected) {
      // When local peer is finished writing, close connection to remote peer.
      // Half open connections are currently not supported.
      // Wait a bit before destroying so the datachannel flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If data channel is not connected when local peer is finished writing, wait until
      // data is flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose config, constraints, and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      url: 'stun:23.21.150.121', // deprecated, replaced by `urls`
      urls: 'stun:23.21.150.121'
    }
  ]
}
Peer.constraints = {}
Peer.channelConfig = {}

Object.defineProperty(Peer.prototype, 'bufferSize', {
  get: function () {
    var self = this
    return (self._channel && self._channel.bufferedAmount) || 0
  }
})

Peer.prototype.address = function () {
  var self = this
  return { port: self.localPort, family: 'IPv4', address: self.localAddress }
}

Peer.prototype.signal = function (data) {
  var self = this
  if (self.destroyed) throw new Error('cannot signal after peer is destroyed')
  if (typeof data === 'string') {
    try {
      data = JSON.parse(data)
    } catch (err) {
      data = {}
    }
  }
  self._debug('signal()')

  function addIceCandidate (candidate) {
    try {
      self._pc.addIceCandidate(
        new self._wrtc.RTCIceCandidate(candidate),
        noop,
        function (err) { self._onError(err) }
      )
    } catch (err) {
      self._destroy(new Error('error adding candidate: ' + err.message))
    }
  }

  if (data.sdp) {
    self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data), function () {
      if (self.destroyed) return
      if (self._pc.remoteDescription.type === 'offer') self._createAnswer()

      self._pendingCandidates.forEach(addIceCandidate)
      self._pendingCandidates = []
    }, function (err) { self._onError(err) })
  }
  if (data.candidate) {
    if (self._pc.remoteDescription) addIceCandidate(data.candidate)
    else self._pendingCandidates.push(data.candidate)
  }
  if (!data.sdp && !data.candidate) {
    self._destroy(new Error('signal() called with invalid signal data'))
  }
}

/**
 * Send text/binary data to the remote peer.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Peer.prototype.send = function (chunk) {
  var self = this

  // HACK: `wrtc` module doesn't accept node.js buffer. See issue: #60
  if (Buffer.isBuffer(chunk) && self._isWrtc) {
    chunk = new Uint8Array(chunk)
  }

  var len = chunk.length || chunk.byteLength || chunk.size
  self._channel.send(chunk)
  self._debug('write: %d bytes', len)
}

Peer.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Peer.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  self._debug('destroy (error: %s)', err && err.message)

  self.readable = self.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.destroyed = true
  self.connected = false
  self._pcReady = false
  self._channelReady = false

  self._chunk = null
  self._cb = null
  clearInterval(self._interval)
  clearTimeout(self._reconnectTimeout)

  if (self._pc) {
    try {
      self._pc.close()
    } catch (err) {}

    self._pc.oniceconnectionstatechange = null
    self._pc.onsignalingstatechange = null
    self._pc.onicecandidate = null
    self._pc.onaddstream = null
    self._pc.onnegotiationneeded = null
    self._pc.ondatachannel = null
  }

  if (self._channel) {
    try {
      self._channel.close()
    } catch (err) {}

    self._channel.onmessage = null
    self._channel.onopen = null
    self._channel.onclose = null
  }
  self._pc = null
  self._channel = null

  if (err) self.emit('error', err)
  self.emit('close')
}

Peer.prototype._setupData = function (event) {
  var self = this
  self._channel = event.channel
  self.channelName = self._channel.label

  self._channel.binaryType = 'arraybuffer'
  self._channel.onmessage = function (event) {
    self._onChannelMessage(event)
  }
  self._channel.onopen = function () {
    self._onChannelOpen()
  }
  self._channel.onclose = function () {
    self._onChannelClose()
  }
}

Peer.prototype._read = function () {}

Peer.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self._onError(err)
    }
    if (self._channel.bufferedAmount > self._maxBufferedAmount) {
      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    self._debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Peer.prototype._createOffer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createOffer(function (offer) {
    if (self.destroyed) return
    offer.sdp = self.sdpTransform(offer.sdp)
    self._pc.setLocalDescription(offer, noop, function (err) { self._onError(err) })
    var sendOffer = function () {
      var signal = self._pc.localDescription || offer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
    if (self.trickle || self._iceComplete) sendOffer()
    else self.once('_iceComplete', sendOffer) // wait for candidates
  }, function (err) { self._onError(err) }, self.offerConstraints)
}

Peer.prototype._createAnswer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createAnswer(function (answer) {
    if (self.destroyed) return
    answer.sdp = self.sdpTransform(answer.sdp)
    self._pc.setLocalDescription(answer, noop, function (err) { self._onError(err) })
    var sendAnswer = function () {
      var signal = self._pc.localDescription || answer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
    if (self.trickle || self._iceComplete) sendAnswer()
    else self.once('_iceComplete', sendAnswer)
  }, function (err) { self._onError(err) }, self.answerConstraints)
}

Peer.prototype._onIceConnectionStateChange = function () {
  var self = this
  if (self.destroyed) return
  var iceGatheringState = self._pc.iceGatheringState
  var iceConnectionState = self._pc.iceConnectionState
  self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState)
  self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState)
  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
    clearTimeout(self._reconnectTimeout)
    self._pcReady = true
    self._maybeReady()
  }
  if (iceConnectionState === 'disconnected') {
    if (self.reconnectTimer) {
      // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect
      clearTimeout(self._reconnectTimeout)
      self._reconnectTimeout = setTimeout(function () {
        self._destroy()
      }, self.reconnectTimer)
    } else {
      self._destroy()
    }
  }
  if (iceConnectionState === 'failed') {
    self._destroy()
  }
  if (iceConnectionState === 'closed') {
    self._destroy()
  }
}

Peer.prototype.getStats = function (cb) {
  var self = this
  if (!self._pc.getStats) { // No ability to call stats
    cb([])
  } else if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) { // Mozilla
    self._pc.getStats(null, function (res) {
      var items = []
      res.forEach(function (item) {
        items.push(item)
      })
      cb(items)
    }, function (err) { self._onError(err) })
  } else {
    self._pc.getStats(function (res) { // Chrome
      var items = []
      res.result().forEach(function (result) {
        var item = {}
        result.names().forEach(function (name) {
          item[name] = result.stat(name)
        })
        item.id = result.id
        item.type = result.type
        item.timestamp = result.timestamp
        items.push(item)
      })
      cb(items)
    })
  }
}

Peer.prototype._maybeReady = function () {
  var self = this
  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)
  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return
  self._connecting = true

  self.getStats(function (items) {
    self._connecting = false
    self.connected = true

    var remoteCandidates = {}
    var localCandidates = {}

    function setActiveCandidates (item) {
      var local = localCandidates[item.localCandidateId]
      var remote = remoteCandidates[item.remoteCandidateId]

      if (local) {
        self.localAddress = local.ipAddress
        self.localPort = Number(local.portNumber)
      } else if (typeof item.googLocalAddress === 'string') {
        // Sometimes `item.id` is undefined in `wrtc` and Chrome
        // See: https://github.com/feross/simple-peer/issues/66
        local = item.googLocalAddress.split(':')
        self.localAddress = local[0]
        self.localPort = Number(local[1])
      }
      self._debug('connect local: %s:%s', self.localAddress, self.localPort)

      if (remote) {
        self.remoteAddress = remote.ipAddress
        self.remotePort = Number(remote.portNumber)
        self.remoteFamily = 'IPv4'
      } else if (typeof item.googRemoteAddress === 'string') {
        remote = item.googRemoteAddress.split(':')
        self.remoteAddress = remote[0]
        self.remotePort = Number(remote[1])
        self.remoteFamily = 'IPv4'
      }
      self._debug('connect remote: %s:%s', self.remoteAddress, self.remotePort)
    }

    items.forEach(function (item) {
      if (item.type === 'remotecandidate') remoteCandidates[item.id] = item
      if (item.type === 'localcandidate') localCandidates[item.id] = item
    })

    items.forEach(function (item) {
      var isCandidatePair = (
        (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
        (item.type === 'candidatepair' && item.selected)
      )
      if (isCandidatePair) setActiveCandidates(item)
    })

    if (self._chunk) {
      try {
        self.send(self._chunk)
      } catch (err) {
        return self._onError(err)
      }
      self._chunk = null
      self._debug('sent chunk from "write before connect"')

      var cb = self._cb
      self._cb = null
      cb(null)
    }

    self._interval = setInterval(function () {
      if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return
      self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()

    self._debug('connect')
    self.emit('connect')
  })
}

Peer.prototype._onSignalingStateChange = function () {
  var self = this
  if (self.destroyed) return
  self._debug('signalingStateChange %s', self._pc.signalingState)
  self.emit('signalingStateChange', self._pc.signalingState)
}

Peer.prototype._onIceCandidate = function (event) {
  var self = this
  if (self.destroyed) return
  if (event.candidate && self.trickle) {
    self.emit('signal', {
      candidate: {
        candidate: event.candidate.candidate,
        sdpMLineIndex: event.candidate.sdpMLineIndex,
        sdpMid: event.candidate.sdpMid
      }
    })
  } else if (!event.candidate) {
    self._iceComplete = true
    self.emit('_iceComplete')
  }
}

Peer.prototype._onChannelMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  self._debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) data = new Buffer(data)
  self.push(data)
}

Peer.prototype._onChannelOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self._debug('on channel open')
  self._channelReady = true
  self._maybeReady()
}

Peer.prototype._onChannelClose = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on channel close')
  self._destroy()
}

Peer.prototype._onAddStream = function (event) {
  var self = this
  if (self.destroyed) return
  self._debug('on add stream')
  self.emit('stream', event.stream)
}

Peer.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  self._debug('error %s', err.message || err)
  self._destroy(err)
}

Peer.prototype._debug = function () {
  var self = this
  var args = [].slice.call(arguments)
  var id = self.channelName && self.channelName.substring(0, 7)
  args[0] = '[' + id + '] ' + args[0]
  debug.apply(null, args)
}

function noop () {}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"debug":31,"get-browser-rtc":38,"hat":39,"inherits":43,"once":63,"readable-stream":86}],96:[function(require,module,exports){
var Rusha = require('rusha')

var rusha = new Rusha
var crypto = window.crypto || window.msCrypto || {}
var subtle = crypto.subtle || crypto.webkitSubtle

function sha1sync (buf) {
  return rusha.digest(buf)
}

// Browsers throw if they lack support for an algorithm.
// Promise will be rejected on non-secure origins. (http://goo.gl/lq4gCo)
try {
  subtle.digest({ name: 'sha-1' }, new Uint8Array).catch(function () {
    subtle = false
  })
} catch (err) { subtle = false }

function sha1 (buf, cb) {
  if (!subtle) {
    // Use Rusha
    setTimeout(cb, 0, sha1sync(buf))
    return
  }

  if (typeof buf === 'string') {
    buf = uint8array(buf)
  }

  subtle.digest({ name: 'sha-1' }, buf)
    .then(function succeed (result) {
      cb(hex(new Uint8Array(result)))
    },
    function fail (error) {
      cb(sha1sync(buf))
    })
}

function uint8array (s) {
  var l = s.length
  var array = new Uint8Array(l)
  for (var i = 0; i < l; i++) {
    array[i] = s.charCodeAt(i)
  }
  return array
}

function hex (buf) {
  var l = buf.length
  var chars = []
  for (var i = 0; i < l; i++) {
    var bite = buf[i]
    chars.push((bite >>> 4).toString(16))
    chars.push((bite & 0x0f).toString(16))
  }
  return chars.join('')
}

module.exports = sha1
module.exports.sync = sha1sync

},{"rusha":91}],97:[function(require,module,exports){
(function (process,Buffer){
/* global WebSocket */

module.exports = Socket

var debug = require('debug')('simple-websocket')
var inherits = require('inherits')
var stream = require('readable-stream')
var ws = require('ws') // websockets in node - will be empty object in browser

var _WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : ws

inherits(Socket, stream.Duplex)

/**
 * WebSocket. Same API as node core `net.Socket`. Duplex stream.
 * @param {string} url websocket server url
 * @param {Object} opts options to stream.Duplex
 */
function Socket (url, opts) {
  var self = this
  if (!(self instanceof Socket)) return new Socket(url, opts)
  if (!opts) opts = {}
  debug('new websocket: %s %o', url, opts)

  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.url = url
  self.connected = false
  self.destroyed = false

  self._maxBufferedAmount = opts.highWaterMark
  self._chunk = null
  self._cb = null
  self._interval = null

  try {
    if (typeof WebSocket === 'undefined') {
      // `ws` package accepts options
      self._ws = new _WebSocket(self.url, opts)
    } else {
      self._ws = new _WebSocket(self.url)
    }
  } catch (err) {
    process.nextTick(function () {
      self._onError(err)
    })
    return
  }
  self._ws.binaryType = 'arraybuffer'
  self._ws.onopen = function () {
    self._onOpen()
  }
  self._ws.onmessage = function (event) {
    self._onMessage(event)
  }
  self._ws.onclose = function () {
    self._onClose()
  }
  self._ws.onerror = function () {
    self._onError(new Error('connection error to ' + self.url))
  }

  self.on('finish', function () {
    if (self.connected) {
      // When stream is finished writing, close socket connection. Half open connections
      // are currently not supported.
      // Wait a bit before destroying so the socket flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If socket is not connected when stream is finished writing, wait until data is
      // flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Socket.WEBSOCKET_SUPPORT = !!_WebSocket

/**
 * Send text/binary data to the WebSocket server.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Socket.prototype.send = function (chunk) {
  var self = this

  var len = chunk.length || chunk.byteLength || chunk.size
  self._ws.send(chunk)
  debug('write: %d bytes', len)
}

Socket.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Socket.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  debug('destroy (error: %s)', err && err.message)

  this.readable = this.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.connected = false
  self.destroyed = true

  clearInterval(self._interval)
  self._interval = null
  self._chunk = null
  self._cb = null

  if (self._ws) {
    var ws = self._ws
    var onClose = function () {
      ws.onclose = null
      self.emit('close')
    }
    if (ws.readyState === _WebSocket.CLOSED) {
      onClose()
    } else {
      try {
        ws.onclose = onClose
        ws.close()
      } catch (err) {
        onClose()
      }
    }

    ws.onopen = null
    ws.onmessage = null
    ws.onerror = null
  }
  self._ws = null

  if (err) self.emit('error', err)
}

Socket.prototype._read = function () {}

Socket.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after socket is destroyed'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self._onError(err)
    }
    if (typeof ws !== 'function' && self._ws.bufferedAmount > self._maxBufferedAmount) {
      debug('start backpressure: bufferedAmount %d', self._ws.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Socket.prototype._onMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) data = new Buffer(data)
  self.push(data)
}

Socket.prototype._onOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self.connected = true

  if (self._chunk) {
    try {
      self.send(self._chunk)
    } catch (err) {
      return self._onError(err)
    }
    self._chunk = null
    debug('sent chunk from "write before connect"')

    var cb = self._cb
    self._cb = null
    cb(null)
  }

  // No backpressure in node. The `ws` module has a buggy `bufferedAmount` property.
  // See: https://github.com/websockets/ws/issues/492
  if (typeof ws !== 'function') {
    self._interval = setInterval(function () {
      if (!self._cb || !self._ws || self._ws.bufferedAmount > self._maxBufferedAmount) {
        return
      }
      debug('ending backpressure: bufferedAmount %d', self._ws.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()
  }

  debug('connect')
  self.emit('connect')
}

Socket.prototype._onClose = function () {
  var self = this
  if (self.destroyed) return
  debug('on close')
  self._destroy()
}

Socket.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  debug('error: %s', err.message || err)
  self._destroy(err)
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":73,"buffer":20,"debug":31,"inherits":43,"readable-stream":86,"ws":17}],98:[function(require,module,exports){
var tick = 1
var maxTick = 65535
var resolution = 4
var inc = function () {
  tick = (tick + 1) & maxTick
}

var timer = setInterval(inc, (1000 / resolution) | 0)
if (timer.unref) timer.unref()

module.exports = function (seconds) {
  var size = resolution * (seconds || 5)
  var buffer = [0]
  var pointer = 1
  var last = (tick - 1) & maxTick

  return function (delta) {
    var dist = (tick - last) & maxTick
    if (dist > size) dist = size
    last = tick

    while (dist--) {
      if (pointer === size) pointer = 0
      buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1]
      pointer++
    }

    if (delta) buffer[pointer - 1] += delta

    var top = buffer[pointer - 1]
    var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer]

    return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length
  }
}

},{}],99:[function(require,module,exports){
(function (global){
var ClientRequest = require('./lib/request')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/request":101,"builtin-status-codes":21,"url":117,"xtend":139}],100:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

var xhr = new global.XMLHttpRequest()
// If location.host is empty, e.g. if this page/worker was loaded
// from a Blob, then use example.com to avoid an error
xhr.open('GET', global.location.host ? '/' : 'https://example.com')

function checkTypeSupport (type) {
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

exports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')
// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')
exports.overrideMimeType = isFunction(xhr.overrideMimeType)
exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
  return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],101:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary) {
	if (capability.fetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary)

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var self = this
	return self._headers[name.toLowerCase()].value
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body
	if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {
		if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	if (self._mode === 'fetch') {
		var headers = Object.keys(headersObj).map(function (name) {
			return [headersObj[name].name, headersObj[name].value]
		})

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headers,
			body: body,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin'
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		Object.keys(headersObj).forEach(function (name) {
			xhr.setRequestHeader(headersObj[name].name, headersObj[name].value)
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	// Currently, there isn't a way to truly abort a fetch.
	// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'user-agent',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":100,"./response":102,"_process":73,"buffer":20,"inherits":43,"readable-stream":86,"to-arraybuffer":110}],102:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		// backwards compatible version of for (<item> of <iterable>):
		// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
		for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
			self.headers[header[0].toLowerCase()] = header[1]
			self.rawHeaders.push(header[0], header[1])
		}

		// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			})
		}
		read()

	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":100,"_process":73,"buffer":20,"inherits":43,"readable-stream":86}],103:[function(require,module,exports){
/* global URL */

var getBlob = require('stream-to-blob')

module.exports = function getBlobURL (stream, mimeType, cb) {
  if (typeof mimeType === 'function') return getBlobURL(stream, null, mimeType)
  getBlob(stream, mimeType, function (err, blob) {
    if (err) return cb(err)
    var url = URL.createObjectURL(blob)
    cb(null, url)
  })
}

},{"stream-to-blob":104}],104:[function(require,module,exports){
/* global Blob */

var once = require('once')

module.exports = function getBlob (stream, mimeType, cb) {
  if (typeof mimeType === 'function') return getBlob(stream, null, mimeType)
  cb = once(cb)
  var chunks = []
  stream
    .on('data', function (chunk) {
      chunks.push(chunk)
    })
    .on('end', function () {
      var blob = mimeType
        ? new Blob(chunks, { type: mimeType })
        : new Blob(chunks)
      cb(null, blob)
    })
    .on('error', cb)
}

},{"once":63}],105:[function(require,module,exports){
(function (Buffer){
var once = require('once')

module.exports = function getBuffer (stream, length, cb) {
  cb = once(cb)
  var buf = new Buffer(length)
  var offset = 0
  stream
    .on('data', function (chunk) {
      chunk.copy(buf, offset)
      offset += chunk.length
    })
    .on('end', function () { cb(null, buf) })
    .on('error', cb)
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"once":63}],106:[function(require,module,exports){
(function (Buffer){
var addrToIPPort = require('addr-to-ip-port')
var ipaddr = require('ipaddr.js')

module.exports = function (addrs) {
  if (typeof addrs === 'string') {
    addrs = [ addrs ]
  }

  return Buffer.concat(addrs.map(function (addr) {
    var s = addrToIPPort(addr)
    if (s.length !== 2) {
      throw new Error('invalid address format, expecting: 10.10.10.5:128')
    }

    var ip = ipaddr.parse(s[0])
    var ipBuf = new Buffer(ip.toByteArray())
    var port = Number(s[1])
    var portBuf = new Buffer(2)
    portBuf.writeUInt16BE(port, 0)
    return Buffer.concat([ipBuf, portBuf])
  }))
}

/**
 * Also support this usage:
 *   string2compact.multi([ '10.10.10.5:128', '100.56.58.99:28525' ])
 *
 * for parallelism with the `compact2string` module.
 */
module.exports.multi = module.exports
module.exports.multi6 = module.exports

}).call(this,require("buffer").Buffer)

},{"addr-to-ip-port":3,"buffer":20,"ipaddr.js":44}],107:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":20}],108:[function(require,module,exports){
/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in      
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE.
*/

var base32 = require('./thirty-two');

exports.encode = base32.encode;
exports.decode = base32.decode;

},{"./thirty-two":109}],109:[function(require,module,exports){
(function (Buffer){
/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.                                                                   
*/

var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var byteTable = [
    0xff, 0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff
];

function quintetCount(buff) {
    var quintets = Math.floor(buff.length / 5);
    return buff.length % 5 == 0 ? quintets: quintets + 1;
}

exports.encode = function(plain) {
    if(!Buffer.isBuffer(plain)){
    	plain = new Buffer(plain);
    }
    var i = 0;
    var j = 0;
    var shiftIndex = 0;
    var digit = 0;
    var encoded = new Buffer(quintetCount(plain) * 8);

    /* byte by byte isn't as pretty as quintet by quintet but tests a bit
        faster. will have to revisit. */
    while(i < plain.length) {
        var current = plain[i];
    
        if(shiftIndex > 3) {
            digit = current & (0xff >> shiftIndex);
            shiftIndex = (shiftIndex + 5) % 8;
            digit = (digit << shiftIndex) | ((i + 1 < plain.length) ?
                plain[i + 1] : 0) >> (8 - shiftIndex);
            i++;
        } else {
            digit = (current >> (8 - (shiftIndex + 5))) & 0x1f;
            shiftIndex = (shiftIndex + 5) % 8;            
            if(shiftIndex == 0) i++;
        }
        
        encoded[j] = charTable.charCodeAt(digit);
        j++;
    }

    for(i = j; i < encoded.length; i++)
        encoded[i] = 0x3d; //'='.charCodeAt(0)
        
    return encoded;
};

exports.decode = function(encoded) {
    var shiftIndex = 0;
    var plainDigit = 0;
    var plainChar;
    var plainPos = 0;
    if(!Buffer.isBuffer(encoded)){
    	encoded = new Buffer(encoded);
    }
    var decoded = new Buffer(Math.ceil(encoded.length * 5 / 8));
    
    /* byte by byte isn't as pretty as octet by octet but tests a bit
        faster. will have to revisit. */    
    for(var i = 0; i < encoded.length; i++) {
    	if(encoded[i] == 0x3d){ //'='
    		break;
    	}
    		
        var encodedByte = encoded[i] - 0x30;
        
        if(encodedByte < byteTable.length) {
            plainDigit = byteTable[encodedByte];
            
            if(shiftIndex <= 3) {
                shiftIndex = (shiftIndex + 5) % 8;
                
                if(shiftIndex == 0) {
                    plainChar |= plainDigit;
                    decoded[plainPos] = plainChar;
                    plainPos++;
                    plainChar = 0;
                } else {
                    plainChar |= 0xff & (plainDigit << (8 - shiftIndex));
                }
            } else {
                shiftIndex = (shiftIndex + 5) % 8;
                plainChar |= 0xff & (plainDigit >>> shiftIndex);
                decoded[plainPos] = plainChar;
                plainPos++;

                plainChar = 0xff & (plainDigit << (8 - shiftIndex));
            }
        } else {
        	throw new Error('Invalid input - it is not base32 encoded string');
        }
    }
    return decoded.slice(0, plainPos);
};

}).call(this,require("buffer").Buffer)

},{"buffer":20}],110:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":20}],111:[function(require,module,exports){
(function (process){
module.exports = Discovery

var debug = require('debug')('torrent-discovery')
var DHT = require('bittorrent-dht/client') // empty object in browser
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var inherits = require('inherits')
var parallel = require('run-parallel')
var Tracker = require('bittorrent-tracker/client')

inherits(Discovery, EventEmitter)

function Discovery (opts) {
  var self = this
  if (!(self instanceof Discovery)) return new Discovery(opts)
  EventEmitter.call(self)

  if (!opts.peerId) throw new Error('Option `peerId` is required')
  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!process.browser && !opts.port) throw new Error('Option `port` is required')

  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : opts.peerId.toString('hex')
  self.infoHash = typeof opts.infoHash === 'string'
    ? opts.infoHash
    : opts.infoHash.toString('hex')
  self._port = opts.port // torrent port

  self.destroyed = false

  self._announce = opts.announce || []
  self._intervalMs = opts.intervalMs || (15 * 60 * 1000)
  self._trackerOpts = null
  self._dhtAnnouncing = false
  self._dhtTimeout = false
  self._internalDHT = false // is the DHT created internally?

  self._onWarning = function (err) {
    self.emit('warning', err)
  }
  self._onError = function (err) {
    self.emit('error', err)
  }
  self._onDHTPeer = function (peer, infoHash) {
    if (infoHash.toString('hex') !== self.infoHash) return
    self.emit('peer', peer.host + ':' + peer.port)
  }
  self._onTrackerPeer = function (peer) {
    self.emit('peer', peer)
  }
  self._onTrackerAnnounce = function () {
    self.emit('trackerAnnounce')
  }

  if (opts.tracker === false) {
    self.tracker = null
  } else if (opts.tracker && typeof opts.tracker === 'object') {
    self._trackerOpts = extend(opts.tracker)
    self.tracker = self._createTracker()
  } else {
    self.tracker = self._createTracker()
  }

  if (opts.dht === false || typeof DHT !== 'function') {
    self.dht = null
  } else if (opts.dht && typeof opts.dht.addNode === 'function') {
    self.dht = opts.dht
  } else if (opts.dht && typeof opts.dht === 'object') {
    self.dht = createDHT(opts.dhtPort, opts.dht)
  } else {
    self.dht = createDHT(opts.dhtPort)
  }

  if (self.dht) {
    self.dht.on('peer', self._onDHTPeer)
    self._dhtAnnounce()
  }

  function createDHT (port, opts) {
    var dht = new DHT(opts)
    dht.on('warning', self._onWarning)
    dht.on('error', self._onError)
    dht.listen(port)
    self._internalDHT = true
    return dht
  }
}

Discovery.prototype.updatePort = function (port) {
  var self = this
  if (port === self._port) return
  self._port = port

  if (self.dht) self._dhtAnnounce()

  if (self.tracker) {
    self.tracker.stop()
    self.tracker.destroy(function () {
      self.tracker = self._createTracker()
    })
  }
}

Discovery.prototype.destroy = function (cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true

  clearTimeout(self._dhtTimeout)

  var tasks = []

  if (self.tracker) {
    self.tracker.stop()
    self.tracker.removeListener('warning', self._onWarning)
    self.tracker.removeListener('error', self._onError)
    self.tracker.removeListener('peer', self._onTrackerPeer)
    self.tracker.removeListener('update', self._onTrackerAnnounce)
    tasks.push(function (cb) {
      self.tracker.destroy(cb)
    })
  }

  if (self.dht) {
    self.dht.removeListener('peer', self._onDHTPeer)
  }

  if (self._internalDHT) {
    self.dht.removeListener('warning', self._onWarning)
    self.dht.removeListener('error', self._onError)
    tasks.push(function (cb) {
      self.dht.destroy(cb)
    })
  }

  parallel(tasks, cb)

  // cleanup
  self.dht = null
  self.tracker = null
  self._announce = null
}

Discovery.prototype._createTracker = function () {
  var self = this

  var opts = extend(self._trackerOpts, {
    infoHash: self.infoHash,
    announce: self._announce,
    peerId: self.peerId,
    port: self._port
  })

  var tracker = new Tracker(opts)
  tracker.on('warning', self._onWarning)
  tracker.on('error', self._onError)
  tracker.on('peer', self._onTrackerPeer)
  tracker.on('update', self._onTrackerAnnounce)
  tracker.setInterval(self._intervalMs)
  tracker.start()
  return tracker
}

Discovery.prototype._dhtAnnounce = function () {
  var self = this
  if (self._dhtAnnouncing) return
  debug('dht announce')

  self._dhtAnnouncing = true
  clearTimeout(self._dhtTimeout)

  self.dht.announce(self.infoHash, self._port, function (err) {
    self._dhtAnnouncing = false
    debug('dht announce complete')

    if (err) self.emit('warning', err)
    self.emit('dhtAnnounce')

    if (!self.destroyed) {
      self._dhtTimeout = setTimeout(function () {
        self._dhtAnnounce()
      }, getRandomTimeout())
      if (self._dhtTimeout.unref) self._dhtTimeout.unref()
    }
  })

  // Returns timeout interval, with some random jitter
  function getRandomTimeout () {
    return self._intervalMs + Math.floor(Math.random() * self._intervalMs / 5)
  }
}

}).call(this,require('_process'))

},{"_process":73,"bittorrent-dht/client":17,"bittorrent-tracker/client":11,"debug":31,"events":35,"inherits":43,"run-parallel":90,"xtend":139}],112:[function(require,module,exports){
(function (Buffer){
module.exports = Piece

var BLOCK_LENGTH = 1 << 14

function Piece (length) {
  if (!(this instanceof Piece)) return new Piece(length)

  this.length = length
  this.missing = length
  this.sources = null

  this._chunks = Math.ceil(length / BLOCK_LENGTH)
  this._remainder = (length % BLOCK_LENGTH) || BLOCK_LENGTH
  this._buffered = 0
  this._buffer = null
  this._cancellations = null
  this._reservations = 0
  this._flushed = false
}

Piece.BLOCK_LENGTH = BLOCK_LENGTH

Piece.prototype.chunkLength = function (i) {
  return i === this._chunks - 1 ? this._remainder : BLOCK_LENGTH
}

Piece.prototype.chunkLengthRemaining = function (i) {
  return this.length - (i * BLOCK_LENGTH)
}

Piece.prototype.chunkOffset = function (i) {
  return i * BLOCK_LENGTH
}

Piece.prototype.reserve = function () {
  if (!this.init()) return -1
  if (this._cancellations.length) return this._cancellations.pop()
  if (this._reservations < this._chunks) return this._reservations++
  return -1
}

Piece.prototype.reserveRemaining = function () {
  if (!this.init()) return -1
  if (this._reservations < this._chunks) {
    var min = this._reservations
    this._reservations = this._chunks
    return min
  }
  return -1
}

Piece.prototype.cancel = function (i) {
  if (!this.init()) return
  this._cancellations.push(i)
}

Piece.prototype.cancelRemaining = function (i) {
  if (!this.init()) return
  this._reservations = i
}

Piece.prototype.get = function (i) {
  if (!this.init()) return null
  return this._buffer[i]
}

Piece.prototype.set = function (i, data, source) {
  if (!this.init()) return false
  var len = data.length
  var blocks = Math.ceil(len / BLOCK_LENGTH)
  for (var j = 0; j < blocks; j++) {
    if (!this._buffer[i + j]) {
      var offset = j * BLOCK_LENGTH
      var splitData = data.slice(offset, offset + BLOCK_LENGTH)
      this._buffered++
      this._buffer[i + j] = splitData
      this.missing -= splitData.length
      if (this.sources.indexOf(source) === -1) {
        this.sources.push(source)
      }
    }
  }
  return this._buffered === this._chunks
}

Piece.prototype.flush = function () {
  if (!this._buffer || this._chunks !== this._buffered) return null
  var buffer = Buffer.concat(this._buffer, this.length)
  this._buffer = null
  this._cancellations = null
  this.sources = null
  this._flushed = true
  return buffer
}

Piece.prototype.init = function () {
  if (this._flushed) return false
  if (this._buffer) return true
  this._buffer = new Array(this._chunks)
  this._cancellations = []
  this.sources = []
  return true
}

}).call(this,require("buffer").Buffer)

},{"buffer":20}],113:[function(require,module,exports){
(function (Buffer){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = require('is-typedarray').strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = new Buffer(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to the `Buffer` constructor
    return new Buffer(arr)
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"is-typedarray":48}],114:[function(require,module,exports){
(function (Buffer){
var UINT_32_MAX = 0xffffffff

exports.encodingLength = function () {
  return 8
}

exports.encode = function (num, buf, offset) {
  if (!buf) buf = new Buffer(8)
  if (!offset) offset = 0

  var top = Math.floor(num / UINT_32_MAX)
  var rem = num - top * UINT_32_MAX

  buf.writeUInt32BE(top, offset)
  buf.writeUInt32BE(rem, offset + 4)
  return buf
}

exports.decode = function (buf, offset) {
  if (!offset) offset = 0

  if (!buf) buf = new Buffer(4)
  if (!offset) offset = 0

  var top = buf.readUInt32BE(offset)
  var rem = buf.readUInt32BE(offset + 4)

  return top * UINT_32_MAX + rem
}

exports.encode.bytes = 8
exports.decode.bytes = 8

}).call(this,require("buffer").Buffer)

},{"buffer":20}],115:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],116:[function(require,module,exports){
module.exports = remove

function remove (arr, i) {
  if (i >= arr.length || i < 0) return
  var last = arr.pop()
  if (i < arr.length) {
    var tmp = arr[i]
    arr[i] = last
    return tmp
  }
  return last
}

},{}],117:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":118,"punycode":75,"querystring":78}],118:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],119:[function(require,module,exports){
var bencode = require('bencode')
var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('ut_metadata')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var sha1 = require('simple-sha1')

var MAX_METADATA_SIZE = 10000000 // 10MB
var BITFIELD_GROW = 1000
var PIECE_LENGTH = 16 * 1024

module.exports = function (metadata) {
  inherits(utMetadata, EventEmitter)

  function utMetadata (wire) {
    EventEmitter.call(this)

    this._wire = wire

    this._metadataComplete = false
    this._metadataSize = null
    this._remainingRejects = null // how many reject messages to tolerate before quitting
    this._fetching = false

    // The largest .torrent file that I know of is ~1-2MB, which is ~100 pieces.
    // Therefore, cap the bitfield to 10x that (1000 pieces) so a malicious peer can't
    // make it grow to fill all memory.
    this._bitfield = new BitField(0, { grow: BITFIELD_GROW })

    if (Buffer.isBuffer(metadata)) {
      this.setMetadata(metadata)
    }
  }

  // Name of the bittorrent-protocol extension
  utMetadata.prototype.name = 'ut_metadata'

  utMetadata.prototype.onHandshake = function (infoHash, peerId, extensions) {
    this._infoHash = infoHash
  }

  utMetadata.prototype.onExtendedHandshake = function (handshake) {
    if (!handshake.m || !handshake.m.ut_metadata) {
      return this.emit('warning', new Error('Peer does not support ut_metadata'))
    }
    if (!handshake.metadata_size) {
      return this.emit('warning', new Error('Peer does not have metadata'))
    }
    if (typeof handshake.metadata_size !== 'number' ||
        MAX_METADATA_SIZE < handshake.metadata_size ||
        handshake.metadata_size <= 0) {
      return this.emit('warning', new Error('Peer gave invalid metadata size'))
    }

    this._metadataSize = handshake.metadata_size
    this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH)
    this._remainingRejects = this._numPieces * 2

    if (this._fetching) {
      this._requestPieces()
    }
  }

  utMetadata.prototype.onMessage = function (buf) {
    var dict, trailer
    try {
      var str = buf.toString()
      var trailerIndex = str.indexOf('ee') + 2
      dict = bencode.decode(str.substring(0, trailerIndex))
      trailer = buf.slice(trailerIndex)
    } catch (err) {
      // drop invalid messages
      return
    }

    switch (dict.msg_type) {
      case 0:
        // ut_metadata request (from peer)
        // example: { 'msg_type': 0, 'piece': 0 }
        this._onRequest(dict.piece)
        break
      case 1:
        // ut_metadata data (in response to our request)
        // example: { 'msg_type': 1, 'piece': 0, 'total_size': 3425 }
        this._onData(dict.piece, trailer, dict.total_size)
        break
      case 2:
        // ut_metadata reject (peer doesn't have piece we requested)
        // { 'msg_type': 2, 'piece': 0 }
        this._onReject(dict.piece)
        break
    }
  }

  /**
   * Ask the peer to send metadata.
   * @public
   */
  utMetadata.prototype.fetch = function () {
    if (this._metadataComplete) {
      return
    }
    this._fetching = true
    if (this._metadataSize) {
      this._requestPieces()
    }
  }

  /**
   * Stop asking the peer to send metadata.
   * @public
   */
  utMetadata.prototype.cancel = function () {
    this._fetching = false
  }

  utMetadata.prototype.setMetadata = function (metadata) {
    if (this._metadataComplete) return true
    debug('set metadata')

    // if full torrent dictionary was passed in, pull out just `info` key
    try {
      var info = bencode.decode(metadata).info
      if (info) {
        metadata = bencode.encode(info)
      }
    } catch (err) {}

    // check hash
    if (this._infoHash && this._infoHash !== sha1.sync(metadata)) {
      return false
    }

    this.cancel()

    this.metadata = metadata
    this._metadataComplete = true
    this._metadataSize = this.metadata.length
    this._wire.extendedHandshake.metadata_size = this._metadataSize

    this.emit('metadata', bencode.encode({ info: bencode.decode(this.metadata) }))

    return true
  }

  utMetadata.prototype._send = function (dict, trailer) {
    var buf = bencode.encode(dict)
    if (Buffer.isBuffer(trailer)) {
      buf = Buffer.concat([buf, trailer])
    }
    this._wire.extended('ut_metadata', buf)
  }

  utMetadata.prototype._request = function (piece) {
    this._send({ msg_type: 0, piece: piece })
  }

  utMetadata.prototype._data = function (piece, buf, totalSize) {
    var msg = { msg_type: 1, piece: piece }
    if (typeof totalSize === 'number') {
      msg.total_size = totalSize
    }
    this._send(msg, buf)
  }

  utMetadata.prototype._reject = function (piece) {
    this._send({ msg_type: 2, piece: piece })
  }

  utMetadata.prototype._onRequest = function (piece) {
    if (!this._metadataComplete) {
      this._reject(piece)
      return
    }
    var start = piece * PIECE_LENGTH
    var end = start + PIECE_LENGTH
    if (end > this._metadataSize) {
      end = this._metadataSize
    }
    var buf = this.metadata.slice(start, end)
    this._data(piece, buf, this._metadataSize)
  }

  utMetadata.prototype._onData = function (piece, buf, totalSize) {
    if (buf.length > PIECE_LENGTH) {
      return
    }
    buf.copy(this.metadata, piece * PIECE_LENGTH)
    this._bitfield.set(piece)
    this._checkDone()
  }

  utMetadata.prototype._onReject = function (piece) {
    if (this._remainingRejects > 0 && this._fetching) {
      // If we haven't been rejected too much, then try to request the piece again
      this._request(piece)
      this._remainingRejects -= 1
    } else {
      this.emit('warning', new Error('Peer sent "reject" too much'))
    }
  }

  utMetadata.prototype._requestPieces = function () {
    this.metadata = Buffer.alloc(this._metadataSize)
    for (var piece = 0; piece < this._numPieces; piece++) {
      this._request(piece)
    }
  }

  utMetadata.prototype._checkDone = function () {
    var done = true
    for (var piece = 0; piece < this._numPieces; piece++) {
      if (!this._bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) return

    // attempt to set metadata -- may fail sha1 check
    var success = this.setMetadata(this.metadata)

    if (!success) {
      this._failedMetadata()
    }
  }

  utMetadata.prototype._failedMetadata = function () {
    // reset bitfield & try again
    this._bitfield = new BitField(0, { grow: BITFIELD_GROW })
    this._remainingRejects -= this._numPieces
    if (this._remainingRejects > 0) {
      this._requestPieces()
    } else {
      this.emit('warning', new Error('Peer sent invalid metadata'))
    }
  }

  return utMetadata
}

},{"bencode":7,"bitfield":9,"debug":31,"events":35,"inherits":43,"safe-buffer":92,"simple-sha1":96}],120:[function(require,module,exports){
(function (Buffer){
/* jshint camelcase: false */

// TODO: ipv6 support
// TODO: parse and send peer flags (currently unused)
// NOTE: addPeer should take in an optional second argument, flags
// TODO: destroy wire if peer sends PEX messages too frequently

var EventEmitter = require('events').EventEmitter
var compact2string = require('compact2string')
var string2compact = require('string2compact')
var bencode = require('bencode')
var inherits = require('inherits')

var PEX_INTERVAL = 65000 // just over one minute
var PEX_MAX_PEERS = 50    // max number of peers to advertise per PEX message

module.exports = function () {
  inherits(ut_pex, EventEmitter)

  function ut_pex (wire) {
    var self = this
    EventEmitter.call(self)

    self._wire = wire
    self._intervalId = null

    self.reset()
  }

  ut_pex.prototype.name = 'ut_pex'

  /**
   * Start sending regular PEX updates to remote peer.
   */
  ut_pex.prototype.start = function () {
    var self = this
    clearInterval(self._intervalId)
    self._intervalId = setInterval(self._sendMessage.bind(self), PEX_INTERVAL)
    if (self._intervalId.unref) self._intervalId.unref()
  }

  /**
   * Stop sending PEX updates to the remote peer.
   */
  ut_pex.prototype.stop = function () {
    var self = this
    clearInterval(self._intervalId)
    self._intervalId = null
  }

  /**
   * Stops sending updates to the remote peer and resets internal state of peers seen.
   */
  ut_pex.prototype.reset = function () {
    var self = this
    self._remoteAddedPeers = {}
    self._remoteDroppedPeers = {}
    self._localAddedPeers = {}
    self._localDroppedPeers = {}
    self.stop()
  }

  /**
   * Adds a peer to the locally discovered peer list for the next PEX message.
   */
  ut_pex.prototype.addPeer = function (peer) {
    var self = this
    if (peer.indexOf(':') < 0) return // disregard invalid peers
    if (peer in self._remoteAddedPeers) return // never advertise peer the remote wire already sent us
    if (peer in self._localDroppedPeers) delete self._localDroppedPeers[peer]
    self._localAddedPeers[peer] = true
  }

  /**
   * Adds a peer to the locally dropped peer list for the next PEX message.
   */
  ut_pex.prototype.dropPeer = function (peer) {
    var self = this
    if (peer.indexOf(':') < 0) return // disregard invalid peers
    if (peer in self._remoteDroppedPeers) return // never advertise peer the remote wire already sent us
    if (peer in self._localAddedPeers) delete self._localAddedPeers[peer]
    self._localDroppedPeers[peer] = true
  }

  ut_pex.prototype.onExtendedHandshake = function (handshake) {
    var self = this
    if (!handshake.m || !handshake.m.ut_pex) {
      return self.emit('warning', new Error('Peer does not support ut_pex'))
    }
  }

  /**
   * PEX messages are bencoded dictionaries with the following keys:
   * 'added'     : array of peers met since last PEX message
   * 'added.f'   : array of flags per peer
   *  '0x01'     : peer prefers encryption
   *  '0x02'     : peer is seeder
   * 'dropped'   : array of peers locally dropped from swarm since last PEX message
   * 'added6'    : ipv6 version of 'added'
   * 'added6.f'  : ipv6 version of 'added.f'
   * 'dropped.f' : ipv6 version of 'dropped'
   *
   * @param {Buffer} buf bencoded PEX dictionary
   */
  ut_pex.prototype.onMessage = function (buf) {
    var self = this
    var message

    try {
      message = bencode.decode(buf)
    } catch (err) {
      // drop invalid messages
      return
    }

    if (message.added) {
      compact2string.multi(message.added).forEach(function (peer) {
        delete self._remoteDroppedPeers[peer]
        if (!(peer in self._remoteAddedPeers)) {
          self._remoteAddedPeers[peer] = true
          self.emit('peer', peer)
        }
      })
    }

    if (message.dropped) {
      compact2string.multi(message.dropped).forEach(function (peer) {
        delete self._remoteAddedPeers[peer]
        if (!(peer in self._remoteDroppedPeers)) {
          self._remoteDroppedPeers[peer] = true
          self.emit('dropped', peer)
        }
      })
    }
  }

  /**
   * Sends a PEX message to the remote peer including information about any locally
   * added / dropped peers.
   */
  ut_pex.prototype._sendMessage = function () {
    var self = this

    var localAdded = Object.keys(self._localAddedPeers).slice(0, PEX_MAX_PEERS)
    var localDropped = Object.keys(self._localDroppedPeers).slice(0, PEX_MAX_PEERS)

    var added = Buffer.concat(localAdded.map(string2compact))
    var dropped = Buffer.concat(localDropped.map(string2compact))

    var addedFlags = Buffer.concat(localAdded.map(function () {
      // TODO: support flags
      return new Buffer([0])
    }))

    // update local deltas
    localAdded.forEach(function (peer) { delete self._localAddedPeers[peer] })
    localDropped.forEach(function (peer) { delete self._localDroppedPeers[peer] })

    // send PEX message
    self._wire.extended('ut_pex', {
      'added': added,
      'added.f': addedFlags,
      'dropped': dropped,
      'added6': new Buffer(0),
      'added6.f': new Buffer(0),
      'dropped6': new Buffer(0)
    })
  }

  return ut_pex
}

}).call(this,require("buffer").Buffer)

},{"bencode":121,"buffer":20,"compact2string":24,"events":35,"inherits":43,"string2compact":106}],121:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./lib/decode":122,"./lib/encode":124,"dup":27}],122:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":123,"buffer":20}],123:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],124:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],125:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],126:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],127:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":126,"_process":73,"inherits":43}],128:[function(require,module,exports){
(function (Buffer){
var bs = require('binary-search')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var mp4 = require('mp4-stream')
var Box = require('mp4-box-encoding')
var RangeSliceStream = require('range-slice-stream')

module.exports = MP4Remuxer

function MP4Remuxer (file) {
	var self = this
	EventEmitter.call(self)
	self._tracks = []
	self._fragmentSequence = 1
	self._file = file
	self._decoder = null
	self._findMoov(0)
}

inherits(MP4Remuxer, EventEmitter)

MP4Remuxer.prototype._findMoov = function (offset) {
	var self = this

	if (self._decoder) {
		self._decoder.destroy()
	}

	self._decoder = mp4.decode()
	var fileStream = self._file.createReadStream({
		start: offset
	})
	fileStream.pipe(self._decoder)

	self._decoder.once('box', function (headers) {
		if (headers.type === 'moov') {
			self._decoder.decode(function (moov) {
				fileStream.destroy()
				try {
					self._processMoov(moov)
				} catch (err) {
					err.message = 'Cannot parse mp4 file: ' + err.message
					self.emit('error', err)
				}
			})
		} else {
			fileStream.destroy()
			self._findMoov(offset + headers.length)
		}
	})
}

function RunLengthIndex (entries, countName) {
	var self = this
	self._entries = entries
	self._countName = countName || 'count'
	self._index = 0
	self._offset = 0

	self.value = self._entries[0]
}

RunLengthIndex.prototype.inc = function () {
	var self = this
	self._offset++
	if (self._offset >= self._entries[self._index][self._countName]) {
		self._index++
		self._offset = 0
	}

	self.value = self._entries[self._index]
}

MP4Remuxer.prototype._processMoov = function (moov) {
	var self = this

	var traks = moov.traks
	self._tracks = []
	self._hasVideo = false
	self._hasAudio = false
	for (var i = 0; i < traks.length; i++) {
		var trak = traks[i]
		var stbl = trak.mdia.minf.stbl
		var stsdEntry = stbl.stsd.entries[0]
		var handlerType = trak.mdia.hdlr.handlerType
		var codec
		var mime
		if (handlerType === 'vide' && stsdEntry.type === 'avc1') {
			if (self._hasVideo) {
				continue
			}
			self._hasVideo = true
			codec = 'avc1'
			if (stsdEntry.avcC) {
				codec += '.' + stsdEntry.avcC.mimeCodec
			}
			mime = 'video/mp4; codecs="' + codec + '"'
		} else if (handlerType === 'soun' && stsdEntry.type === 'mp4a') {
			if (self._hasAudio) {
				continue
			}
			self._hasAudio = true
			codec = 'mp4a'
			if (stsdEntry.esds && stsdEntry.esds.mimeCodec) {
				codec += '.' + stsdEntry.esds.mimeCodec
			}
			mime = 'audio/mp4; codecs="' + codec + '"'
		} else {
			continue
		}

		var samples = []
		var sample = 0

		// Chunk/position data
		var sampleInChunk = 0
		var chunk = 0
		var offsetInChunk = 0
		var sampleToChunkIndex = 0

		// Time data
		var dts = 0
		var decodingTimeEntry = new RunLengthIndex(stbl.stts.entries)
		var presentationOffsetEntry = null
		if (stbl.ctts) {
			presentationOffsetEntry = new RunLengthIndex(stbl.ctts.entries)
		}

		// Sync table index
		var syncSampleIndex = 0

		while (true) {
			var currChunkEntry = stbl.stsc.entries[sampleToChunkIndex]

			// Compute size
			var size = stbl.stsz.entries[sample]

			// Compute time data
			var duration = decodingTimeEntry.value.duration
			var presentationOffset = presentationOffsetEntry ? presentationOffsetEntry.value.compositionOffset : 0

			// Compute sync
			var sync = true
			if (stbl.stss) {
				sync = stbl.stss.entries[syncSampleIndex] === sample + 1
			}

			// Create new sample entry
			samples.push({
				size: size,
				duration: duration,
				dts: dts,
				presentationOffset: presentationOffset,
				sync: sync,
				offset: offsetInChunk + stbl.stco.entries[chunk]
			})

			// Go to next sample
			sample++
			if (sample >= stbl.stsz.entries.length) {
				break
			}

			// Move position/chunk
			sampleInChunk++
			offsetInChunk += size
			if (sampleInChunk >= currChunkEntry.samplesPerChunk) {
				// Move to new chunk
				sampleInChunk = 0
				offsetInChunk = 0
				chunk++
				// Move sample to chunk box index
				var nextChunkEntry = stbl.stsc.entries[sampleToChunkIndex + 1]
				if (nextChunkEntry && chunk + 1 >= nextChunkEntry.firstChunk) {
					sampleToChunkIndex++
				}
			}

			// Move time forward
			dts += duration
			decodingTimeEntry.inc()
			presentationOffsetEntry && presentationOffsetEntry.inc()

			// Move sync table index
			if (sync) {
				syncSampleIndex++
			}
		}

		trak.mdia.mdhd.duration = 0
		trak.tkhd.duration = 0

		var defaultSampleDescriptionIndex = currChunkEntry.sampleDescriptionId

		var trackMoov = {
			type: 'moov',
			mvhd: moov.mvhd,
			traks: [{
				tkhd: trak.tkhd,
				mdia: {
					mdhd: trak.mdia.mdhd,
					hdlr: trak.mdia.hdlr,
					elng: trak.mdia.elng,
					minf: {
						vmhd: trak.mdia.minf.vmhd,
						smhd: trak.mdia.minf.smhd,
						dinf: trak.mdia.minf.dinf,
						stbl: {
							stsd: stbl.stsd,
							stts: empty(),
							ctts: empty(),
							stsc: empty(),
							stsz: empty(),
							stco: empty(),
							stss: empty()
						}
					}
				}
			}],
			mvex: {
				mehd: {
					fragmentDuration: moov.mvhd.duration
				},
				trexs: [{
					trackId: trak.tkhd.trackId,
					defaultSampleDescriptionIndex: defaultSampleDescriptionIndex,
					defaultSampleDuration: 0,
					defaultSampleSize: 0,
					defaultSampleFlags: 0
				}]
			}
		}

		self._tracks.push({
			trackId: trak.tkhd.trackId,
			timeScale: trak.mdia.mdhd.timeScale,
			samples: samples,
			currSample: null,
			currTime: null,
			moov: trackMoov,
			mime: mime
		})
	}

	if (self._tracks.length === 0) {
		self.emit('error', new Error('no playable tracks'))
		return
	}

	// Must be set last since this is used above
	moov.mvhd.duration = 0

	self._ftyp = {
		type: 'ftyp',
		brand: 'iso5',
		brandVersion: 0,
		compatibleBrands: [
			'iso5'
		]
	}

	var ftypBuf = Box.encode(self._ftyp)
	var data = self._tracks.map(function (track) {
		var moovBuf = Box.encode(track.moov)
		return {
			mime: track.mime,
			init: Buffer.concat([ftypBuf, moovBuf])
		}
	})

	self.emit('ready', data)
}

function empty () {
	return {
		version: 0,
		flags: 0,
		entries: []
	}
}

MP4Remuxer.prototype.seek = function (time) {
	var self = this
	if (!self._tracks) {
		throw new Error('Not ready yet; wait for \'ready\' event')
	}

	if (self._fileStream) {
		self._fileStream.destroy()
		self._fileStream = null
	}

	var startOffset = -1
	self._tracks.map(function (track, i) {
		// find the keyframe before the time
		// stream from there
		if (track.outStream) {
			track.outStream.destroy()
		}
		if (track.inStream) {
			track.inStream.destroy()
			track.inStream = null
		}
		var outStream = track.outStream = mp4.encode()
		var fragment = self._generateFragment(i, time)
		if (!fragment) {
			return outStream.finalize()
		}

		if (startOffset === -1 || fragment.ranges[0].start < startOffset) {
			startOffset = fragment.ranges[0].start
		}

		writeFragment(fragment)

		function writeFragment (frag) {
			if (outStream.destroyed) return
			outStream.box(frag.moof, function (err) {
				if (err) return self.emit('error', err)
				if (outStream.destroyed) return
				var slicedStream = track.inStream.slice(frag.ranges)
				slicedStream.pipe(outStream.mediaData(frag.length, function (err) {
					if (err) return self.emit('error', err)
					if (outStream.destroyed) return
					var nextFrag = self._generateFragment(i)
					if (!nextFrag) {
						return outStream.finalize()
					}
					writeFragment(nextFrag)
				}))
			})
		}
	})

	if (startOffset >= 0) {
		var fileStream = self._fileStream = self._file.createReadStream({
			start: startOffset
		})

		self._tracks.forEach(function (track) {
			track.inStream = new RangeSliceStream(startOffset)
			fileStream.pipe(track.inStream)
		})
	}

	return self._tracks.map(function (track) {
		return track.outStream
	})
}

MP4Remuxer.prototype._findSampleBefore = function (trackInd, time) {
	var self = this

	var track = self._tracks[trackInd]
	var scaledTime = Math.floor(track.timeScale * time)
	var sample = bs(track.samples, scaledTime, function (sample, t) {
		var pts = sample.dts + sample.presentationOffset// - track.editShift
		return pts - t
	})
	if (sample === -1) {
		sample = 0
	} else if (sample < 0) {
		sample = -sample - 2
	}
	// sample is now the last sample with dts <= time
	// Find the preceeding sync sample
	while (!track.samples[sample].sync) {
		sample--
	}
	return sample
}

var MIN_FRAGMENT_DURATION = 1 // second

MP4Remuxer.prototype._generateFragment = function (track, time) {
	var self = this
	/*
	1. Find correct sample
	2. Process backward until sync sample found
	3. Process forward until next sync sample after MIN_FRAGMENT_DURATION found
	*/
	var currTrack = self._tracks[track]
	var firstSample
	if (time !== undefined) {
		firstSample = self._findSampleBefore(track, time)
	} else {
		firstSample = currTrack.currSample
	}

	if (firstSample >= currTrack.samples.length)
		return null

	var startDts = currTrack.samples[firstSample].dts

	var totalLen = 0
	var ranges = []
	for (var currSample = firstSample; currSample < currTrack.samples.length; currSample++) {
		var sample = currTrack.samples[currSample]
		if (sample.sync && sample.dts - startDts >= currTrack.timeScale * MIN_FRAGMENT_DURATION) {
			break // This is a reasonable place to end the fragment
		}

		totalLen += sample.size
		var currRange = ranges.length - 1
		if (currRange < 0 || ranges[currRange].end !== sample.offset) {
			// Push a new range
			ranges.push({
				start: sample.offset,
				end: sample.offset + sample.size
			})
		} else {
			ranges[currRange].end += sample.size
		}
	}

	currTrack.currSample = currSample

	return {
		moof: self._generateMoof(track, firstSample, currSample),
		ranges: ranges,
		length: totalLen
	}
}

MP4Remuxer.prototype._generateMoof = function (track, firstSample, lastSample) {
	var self = this

	var currTrack = self._tracks[track]

	var entries = []
	for (var j = firstSample; j < lastSample; j++) {
		var currSample = currTrack.samples[j]
		entries.push({
			sampleDuration: currSample.duration,
			sampleSize: currSample.size,
			sampleFlags: currSample.sync ? 0x2000000 : 0x1010000,
			sampleCompositionTimeOffset: currSample.presentationOffset
		})
	}

	var moof = {
		type: 'moof',
		mfhd: {
			sequenceNumber: self._fragmentSequence++
		},
		trafs: [{
			tfhd: {
				flags: 0x20000, // default-base-is-moof
				trackId: currTrack.trackId
			},
			tfdt: {
				baseMediaDecodeTime: currTrack.samples[firstSample].dts
			},
			trun: {
				flags: 0xf01,
				dataOffset: 8, // The moof size has to be added to this later as well
				entries: entries
			}
		}]
	}

	// Update the offset
	moof.trafs[0].trun.dataOffset += Box.encodingLength(moof)

	return moof
}

}).call(this,require("buffer").Buffer)

},{"binary-search":8,"buffer":20,"events":35,"inherits":43,"mp4-box-encoding":56,"mp4-stream":59,"range-slice-stream":80}],129:[function(require,module,exports){
var MediaElementWrapper = require('mediasource')
var pump = require('pump')

var MP4Remuxer = require('./mp4-remuxer')

module.exports = VideoStream

function VideoStream (file, mediaElem, opts) {
	var self = this
	if (!(this instanceof VideoStream)) return new VideoStream(file, mediaElem, opts)
	opts = opts || {}

	self._elem = mediaElem
	self._elemWrapper = new MediaElementWrapper(mediaElem)
	self._waitingFired = false
	self._trackMeta = null
	self._file = file
	self._tracks = null
	if (self._elem.preload !== 'none') {
		self._createMuxer()
	}

	self._onError = function (err) {
		self.destroy() // don't pass err though so the user doesn't need to listen for errors
	}
	self._onWaiting = function () {
		self._waitingFired = true
		if (!self._muxer) {
			self._createMuxer()
		} else if (self._tracks) {
			self._pump()
		}
	}
	self._elem.addEventListener('waiting', self._onWaiting)
	self._elem.addEventListener('error', self._onError)
}

VideoStream.prototype._createMuxer = function () {
	var self = this
	self._muxer = new MP4Remuxer(self._file)
	self._muxer.on('ready', function (data) {
		self._tracks = data.map(function (trackData) {
			var mediaSource = self._elemWrapper.createWriteStream(trackData.mime)
			mediaSource.on('error', function (err) {
				self._elemWrapper.error(err)
			})
			mediaSource.write(trackData.init)
			return {
				muxed: null,
				mediaSource: mediaSource
			}
		})

		if (self._waitingFired || self._elem.preload === 'auto') {
			self._pump()
		}
	})

	self._muxer.on('error', function (err) {
		self._elemWrapper.error(err)
	})
}

VideoStream.prototype._pump = function () {
	var self = this

	var muxed = self._muxer.seek(self._elem.currentTime, !self._tracks)

	self._tracks.forEach(function (track, i) {
		if (track.muxed) {
			track.muxed.destroy()
			track.mediaSource = self._elemWrapper.createWriteStream(track.mediaSource)
			track.mediaSource.on('error', function (err) {
				self._elemWrapper.error(err)
			})
		}
		track.muxed = muxed[i]
		pump(track.muxed, track.mediaSource)
	})
}

VideoStream.prototype.destroy = function () {
	var self = this
	if (self.destroyed) {
		return
	}
	self.destroyed = true

	self._elem.removeEventListener('waiting', self._onWaiting)
	self._elem.removeEventListener('error', self._onError)

	if (self._tracks) {
		self._tracks.forEach(function (track) {
			track.muxed.destroy()
		})
	}

	self._elem.src = ''
}

},{"./mp4-remuxer":128,"mediasource":52,"pump":74}],130:[function(require,module,exports){
(function (process,global){
module.exports = WebTorrent

var Buffer = require('safe-buffer').Buffer
var concat = require('simple-concat')
var createTorrent = require('create-torrent')
var debug = require('debug')('webtorrent')
var DHT = require('bittorrent-dht/client') // browser exclude
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var loadIPSet = require('load-ip-set') // browser exclude
var parallel = require('run-parallel')
var parseTorrent = require('parse-torrent')
var path = require('path')
var Peer = require('simple-peer')
var speedometer = require('speedometer')
var zeroFill = require('zero-fill')

var TCPPool = require('./lib/tcp-pool') // browser exclude
var Torrent = require('./lib/torrent')

/**
 * WebTorrent version.
 */
var VERSION = require('./package.json').version

/**
 * Version number in Azureus-style. Generated from major and minor semver version.
 * For example:
 *   '0.16.1' -> '0016'
 *   '1.2.5' -> '0102'
 */
var VERSION_STR = VERSION.match(/([0-9]+)/g).slice(0, 2).map(zeroFill(2)).join('')

/**
 * Version prefix string (used in peer ID). WebTorrent uses the Azureus-style
 * encoding: '-', two characters for client id ('WW'), four ascii digits for version
 * number, '-', followed by random numbers.
 * For example:
 *   '-WW0102-'...
 */
var VERSION_PREFIX = '-WW' + VERSION_STR + '-'

inherits(WebTorrent, EventEmitter)

/**
 * WebTorrent Client
 * @param {Object=} opts
 */
function WebTorrent (opts) {
  var self = this
  if (!(self instanceof WebTorrent)) return new WebTorrent(opts)
  EventEmitter.call(self)

  if (!opts) opts = {}

  if (typeof opts.peerId === 'string') {
    self.peerId = opts.peerId
  } else if (Buffer.isBuffer(opts.peerId)) {
    self.peerId = opts.peerId.toString('hex')
  } else {
    self.peerId = Buffer.from(VERSION_PREFIX + hat(48))
  }
  self.peerIdBuffer = Buffer.from(self.peerId, 'hex')

  if (typeof opts.nodeId === 'string') {
    self.nodeId = opts.nodeId
  } else if (Buffer.isBuffer(opts.nodeId)) {
    self.nodeId = opts.nodeId.toString('hex')
  } else {
    self.nodeId = hat(160)
  }
  self.nodeIdBuffer = Buffer.from(self.nodeId, 'hex')

  self.destroyed = false
  self.listening = false
  self.torrentPort = opts.torrentPort || 0
  self.dhtPort = opts.dhtPort || 0
  self.tracker = opts.tracker !== undefined ? opts.tracker : {}
  self.torrents = []
  self.maxConns = Number(opts.maxConns) || 55

  if (self.tracker) {
    if (typeof self.tracker !== 'object') self.tracker = {}
    if (opts.rtcConfig) {
      // TODO: remove in v1
      console.warn('WebTorrent: opts.rtcConfig is deprecated. Use opts.tracker.rtcConfig instead')
      self.tracker.rtcConfig = opts.rtcConfig
    }
    if (opts.wrtc) {
      // TODO: remove in v1
      console.warn('WebTorrent: opts.wrtc is deprecated. Use opts.tracker.wrtc instead')
      self.tracker.wrtc = opts.wrtc // to support `webtorrent-hybrid` package
    }
    if (global.WRTC && !self.tracker.wrtc) self.tracker.wrtc = global.WRTC
  }

  if (typeof TCPPool === 'function') {
    self._tcpPool = new TCPPool(self)
  } else {
    process.nextTick(function () {
      self._onListening()
    })
  }

  // stats
  self._downloadSpeed = speedometer()
  self._uploadSpeed = speedometer()

  if (opts.dht !== false && typeof DHT === 'function' /* browser exclude */) {
    // use a single DHT instance for all torrents, so the routing table can be reused
    self.dht = new DHT(extend({ nodeId: self.nodeId }, opts.dht))

    self.dht.once('error', function (err) {
      self._destroy(err)
    })

    self.dht.once('listening', function () {
      var address = self.dht.address()
      if (address) self.dhtPort = address.port
    })

    // Ignore warning when there are > 10 torrents in the client
    self.dht.setMaxListeners(0)

    self.dht.listen(self.dhtPort)
  } else {
    self.dht = false
  }

  debug('new webtorrent (peerId %s, nodeId %s)', self.peerId, self.nodeId)

  if (typeof loadIPSet === 'function') {
    loadIPSet(opts.blocklist, {
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)'
      }
    }, function (err, ipSet) {
      if (err) return self.error('Failed to load blocklist: ' + err.message)
      self.blocked = ipSet
      ready()
    })
  } else process.nextTick(ready)

  function ready () {
    if (self.destroyed) return
    self.ready = true
    self.emit('ready')
  }
}

WebTorrent.WEBRTC_SUPPORT = Peer.WEBRTC_SUPPORT

Object.defineProperty(WebTorrent.prototype, 'downloadSpeed', {
  get: function () { return this._downloadSpeed() }
})

Object.defineProperty(WebTorrent.prototype, 'uploadSpeed', {
  get: function () { return this._uploadSpeed() }
})

Object.defineProperty(WebTorrent.prototype, 'progress', {
  get: function () {
    var torrents = this.torrents.filter(function (torrent) {
      return torrent.progress !== 1
    })
    var downloaded = torrents.reduce(function (total, torrent) {
      return total + torrent.downloaded
    }, 0)
    var length = torrents.reduce(function (total, torrent) {
      return total + (torrent.length || 0)
    }, 0) || 1
    return downloaded / length
  }
})

Object.defineProperty(WebTorrent.prototype, 'ratio', {
  get: function () {
    var uploaded = this.torrents.reduce(function (total, torrent) {
      return total + torrent.uploaded
    }, 0)
    var received = this.torrents.reduce(function (total, torrent) {
      return total + torrent.received
    }, 0) || 1
    return uploaded / received
  }
})

/**
 * Returns the torrent with the given `torrentId`. Convenience method. Easier than
 * searching through the `client.torrents` array. Returns `null` if no matching torrent
 * found.
 *
 * @param  {string|Buffer|Object|Torrent} torrentId
 * @return {Torrent|null}
 */
WebTorrent.prototype.get = function (torrentId) {
  var self = this
  var i, torrent
  var len = self.torrents.length

  if (torrentId instanceof Torrent) {
    for (i = 0; i < len; i++) {
      torrent = self.torrents[i]
      if (torrent === torrentId) return torrent
    }
  } else {
    var parsed
    try { parsed = parseTorrent(torrentId) } catch (err) {}

    if (!parsed) return null
    if (!parsed.infoHash) throw new Error('Invalid torrent identifier')

    for (i = 0; i < len; i++) {
      torrent = self.torrents[i]
      if (torrent.infoHash === parsed.infoHash) return torrent
    }
  }
  return null
}

// TODO: remove in v1
WebTorrent.prototype.download = function (torrentId, opts, ontorrent) {
  console.warn('WebTorrent: client.download() is deprecated. Use client.add() instead')
  return this.add(torrentId, opts, ontorrent)
}

/**
 * Start downloading a new torrent. Aliased as `client.download`.
 * @param {string|Buffer|Object} torrentId
 * @param {Object} opts torrent-specific options
 * @param {function=} ontorrent called when the torrent is ready (has metadata)
 */
WebTorrent.prototype.add = function (torrentId, opts, ontorrent) {
  var self = this
  if (self.destroyed) throw new Error('client is destroyed')
  if (typeof opts === 'function') return self.add(torrentId, null, opts)

  debug('add')
  opts = opts ? extend(opts) : {}

  var torrent = new Torrent(torrentId, self, opts)
  self.torrents.push(torrent)

  torrent.once('_infoHash', onInfoHash)
  torrent.once('ready', onReady)
  torrent.once('close', onClose)

  function onInfoHash () {
    if (self.destroyed) return
    for (var i = 0, len = self.torrents.length; i < len; i++) {
      var t = self.torrents[i]
      if (t.infoHash === torrent.infoHash && t !== torrent) {
        torrent._destroy(new Error('Cannot add duplicate torrent ' + torrent.infoHash))
        return
      }
    }
  }

  function onReady () {
    if (self.destroyed) return
    if (typeof ontorrent === 'function') ontorrent(torrent)
    self.emit('torrent', torrent)
  }

  function onClose () {
    torrent.removeListener('_infoHash', onInfoHash)
    torrent.removeListener('ready', onReady)
    torrent.removeListener('close', onClose)
  }

  return torrent
}

/**
 * Start seeding a new file/folder.
 * @param  {string|File|FileList|Buffer|Array.<string|File|Buffer>} input
 * @param  {Object=} opts
 * @param  {function=} onseed called when torrent is seeding
 */
WebTorrent.prototype.seed = function (input, opts, onseed) {
  var self = this
  if (self.destroyed) throw new Error('client is destroyed')
  if (typeof opts === 'function') return self.seed(input, null, opts)

  debug('seed')
  opts = opts ? extend(opts) : {}

  // When seeding from fs path, initialize store from that path to avoid a copy
  if (typeof input === 'string') opts.path = path.dirname(input)
  if (!opts.createdBy) opts.createdBy = 'WebTorrent/' + VERSION_STR
  if (!self.tracker) opts.announce = []

  var torrent = self.add(null, opts, onTorrent)
  var streams

  if (!Array.isArray(input)) input = [ input ]
  parallel(input.map(function (item) {
    return function (cb) {
      if (isReadable(item)) concat(item, cb)
      else cb(null, item)
    }
  }), function (err, input) {
    if (self.destroyed) return
    if (err) return torrent._destroy(err)

    createTorrent.parseInput(input, opts, function (err, files) {
      if (self.destroyed) return
      if (err) return torrent._destroy(err)

      streams = files.map(function (file) {
        return file.getStream
      })

      createTorrent(input, opts, function (err, torrentBuf) {
        if (self.destroyed) return
        if (err) return torrent._destroy(err)

        var existingTorrent = self.get(torrentBuf)
        if (existingTorrent) {
          torrent._destroy(new Error('Cannot add duplicate torrent ' + existingTorrent.infoHash))
        } else {
          torrent._onTorrentId(torrentBuf)
        }
      })
    })
  })

  function onTorrent (torrent) {
    var tasks = [
      function (cb) {
        torrent.load(streams, cb)
      }
    ]
    if (self.dht) {
      tasks.push(function (cb) {
        torrent.once('dhtAnnounce', cb)
      })
    }
    parallel(tasks, function (err) {
      if (self.destroyed) return
      if (err) return torrent._destroy(err)
      _onseed(torrent)
    })
  }

  function _onseed (torrent) {
    debug('on seed')
    if (typeof onseed === 'function') onseed(torrent)
    self.emit('seed', torrent)
  }

  return torrent
}

/**
 * Remove a torrent from the client.
 * @param  {string|Buffer|Torrent}   torrentId
 * @param  {function} cb
 */
WebTorrent.prototype.remove = function (torrentId, cb) {
  debug('remove')
  var torrent = this.get(torrentId)
  if (!torrent) throw new Error('No torrent with id ' + torrentId)
  this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
  var torrent = this.get(torrentId)
  if (!torrent) return
  this.torrents.splice(this.torrents.indexOf(torrent), 1)
  torrent.destroy(cb)
}

WebTorrent.prototype.address = function () {
  if (!this.listening) return null
  return this._tcpPool
    ? this._tcpPool.server.address()
    : { address: '0.0.0.0', family: 'IPv4', port: 0 }
}

/**
 * Destroy the client, including all torrents and connections to peers.
 * @param  {function} cb
 */
WebTorrent.prototype.destroy = function (cb) {
  if (this.destroyed) throw new Error('client already destroyed')
  this._destroy(null, cb)
}

WebTorrent.prototype._destroy = function (err, cb) {
  var self = this
  debug('client destroy')
  self.destroyed = true

  var tasks = self.torrents.map(function (torrent) {
    return function (cb) {
      torrent.destroy(cb)
    }
  })

  if (self._tcpPool) {
    tasks.push(function (cb) {
      self._tcpPool.destroy(cb)
    })
  }

  if (self.dht) {
    tasks.push(function (cb) {
      self.dht.destroy(cb)
    })
  }

  parallel(tasks, cb)

  if (err) self.emit('error', err)

  self.torrents = []
  self._tcpPool = null
  self.dht = null
}

WebTorrent.prototype._onListening = function () {
  this.listening = true

  if (this._tcpPool) {
    // Sometimes server.address() returns `null` in Docker.
    // WebTorrent issue: https://github.com/feross/bittorrent-swarm/pull/18
    var address = this._tcpPool.server.address()
    if (address) this.torrentPort = address.port
  }

  this.emit('listening')
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/tcp-pool":17,"./lib/torrent":135,"./package.json":137,"_process":73,"bittorrent-dht/client":17,"create-torrent":26,"debug":31,"events":35,"hat":39,"inherits":43,"load-ip-set":17,"parse-torrent":69,"path":70,"run-parallel":90,"safe-buffer":92,"simple-concat":93,"simple-peer":95,"speedometer":98,"xtend":139,"zero-fill":141}],131:[function(require,module,exports){
module.exports = FileStream

var debug = require('debug')('webtorrent:file-stream')
var inherits = require('inherits')
var stream = require('readable-stream')

inherits(FileStream, stream.Readable)

/**
 * Readable stream of a torrent file
 *
 * @param {File} file
 * @param {Object} opts
 * @param {number} opts.start stream slice of file, starting from this byte (inclusive)
 * @param {number} opts.end stream slice of file, ending with this byte (inclusive)
 */
function FileStream (file, opts) {
  stream.Readable.call(this, opts)

  this.destroyed = false
  this._torrent = file._torrent

  var start = (opts && opts.start) || 0
  var end = (opts && opts.end && opts.end < file.length)
    ? opts.end
    : file.length - 1

  var pieceLength = file._torrent.pieceLength

  this._startPiece = (start + file.offset) / pieceLength | 0
  this._endPiece = (end + file.offset) / pieceLength | 0

  this._piece = this._startPiece
  this._offset = (start + file.offset) - (this._startPiece * pieceLength)

  this._missing = end - start + 1
  this._reading = false
  this._notifying = false
  this._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)
}

FileStream.prototype._read = function () {
  if (this._reading) return
  this._reading = true
  this._notify()
}

FileStream.prototype._notify = function () {
  var self = this

  if (!self._reading || self._missing === 0) return
  if (!self._torrent.bitfield.get(self._piece)) {
    return self._torrent.critical(self._piece, self._piece + self._criticalLength)
  }

  if (self._notifying) return
  self._notifying = true

  var p = self._piece
  self._torrent.store.get(p, function (err, buffer) {
    self._notifying = false
    if (self.destroyed) return
    if (err) return self._destroy(err)
    debug('read %s (length %s) (err %s)', p, buffer.length, err && err.message)

    if (self._offset) {
      buffer = buffer.slice(self._offset)
      self._offset = 0
    }

    if (self._missing < buffer.length) {
      buffer = buffer.slice(0, self._missing)
    }
    self._missing -= buffer.length

    debug('pushing buffer of length %s', buffer.length)
    self._reading = false
    self.push(buffer)

    if (self._missing === 0) self.push(null)
  })
  self._piece += 1
}

FileStream.prototype.destroy = function (onclose) {
  this._destroy(null, onclose)
}

FileStream.prototype._destroy = function (err, onclose) {
  if (this.destroyed) return
  this.destroyed = true

  if (!this._torrent.destroyed) {
    this._torrent.deselect(this._startPiece, this._endPiece, true)
  }

  if (err) this.emit('error', err)
  this.emit('close')
  if (onclose) onclose()
}

},{"debug":31,"inherits":43,"readable-stream":86}],132:[function(require,module,exports){
(function (process){
module.exports = File

var eos = require('end-of-stream')
var EventEmitter = require('events').EventEmitter
var FileStream = require('./file-stream')
var inherits = require('inherits')
var path = require('path')
var render = require('render-media')
var stream = require('readable-stream')
var streamToBlobURL = require('stream-to-blob-url')
var streamToBuffer = require('stream-with-known-length-to-buffer')

inherits(File, EventEmitter)

function File (torrent, file) {
  EventEmitter.call(this)

  this._torrent = torrent
  this._destroyed = false

  this.name = file.name
  this.path = file.path
  this.length = file.length
  this.offset = file.offset

  this.done = false

  var start = file.offset
  var end = start + file.length - 1

  this._startPiece = start / this._torrent.pieceLength | 0
  this._endPiece = end / this._torrent.pieceLength | 0

  if (this.length === 0) {
    this.done = true
    this.emit('done')
  }
}

File.prototype.select = function (priority) {
  if (this.length === 0) return
  this._torrent.select(this._startPiece, this._endPiece, priority)
}

File.prototype.deselect = function () {
  if (this.length === 0) return
  this._torrent.deselect(this._startPiece, this._endPiece, false)
}

File.prototype.createReadStream = function (opts) {
  var self = this
  if (this.length === 0) {
    var empty = new stream.PassThrough()
    process.nextTick(function () {
      empty.end()
    })
    return empty
  }

  var fileStream = new FileStream(self, opts)
  self._torrent.select(fileStream._startPiece, fileStream._endPiece, true, function () {
    fileStream._notify()
  })
  eos(fileStream, function () {
    if (self._destroyed) return
    if (!self._torrent.destroyed) {
      self._torrent.deselect(fileStream._startPiece, fileStream._endPiece, true)
    }
  })
  return fileStream
}

File.prototype.getBuffer = function (cb) {
  streamToBuffer(this.createReadStream(), this.length, cb)
}

File.prototype.getBlobURL = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  var mime = render.mime[path.extname(this.name).toLowerCase()]
  streamToBlobURL(this.createReadStream(), mime, cb)
}

File.prototype.appendTo = function (elem, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.append(this, elem, cb)
}

File.prototype.renderTo = function (elem, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.render(this, elem, cb)
}

File.prototype._destroy = function () {
  this._destroyed = true
  this._torrent = null
}

}).call(this,require('_process'))

},{"./file-stream":131,"_process":73,"end-of-stream":34,"events":35,"inherits":43,"path":70,"readable-stream":86,"render-media":87,"stream-to-blob-url":103,"stream-with-known-length-to-buffer":105}],133:[function(require,module,exports){
var arrayRemove = require('unordered-array-remove')
var debug = require('debug')('webtorrent:peer')
var Wire = require('bittorrent-protocol')

var WebConn = require('./webconn')

var CONNECT_TIMEOUT_TCP = 5000
var CONNECT_TIMEOUT_WEBRTC = 25000
var HANDSHAKE_TIMEOUT = 25000

/**
 * WebRTC peer connections start out connected, because WebRTC peers require an
 * "introduction" (i.e. WebRTC signaling), and there's no equivalent to an IP address
 * that lets you refer to a WebRTC endpoint.
 */
exports.createWebRTCPeer = function (conn, swarm) {
  var peer = new Peer(conn.id, 'webrtc')
  peer.conn = conn
  peer.swarm = swarm

  if (peer.conn.connected) {
    peer.onConnect()
  } else {
    peer.conn.once('connect', function () { peer.onConnect() })
    peer.conn.once('error', function (err) { peer.destroy(err) })
    peer.startConnectTimeout()
  }

  return peer
}

/**
 * Incoming TCP peers start out connected, because the remote peer connected to the
 * listening port of the TCP server. Until the remote peer sends a handshake, we don't
 * know what swarm the connection is intended for.
 */
exports.createTCPIncomingPeer = function (conn) {
  var addr = conn.remoteAddress + ':' + conn.remotePort
  var peer = new Peer(addr, 'tcpIncoming')
  peer.conn = conn
  peer.addr = addr

  peer.onConnect()

  return peer
}

/**
 * Outgoing TCP peers start out with just an IP address. At some point (when there is an
 * available connection), the client can attempt to connect to the address.
 */
exports.createTCPOutgoingPeer = function (addr, swarm) {
  var peer = new Peer(addr, 'tcpOutgoing')
  peer.addr = addr
  peer.swarm = swarm

  return peer
}

/**
 * Peer that represents a Web Seed (BEP17 / BEP19).
 */
exports.createWebSeedPeer = function (url, swarm) {
  var peer = new Peer(url, 'webSeed')
  peer.swarm = swarm
  peer.conn = new WebConn(url, swarm)

  peer.onConnect()

  return peer
}

/**
 * Peer. Represents a peer in the torrent swarm.
 *
 * @param {string} id "ip:port" string, peer id (for WebRTC peers), or url (for Web Seeds)
 * @param {string} type the type of the peer
 */
function Peer (id, type) {
  var self = this
  self.id = id
  self.type = type

  debug('new Peer %s', id)

  self.addr = null
  self.conn = null
  self.swarm = null
  self.wire = null

  self.connected = false
  self.destroyed = false
  self.timeout = null // handshake timeout
  self.retries = 0 // outgoing TCP connection retry count

  self.sentHandshake = false
}

/**
 * Called once the peer is connected (i.e. fired 'connect' event)
 * @param {Socket} conn
 */
Peer.prototype.onConnect = function () {
  var self = this
  if (self.destroyed) return
  self.connected = true

  debug('Peer %s connected', self.id)

  clearTimeout(self.connectTimeout)

  var conn = self.conn
  conn.once('end', function () {
    self.destroy()
  })
  conn.once('close', function () {
    self.destroy()
  })
  conn.once('finish', function () {
    self.destroy()
  })
  conn.once('error', function (err) {
    self.destroy(err)
  })

  var wire = self.wire = new Wire()
  wire.type = self.type
  wire.once('end', function () {
    self.destroy()
  })
  wire.once('close', function () {
    self.destroy()
  })
  wire.once('finish', function () {
    self.destroy()
  })
  wire.once('error', function (err) {
    self.destroy(err)
  })

  wire.once('handshake', function (infoHash, peerId) {
    self.onHandshake(infoHash, peerId)
  })
  self.startHandshakeTimeout()

  conn.pipe(wire).pipe(conn)
  if (self.swarm && !self.sentHandshake) self.handshake()
}

/**
 * Called when handshake is received from remote peer.
 * @param {string} infoHash
 * @param {string} peerId
 */
Peer.prototype.onHandshake = function (infoHash, peerId) {
  var self = this
  if (!self.swarm) return // `self.swarm` not set yet, so do nothing
  if (self.destroyed) return

  if (self.swarm.destroyed) {
    return self.destroy(new Error('swarm already destroyed'))
  }
  if (infoHash !== self.swarm.infoHash) {
    return self.destroy(new Error('unexpected handshake info hash for this swarm'))
  }
  if (peerId === self.swarm.peerId) {
    return self.destroy(new Error('refusing to connect to ourselves'))
  }

  debug('Peer %s got handshake %s', self.id, infoHash)

  clearTimeout(self.handshakeTimeout)

  self.retries = 0

  var addr = self.addr
  if (!addr && self.conn.remoteAddress) {
    addr = self.conn.remoteAddress + ':' + self.conn.remotePort
  }
  self.swarm._onWire(self.wire, addr)

  // swarm could be destroyed in user's 'wire' event handler
  if (!self.swarm || self.swarm.destroyed) return

  if (!self.sentHandshake) self.handshake()
}

Peer.prototype.handshake = function () {
  var self = this
  var opts = {
    dht: self.swarm.private ? false : !!self.swarm.client.dht
  }
  self.wire.handshake(self.swarm.infoHash, self.swarm.client.peerId, opts)
  self.sentHandshake = true
}

Peer.prototype.startConnectTimeout = function () {
  var self = this
  clearTimeout(self.connectTimeout)
  self.connectTimeout = setTimeout(function () {
    self.destroy(new Error('connect timeout'))
  }, self.type === 'webrtc' ? CONNECT_TIMEOUT_WEBRTC : CONNECT_TIMEOUT_TCP)
  if (self.connectTimeout.unref) self.connectTimeout.unref()
}

Peer.prototype.startHandshakeTimeout = function () {
  var self = this
  clearTimeout(self.handshakeTimeout)
  self.handshakeTimeout = setTimeout(function () {
    self.destroy(new Error('handshake timeout'))
  }, HANDSHAKE_TIMEOUT)
  if (self.handshakeTimeout.unref) self.handshakeTimeout.unref()
}

Peer.prototype.destroy = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self.connected = false

  debug('destroy %s (error: %s)', self.id, err && (err.message || err))

  clearTimeout(self.connectTimeout)
  clearTimeout(self.handshakeTimeout)

  var swarm = self.swarm
  var conn = self.conn
  var wire = self.wire

  self.swarm = null
  self.conn = null
  self.wire = null

  if (swarm && wire) {
    arrayRemove(swarm.wires, swarm.wires.indexOf(wire))
  }
  if (conn) {
    conn.on('error', noop)
    conn.destroy()
  }
  if (wire) wire.destroy()
  if (swarm) swarm.removePeer(self.id)
}

function noop () {}

},{"./webconn":136,"bittorrent-protocol":10,"debug":31,"unordered-array-remove":116}],134:[function(require,module,exports){
module.exports = RarityMap

/**
 * Mapping of torrent pieces to their respective availability in the torrent swarm. Used
 * by the torrent manager for implementing the rarest piece first selection strategy.
 */
function RarityMap (torrent) {
  var self = this

  self._torrent = torrent
  self._numPieces = torrent.pieces.length
  self._pieces = []

  self._onWire = function (wire) {
    self.recalculate()
    self._initWire(wire)
  }
  self._onWireHave = function (index) {
    self._pieces[index] += 1
  }
  self._onWireBitfield = function () {
    self.recalculate()
  }

  self._torrent.wires.forEach(function (wire) {
    self._initWire(wire)
  })
  self._torrent.on('wire', self._onWire)
  self.recalculate()
}

/**
 * Get the index of the rarest piece. Optionally, pass a filter function to exclude
 * certain pieces (for instance, those that we already have).
 *
 * @param {function} pieceFilterFunc
 * @return {number} index of rarest piece, or -1
 */
RarityMap.prototype.getRarestPiece = function (pieceFilterFunc) {
  if (!pieceFilterFunc) pieceFilterFunc = trueFn

  var candidates = []
  var min = Infinity

  for (var i = 0; i < this._numPieces; ++i) {
    if (!pieceFilterFunc(i)) continue

    var availability = this._pieces[i]
    if (availability === min) {
      candidates.push(i)
    } else if (availability < min) {
      candidates = [ i ]
      min = availability
    }
  }

  if (candidates.length > 0) {
    // if there are multiple pieces with the same availability, choose one randomly
    return candidates[Math.random() * candidates.length | 0]
  } else {
    return -1
  }
}

RarityMap.prototype.destroy = function () {
  var self = this
  self._torrent.removeListener('wire', self._onWire)
  self._torrent.wires.forEach(function (wire) {
    self._cleanupWireEvents(wire)
  })
  self._torrent = null
  self._pieces = null

  self._onWire = null
  self._onWireHave = null
  self._onWireBitfield = null
}

RarityMap.prototype._initWire = function (wire) {
  var self = this

  wire._onClose = function () {
    self._cleanupWireEvents(wire)
    for (var i = 0; i < this._numPieces; ++i) {
      self._pieces[i] -= wire.peerPieces.get(i)
    }
  }

  wire.on('have', self._onWireHave)
  wire.on('bitfield', self._onWireBitfield)
  wire.once('close', wire._onClose)
}

/**
 * Recalculates piece availability across all peers in the torrent.
 */
RarityMap.prototype.recalculate = function () {
  var i
  for (i = 0; i < this._numPieces; ++i) {
    this._pieces[i] = 0
  }

  var numWires = this._torrent.wires.length
  for (i = 0; i < numWires; ++i) {
    var wire = this._torrent.wires[i]
    for (var j = 0; j < this._numPieces; ++j) {
      this._pieces[j] += wire.peerPieces.get(j)
    }
  }
}

RarityMap.prototype._cleanupWireEvents = function (wire) {
  wire.removeListener('have', this._onWireHave)
  wire.removeListener('bitfield', this._onWireBitfield)
  if (wire._onClose) wire.removeListener('close', wire._onClose)
  wire._onClose = null
}

function trueFn () {
  return true
}

},{}],135:[function(require,module,exports){
(function (process,global){
/* global URL, Blob */

module.exports = Torrent

var addrToIPPort = require('addr-to-ip-port')
var BitField = require('bitfield')
var ChunkStoreWriteStream = require('chunk-store-stream/write')
var debug = require('debug')('webtorrent:torrent')
var Discovery = require('torrent-discovery')
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var extendMutable = require('xtend/mutable')
var fs = require('fs')
var FSChunkStore = require('fs-chunk-store') // browser: `memory-chunk-store`
var get = require('simple-get')
var ImmediateChunkStore = require('immediate-chunk-store')
var inherits = require('inherits')
var MultiStream = require('multistream')
var net = require('net') // browser exclude
var os = require('os') // browser exclude
var parallel = require('run-parallel')
var parallelLimit = require('run-parallel-limit')
var parseTorrent = require('parse-torrent')
var path = require('path')
var Piece = require('torrent-piece')
var pump = require('pump')
var randomIterate = require('random-iterate')
var sha1 = require('simple-sha1')
var speedometer = require('speedometer')
var uniq = require('uniq')
var utMetadata = require('ut_metadata')
var utPex = require('ut_pex') // browser exclude

var File = require('./file')
var Peer = require('./peer')
var RarityMap = require('./rarity-map')
var Server = require('./server') // browser exclude

var MAX_BLOCK_LENGTH = 128 * 1024
var PIECE_TIMEOUT = 30000
var CHOKE_TIMEOUT = 5000
var SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH

var PIPELINE_MIN_DURATION = 0.5
var PIPELINE_MAX_DURATION = 1

var RECHOKE_INTERVAL = 10000 // 10 seconds
var RECHOKE_OPTIMISTIC_DURATION = 2 // 30 seconds

var FILESYSTEM_CONCURRENCY = 2

var RECONNECT_WAIT = [ 1000, 5000, 15000 ]

var VERSION = require('../package.json').version

var TMP
try {
  TMP = path.join(fs.statSync('/tmp') && '/tmp', 'webtorrent')
} catch (err) {
  TMP = path.join(typeof os.tmpDir === 'function' ? os.tmpDir() : '/', 'webtorrent')
}

inherits(Torrent, EventEmitter)

function Torrent (torrentId, client, opts) {
  EventEmitter.call(this)

  this.client = client
  this._debugId = this.client.peerId.slice(32)

  this._debug('new torrent')

  this.announce = opts.announce
  this.urlList = opts.urlList

  this.path = opts.path
  this._store = opts.store || FSChunkStore
  this._getAnnounceOpts = opts.getAnnounceOpts

  this.strategy = opts.strategy || 'sequential'

  this.maxWebConns = opts.maxWebConns || 4

  this._rechokeNumSlots = (opts.uploads === false || opts.uploads === 0)
    ? 0
    : (+opts.uploads || 10)
  this._rechokeOptimisticWire = null
  this._rechokeOptimisticTime = 0
  this._rechokeIntervalId = null

  this.ready = false
  this.destroyed = false
  this.paused = false
  this.done = false

  this.metadata = null
  this.store = null
  this.files = []
  this.pieces = []

  this._amInterested = false
  this._selections = []
  this._critical = []

  this.wires = [] // open wires (added *after* handshake)

  this._queue = [] // queue of outgoing tcp peers to connect to
  this._peers = {} // connected peers (addr/peerId -> Peer)
  this._peersLength = 0 // number of elements in `this._peers` (cache, for perf)

  // stats
  this.received = 0
  this.uploaded = 0
  this._downloadSpeed = speedometer()
  this._uploadSpeed = speedometer()

  // for cleanup
  this._servers = []
  this._xsRequests = []

  // TODO: remove this and expose a hook instead
  // optimization: don't recheck every file if it hasn't changed
  this._fileModtimes = opts.fileModtimes

  if (torrentId !== null) this._onTorrentId(torrentId)
}

Object.defineProperty(Torrent.prototype, 'timeRemaining', {
  get: function () {
    if (this.done) return 0
    if (this.downloadSpeed === 0) return Infinity
    return ((this.length - this.downloaded) / this.downloadSpeed) * 1000
  }
})

Object.defineProperty(Torrent.prototype, 'downloaded', {
  get: function () {
    if (!this.bitfield) return 0
    var downloaded = 0
    for (var index = 0, len = this.pieces.length; index < len; ++index) {
      if (this.bitfield.get(index)) { // verified data
        downloaded += (index === len - 1) ? this.lastPieceLength : this.pieceLength
      } else { // "in progress" data
        var piece = this.pieces[index]
        downloaded += (piece.length - piece.missing)
      }
    }
    return downloaded
  }
})

// TODO: re-enable this. The number of missing pieces. Used to implement 'end game' mode.
// Object.defineProperty(Storage.prototype, 'numMissing', {
//   get: function () {
//     var self = this
//     var numMissing = self.pieces.length
//     for (var index = 0, len = self.pieces.length; index < len; index++) {
//       numMissing -= self.bitfield.get(index)
//     }
//     return numMissing
//   }
// })

Object.defineProperty(Torrent.prototype, 'downloadSpeed', {
  get: function () { return this._downloadSpeed() }
})

Object.defineProperty(Torrent.prototype, 'uploadSpeed', {
  get: function () { return this._uploadSpeed() }
})

Object.defineProperty(Torrent.prototype, 'progress', {
  get: function () { return this.length ? this.downloaded / this.length : 0 }
})

Object.defineProperty(Torrent.prototype, 'ratio', {
  get: function () { return this.uploaded / (this.received || 1) }
})

Object.defineProperty(Torrent.prototype, 'numPeers', {
  get: function () { return this.wires.length }
})

Object.defineProperty(Torrent.prototype, 'torrentFileBlobURL', {
  get: function () {
    if (typeof window === 'undefined') throw new Error('browser-only property')
    if (!this.torrentFile) return null
    return URL.createObjectURL(
      new Blob([ this.torrentFile ], { type: 'application/x-bittorrent' })
    )
  }
})

Object.defineProperty(Torrent.prototype, '_numQueued', {
  get: function () {
    return this._queue.length + (this._peersLength - this._numConns)
  }
})

Object.defineProperty(Torrent.prototype, '_numConns', {
  get: function () {
    var self = this
    var numConns = 0
    for (var id in self._peers) {
      if (self._peers[id].connected) numConns += 1
    }
    return numConns
  }
})

// TODO: remove in v1
Object.defineProperty(Torrent.prototype, 'swarm', {
  get: function () {
    console.warn('WebTorrent: `torrent.swarm` is deprecated. Use `torrent` directly instead.')
    return this
  }
})

Torrent.prototype._onTorrentId = function (torrentId) {
  var self = this
  if (self.destroyed) return

  var parsedTorrent
  try { parsedTorrent = parseTorrent(torrentId) } catch (err) {}
  if (parsedTorrent) {
    // Attempt to set infoHash property synchronously
    self.infoHash = parsedTorrent.infoHash
    process.nextTick(function () {
      if (self.destroyed) return
      self._onParsedTorrent(parsedTorrent)
    })
  } else {
    // If torrentId failed to parse, it could be in a form that requires an async
    // operation, i.e. http/https link, filesystem path, or Blob.
    parseTorrent.remote(torrentId, function (err, parsedTorrent) {
      if (self.destroyed) return
      if (err) return self._destroy(err)
      self._onParsedTorrent(parsedTorrent)
    })
  }
}

Torrent.prototype._onParsedTorrent = function (parsedTorrent) {
  var self = this
  if (self.destroyed) return

  self._processParsedTorrent(parsedTorrent)

  if (!self.infoHash) {
    return self._destroy(new Error('Malformed torrent data: No info hash'))
  }

  if (!self.path) self.path = path.join(TMP, self.infoHash)

  self._rechokeIntervalId = setInterval(function () {
    self._rechoke()
  }, RECHOKE_INTERVAL)
  if (self._rechokeIntervalId.unref) self._rechokeIntervalId.unref()

  // Private 'infoHash' event allows client.add to check for duplicate torrents and
  // destroy them before the normal 'infoHash' event is emitted. Prevents user
  // applications from needing to deal with duplicate 'infoHash' events.
  self.emit('_infoHash', self.infoHash)
  if (self.destroyed) return

  self.emit('infoHash', self.infoHash)
  if (self.destroyed) return // user might destroy torrent in event handler

  if (self.client.listening) {
    self._onListening()
  } else {
    self.client.once('listening', function () {
      self._onListening()
    })
  }
}

Torrent.prototype._processParsedTorrent = function (parsedTorrent) {
  if (this.announce) {
    // Allow specifying trackers via `opts` parameter
    parsedTorrent.announce = parsedTorrent.announce.concat(this.announce)
  }

  if (this.client.tracker && global.WEBTORRENT_ANNOUNCE && !this.private) {
    // So `webtorrent-hybrid` can force specific trackers to be used
    parsedTorrent.announce = parsedTorrent.announce.concat(global.WEBTORRENT_ANNOUNCE)
  }

  if (this.urlList) {
    // Allow specifying web seeds via `opts` parameter
    parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList)
  }

  uniq(parsedTorrent.announce)
  uniq(parsedTorrent.urlList)

  extendMutable(this, parsedTorrent)

  this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent)
  this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent)
}

Torrent.prototype._onListening = function () {
  var self = this
  if (self.discovery || self.destroyed) return

  var trackerOpts = self.client.tracker
  if (trackerOpts) {
    trackerOpts = extend(self.client.tracker, {
      getAnnounceOpts: function () {
        var opts = {
          uploaded: self.uploaded,
          downloaded: self.downloaded,
          left: Math.max(self.length - self.downloaded, 0)
        }
        if (self.client.tracker.getAnnounceOpts) {
          extendMutable(opts, self.client.tracker.getAnnounceOpts())
        }
        if (self._getAnnounceOpts) {
          // TODO: consider deprecating this, as it's redundant with the former case
          extendMutable(opts, self._getAnnounceOpts())
        }
        return opts
      }
    })
  }

  // begin discovering peers via DHT and trackers
  self.discovery = new Discovery({
    infoHash: self.infoHash,
    announce: self.announce,
    peerId: self.client.peerId,
    dht: !self.private && self.client.dht,
    tracker: trackerOpts,
    port: self.client.torrentPort
  })

  self.discovery.on('error', onError)
  self.discovery.on('peer', onPeer)
  self.discovery.on('trackerAnnounce', onTrackerAnnounce)
  self.discovery.on('dhtAnnounce', onDHTAnnounce)
  self.discovery.on('warning', onWarning)

  function onError (err) {
    self._destroy(err)
  }

  function onPeer (peer) {
    // Don't create new outgoing TCP connections when torrent is done
    if (typeof peer === 'string' && self.done) return
    self.addPeer(peer)
  }

  function onTrackerAnnounce () {
    self.emit('trackerAnnounce')
    if (self.numPeers === 0) self.emit('noPeers', 'tracker')
  }

  function onDHTAnnounce () {
    self.emit('dhtAnnounce')
    if (self.numPeers === 0) self.emit('noPeers', 'dht')
  }

  function onWarning (err) {
    self.emit('warning', err)
  }

  if (self.info) {
    // if full metadata was included in initial torrent id, use it immediately. Otherwise,
    // wait for torrent-discovery to find peers and ut_metadata to get the metadata.
    self._onMetadata(self)
  } else if (self.xs) {
    self._getMetadataFromServer()
  }
}

Torrent.prototype._getMetadataFromServer = function () {
  var self = this
  var urls = Array.isArray(self.xs) ? self.xs : [ self.xs ]

  var tasks = urls.map(function (url) {
    return function (cb) {
      getMetadataFromURL(url, cb)
    }
  })
  parallel(tasks)

  function getMetadataFromURL (url, cb) {
    if (url.indexOf('http://') !== 0 && url.indexOf('https://') !== 0) {
      self._debug('skipping non-http xs param: %s', url)
      return cb(null)
    }

    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)'
      }
    }
    var req
    try {
      req = get.concat(opts, onResponse)
    } catch (err) {
      self._debug('skipping invalid url xs param: %s', url)
      return cb(null)
    }

    self._xsRequests.push(req)

    function onResponse (err, res, torrent) {
      if (self.destroyed) return cb(null)
      if (self.metadata) return cb(null)

      if (err) {
        self._debug('http error from xs param: %s', url)
        return cb(null)
      }
      if (res.statusCode !== 200) {
        self._debug('non-200 status code %s from xs param: %s', res.statusCode, url)
        return cb(null)
      }

      var parsedTorrent
      try {
        parsedTorrent = parseTorrent(torrent)
      } catch (err) {}

      if (!parsedTorrent) {
        self._debug('got invalid torrent file from xs param: %s', url)
        return cb(null)
      }

      if (parsedTorrent.infoHash !== self.infoHash) {
        self._debug('got torrent file with incorrect info hash from xs param: %s', url)
        return cb(null)
      }

      self._onMetadata(parsedTorrent)
      cb(null)
    }
  }
}

/**
 * Called when the full torrent metadata is received.
 */
Torrent.prototype._onMetadata = function (metadata) {
  var self = this
  if (self.metadata || self.destroyed) return
  self._debug('got metadata')

  self._xsRequests.forEach(function (req) {
    req.abort()
  })
  self._xsRequests = []

  var parsedTorrent
  if (metadata && metadata.infoHash) {
    // `metadata` is a parsed torrent (from parse-torrent module)
    parsedTorrent = metadata
  } else {
    try {
      parsedTorrent = parseTorrent(metadata)
    } catch (err) {
      return self._destroy(err)
    }
  }

  self._processParsedTorrent(parsedTorrent)
  self.metadata = self.torrentFile

  // add web seed urls (BEP19)
  self.urlList.forEach(function (url) {
    self.addWebSeed(url)
  })

  self._rarityMap = new RarityMap(self)

  self.store = new ImmediateChunkStore(
    new self._store(self.pieceLength, {
      torrent: {
        infoHash: self.infoHash
      },
      files: self.files.map(function (file) {
        return {
          path: path.join(self.path, file.path),
          length: file.length,
          offset: file.offset
        }
      }),
      length: self.length
    })
  )

  self.files = self.files.map(function (file) {
    return new File(self, file)
  })

  self._hashes = self.pieces

  self.pieces = self.pieces.map(function (hash, i) {
    var pieceLength = (i === self.pieces.length - 1)
      ? self.lastPieceLength
      : self.pieceLength
    return new Piece(pieceLength)
  })

  self._reservations = self.pieces.map(function () {
    return []
  })

  self.bitfield = new BitField(self.pieces.length)

  self.wires.forEach(function (wire) {
    // If we didn't have the metadata at the time ut_metadata was initialized for this
    // wire, we still want to make it available to the peer in case they request it.
    if (wire.ut_metadata) wire.ut_metadata.setMetadata(self.metadata)

    self._onWireWithMetadata(wire)
  })

  self._debug('verifying existing torrent data')
  if (self._fileModtimes && self._store === FSChunkStore) {
    // don't verify if the files haven't been modified since we last checked
    self.getFileModtimes(function (err, fileModtimes) {
      if (err) return self._destroy(err)

      var unchanged = self.files.map(function (_, index) {
        return fileModtimes[index] === self._fileModtimes[index]
      }).every(function (x) {
        return x
      })

      if (unchanged) {
        for (var index = 0; index < self.pieces.length; index++) {
          self._markVerified(index)
        }
        self._onStore()
      } else {
        self._verifyPieces()
      }
    })
  } else {
    self._verifyPieces()
  }

  self.emit('metadata')
}

/*
 * TODO: remove this
 * Gets the last modified time of every file on disk for this torrent.
 * Only valid in Node, not in the browser.
 */
Torrent.prototype.getFileModtimes = function (cb) {
  var self = this
  var ret = []
  parallelLimit(self.files.map(function (file, index) {
    return function (cb) {
      fs.stat(path.join(self.path, file.path), function (err, stat) {
        if (err && err.code !== 'ENOENT') return cb(err)
        ret[index] = stat && stat.mtime.getTime()
        cb(null)
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    self._debug('done getting file modtimes')
    cb(err, ret)
  })
}

Torrent.prototype._verifyPieces = function () {
  var self = this
  parallelLimit(self.pieces.map(function (_, index) {
    return function (cb) {
      if (self.destroyed) return cb(new Error('torrent is destroyed'))
      self.store.get(index, function (err, buf) {
        if (err) return cb(null) // ignore error
        sha1(buf, function (hash) {
          if (hash === self._hashes[index]) {
            if (!self.pieces[index]) return
            self._debug('piece verified %s', index)
            self._markVerified(index)
          } else {
            self._debug('piece invalid %s', index)
          }
          cb(null)
        })
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    if (err) return self._destroy(err)
    self._debug('done verifying')
    self._onStore()
  })
}

Torrent.prototype._markVerified = function (index) {
  this.pieces[index] = null
  this._reservations[index] = null
  this.bitfield.set(index, true)
}

/**
 * Called when the metadata, listening server, and underlying chunk store is initialized.
 */
Torrent.prototype._onStore = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on store')

  // start off selecting the entire torrent with low priority
  if (self.pieces.length !== 0) {
    self.select(0, self.pieces.length - 1, false)
  }

  self.ready = true
  self.emit('ready')

  // Files may start out done if the file was already in the store
  self._checkDone()

  // In case any selections were made before torrent was ready
  self._updateSelections()
}

Torrent.prototype.destroy = function (cb) {
  var self = this
  self._destroy(null, cb)
}

Torrent.prototype._destroy = function (err, cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self._debug('destroy')

  self.client._remove(self)

  clearInterval(self._rechokeIntervalId)

  self._xsRequests.forEach(function (req) {
    req.abort()
  })

  if (self._rarityMap) {
    self._rarityMap.destroy()
  }

  for (var id in self._peers) {
    self.removePeer(id)
  }

  self.files.forEach(function (file) {
    if (file instanceof File) file._destroy()
  })

  var tasks = self._servers.map(function (server) {
    return function (cb) {
      server.destroy(cb)
    }
  })

  if (self.discovery) {
    tasks.push(function (cb) {
      self.discovery.destroy(cb)
    })
  }

  if (self.store) {
    tasks.push(function (cb) {
      self.store.close(cb)
    })
  }

  parallel(tasks, cb)

  if (err) {
    // Torrent errors are emitted at `torrent.on('error')`. If there are no 'error' event
    // handlers on the torrent instance, the error will be emitted at
    // `client.on('error')`. This prevents crashing the user's program, but it makes it
    // impossible to determine a client error versus a torrent error (where the client
    // is still usable afterwards). Users are recommended for errors in both places
    // to distinguish between the error types.
    if (self.listenerCount('error') === 0) {
      self.client.emit('error', err)
    } else {
      self.emit('error', err)
    }
  }

  self.emit('close')

  self.client = null
  self.files = []
  self.discovery = null
  self.store = null
  self._rarityMap = null
  self._peers = null
  self._servers = null
  self._xsRequests = null
}

Torrent.prototype.addPeer = function (peer) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.infoHash) throw new Error('addPeer() must not be called before the `infoHash` event')

  if (self.client.blocked) {
    var host
    if (typeof peer === 'string') {
      var parts
      try {
        parts = addrToIPPort(peer)
      } catch (e) {
        self._debug('ignoring peer: invalid %s', peer)
        self.emit('invalidPeer', peer)
        return false
      }
      host = parts[0]
    } else if (typeof peer.remoteAddress === 'string') {
      host = peer.remoteAddress
    }

    if (host && self.client.blocked.contains(host)) {
      self._debug('ignoring peer: blocked %s', peer)
      if (typeof peer !== 'string') peer.destroy()
      self.emit('blockedPeer', peer)
      return false
    }
  }

  var wasAdded = !!self._addPeer(peer)
  if (wasAdded) {
    self.emit('peer', peer)
  } else {
    self.emit('invalidPeer', peer)
  }
  return wasAdded
}

Torrent.prototype._addPeer = function (peer) {
  var self = this
  if (self.destroyed) {
    self._debug('ignoring peer: torrent is destroyed')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }
  if (typeof peer === 'string' && !self._validAddr(peer)) {
    self._debug('ignoring peer: invalid %s', peer)
    return null
  }

  var id = (peer && peer.id) || peer
  if (self._peers[id]) {
    self._debug('ignoring peer: duplicate (%s)', id)
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  if (self.paused) {
    self._debug('ignoring peer: torrent is paused')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  self._debug('add peer %s', id)

  var newPeer
  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    newPeer = Peer.createTCPOutgoingPeer(peer, self)
  } else {
    // `peer` is a WebRTC connection (simple-peer)
    newPeer = Peer.createWebRTCPeer(peer, self)
  }

  self._peers[newPeer.id] = newPeer
  self._peersLength += 1

  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    self._queue.push(newPeer)
    self._drain()
  }

  return newPeer
}

Torrent.prototype.addWebSeed = function (url) {
  if (this.destroyed) throw new Error('torrent is destroyed')

  if (!/^https?:\/\/.+/.test(url)) {
    this._debug('ignoring invalid web seed %s', url)
    this.emit('invalidPeer', url)
    return
  }

  if (this._peers[url]) {
    this._debug('ignoring duplicate web seed %s', url)
    this.emit('invalidPeer', url)
    return
  }

  this._debug('add web seed %s', url)

  var newPeer = Peer.createWebSeedPeer(url, this)
  this._peers[newPeer.id] = newPeer
  this._peersLength += 1

  this.emit('peer', url)
}

/**
 * Called whenever a new incoming TCP peer connects to this torrent swarm. Called with a
 * peer that has already sent a handshake.
 */
Torrent.prototype._addIncomingPeer = function (peer) {
  var self = this
  if (self.destroyed) return peer.destroy(new Error('torrent is destroyed'))
  if (self.paused) return peer.destroy(new Error('torrent is paused'))

  this._debug('add incoming peer %s', peer.id)

  self._peers[peer.id] = peer
  self._peersLength += 1
}

Torrent.prototype.removePeer = function (peer) {
  var self = this
  var id = (peer && peer.id) || peer
  peer = self._peers[id]

  if (!peer) return

  this._debug('removePeer %s', id)

  delete self._peers[id]
  self._peersLength -= 1

  peer.destroy()

  // If torrent swarm was at capacity before, try to open a new connection now
  self._drain()
}

Torrent.prototype.select = function (start, end, priority, notify) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  if (start < 0 || end < start || self.pieces.length <= end) {
    throw new Error('invalid selection ', start, ':', end)
  }
  priority = Number(priority) || 0

  self._debug('select %s-%s (priority %s)', start, end, priority)

  self._selections.push({
    from: start,
    to: end,
    offset: 0,
    priority: priority,
    notify: notify || noop
  })

  self._selections.sort(function (a, b) {
    return b.priority - a.priority
  })

  self._updateSelections()
}

Torrent.prototype.deselect = function (start, end, priority) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  priority = Number(priority) || 0
  self._debug('deselect %s-%s (priority %s)', start, end, priority)

  for (var i = 0; i < self._selections.length; ++i) {
    var s = self._selections[i]
    if (s.from === start && s.to === end && s.priority === priority) {
      self._selections.splice(i--, 1)
      break
    }
  }

  self._updateSelections()
}

Torrent.prototype.critical = function (start, end) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  self._debug('critical %s-%s', start, end)

  for (var i = start; i <= end; ++i) {
    self._critical[i] = true
  }

  self._updateSelections()
}

Torrent.prototype._onWire = function (wire, addr) {
  var self = this
  self._debug('got wire %s (%s)', wire._debugId, addr || 'Unknown')

  wire.on('download', function (downloaded) {
    if (self.destroyed) return
    self.received += downloaded
    self._downloadSpeed(downloaded)
    self.client._downloadSpeed(downloaded)
    self.emit('download', downloaded)
    self.client.emit('download', downloaded)
  })

  wire.on('upload', function (uploaded) {
    if (self.destroyed) return
    self.uploaded += uploaded
    self._uploadSpeed(uploaded)
    self.client._uploadSpeed(uploaded)
    self.emit('upload', uploaded)
    self.client.emit('upload', uploaded)
  })

  self.wires.push(wire)

  if (addr) {
    // Sometimes RTCPeerConnection.getStats() doesn't return an ip:port for peers
    var parts = addrToIPPort(addr)
    wire.remoteAddress = parts[0]
    wire.remotePort = parts[1]
  }

  // When peer sends PORT message, add that DHT node to routing table
  if (self.client.dht && self.client.dht.listening) {
    wire.on('port', function (port) {
      if (self.destroyed || self.client.dht.destroyed) {
        return
      }
      if (!wire.remoteAddress) {
        return self._debug('ignoring PORT from peer with no address')
      }
      if (port === 0 || port > 65536) {
        return self._debug('ignoring invalid PORT from peer')
      }

      self._debug('port: %s (from %s)', port, addr)
      self.client.dht.addNode({ host: wire.remoteAddress, port: port })
    })
  }

  wire.on('timeout', function () {
    self._debug('wire timeout (%s)', addr)
    // TODO: this might be destroying wires too eagerly
    wire.destroy()
  })

  // Timeout for piece requests to this peer
  wire.setTimeout(PIECE_TIMEOUT, true)

  // Send KEEP-ALIVE (every 60s) so peers will not disconnect the wire
  wire.setKeepAlive(true)

  // use ut_metadata extension
  wire.use(utMetadata(self.metadata))

  wire.ut_metadata.on('warning', function (err) {
    self._debug('ut_metadata warning: %s', err.message)
  })

  if (!self.metadata) {
    wire.ut_metadata.on('metadata', function (metadata) {
      self._debug('got metadata via ut_metadata')
      self._onMetadata(metadata)
    })
    wire.ut_metadata.fetch()
  }

  // use ut_pex extension if the torrent is not flagged as private
  if (typeof utPex === 'function' && !self.private) {
    wire.use(utPex())

    wire.ut_pex.on('peer', function (peer) {
      // Only add potential new peers when we're not seeding
      if (self.done) return
      self._debug('ut_pex: got peer: %s (from %s)', peer, addr)
      self.addPeer(peer)
    })

    wire.ut_pex.on('dropped', function (peer) {
      // the remote peer believes a given peer has been dropped from the torrent swarm.
      // if we're not currently connected to it, then remove it from the queue.
      var peerObj = self._peers[peer]
      if (peerObj && !peerObj.connected) {
        self._debug('ut_pex: dropped peer: %s (from %s)', peer, addr)
        self.removePeer(peer)
      }
    })

    wire.once('close', function () {
      // Stop sending updates to remote peer
      wire.ut_pex.reset()
    })
  }

  // Hook to allow user-defined `bittorrent-protocol` extensions
  // More info: https://github.com/feross/bittorrent-protocol#extension-api
  self.emit('wire', wire, addr)

  if (self.metadata) {
    process.nextTick(function () {
      // This allows wire.handshake() to be called (by Peer.onHandshake) before any
      // messages get sent on the wire
      self._onWireWithMetadata(wire)
    })
  }
}

Torrent.prototype._onWireWithMetadata = function (wire) {
  var self = this
  var timeoutId = null

  function onChokeTimeout () {
    if (self.destroyed || wire.destroyed) return

    if (self._numQueued > 2 * (self._numConns - self.numPeers) &&
      wire.amInterested) {
      wire.destroy()
    } else {
      timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
      if (timeoutId.unref) timeoutId.unref()
    }
  }

  var i = 0
  function updateSeedStatus () {
    if (wire.peerPieces.length !== self.pieces.length) return
    for (; i < self.pieces.length; ++i) {
      if (!wire.peerPieces.get(i)) return
    }
    wire.isSeeder = true
    wire.choke() // always choke seeders
  }

  wire.on('bitfield', function () {
    updateSeedStatus()
    self._update()
  })

  wire.on('have', function () {
    updateSeedStatus()
    self._update()
  })

  wire.once('interested', function () {
    wire.unchoke()
  })

  wire.once('close', function () {
    clearTimeout(timeoutId)
  })

  wire.on('choke', function () {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
    if (timeoutId.unref) timeoutId.unref()
  })

  wire.on('unchoke', function () {
    clearTimeout(timeoutId)
    self._update()
  })

  wire.on('request', function (index, offset, length, cb) {
    if (length > MAX_BLOCK_LENGTH) {
      // Per spec, disconnect from peers that request >128KB
      return wire.destroy()
    }
    if (self.pieces[index]) return
    self.store.get(index, { offset: offset, length: length }, cb)
  })

  wire.bitfield(self.bitfield) // always send bitfield (required)
  wire.interested() // always start out interested

  // Send PORT message to peers that support DHT
  if (wire.peerExtensions.dht && self.client.dht && self.client.dht.listening) {
    wire.port(self.client.dht.address().port)
  }

  timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
  if (timeoutId.unref) timeoutId.unref()

  wire.isSeeder = false
  updateSeedStatus()
}

/**
 * Called on selection changes.
 */
Torrent.prototype._updateSelections = function () {
  var self = this
  if (!self.ready || self.destroyed) return

  process.nextTick(function () {
    self._gcSelections()
  })
  self._updateInterest()
  self._update()
}

/**
 * Garbage collect selections with respect to the store's current state.
 */
Torrent.prototype._gcSelections = function () {
  var self = this

  for (var i = 0; i < self._selections.length; i++) {
    var s = self._selections[i]
    var oldOffset = s.offset

    // check for newly downloaded pieces in selection
    while (self.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {
      s.offset++
    }

    if (oldOffset !== s.offset) s.notify()
    if (s.to !== s.from + s.offset) continue
    if (!self.bitfield.get(s.from + s.offset)) continue

    // remove fully downloaded selection
    self._selections.splice(i--, 1) // decrement i to offset splice
    s.notify() // TODO: this may notify twice in a row. is this a problem?
    self._updateInterest()
  }

  if (!self._selections.length) self.emit('idle')
}

/**
 * Update interested status for all peers.
 */
Torrent.prototype._updateInterest = function () {
  var self = this

  var prev = self._amInterested
  self._amInterested = !!self._selections.length

  self.wires.forEach(function (wire) {
    // TODO: only call wire.interested if the wire has at least one piece we need
    if (self._amInterested) wire.interested()
    else wire.uninterested()
  })

  if (prev === self._amInterested) return
  if (self._amInterested) self.emit('interested')
  else self.emit('uninterested')
}

/**
 * Heartbeat to update all peers and their requests.
 */
Torrent.prototype._update = function () {
  var self = this
  if (self.destroyed) return

  // update wires in random order for better request distribution
  var ite = randomIterate(self.wires)
  var wire
  while ((wire = ite())) {
    self._updateWire(wire)
  }
}

/**
 * Attempts to update a peer's requests
 */
Torrent.prototype._updateWire = function (wire) {
  var self = this

  if (wire.peerChoking) return
  if (!wire.downloaded) return validateWire()

  var minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION)
  if (wire.requests.length >= minOutstandingRequests) return
  var maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  trySelectWire(false) || trySelectWire(true)

  function genPieceFilterFunc (start, end, tried, rank) {
    return function (i) {
      return i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i))
    }
  }

  // TODO: Do we need both validateWire and trySelectWire?
  function validateWire () {
    if (wire.requests.length) return

    var i = self._selections.length
    while (i--) {
      var next = self._selections[i]
      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried)

        while (tries < len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece < 0) break
          if (self._request(wire, piece, false)) return
          tried[piece] = true
          tries += 1
        }
      } else {
        for (piece = next.to; piece >= next.from + next.offset; --piece) {
          if (!wire.peerPieces.get(piece)) continue
          if (self._request(wire, piece, false)) return
        }
      }
    }

    // TODO: wire failed to validate as useful; should we close it?
    // probably not, since 'have' and 'bitfield' messages might be coming
  }

  function speedRanker () {
    var speed = wire.downloadSpeed() || 1
    if (speed > SPEED_THRESHOLD) return function () { return true }

    var secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed
    var tries = 10
    var ptr = 0

    return function (index) {
      if (!tries || self.bitfield.get(index)) return true

      var missing = self.pieces[index].missing

      for (; ptr < self.wires.length; ptr++) {
        var otherWire = self.wires[ptr]
        var otherSpeed = otherWire.downloadSpeed()

        if (otherSpeed < SPEED_THRESHOLD) continue
        if (otherSpeed <= speed) continue
        if (!otherWire.peerPieces.get(index)) continue
        if ((missing -= otherSpeed * secs) > 0) continue

        tries--
        return false
      }

      return true
    }
  }

  function shufflePriority (i) {
    var last = i
    for (var j = i; j < self._selections.length && self._selections[j].priority; j++) {
      last = j
    }
    var tmp = self._selections[i]
    self._selections[i] = self._selections[last]
    self._selections[last] = tmp
  }

  function trySelectWire (hotswap) {
    if (wire.requests.length >= maxOutstandingRequests) return true
    var rank = speedRanker()

    for (var i = 0; i < self._selections.length; i++) {
      var next = self._selections[i]

      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried, rank)

        while (tries < len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece < 0) break

          // request all non-reserved blocks in this piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length < maxOutstandingRequests) {
            tried[piece] = true
            tries++
            continue
          }

          if (next.priority) shufflePriority(i)
          return true
        }
      } else {
        for (piece = next.from + next.offset; piece <= next.to; piece++) {
          if (!wire.peerPieces.get(piece) || !rank(piece)) continue

          // request all non-reserved blocks in piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length < maxOutstandingRequests) continue

          if (next.priority) shufflePriority(i)
          return true
        }
      }
    }

    return false
  }
}

/**
 * Called periodically to update the choked status of all peers, handling optimistic
 * unchoking as described in BEP3.
 */
Torrent.prototype._rechoke = function () {
  var self = this
  if (!self.ready) return

  if (self._rechokeOptimisticTime > 0) self._rechokeOptimisticTime -= 1
  else self._rechokeOptimisticWire = null

  var peers = []

  self.wires.forEach(function (wire) {
    if (!wire.isSeeder && wire !== self._rechokeOptimisticWire) {
      peers.push({
        wire: wire,
        downloadSpeed: wire.downloadSpeed(),
        uploadSpeed: wire.uploadSpeed(),
        salt: Math.random(),
        isChoked: true
      })
    }
  })

  peers.sort(rechokeSort)

  var unchokeInterested = 0
  var i = 0
  for (; i < peers.length && unchokeInterested < self._rechokeNumSlots; ++i) {
    peers[i].isChoked = false
    if (peers[i].wire.peerInterested) unchokeInterested += 1
  }

  // Optimistically unchoke a peer
  if (!self._rechokeOptimisticWire && i < peers.length && self._rechokeNumSlots) {
    var candidates = peers.slice(i).filter(function (peer) { return peer.wire.peerInterested })
    var optimistic = candidates[randomInt(candidates.length)]

    if (optimistic) {
      optimistic.isChoked = false
      self._rechokeOptimisticWire = optimistic.wire
      self._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION
    }
  }

  // Unchoke best peers
  peers.forEach(function (peer) {
    if (peer.wire.amChoking !== peer.isChoked) {
      if (peer.isChoked) peer.wire.choke()
      else peer.wire.unchoke()
    }
  })

  function rechokeSort (peerA, peerB) {
    // Prefer higher download speed
    if (peerA.downloadSpeed !== peerB.downloadSpeed) {
      return peerB.downloadSpeed - peerA.downloadSpeed
    }

    // Prefer higher upload speed
    if (peerA.uploadSpeed !== peerB.uploadSpeed) {
      return peerB.uploadSpeed - peerA.uploadSpeed
    }

    // Prefer unchoked
    if (peerA.wire.amChoking !== peerB.wire.amChoking) {
      return peerA.wire.amChoking ? 1 : -1
    }

    // Random order
    return peerA.salt - peerB.salt
  }
}

/**
 * Attempts to cancel a slow block request from another wire such that the
 * given wire may effectively swap out the request for one of its own.
 */
Torrent.prototype._hotswap = function (wire, index) {
  var self = this

  var speed = wire.downloadSpeed()
  if (speed < Piece.BLOCK_LENGTH) return false
  if (!self._reservations[index]) return false

  var r = self._reservations[index]
  if (!r) {
    return false
  }

  var minSpeed = Infinity
  var minWire

  var i
  for (i = 0; i < r.length; i++) {
    var otherWire = r[i]
    if (!otherWire || otherWire === wire) continue

    var otherSpeed = otherWire.downloadSpeed()
    if (otherSpeed >= SPEED_THRESHOLD) continue
    if (2 * otherSpeed > speed || otherSpeed > minSpeed) continue

    minWire = otherWire
    minSpeed = otherSpeed
  }

  if (!minWire) return false

  for (i = 0; i < r.length; i++) {
    if (r[i] === minWire) r[i] = null
  }

  for (i = 0; i < minWire.requests.length; i++) {
    var req = minWire.requests[i]
    if (req.piece !== index) continue

    self.pieces[index].cancel((req.offset / Piece.BLOCK_LENGTH) | 0)
  }

  self.emit('hotswap', minWire, wire, index)
  return true
}

/**
 * Attempts to request a block from the given wire.
 */
Torrent.prototype._request = function (wire, index, hotswap) {
  var self = this
  var numRequests = wire.requests.length
  var isWebSeed = wire.type === 'webSeed'

  if (self.bitfield.get(index)) return false

  var maxOutstandingRequests = isWebSeed
    ? Math.min(
        getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self.pieceLength),
        self.maxWebConns
      )
    : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  if (numRequests >= maxOutstandingRequests) return false
  // var endGame = (wire.requests.length === 0 && self.store.numMissing < 30)

  var piece = self.pieces[index]
  var reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()

  if (reservation === -1 && hotswap && self._hotswap(wire, index)) {
    reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()
  }
  if (reservation === -1) return false

  var r = self._reservations[index]
  if (!r) r = self._reservations[index] = []
  var i = r.indexOf(null)
  if (i === -1) i = r.length
  r[i] = wire

  var chunkOffset = piece.chunkOffset(reservation)
  var chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation)

  wire.request(index, chunkOffset, chunkLength, function onChunk (err, chunk) {
    // TODO: what is this for?
    if (!self.ready) return self.once('ready', function () { onChunk(err, chunk) })

    if (r[i] === wire) r[i] = null

    if (piece !== self.pieces[index]) return onUpdateTick()

    if (err) {
      self._debug(
        'error getting piece %s (offset: %s length: %s) from %s: %s',
        index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort,
        err.message
      )
      isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation)
      onUpdateTick()
      return
    }

    self._debug(
      'got piece %s (offset: %s length: %s) from %s',
      index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort
    )

    if (!piece.set(reservation, chunk, wire)) return onUpdateTick()

    var buf = piece.flush()

    // TODO: might need to set self.pieces[index] = null here since sha1 is async

    sha1(buf, function (hash) {
      if (hash === self._hashes[index]) {
        if (!self.pieces[index]) return
        self._debug('piece verified %s', index)

        self.pieces[index] = null
        self._reservations[index] = null
        self.bitfield.set(index, true)

        self.store.put(index, buf)

        self.wires.forEach(function (wire) {
          wire.have(index)
        })

        self._checkDone()
      } else {
        self.pieces[index] = new Piece(piece.length)
        self.emit('warning', new Error('Piece ' + index + ' failed verification'))
      }
      onUpdateTick()
    })
  })

  function onUpdateTick () {
    process.nextTick(function () { self._update() })
  }

  return true
}

Torrent.prototype._checkDone = function () {
  var self = this
  if (self.destroyed) return

  // are any new files done?
  self.files.forEach(function (file) {
    if (file.done) return
    for (var i = file._startPiece; i <= file._endPiece; ++i) {
      if (!self.bitfield.get(i)) return
    }
    file.done = true
    file.emit('done')
    self._debug('file done: ' + file.name)
  })

  // is the torrent done? (if all current selections are satisfied, or there are
  // no selections, then torrent is done)
  var done = true
  for (var i = 0; i < self._selections.length; i++) {
    var selection = self._selections[i]
    for (var piece = selection.from; piece <= selection.to; piece++) {
      if (!self.bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) break
  }
  if (!self.done && done) {
    self.done = true
    self._debug('torrent done: ' + self.infoHash)
    if (self.discovery.tracker) {
      self.discovery.tracker.complete()
    }
    self.emit('done')
  }

  self._gcSelections()
}

Torrent.prototype.load = function (streams, cb) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.ready) return self.once('ready', function () { self.load(streams, cb) })

  if (!Array.isArray(streams)) streams = [ streams ]
  if (!cb) cb = noop

  var readable = new MultiStream(streams)
  var writable = new ChunkStoreWriteStream(self.store, self.pieceLength)

  pump(readable, writable, function (err) {
    if (err) return cb(err)
    self.pieces.forEach(function (piece, index) {
      self.pieces[index] = null
      self._reservations[index] = null
      self.bitfield.set(index, true)
    })
    self._checkDone()
    cb(null)
  })
}

Torrent.prototype.createServer = function (opts) {
  if (typeof Server !== 'function') throw new Error('node.js-only method')
  if (this.destroyed) throw new Error('torrent is destroyed')
  var server = new Server(this, opts)
  this._servers.push(server)
  return server
}

Torrent.prototype.pause = function () {
  if (this.destroyed) return
  this._debug('pause')
  this.paused = true
}

Torrent.prototype.resume = function () {
  if (this.destroyed) return
  this._debug('resume')
  this.paused = false
  this._drain()
}

Torrent.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}

/**
 * Pop a peer off the FIFO queue and connect to it. When _drain() gets called,
 * the queue will usually have only one peer in it, except when there are too
 * many peers (over `this.maxConns`) in which case they will just sit in the
 * queue until another connection closes.
 */
Torrent.prototype._drain = function () {
  var self = this
  this._debug('_drain numConns %s maxConns %s', self._numConns, self.client.maxConns)
  if (typeof net.connect !== 'function' || self.destroyed || self.paused ||
      self._numConns >= self.client.maxConns) {
    return
  }
  this._debug('drain (%s queued, %s/%s peers)', self._numQueued, self.numPeers, self.client.maxConns)

  var peer = self._queue.shift()
  if (!peer) return // queue could be empty

  this._debug('tcp connect attempt to %s', peer.addr)

  var parts = addrToIPPort(peer.addr)
  var opts = {
    host: parts[0],
    port: parts[1]
  }

  var conn = peer.conn = net.connect(opts)

  conn.once('connect', function () { peer.onConnect() })
  conn.once('error', function (err) { peer.destroy(err) })
  peer.startConnectTimeout()

  // When connection closes, attempt reconnect after timeout (with exponential backoff)
  conn.on('close', function () {
    if (self.destroyed) return

    // TODO: If torrent is done, do not try to reconnect after a timeout

    if (peer.retries >= RECONNECT_WAIT.length) {
      self._debug(
        'conn %s closed: will not re-add (max %s attempts)',
        peer.addr, RECONNECT_WAIT.length
      )
      return
    }

    var ms = RECONNECT_WAIT[peer.retries]
    self._debug(
      'conn %s closed: will re-add to queue in %sms (attempt %s)',
      peer.addr, ms, peer.retries + 1
    )

    var reconnectTimeout = setTimeout(function reconnectTimeout () {
      var newPeer = self._addPeer(peer.addr)
      if (newPeer) newPeer.retries = peer.retries + 1
    }, ms)
    if (reconnectTimeout.unref) reconnectTimeout.unref()
  })
}

/**
 * Returns `true` if string is valid IPv4/6 address.
 * @param {string} addr
 * @return {boolean}
 */
Torrent.prototype._validAddr = function (addr) {
  var parts
  try {
    parts = addrToIPPort(addr)
  } catch (e) {
    return false
  }
  var host = parts[0]
  var port = parts[1]
  return port > 0 && port < 65535 &&
    !(host === '127.0.0.1' && port === this.client.torrentPort)
}

function getBlockPipelineLength (wire, duration) {
  return 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH)
}

function getPiecePipelineLength (wire, duration, pieceLength) {
  return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength)
}

/**
 * Returns a random integer in [0,high)
 */
function randomInt (high) {
  return Math.random() * high | 0
}

function noop () {}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":137,"./file":132,"./peer":133,"./rarity-map":134,"./server":17,"_process":73,"addr-to-ip-port":3,"bitfield":9,"chunk-store-stream/write":22,"debug":31,"events":35,"fs":18,"fs-chunk-store":53,"immediate-chunk-store":42,"inherits":43,"multistream":61,"net":17,"os":17,"parse-torrent":69,"path":70,"pump":74,"random-iterate":79,"run-parallel":90,"run-parallel-limit":89,"simple-get":94,"simple-sha1":96,"speedometer":98,"torrent-discovery":111,"torrent-piece":112,"uniq":115,"ut_metadata":119,"ut_pex":17,"xtend":139,"xtend/mutable":140}],136:[function(require,module,exports){
module.exports = WebConn

var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('webtorrent:webconn')
var get = require('simple-get')
var inherits = require('inherits')
var sha1 = require('simple-sha1')
var Wire = require('bittorrent-protocol')

var VERSION = require('../package.json').version

inherits(WebConn, Wire)

/**
 * Converts requests for torrent blocks into http range requests.
 * @param {string} url web seed url
 * @param {Object} torrent
 */
function WebConn (url, torrent) {
  Wire.call(this)

  this.url = url
  this.webPeerId = sha1.sync(url)
  this._torrent = torrent

  this._init()
}

WebConn.prototype._init = function () {
  var self = this
  self.setKeepAlive(true)

  self.once('handshake', function (infoHash, peerId) {
    if (self.destroyed) return
    self.handshake(infoHash, self.webPeerId)
    var numPieces = self._torrent.pieces.length
    var bitfield = new BitField(numPieces)
    for (var i = 0; i <= numPieces; i++) {
      bitfield.set(i, true)
    }
    self.bitfield(bitfield)
  })

  self.once('interested', function () {
    debug('interested')
    self.unchoke()
  })

  self.on('uninterested', function () { debug('uninterested') })
  self.on('choke', function () { debug('choke') })
  self.on('unchoke', function () { debug('unchoke') })
  self.on('bitfield', function () { debug('bitfield') })

  self.on('request', function (pieceIndex, offset, length, callback) {
    debug('request pieceIndex=%d offset=%d length=%d', pieceIndex, offset, length)
    self.httpRequest(pieceIndex, offset, length, callback)
  })
}

WebConn.prototype.httpRequest = function (pieceIndex, offset, length, cb) {
  var self = this
  var pieceOffset = pieceIndex * self._torrent.pieceLength
  var rangeStart = pieceOffset + offset /* offset within whole torrent */
  var rangeEnd = rangeStart + length - 1

  // Web seed URL format:
  // For single-file torrents, make HTTP range requests directly to the web seed URL
  // For multi-file torrents, add the torrent folder and file name to the URL
  var files = self._torrent.files
  var requests
  if (files.length <= 1) {
    requests = [{
      url: self.url,
      start: rangeStart,
      end: rangeEnd
    }]
  } else {
    var requestedFiles = files.filter(function (file) {
      return file.offset <= rangeEnd && (file.offset + file.length) > rangeStart
    })
    if (requestedFiles.length < 1) {
      return cb(new Error('Could not find file corresponnding to web seed range request'))
    }

    requests = requestedFiles.map(function (requestedFile) {
      var fileEnd = requestedFile.offset + requestedFile.length - 1
      var url = self.url +
        (self.url[self.url.length - 1] === '/' ? '' : '/') +
        requestedFile.path
      return {
        url: url,
        fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
        start: Math.max(rangeStart - requestedFile.offset, 0),
        end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
      }
    })
  }

  // Now make all the HTTP requests we need in order to load this piece
  // Usually that's one requests, but sometimes it will be multiple
  // Send requests in parallel and wait for them all to come back
  var numRequestsSucceeded = 0
  var hasError = false

  var ret
  if (requests.length > 1) {
    ret = Buffer.alloc(length)
  }

  requests.forEach(function (request) {
    var url = request.url
    var start = request.start
    var end = request.end
    debug(
      'Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d',
      url, pieceIndex, offset, length, start, end
    )
    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)',
        range: 'bytes=' + start + '-' + end
      }
    }
    get.concat(opts, function (err, res, data) {
      if (hasError) return
      if (err) {
        hasError = true
        return cb(err)
      }
      if (res.statusCode < 200 || res.statusCode >= 300) {
        hasError = true
        return cb(new Error('Unexpected HTTP status code ' + res.statusCode))
      }
      debug('Got data of length %d', data.length)

      if (requests.length === 1) {
        // Common case: fetch piece in a single HTTP request, return directly
        cb(null, data)
      } else {
        // Rare case: reconstruct multiple HTTP requests across 2+ files into one
        // piece buffer
        data.copy(ret, request.fileOffsetInRange)
        if (++numRequestsSucceeded === requests.length) {
          cb(null, ret)
        }
      }
    })
  })
}

WebConn.prototype.destroy = function () {
  Wire.prototype.destroy.call(this)
  this._torrent = null
}

},{"../package.json":137,"bitfield":9,"bittorrent-protocol":10,"debug":31,"inherits":43,"safe-buffer":92,"simple-get":94,"simple-sha1":96}],137:[function(require,module,exports){
module.exports={"version":"0.94.4"}
},{}],138:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],139:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],140:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],141:[function(require,module,exports){
/**
 * Given a number, return a zero-filled string.
 * From http://stackoverflow.com/questions/1267283/
 * @param  {number} width
 * @param  {number} number
 * @return {string}
 */
module.exports = function zeroFill (width, number, pad) {
  if (number === undefined) {
    return function (number, pad) {
      return zeroFill(width, number, pad)
    }
  }
  if (pad === undefined) pad = '0'
  width -= number.toString().length
  if (width > 0) return new Array(width + (/\./.test(number) ? 2 : 1)).join(pad) + number
  return number + ''
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJKYXNtaW5lX3Rlc3RzdWl0ZXNfaGVscC5qcyIsIk9ha1N0cmVhbWluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hZGRyLXRvLWlwLXBvcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtcHJvdG9jb2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0dG9ycmVudC10cmFja2VyL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR0b3JyZW50LXRyYWNrZXIvbGliL2NsaWVudC90cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtdHJhY2tlci9saWIvY2xpZW50L3dlYnNvY2tldC10cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtdHJhY2tlci9saWIvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2Jsb2ItdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jsb2NrLXN0cmVhbTIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci1zaGltcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVpbHRpbi1zdGF0dXMtY29kZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jaHVuay1zdG9yZS1zdHJlYW0vd3JpdGUuanMiLCJub2RlX21vZHVsZXMvY2xvc2VzdC10by9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21wYWN0MnN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLXRvcnJlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLXRvcnJlbnQvbm9kZV9tb2R1bGVzL2JlbmNvZGUvYmVuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtdG9ycmVudC9ub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS10b3JyZW50L25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9kaWN0LmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS10b3JyZW50L25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvZGVidWcvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9kZWZpbmVkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZC1vZi1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9maWxlc3RyZWFtL3JlYWQuanMiLCJub2RlX21vZHVsZXMvZmxhdHRlbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtYnJvd3Nlci1ydGMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGF0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbW1lZGlhdGUtY2h1bmstc3RvcmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGFkZHIuanMvbGliL2lwYWRkci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hc2NpaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZmlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy10eXBlZGFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanVuay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYWduZXQtdXJpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lbW9yeS1jaHVuay1zdG9yZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tcDQtYm94LWVuY29kaW5nL2JveGVzLmpzIiwibm9kZV9tb2R1bGVzL21wNC1ib3gtZW5jb2RpbmcvZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9tcDQtYm94LWVuY29kaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21wNC1zdHJlYW0vZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL21wNC1zdHJlYW0vZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL21wNC1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGlzdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmV4dC1ldmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMvcGFyc2UtdG9ycmVudC1maWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLXRvcnJlbnQtZmlsZS9ub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLXRvcnJlbnQtZmlsZS9ub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLXRvcnJlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BpZWNlLWxlbmd0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVtcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmRvbS1pdGVyYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmdlLXNsaWNlLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlbmRlci1tZWRpYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZW5kZXItbWVkaWEvbGliL21pbWUuanNvbiIsIm5vZGVfbW9kdWxlcy9ydW4tcGFyYWxsZWwtbGltaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcnVuLXBhcmFsbGVsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3J1c2hhL3J1c2hhLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLWNvbmNhdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2V0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zaGExL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXdlYnNvY2tldC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcGVlZG9tZXRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVzcG9uc2UuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLXRvLWJsb2ItdXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS10by1ibG9iL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS13aXRoLWtub3duLWxlbmd0aC10by1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nMmNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhpcnR5LXR3by9saWIvdGhpcnR5LXR3by9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aGlydHktdHdvL2xpYi90aGlydHktdHdvL3RoaXJ0eS10d28uanMiLCJub2RlX21vZHVsZXMvdG8tYXJyYXlidWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9ycmVudC1kaXNjb3ZlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9ycmVudC1waWVjZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90eXBlZGFycmF5LXRvLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91aW50NjRiZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlxL3VuaXEuanMiLCJub2RlX21vZHVsZXMvdW5vcmRlcmVkLWFycmF5LXJlbW92ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3V0X21ldGFkYXRhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0X3BleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dF9wZXgvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy91dF9wZXgvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZGVvc3RyZWFtL21wNC1yZW11eGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZGVvc3RyZWFtL3ZpZGVvc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvZmlsZS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvZmlsZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2xpYi9wZWVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvbGliL3Jhcml0eS1tYXAuanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvdG9ycmVudC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2xpYi93ZWJjb25uLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL211dGFibGUuanMiLCJub2RlX21vZHVsZXMvemVyby1maWxsL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3g1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3J1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuREE7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2o2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsSUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1M0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1WkE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqc0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIndpbmRvdy5PYWtTdHJlYW1pbmcgPSByZXF1aXJlKCcuL09ha1N0cmVhbWluZycpO1xyXG53aW5kb3cuaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcclxud2luZG93LldlYlRvcnJlbnQgPSByZXF1aXJlKCd3ZWJ0b3JyZW50Jyk7XHJcblxyXG5cclxuZG9jdW1lbnQuYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO1xyXG5cclxudmFyIHBhcmEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XHJcbnBhcmEuaWQgPSBcIm15VmlkZW9cIjtcclxucGFyYS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyYSk7XHJcblxyXG5wYXJhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XHJcbnBhcmEuaWQgPSBcIldlYlRvcnJlbnQtcmVjZWl2ZWRcIjtcclxucGFyYS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyYSk7XHJcblxyXG53aW5kb3cubXlTdHJlYW1pbmdBID0gbmV3IE9ha1N0cmVhbWluZyhcIm15U3RyZWFtaW5nQVwiKTtcclxud2luZG93Lm15U3RyZWFtaW5nQiA9IG5ldyBPYWtTdHJlYW1pbmcoXCJteVN0cmVhbWluZ0JcIik7XHJcbndpbmRvdy5teVN0cmVhbWluZ0MgPSBuZXcgT2FrU3RyZWFtaW5nKFwibXlTdHJlYW1pbmdDXCIpOyIsInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG52YXIgTXVsdGlTdHJlYW0gPSByZXF1aXJlKCdtdWx0aXN0cmVhbScpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxudmFyIHJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XHJcbnZhciBWaWRlb3N0cmVhbSA9IHJlcXVpcmUoJ3ZpZGVvc3RyZWFtJyk7XHJcbnZhciB1dF9wZXggPSByZXF1aXJlKCd1dF9wZXgnKTtcclxudmFyIFdlYlRvcnJlbnQgPSByZXF1aXJlKCd3ZWJ0b3JyZW50Jyk7XHJcbnZhciBTaW1wbGVQZWVyID0gcmVxdWlyZSgnc2ltcGxlLXBlZXInKTtcclxudmFyIHBhcnNlVG9ycmVudCA9IHJlcXVpcmUoJ3BhcnNlLXRvcnJlbnQnKTtcclxuXHJcblxyXG4gLyoqXHJcbiAqIEBtb2R1bGUgRlZTTFxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBGVlNMO1xyXG5cclxuXHJcbiAvKipcclxuICogQ3JlYXRlcyBhIG5ldyBGVlNMIGluc3RhbmNlIHdoaWNoIGhhcyB0aGUgbWV0aG9kcyBzdHJlYW1WaWRlbywgbG9hZFZpZGVvLCBjcmVhdGVTaWduYWxpbmdEYXRhLCBjcmVhdGVTaWduYWxpbmdEYXRhUmVzcG9uc2UsIHByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSBhbmQgc2V2ZXJhbCBzaW1wbGUgZ2V0IG1ldGhvZHMgIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovIFxyXG5mdW5jdGlvbiBGVlNMKE9ha05hbWUpe1xyXG4gICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgIChmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgcGVlcklkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMTAsMzAwKSArIDEpOyAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhcIlZlcnNpb246IEhlYWRodW50ZXIgICBJbiBPYWtTdHJlYW1pbmcgY29uc3RydWN0b3IuIHRoaXMubmFtZTogXCIgKyBPYWtOYW1lKTtcclxuICAgICAgdmFyIE9ha05hbWUgPSBPYWtOYW1lIHx8IFwiTm9OYW1lIEZWU0wgaW5zdGFuY2VcIjtcclxuICAgICAgXHJcbiAgICAgIC8vIE9ubHkgbWV0aG9kcyBzaG91bGQgYmUgcGFydCBvZiB0aGUgQVBJLCBpLmUuIG9ubHkgbWV0aG9kcyBzaG91bGQgYmUgcHVibGljYWxseSBhY2Nlc3NpYmxlLlxyXG4gICAgICAvLyBFdmVyeSBtZXRob2Qgc2hvdWxkIGhhdmUgYWNjZXNzIHRvIHRoZXNlIHZhcmlhYmxlcy4gVGhlcmVmb3JlIHRoZXkgYXJlIGRlZmluaWVkIGF0IHRoaXMgaGlnaCBzY29wZS5cclxuICAgICAgdmFyIHNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXIgPSAwO1xyXG4gICAgICB2YXIgY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YSA9IFtdO1xyXG4gICAgICB2YXIgdGhlVG9ycmVudCA9IG51bGw7XHJcbiAgICAgIHZhciBwZWVyc1RvQWRkID0gW107XHJcbiAgICAgIHZhciBieXRlc1JlY2VpdmVkRnJvbVNlcnZlciA9IDA7XHJcbiAgICAgIHZhciBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzID0gMDtcclxuICAgICAgdmFyIFNJWkVfT0ZfVklERU9fRklMRSA9IC00MjtcclxuICAgICAgXHJcbiAgICAgIHNlbGYuc3RyZWFtVmlkZW8gPSBzdHJlYW1WaWRlbztcclxuICAgICAgc2VsZi5sb2FkVmlkZW8gPSBsb2FkVmlkZW87XHJcbiAgICAgIHNlbGYuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICBzZWxmLmdldE51bWJlck9mQnl0ZXNEb3dubG9hZGVkRnJvbVNlcnZlciA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIHJldHVybiBieXRlc1JlY2VpdmVkRnJvbVNlcnZlcjtcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIHNlbGYuZ2V0TnVtYmVyT2ZCeXN0ZXNEb3dubG9hZGVkUDJQID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgaWYodGhlVG9ycmVudCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGVUb3JyZW50LmRvd25sb2FkZWQ7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBzZWxmLmdldE51bWJlck9mQnl0ZXNVcGxvYWRlZFAyUCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIGlmKHRoZVRvcnJlbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhlVG9ycmVudC51cGxvYWRlZDtcclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIHNlbGYuZ2V0UGVyY2VudGFnZURvd25sb2FkZWRUb3JyZW50ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgaWYodGhlVG9ycmVudCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGVUb3JyZW50LnByb2dyZXNzO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgc2VsZi5nZXRGaWxlU2l6ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIHJldHVybiBTSVpFX09GX1ZJREVPX0ZJTEU7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBzZWxmLmNyZWF0ZVNpZ25hbGluZ0RhdGEgPSBmdW5jdGlvbiAoY2FsbGJhY2spe1xyXG4gICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZENhbGxiYWNrID0gZmFsc2U7XHJcbiAgICAgICAgIHZhciBvYWtOdW1iZXIgPSBzaW1wbGVQZWVyQ3JlYXRpb25Db3VudGVyO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGEgZm9yIG9ha051bWJlcjogXCIgKyBvYWtOdW1iZXIpO1xyXG4gICAgICAgICBjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0gPSBuZXcgU2ltcGxlUGVlcih7aW5pdGlhdG9yOiB0cnVlLCB0aWNrbGU6IGZhbHNlfSk7XHJcbiAgICAgICAgIHNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXIrKztcclxuICAgICAgICAgXHJcbiAgICAgICAgIGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbb2FrTnVtYmVyXS5vbignc2lnbmFsJywgZnVuY3Rpb24gKHNpZ25hbGluZ0RhdGEpe1xyXG4gICAgICAgICAgICBpZighYWxyZWFkeUNhbGxlZENhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgYWxyZWFkeUNhbGxlZENhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgc2lnbmFsaW5nRGF0YS5vYWtOdW1iZXIgPSBvYWtOdW1iZXI7XHJcbiAgICAgICAgICAgICAgIGNhbGxiYWNrKHNpZ25hbGluZ0RhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgc2VsZi5jcmVhdGVTaWduYWxpbmdEYXRhUmVzcG9uc2UgPSBmdW5jdGlvbiAoc2lnbmFsaW5nRGF0YSwgY2FsbGJhY2spe1xyXG4gICAgICAgICB2YXIgb2FrTnVtYmVyID0gc2lnbmFsaW5nRGF0YS5vYWtOdW1iZXI7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gY3JlYXRlU2lnbmFsaW5nRGF0YVJlc3BvbnNlLiBJbiB0aGUgYmVnaW5uaW5nIG9ha051bWJlcjogXCIgKyBvYWtOdW1iZXIpO1xyXG4gICAgICAgICBkZWxldGUgc2lnbmFsaW5nRGF0YS5vYWtOdW1iZXI7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgbXlQZWVyID0gbmV3IFNpbXBsZVBlZXIoe2luaXRpYXRvcjogZmFsc2UsIHRpY2tsZTogZmFsc2V9KTtcclxuICAgICAgICAgdmFyIGluZGV4ID0gc2ltcGxlUGVlckNyZWF0aW9uQ291bnRlcjtcclxuICAgICAgICAgY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtpbmRleF0gPSBteVBlZXI7XHJcbiAgICAgICAgIHNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXIrKztcclxuICAgICAgICAgXHJcbiAgICAgICAgIG15UGVlci5vbignc2lnbmFsJywgZnVuY3Rpb24gKGFuc3dlclNpZ25hbGluZ0RhdGEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZSwgYWZ0ZXIgb25TaWduYWwgb2FrTnVtYmVyOiBcIiArIG9ha051bWJlcik7XHJcbiAgICAgICAgICAgIGFuc3dlclNpZ25hbGluZ0RhdGEub2FrTnVtYmVyID0gb2FrTnVtYmVyO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZSwgIG9iamVjdCB0aGF0IGlzIHJldHVybmVkIHdpdGggY2FsbGJhY2s6IFwiICsgSlNPTi5zdHJpbmdpZnkoYW5zd2VyU2lnbmFsaW5nRGF0YSkpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhhbnN3ZXJTaWduYWxpbmdEYXRhKTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgIG15UGVlci5zaWduYWwoc2lnbmFsaW5nRGF0YSk7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIG15UGVlci5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHNlbGYuYWRkU2ltcGxlUGVlckluc3RhbmNlKGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbaW5kZXhdLCB7fSwgZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcImFkZFNpbXBsZVBlZXJJbnN0YW5jZSBlbmRlZFwiKTt9KTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBzZWxmLnByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSA9IGZ1bmN0aW9uIChzaWduYWxpbmdEYXRhLCBjYWxsYmFjayl7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gcHJvY2Vzc1NpZ25hbGluZ1Jlc3BvbnNlLCAgc2lnbmFsaW5nRGF0YSBwYXJhbXRlcjogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWxpbmdEYXRhKSk7XHJcbiAgICAgICAgIHZhciBvYWtOdW1iZXIgPSBzaWduYWxpbmdEYXRhLm9ha051bWJlcjtcclxuICAgICAgICAgZGVsZXRlIHNpZ25hbGluZ0RhdGEub2FrTnVtYmVyO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIHByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSwgIG9ha051bWJlcjogXCIgKyBvYWtOdW1iZXIpO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcImNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGE6IFwiICsgY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YSk7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgKGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbb2FrTnVtYmVyXSkub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0VzdGFibGlzaGVkIGEgc2ltcGxlLXBlZXIgY29ubmVjdGlvbicpO1xyXG4gICAgICAgICAgICBzZWxmLmFkZFNpbXBsZVBlZXJJbnN0YW5jZShjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0pO1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIHByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSwgIG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byAuc2lnbmFsKCk6IFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmFsaW5nRGF0YSkpO1xyXG4gICAgICAgICBjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0uc2lnbmFsKHNpZ25hbGluZ0RhdGEpO1xyXG4gICAgICB9O1xyXG4gICAgICAgXHJcbiAgICAgICAvKipcclxuICAgICAgICogQHR5cGVkZWYgU3RyZWFtSW5mb3JtYXRpb25PYmplY3RcclxuICAgICAgICogQHR5cGUge29iamVjdH1cclxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1hZ25ldFVSSSAtIE1hZ25ldCBVUkkgb2YgdGhlIHRvcnJlbnQuIElmIHRoaXMgcHJvcGVydHkgaXMgdW5kZWZpbmVkLCBubyB2aWRlbyBkYXRhIHdpbGwgYmUgcmVxdWVzdGVkIGZyb20gdGhlIFdlYlRvcnJlbnQgbmV0d29yay5cclxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZpZGVvRmlsZVNpemUgLSBUaGUgc2l6ZSBpbiBieXRlIG9mIHRoZSB2aWRlbyBmaWxlIHRoYXQgd2FzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cclxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFhIUlBhdGggLSBUaGUgZmlsZSBwYXRoIChlLmcuIC9leGFtcGxlLm1wNCBvciAvdmlkZW9zL2V4YW1wbGUyLm1wNCkgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBYTUwgSFRUUCBSZXF1ZXN0cyB0byB0aGUgV2ViIHNlcnZlci4gVmlhIHRoZXNlIFhNTCBIVFRQIFJlcXVlc3RzLCB2aWRlbyBkYXRhIHdpbGwgYmUgcmVxdWVzdGVkIGZyb20gdGhlIFdlYiBzZXZlci4gSWYgdGhpcyBwcm9wZXJ0eSBpcyB1bmRlZmluZWQsIG5vIHZpZGVvIGRhdGEgd2lsbCBiZSByZXF1ZXN0ZWQgZnJvbSB0aGUgV2ViIHNlcnZlci5cclxuICAgICAgICovXHJcbiAgICAgICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBjYWxsYmFjayBPYWtTdHJlYW1pbmd+c3RyZWFtVmlkZW9GaW5pc2hlZFxyXG4gICAgICAgKiBAcGFyYW0ge1N0cmVhbUluZm9ybWF0aW9uT2JqZWN0fSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCAtIEFuIG9iamVjdCB0aGF0IG90aGVyIGNsaWVudHMvcGVlcnMgY2FuIHBhc3MgYXMgYW4gYXJndW1lbnQgdG8gdGhlaXIgbG9hZFZpZGVvIG1ldGhvZCB0byBkb3dubG9hZCB0aGUgdmlkZW8gZnJvbSBvdGhlciBjbGllbnRzL3BlZXJzIGFuZC9vciB0aGUgV2ViIFNlcnZlci5cclxuICAgICAgICovIFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFN0cmVhbXMgYSB2aWRlbyBmaWxlIHRvIGFsbCBvdGhlciBjbGllbnRzL3BlZXJzLlxyXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gdmlkZW9fZmlsZSAtIFRoZSB2aWRlbyBmaWxlIHRoYXQgc2hvdWxkIGJlIHN0cmVhbWVkIHRvIHRoZSBvdGhlciBjbGllbnRzL3BlZXJzLiBUaGlzIHBhcmFtdGVyIGNhbiBlaXRoZXIgYmUgYSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGV8VzNDIEZpbGUgb2JqZWN0fSwgYSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGVMaXN0fFczQyBGaWxlTGlzdH0sIGEge0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWx8Tm9kZSBCdWZmZXIgb2JqZWN0fSBvciBhIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9jbGFzc19zdHJlYW1fcmVhZGFibGV8UmVhZGFibGUgc3RyZWFtIG9iamVjdH0uXHJcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciB0aGUgY3JlYXRpb24gb2YgdGhlIFN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LCB0aGF0IGdldHMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucGF0aF90b19maWxlX29uX1hIUl9zZXJ2ZXIgLSBUaGUgcGF0aCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIFhNTCBIVFRQIFJlcXVlc3QgKFhIUikuIEEgdmFsaWQgcGF0aCB3b3VsZCBiZSwgZm9yIGV4YW1wbGUsIFwiL3ZpZGVvcy9hVmlkZW9GaWxlLm1wNFwiLiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHNldCBib3RoIHRoZSBwYXRoVG9GaWxlT25YSFJTZXJ2ZXIgYW5kIHRoZSBoYXNoVmFsdWUgcGFyYW10ZXIgZm9yIHN1Y2Nlc3NmdWxsIFhIUiByZXF1ZXN0cy4gSWYgdGhpcyBwcm9wZXJ0eSBhbmQgdGhlIGhhc2hWYWx1ZSBwcm9wZXJ0eSBpcyB1bmRlZmluZWQsIG5vIHZpZGVvIGRhdGEgd2lsbCBiZSByZXF1ZXN0ZWQgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5oYXNoX3ZhbHVlIC0gSGFzaCB2YWx1ZSBvZiB0aGUgdmlkZW8gZmlsZSB0aGF0IHNob3VsZCBieSByZXF1ZXN0ZWQgZnJvbSB0aGUgU1ZTTCBXZWJTZXJ2ZXIuIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gc2V0IGJvdGggdGhlIHBhdGhUb0ZpbGVPblhIUlNlcnZlciBhbmQgdGhlIGhhc2hWYWx1ZSBwYXJhbXRlciBmb3Igc3VjY2Vzc2Z1bGwgWEhSIHJlcXVlc3RzLiBJZiB0aGlzIHByb3BlcnR5IGFuZCB0aGUgaGFzaFZhbHVlIHByb3BlcnR5IGlzIHVuZGVmaW5lZCwgbm8gdmlkZW8gZGF0YSB3aWxsIGJlIHJlcXVlc3RlZCBmcm9tIHRoZSBzZXJ2ZXIuIFxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5YSFJfc2VydmVyX1VSTCAtIFVSTCBvZiBhIFhIUiBzZXJ2ZXIgdGhhdCBjYW4gc2VydmUgdGhlIHZpZGVvIGZpbGUuIElmIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldCwgWEhSIHdpbGwgYmUgc2VuZCB0byB0aGUgV2ViIHNlcnZlciB0aGF0IHNlcnZlZCB0aGUgV2ViIHBhZ2UuXHJcbiAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuWEhSX3BvcnQgLSBQb3J0IHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gY29tbXVuaWNhdGluZyB3aXRoIHRoZSBYSFIgc2VydmVyIHRoYXQgd2FzIHNwZWNpZmllZCBpbiB0aGUgWEhSU2VydmVyVVJMIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IHNob3VsZCBvbmx5IGJlIHNldCB3aGVuIHRoZSBYSFJTZXJ2ZXJVUkwgcHJvcGVydHkgaXMgc2V0IHRvby4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgODAuXHJcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRvd25sb2FkX2Zyb21fcDJwX3RpbWVfcmFuZ2UgLSBIb3cgbWFueSBzZWNvbmRzIG9mIHZpZGVvIHBsYXliYWNrIG11c3QgYmUgYnVmZmVyZWQgaW4gYWR2YW5jZSBzdWNoIHRoYXQgbm8gbW9yZSBkYXRhIHN0cmVhbXMgYXJlIHJlcXVlc3RlZCBmcm9tIHRoZSBXZWJUb3JyZW50IG5ldHdvcmsuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDIwIHNlY29uZHMuXHJcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNyZWF0ZV9yZWFkU3RyZWFtX3JlcXVlc3Rfc2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBieXRlIHJhbmdlIHJlcXVlc3RzIHRvIHRoZSBXZWJUb3JyZW50IG5ldHdvcmsuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDUwMDAwMDAgYnl0ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICogQHBhcmFtIHtPYWtTdHJlYW1pbmd+c3RyZWFtVmlkZW9GaW5pc2hlZH0gY2FsbGJhY2sgLSBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGdldHMgY2FsbGVkIHdpdGggdGhlIGdlbmVyYXRlZCBTdHJlYW1JbmZvcm1hdGlvbk9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBleGVjdXRpb24gb2Ygc3RyZWFtVmlkZW8uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBzdHJlYW1WaWRlbyh2aWRlb19maWxlLCBvcHRpb25zLCBjYWxsYmFjaywgcmV0dXJuVG9ycmVudCwgZGVzdHJveVRvcnJlbnQpeyBcclxuICAgICAgICAgdmFyIHdlYlRvcnJlbnRDbGllbnQgPSBuZXcgV2ViVG9ycmVudCgpO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwic3RyZWFtVmlkZW8gaXMgZXhlY3V0ZWRcIik7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJ2aWRlb0ZpbGU6IFwiICsgdmlkZW9GaWxlKTtcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm9wdGlvbnM6IFwiICsgb3B0aW9ucyk7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XHJcblxyXG4gICAgICAgICB2YXIgRE9XTkxPQURfRlJPTV9QMlBfVElNRV9SQU5HRSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmRvd25sb2FkRnJvbVAyUFRpbWVSYW5nZSB8fCAyMDsgLy8gaG93IG11Y2ggc2Vjb25kcyBtdXN0IGJlIGJ1ZmZlcmVkIGluIGFkdmFuY2Ugc3VjaCB0aGF0IG5vIG1vcmUgZGF0YSBzdHJlYW1zIGFyZSByZXF1ZXN0ZWQgZnJvbSB0aGUgUDJQIG5ldHdvcmsgICAgICAgICAgICAgICAgICBPbGQgRGVzY3JpYnRpb246IFRoaXMgaXMgdGhlIG1pbm9tdW0gYnl0ZSByYW5nZSB0aGF0IHRoZSBXZWJUb3JyZW50IGNsaWVudCB3aWxsIGRvd25sb2FkIGluIGFkdmFuY2UgKHJlZ2FyZGluZyB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbikgd2l0aCBhIHNlcXVlbnRpYWwgY2h1bmsgc2VsZWN0aW9uIHN0cmF0ZWd5LiBUaGlzIG1lYW5zIHRoZSB2aWRlbyBidWZmZXIgc2l6ZSBpbiBieXRlXHJcbiAgICAgICAgIHZhciBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5jcmVhdGVSZWFkc3RyZWFtUmVxdWVzdFNpemUgfHwgNTAwMDAwMDsgLy8gVGhlIHNpemUgb2YgdGhlIGNyZWF0ZVJlYWRzdHJlYW0gV2ViVG9ycmVudCByZXF1ZXN0cyBpbiBieXRlcy4gXHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgRE9XTkxPQURfRlJPTV9TRVJWRVJfVElNRV9SQU5HRSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmRvd25sb2FkRnJvbVNlcnZlclRpbWVSYW5nZSB8fCA1OyAvLyBpbiBzZWNvbmRzXHJcbiAgICAgICAgIHZhciBVUExPQURfTElNSVQgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC51cGxvYWRMaW1pdCB8fCAyOyAvLyBtdWx0aXBsaWVkIGJ5IG51bWJlciBvZiBkb3dubG9hZGVkIGJ5dGVzXHJcbiAgICAgICAgIHZhciBBRERJVElPTl9UT19VUExPQURfTElNSVQgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5hZGRpdGlvblRvVXBsb2FkTGltaXQgfHwgNTAwMDAwOyAvLyBhbW91bnQgb2YgYnl0ZSBhZGRlZCB0byB1cGxvYWQgbGltaXRcclxuICAgICAgICAgXHJcbiAgICAgICAgICBcclxuICAgICAgICAgdmFyIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0ID0ge307XHJcbiAgICAgICAgIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmRvd25sb2FkRnJvbVAyUFRpbWVSYW5nZSA9IG9wdGlvbnMuZG93bmxvYWRGcm9tUDJQVGltZVJhbmdlO1xyXG4gICAgICAgICBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5wYXRoVG9GaWxlT25YSFJTZXJ2ZXIgPSBvcHRpb25zLnBhdGhUb0ZpbGVPblhIUlNlcnZlcjtcclxuICAgICAgICAgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuWEhSUG9ydCA9IG9wdGlvbnMuWEhSUG9ydDtcclxuICAgICAgICAgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuaGFzaFZhbHVlID0gb3B0aW9ucy5oYXNoVmFsdWU7IFxyXG4gICAgICAgICBcclxuICAgICAgICAgLy92YXIgU0laRV9PRl9WSURFT19GSUxFID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3Quc2l6ZU9mVmlkZW9GaWxlO1xyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgIGlmKHZpZGVvRmlsZSl7XHJcbiAgICAgICAgICAgIHZhciBzZWVkaW5nT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZihvcHRpb25zLndlYlRvcnJlbnRUcmFja2Vycyl7XHJcbiAgICAgICAgICAgICAgIHNlZWRpbmdPcHRpb25zLmFubm91bmNlTGlzdCA9IG9wdGlvbnMud2ViVG9ycmVudFRyYWNrZXJzO1xyXG4gICAgICAgICAgICAgICAvL3NlZWRpbmdPcHRpb25zLmFubm91bmNlID0gb3B0aW9ucy53ZWJUb3JyZW50VHJhY2tlcnM7IC8vIG51ciB6dW0gdGVzdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7IFxyXG4gICAgICAgICAgICB3ZWJUb3JyZW50Q2xpZW50LnNlZWQodmlkZW9GaWxlLCBzZWVkaW5nT3B0aW9ucywgZnVuY3Rpb24odG9ycmVudCl7XHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidG9ycmVudCBmaWxlIGlzIHNlZWRlZFwiKTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZhciB0b3JyZW50RmlsZUFzQmxvYlVSTCA9IHRvcnJlbnQudG9ycmVudEZpbGVCbG9iVVJMO1xyXG4gICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgIHZhciBYSFJPck1ldGhvZEVuZEhhcHBlbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHRvcnJlbnRGaWxlQXNCbG9iVVJMLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcclxuICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50QXNCbG9iID0gdGhpcy5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgIGlmKFhIUk9yTWV0aG9kRW5kSGFwcGVuZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgWEhST3JNZXRob2RFbmRIYXBwZW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIC8vIG15QmxvYiBpcyBub3cgdGhlIGJsb2IgdGhhdCB0aGUgb2JqZWN0IFVSTCBwb2ludGVkIHRvLlxyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICAgICAgICAgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudmlkZW9GaWxlU2l6ZSA9IHRvcnJlbnQuZmlsZXNbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAvL3N0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRvcnJlbnRGaWxlID0gdG9ycmVudC50b3JyZW50RmlsZTtcclxuICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkJ1ZmZlci5pc0J1ZmZlcihzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZSk6IFwiICsgQnVmZmVyLmlzQnVmZmVyKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRvcnJlbnRGaWxlKSk7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZSAgc3RyaW5naWZpZWQ6IFxcblwiICsgSlNPTi5zdHJpbmdpZnkoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudG9ycmVudEZpbGUpKTtcclxuICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInBhcnNlVG9ycmVudChzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZSk6IFxcblwiICsgcGFyc2VUb3JyZW50KHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRvcnJlbnRGaWxlKSk7XHJcbiAgICAgICAgICAgICAgIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnBhcnNlZFRvcnJlbnQgPSAgcGFyc2VUb3JyZW50KHRvcnJlbnQudG9ycmVudEZpbGUpO1xyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5wYXJzZWRUb3JyZW50KSk7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJUSEVfUkVDRUlWRURfVE9SUkVOVF9GSUxFXFxuXCIgKyBwYXJzZVRvcnJlbnQoVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRSkpO1xyXG4gICAgICAgICAgICAgICB2YXIgYnVmZmVyVG9ycmVudCA9IHBhcnNlVG9ycmVudChzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5wYXJzZWRUb3JyZW50KTsgXHJcbiAgICAgICAgICAgICAgIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnBhdGhUb0ZpbGVUb1NlZWQgPSBvcHRpb25zLnBhdGhUb0ZpbGVUb1NlZWQ7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvL2lmKG9wdGlvbnMud2ViVG9ycmVudFRyYWNrZXJzKXsgU2NoYXVlbiBvYiBlcyBhdWNoIG9obmUgaWYgYmxvY2sgZHJ1bSBoZXJ1bSBsw6R1ZnRcclxuICAgICAgICAgICAgICAgICAgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QubWFnbmV0VVJJID0gdG9ycmVudC5tYWduZXRVUkk7XHJcbiAgICAgICAgICAgICAgICAgIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LndlYlRvcnJlbnRUcmFja2VycyA9IG9wdGlvbnMud2ViVG9ycmVudFRyYWNrZXJzO1xyXG4gICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gc3RyZWFtVmlkZW8gICAgXCIgKyBzZWxmLk9ha05hbWUgKyBcIi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgZ2V0cyBjcmVhdGVkXCIpO1xyXG4gICAgICAgICAgICAgICBzZWxmLmZvclRlc3RpbmdfY29ubmVjdGVkVG9OZXdXZWJUb3JyZW50UGVlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbiBzdHJlYW1WaWRlbyAgICBcIiArIHNlbGYuT2FrTmFtZSArIFwiLmZvclRlc3RpbmdfY29ubmVjdGVkVG9OZXdXZWJUb3JyZW50UGVlciBnZXRzIGV4ZWN1dGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICBpZihub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzIDw9IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzLS07XHJcbiAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja0NhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgdG9ycmVudC5vbignd2lyZScsIGZ1bmN0aW9uKHdpcmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighY2FsbGJhY2tDYWxsZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0NhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMtLTsgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdG9ycmVudC5vbignd2lyZScsIGZ1bmN0aW9uICh3aXJlKXtcclxuICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcysrOyAgXHJcbiAgICAgICAgICAgICAgIH0pOyAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYWRlZCBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdDpcXG5cIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0KSk7XHJcbiAgICAgICAgICAgICAgIGlmKHJldHVyblRvcnJlbnQgPT09IFwiSXQncyBhIHRlc3RcIil7XHJcbiAgICAgICAgICAgICAgICAgIGlmKGRlc3Ryb3lUb3JyZW50KXtcclxuICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRvcnJlbnQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2ViVG9ycmVudENsaWVudDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCwgdG9ycmVudCk7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0O1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZihYSFJPck1ldGhvZEVuZEhhcHBlbmQpe1xyXG4gICAgICAgICAgICAgICBjYWxsYmFjayhzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBYSFJPck1ldGhvZEVuZEhhcHBlbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0gIFxyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBjYWxsYmFjayBPYWtTdHJlYW1pbmd+bG9hZGVkVmlkZW9GaW5pc2hlZFxyXG4gICAgICAgKi8gXHJcbiAgICAgICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFN0cmVhbXMgYSB2aWRlbyBmaWxlIHRvIGFsbCBvdGhlciBjbGllbnRzL3BlZXJzLlxyXG4gICAgICAgKiBAcGFyYW0ge1N0cmVhbUluZm9ybWF0aW9uT2JqZWN0fSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCAtIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGFsbCBkYXRhIHRoYXQgaXMgbmVlZGVkIHRvIGluaXRpYXRlIGxvYWRpbmcgdGhlIHZpZGVvIGZyb20gb3RoZXIgcGVlcnMgYW5kL29yIGEgV2ViIHNlcnZlci4gU3RyZWFtSW5mb3JtYXRpb25PYmplY3RzIGNhbiBiZSBjcmVhdGVkIGJ5IHRoZSB7QGxpbmsgc3RyZWFtVmlkZW98c3RyZWFtVmlkZW99IG1ldGhvZC5cclxuICAgICAgICogQHBhcmFtIHtPYWtTdHJlYW1pbmd+bG9hZGVkVmlkZW9GaW5pc2hlZH0gY2FsbGJhY2sgLSBUaGlzIGNhbGxiYWNrIGdldHMgY2FsbGVkIHdoZW4gdGhlIHZpZGVvIGhhcyBiZWVuIGxvYWRlZCBlbnRpcmVseSBpbnRvIHRoZSBidWZmZXIgb2YgdGhlIHZpZGVvIHBsYXllci5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGxvYWRWaWRlbyhzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCwgY2FsbGJhY2ssIGVuZElmVmlkZW9Mb2FkZWQpeyAgICAgICAgIFxyXG4gICAgICAgICBjb25zb2xlLmxvZyhcImxvYWRWaWRlbyBpcyBjYWxsZWRcIik7XHJcbiAgICAgICAgIC8vLy8vL2NvbnNvbGUubG9nKFwib3B0aW9uIHBhcmFtdGVyOlxcblwiICsgSlNPTi5zdHJpbmdpZnkoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QpKTtcclxuICAgICAgICAgdmFyIGRlbGl2ZXJ5QnlTZXJ2ZXIgPSAoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QucGF0aFRvRmlsZU9uWEhSU2VydmVyIHx8IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0Lmhhc2hWYWx1ZSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgIHZhciBkZWxpdmVyeUJ5V2VidG9ycmVudCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnBhcnNlZFRvcnJlbnQgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgIHZhciBYSFJTZXJ2ZXJVUkwgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5YSFJTZXJ2ZXJVUkwgfHwgZmFsc2U7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5YSFJTZXJ2ZXJVUkw6IFwiICsgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuWEhSU2VydmVyVVJMKTtcclxuICAgICAgICAgdmFyIFhIUl9QT1JUID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuWEhSUG9ydCB8fCA4MDtcclxuICAgICAgICAgdmFyIHBhdGhUb0ZpbGVPblhIUlNlcnZlciA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnBhdGhUb0ZpbGVPblhIUlNlcnZlcjsgICAgICAgXHJcbiAgICAgICAgIHZhciBoYXNoVmFsdWUgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5oYXNoVmFsdWU7XHJcbiAgICAgICAgIHZhciB3ZWJUb3JyZW50VHJhY2tlcnMgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC53ZWJUb3JyZW50VHJhY2tlcnM7XHJcbiAgICAgICAgIC8vdmFyIGRlbGl2ZXJ5QnlXZWJ0b3JyZW50ID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QubWFnbmV0VVJJID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICAgICB2YXIgTUFHTkVUX1VSSSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0Lm1hZ25ldFVSSTtcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkJ1ZmZlci5pc0J1ZmZlcihzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZS5kYXRhKTogXCIgKyBCdWZmZXIuaXNCdWZmZXIoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudG9ycmVudEZpbGUuZGF0YSkpO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwic3RyZWFtSW5mb3JtYXRpb25PYmplY3QudG9ycmVudEZpbGU6XFxuXCIgKyBKU09OLnN0cmluZ2lmeShzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZSkpO1xyXG4gICAgICAgICB2YXIgVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnBhcnNlZFRvcnJlbnQ7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRTpcXG5cIiArIEpTT04uc3RyaW5naWZ5KFRIRV9SRUNFSVZFRF9UT1JSRU5UX0ZJTEUpKTtcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkJ1ZmZlci5pc0J1ZmZlcihUSEVfUkVDRUlWRURfVE9SUkVOVF9GSUxFKTogXCIgKyBCdWZmZXIuaXNCdWZmZXIoVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRSkpO1xyXG4gICAgICAgICBcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRIRV9SRUNFSVZFRF9UT1JSRU5UX0ZJTEVcXG5cIiArIHBhcnNlVG9ycmVudChUSEVfUkVDRUlWRURfVE9SUkVOVF9GSUxFKSk7XHJcbiAgICAgICAgIHZhciBTSVpFX09GX1ZJREVPX0ZJTEUgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5zaXplT2ZWaWRlb0ZpbGU7XHJcblxyXG4gICAgICAgICB2YXIgRE9XTkxPQURfRlJPTV9QMlBfVElNRV9SQU5HRSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmRvd25sb2FkRnJvbVAyUFRpbWVSYW5nZSB8fCAyMDsgLy8gaG93IG11Y2ggc2Vjb25kcyBtdXN0IGJlIGJ1ZmZlcmVkIGluIGFkdmFuY2Ugc3VjaCB0aGF0IG5vIG1vcmUgZGF0YSBzdHJlYW1zIGFyZSByZXF1ZXN0ZWQgZnJvbSB0aGUgUDJQIG5ldHdvcmsgICAgICAgICAgICAgICAgICBPbGQgRGVzY3JpYnRpb246IFRoaXMgaXMgdGhlIG1pbm9tdW0gYnl0ZSByYW5nZSB0aGF0IHRoZSBXZWJUb3JyZW50IGNsaWVudCB3aWxsIGRvd25sb2FkIGluIGFkdmFuY2UgKHJlZ2FyZGluZyB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbikgd2l0aCBhIHNlcXVlbnRpYWwgY2h1bmsgc2VsZWN0aW9uIHN0cmF0ZWd5LiBUaGlzIG1lYW5zIHRoZSB2aWRlbyBidWZmZXIgc2l6ZSBpbiBieXRlXHJcbiAgICAgICAgIHZhciBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5jcmVhdGVSZWFkc3RyZWFtUmVxdWVzdFNpemUgfHwgNTAwMDAwMDA7IC8vIFRoZSBzaXplIG9mIHRoZSBjcmVhdGVSZWFkc3RyZWFtIFdlYlRvcnJlbnQgcmVxdWVzdHMgaW4gYnl0ZXMuIFxyXG4gICAgICAgICBcclxuICAgICAgICAgdmFyIERPV05MT0FEX0ZST01fU0VSVkVSX1RJTUVfUkFOR0UgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5kb3dubG9hZEZyb21TZXJ2ZXJUaW1lUmFuZ2UgfHwgNTsgLy8gaW4gc2Vjb25kc1xyXG4gICAgICAgICB2YXIgVVBMT0FEX0xJTUlUID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudXBsb2FkTGltaXQgfHwgMjsgLy8gbXVsdGlwbGllZCBieSBudW1iZXIgb2YgZG93bmxvYWRlZCBieXRlc1xyXG4gICAgICAgICB2YXIgQURESVRJT05fVE9fVVBMT0FEX0xJTUlUID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuYWRkaXRpb25Ub1VwbG9hZExpbWl0IHx8IDUwMDAwMDsgLy8gYW1vdW50IG9mIGJ5dGUgYWRkZWQgdG8gdXBsb2FkIGxpbWl0XHJcbiAgICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgdmFyIFhIUl9SRVFVRVNUX1NJWkUgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC54aHJSZXF1ZXN0U2l6ZSB8fCA1MDAwMDsgLy8gaW4gYnl0ZVxyXG4gICAgICAgICB2YXIgVEhSRVNIT0xEX0ZPUl9SRVRVUk5JTkdfT0ZfQU5TV0VSX1NUUkVBTSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRocmVzaG9sZEZvclJldHVybmluZ0Fuc3dlclN0cmVhbSB8fCA1MDAwMDsgLy8gaW4gYnl0ZVxyXG5cclxuICAgICAgICAgdmFyIENIRUNLX0lGX0JVRkZFUl9GVUxMX0VOT1VHSF9JTlRFUlZBTCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoSW50ZXJ2YWwgfHwgMzAwOyAvLyBpbiBtaWxpc2Vjb25kc1xyXG4gICAgICAgICB2YXIgQ0hFQ0tfSUZfQU5TV0VSU1RSRUFNX1JFQURZX0lOVEVSVkFMID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuY2hlY2tJZkFuc3dlcnN0cmVhbVJlYWR5SW50ZXJ2YWwgfHwgMjAwOyAvLyBpbiBtaWxpc2Vjb25kc1xyXG4gICAgICAgICB2YXIgVVBEQVRFX0NIQVJUX0lOVEVSVkFMID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudXBkYXRlQ2hhcnRJbnRlcnZhbCB8fCAxMDAwOyAvLyBpbiBtaWxpc2Vjb25kc1xyXG4gICAgICAgICB2YXIgQ0hPS0VfSUZfTkVDRVNTQVJZX0lOVEVSVkFMID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuY2hva2VJZk5lY2Vzc2FyeUludGVydmFsIHx8IDUwMDsgLy8gaW4gbWlsaXNlY29uZHNcclxuICAgICAgICAgdmFyIENIRUNLX0lGX05FV19DUkVBVEVfUkVBRFNUUkVBTV9ORUNFU1NBUllfSU5URVJWQUwgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5jaGVja0lmTmV3Q3JlYXRlUmVhZHN0cmVhbUludGVydmFsIHx8IDUwMCA7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIHZhciBlbmRTdHJlYW1pbmcgPSBmYWxzZTtcclxuICAgICAgICAgdmFyIHdlYlRvcnJlbnRDbGllbnQgPSBudWxsO1xyXG4gICAgICAgICB2YXIgd2lyZXMgPSBbXTtcclxuICAgICAgICAgdmFyIGNvbnNvbGVDb3VudGVyID0gMDtcclxuICAgICAgICAgdmFyIGdsb2JhbHZpZGVvc3RyZWFtUmVxdWVzdE51bWJlciA9IDA7XHJcbiAgICAgICAgIGJ5dGVzUmVjZWl2ZWRGcm9tU2VydmVyID0gMDtcclxuICAgICAgICAgdmFyIHdlYlRvcnJlbnRGaWxlO1xyXG4gICAgICAgICB2YXIgdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnMgPSBbXTtcclxuICAgICAgICAgdmFyIGluQ3JpdGljYWwgPSB0cnVlO1xyXG4gICAgICAgICB2YXIgdmlkZW9Db21wbGV0ZWx5TG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgIHZhciBieXRlc1Rha2VuRnJvbVdlYlRvcnJlbnQgPSAwO1xyXG4gICAgICAgICB2YXIgYnl0ZXNUYWtlbkZyb21TZXJ2ZXIgPSAwOyAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgXHJcbiAgICAgICAgIHZhciBteVZpZGVvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcclxuICAgICAgICAgbXlWaWRlby5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG15VmlkZW8uZXJyb3IpO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgICAgXHJcbiAgICAgICAgIGZ1bmN0aW9uIE15UmVhZGFibGVTdHJlYW0ob3B0aW9ucyl7XHJcbiAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtLlJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdXRpbC5pbmhlcml0cyhNeVJlYWRhYmxlU3RyZWFtLCByZWFkYWJsZVN0cmVhbS5SZWFkYWJsZSk7XHJcbiAgICAgICAgIE15UmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oc2l6ZSl7fTtcclxuICAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgIGlmKGRlbGl2ZXJ5QnlXZWJ0b3JyZW50KXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJlbnRlcmVkIGlmKGRlbGl2ZXJ5QnlXZWJ0b3JyZW50KVwiKTtcclxuICAgICAgICAgICAgd2ViVG9ycmVudENsaWVudCA9IG5ldyBXZWJUb3JyZW50KCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9USEVfUkVDRUlWRURfVE9SUkVOVF9GSUxFIFxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgd2ViVG9ycmVudE9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgLyogV2Vpw58gbmljaHQgbWVociB3YXJ1bSBkYXMgaGllciBzdGVodFxyXG4gICAgICAgICAgICBpZihzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5wYXRoVG9GaWxlVG9TZWVkKXtcclxuICAgICAgICAgICAgICAgd2ViVG9ycmVudE9wdGlvbnMucGF0aCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnBhdGhUb0ZpbGVUb1NlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudG9ycmVudEFzQmxvYik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB3ZWJUb3JyZW50Q2xpZW50LmFkZCh1cmwsIHdlYlRvcnJlbnRPcHRpb25zLCBmdW5jdGlvbiAodG9ycmVudCl7ICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ3ZWJUb3JyZW50Q2xpZW50LmFkZCAgIHRvcnJlbnQgbWV0YSBkYXRhIHJlYWR5XCIpOyAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB0aGVUb3JyZW50ID0gdG9ycmVudDtcclxuICAgICAgICAgICAgICAgd2ViVG9ycmVudEZpbGUgPSB0b3JyZW50LmZpbGVzWzBdO1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8IHBlZXJzVG9BZGQubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgICB0aGVUb3JyZW50LmFkZFBlZXIocGVlcnNUb0FkZFtqXVswXSk7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHBlZXJzVG9BZGRbal1bMV0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAocGVlcnNUb0FkZFtqXVsxXSkoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJJbiBsb2FkVmlkZW8gdHlwZW9mIHdlYlRvcnJlbnRGaWxlIGFmdGVyIGFzc2lnbm1lbnQ6IFwiICsgdHlwZW9mIHdlYlRvcnJlbnRGaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gbG9hZFZpZGVvICAgIFwiICsgc2VsZi5PYWtOYW1lICsgXCIuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyIGdldHMgY3JlYXRlZFwiKTtcclxuICAgICAgICAgICAgICAgc2VsZi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gbG9hZFZpZGVvICAgICBcIiArIHNlbGYuT2FrTmFtZSArIFwiLmZvclRlc3RpbmdfY29ubmVjdGVkVG9OZXdXZWJUb3JyZW50UGVlciAgIGdldHMgY2FsbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICBpZihub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzIDw9IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzLS07XHJcbiAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja0NhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgdG9ycmVudC5vbignd2lyZScsIGZ1bmN0aW9uKHdpcmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighY2FsbGJhY2tDYWxsZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0NhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMtLTsgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdG9ycmVudC5vbignd2lyZScsIGZ1bmN0aW9uICh3aXJlKXtcclxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0b3JyZW50Lm9uKCd3aXJlJywgLi4pIGlzIGZpcmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICB3aXJlcy5wdXNoKHdpcmUpO1xyXG4gICAgICAgICAgICAgICAgICBpZighd2luZG93LmZpcnN0V2lyZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5maXJzdFdpcmUgPSB3aXJlO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMrKztcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICB3aXJlLnVzZSh1dF9wZXgoKSk7XHJcbiAgICAgICAgICAgICAgICAgIC8vd2lyZS51dF9wZXguc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgIHdpcmUudXRfcGV4Lm9uKCdwZWVyJywgZnVuY3Rpb24gKHBlZXIpe1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGVUb3JyZW50LmFkZFBlZXIocGVlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vIGdvdCBhIHBlZXJcclxuICAgICAgICAgICAgICAgICAgICAgLy8gcHJvYmFibHkgYWRkIGl0IHRvIHBlZXIgY29ubmVjdGlvbnMgcXVldWVcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgZm9yKHZhciBpPTAsIGxlbmd0aD12aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVycy5sZW5ndGg7IGk8bGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICB2YXIgdGhpc1JlcXVlc3QgPSB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkluIG9uVG9ycmVudCBuYWNodHLDpGdsaWNoIHdlYnRvcnJlbnQgc3RyZWFtIGVyemV1Z2VuICB0aGlzUmVxdWVzdC5zdGFydDogXCIgKyB0aGlzUmVxdWVzdC5zdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJJbiBvblRvcnJlbnQgIHdlYlRvcnJlbnRGaWxlLmxlbmd0aDogXCIgKyB3ZWJUb3JyZW50RmlsZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFID4gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5jcmVhdGVSZWFkU3RyZWFtKHtcInN0YXJ0XCIgOiB0aGlzUmVxdWVzdC5zdGFydCwgXCJlbmRcIiA6IGVuZENyZWF0ZVJlYWRTdHJlYW19KTtcclxuICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiAhPT0gbnVsbCAmJiB0aGlzUmVxdWVzdC5zdGFydCA+IHRoaXNSZXF1ZXN0Lmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtICYmIHRoaXNSZXF1ZXN0LnN0YXJ0IDwgdGhpc1JlcXVlc3QudmlkZW9GaWxlU2l6ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRDcmVhdGVSZWFkU3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRSA+PSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtID0gd2ViVG9ycmVudEZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XCJzdGFydFwiIDogdGhpc1JlcXVlc3Quc3RhcnQsIFwiZW5kXCIgOiBlbmRDcmVhdGVSZWFkU3RyZWFtfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnVucGlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBpcGUodGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgPSB0aGlzUmVxdWVzdC5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5waXBlKHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgdmFyIGZpbGVMaWtlT2JqZWN0ID0gZnVuY3Rpb24gKHBhdGhUb0ZpbGVPblhIUlNlcnZlcil7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aFRvRmlsZU9uWEhSU2VydmVyID0gcGF0aFRvRmlsZU9uWEhSU2VydmVyO1xyXG4gICAgICAgICB9O1xyXG4gICAgICAgICBmaWxlTGlrZU9iamVjdC5wcm90b3R5cGUuY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uIChvcHRzKXtcclxuICAgICAgICAgICAgaWYob3B0cy5zdGFydCA+IFNJWkVfT0ZfVklERU9fRklMRSl7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJvcHRzLnN0YXJ0ID4gU0laRV9PRl9WSURFT19GSUxFIHRoZXJlIGNiKG51bGwsbnVsbCkgZXZlcnkgdGltZVwiKTtcclxuICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgTXVsdGlTdHJlYW0oZnVuY3Rpb24gKGNiKXtjYihudWxsLCBudWxsKTt9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5Dcml0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiIGNhbGxlZCBjcmVhdGVyZWFkU3RyZWFtIFwiKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgb3B0cy5zdGFydDogXCIgKyBvcHRzLnN0YXJ0KTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgb3B0cy5lbmQ6IFwiICsgb3B0cy5lbmQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRoaXNSZXF1ZXN0ID0gbmV3IFZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXIoKytnbG9iYWx2aWRlb3N0cmVhbVJlcXVlc3ROdW1iZXIsIG9wdHMsIHRoaXMpO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihvcHRzLmVuZCAmJiAhaXNOYU4ob3B0cy5lbmQpKXtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuZW5kID0gb3B0cy5lbmQgKyAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5lbmQgPSBTSVpFX09GX1ZJREVPX0ZJTEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBNeVdyaXRlYWJsZVN0cmVhbSA9IGZ1bmN0aW9uKGhpZ2hXYXRlck1hcmspe1xyXG4gICAgICAgICAgICAgICByZWFkYWJsZVN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMsIGhpZ2hXYXRlck1hcmspO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB1dGlsLmluaGVyaXRzKE15V3JpdGVhYmxlU3RyZWFtLCByZWFkYWJsZVN0cmVhbS5Xcml0YWJsZSk7XHJcbiAgICAgICAgICAgIE15V3JpdGVhYmxlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGRvbmUpe1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTXlXcml0ZWFibGVTdHJlYW0gX3dyaXRlIGlzIGNhbGxlZFwiKTsgICAgICAgXHJcbiAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LnN0YXJ0LXRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA8IGNodW5rLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJNeVdyaXRlYWJsZVN0cmVhbSBfd3JpdGU6IHB1c2hpbmcgcmVjZWl2ZWQgZGF0YSBpbiBhbnN3ZXJTdHJlYW1cIilcclxuICAgICAgICAgICAgICAgICAgYnl0ZXNUYWtlbkZyb21XZWJUb3JyZW50ICs9IGNodW5rLmxlbmd0aCAtICh0aGlzUmVxdWVzdC5zdGFydC10aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgc3RyZWFtSGFzTWVtb3J5TGVmdCA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKGNodW5rLnNsaWNlKHRoaXNSZXF1ZXN0LnN0YXJ0LXRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCwgY2h1bmsubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gKz0gY2h1bmsubGVuZ3RoIC0gKHRoaXNSZXF1ZXN0LnN0YXJ0LXRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBpZihzdHJlYW1IYXNNZW1vcnlMZWZ0KXsgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsICYmIHRoaXNSZXF1ZXN0LnN0YXJ0ID49IHRoaXNSZXF1ZXN0LmVuZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFja0Z1bmN0aW9uID0gdGhpc1JlcXVlc3QuY3VycmVudENCO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgQ0Igd2l0aCBkYXRhIG91dCBvZiBhbnN3ZXJTdHJlYW0gZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrRnVuY3Rpb24obnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm5vTW9yZURhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRDQjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudENCID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0gPSBuZXcgTXlSZWFkYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogNTAwMDAwMH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5zdGFydCArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQtdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50KTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAvL2NlY2tJZkFuc3dlclN0cmVhbVJlYWR5KHRoaXNSZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50ICs9IGNodW5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5jb2xsZWN0b3JTdHJlYW1Gb3JXZWJ0b3JyZW50ID0gbmV3IE15V3JpdGVhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwMH0pO1xyXG4gICAgICAgICAgICB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVycy5wdXNoKHRoaXNSZXF1ZXN0KTtcclxuXHJcbiAgICAgICAgICAgIGlmKHdlYlRvcnJlbnRGaWxlICYmIHRoZVRvcnJlbnQudXBsb2FkZWQgPD0gVVBMT0FEX0xJTUlUICogdGhlVG9ycmVudC5kb3dubG9hZGVkICsgQURESVRJT05fVE9fVVBMT0FEX0xJTUlUKXtcclxuICAgICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcImFmdGVyIG5ldyB2aWRlb3N0cmVhbVJlcXVlc3QgY3JlYXRpbmcgYSBjb3JyZXNwb25kaW5nIHdlYnRvcnJlbnQgc3RyZWFtXCIpO1xyXG4gICAgICAgICAgICAgICAvLy8vY29uc29sZS5sb2coXCJvcHRzLnN0YXJ0OiBcIiArIG9wdHMuc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAvLy8vY29uc29sZS5sb2coXCJ3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgd2ViVG9ycmVudEZpbGUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB2YXIgZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPj0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTE7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtID0gd2ViVG9ycmVudEZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XCJzdGFydFwiIDogdGhpc1JlcXVlc3Quc3RhcnQsIFwiZW5kXCIgOiBlbmRDcmVhdGVSZWFkU3RyZWFtfSk7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtID0gZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50ID0gdGhpc1JlcXVlc3Quc3RhcnQ7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnVucGlwZSgpO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBpcGUodGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBtdWx0aSA9IG5ldyBNdWx0aVN0cmVhbShmdW5jdGlvbiAoY2Ipe1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVhZGFibGVTdHJlYW0gcmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyICsgXCIgICAgZG9lcyBhIGNiIHJlcXVlc3RcIik7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmVuZCA+PSAwICYmIHRoaXNSZXF1ZXN0LnN0YXJ0ID49IHRoaXNSZXF1ZXN0LmVuZCl7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgY2IobnVsbCxudWxsKSBmcm9tIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7IFxyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5yZXEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuQ0JOdW1iZXIrKztcclxuICAgICAgICAgICAgICAgaWYoY29uc29sZUNvdW50ZXI8MjApe1xyXG4gICAgICAgICAgICAgICAgICAvLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgICAgXCIgKyB0aGlzUmVxdWVzdC5DQk51bWJlciArIFwiLiBjYWxsIG9mIGZ1bmN0aW9uKGNiKSBmcm9tIFwiICsgdmlkZW9zdHJlYW1SZXF1ZXN0TnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgICAgc3RhcnQ6IFwiICsgdGhpc1JlcXVlc3Quc3RhcnQpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiA9IGNiO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ub01vcmVEYXRhID0gZmFsc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBpZighY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkodGhpc1JlcXVlc3QpKXtcclxuICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucmVzdW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih3ZWJUb3JyZW50RmlsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJOZXcgY2IgZnVuY3Rpb24gd2FzIGNhbGxlZCBhbmQgSSBzdWJzZXF1ZW50bHkgY3JlYXRlIGEgbmV3IHRvcnJlbnRTdHJlYW0gZm9yIGl0IGJlY2F1c2Ugbm9uIGV4aXN0ZWQgYmVmb3JlIGZvciB0aGlzIHZpZGVvc3RyZWFtUmVxdWVzdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgLy8vL2NvbnNvbGUubG9nKFwiQWZ0ZXIgbmV3IE11bHRpc3RyZWFtLiB0aGlzUmVxdWVzdC5zdGFydDogXCIgKyB0aGlzUmVxdWVzdC5zdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vLy9jb25zb2xlLmxvZyhcIndlYlRvcnJlbnRGaWxlLmxlbmd0aDogXCIgKyB3ZWJUb3JyZW50RmlsZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPj0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtID0gd2ViVG9ycmVudEZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XCJzdGFydFwiIDogdGhpc1JlcXVlc3Quc3RhcnQsIFwiZW5kXCIgOiBlbmRDcmVhdGVSZWFkU3RyZWFtfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtID0gZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50ID0gdGhpc1JlcXVlc3Quc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnVucGlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBpcGUodGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmKGRlbGl2ZXJ5QnlTZXJ2ZXIgJiYgaW5Dcml0aWNhbCAmJiAhdGhpc1JlcXVlc3QuWEhSQ29uZHVjdGVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgY29uZHVjdFhIUih0aGlzUmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgdGVybWluYXRlIGNyZWF0ZVJlYWRTdHJlYW1cIik7XHJcbiAgICAgICAgICAgIHZhciBkZXN0cm95ID0gbXVsdGkuZGVzdHJveTtcclxuICAgICAgICAgICAgbXVsdGkuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdC5yZXEpIHtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QucmVxLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBkZXN0cm95LmNhbGwobXVsdGkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbXVsdGk7XHJcbiAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgZnVuY3Rpb24gZnJlcXVlbnRseUNoZWNrSWZOZXdDcmVhdGVSZWFkU3RyZWFtTmVjZXNzYXJ5KCl7XHJcbiAgICAgICAgICAgICAgIGlmKHZpZGVvQ29tcGxldGVseUxvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfSAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGlmKG15VmlkZW8uZHVyYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgICB2YXIgdGltZVJhbmdlcyA9IG15VmlkZW8uYnVmZmVyZWQ7ICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGltZVJhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmIChteVZpZGVvLmN1cnJlbnRUaW1lID49IHRpbWVSYW5nZXMuc3RhcnQoaSkgJiYgbXlWaWRlby5jdXJyZW50VGltZSA8PSB0aW1lUmFuZ2VzLmVuZChpKSszKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lUmFuZ2VzLmVuZChpKSAtIG15VmlkZW8uY3VycmVudFRpbWUgPD0gRE9XTkxPQURfRlJPTV9QMlBfVElNRV9SQU5HRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNSZXF1ZXN0ID0gdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5jdXJyZW50Q0IgIT09IG51bGwgJiYgdGhpc1JlcXVlc3Quc3RhcnQgPiB0aGlzUmVxdWVzdC5sYXN0RW5kQ3JlYXRlUmVhZFN0cmVhbSAmJiB0aGlzUmVxdWVzdC5zdGFydCA8IHRoaXNSZXF1ZXN0LnZpZGVvRmlsZVNpemUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPj0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1wic3RhcnRcIiA6IHRoaXNSZXF1ZXN0LnN0YXJ0LCBcImVuZFwiIDogZW5kQ3JlYXRlUmVhZFN0cmVhbX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgPSB0aGlzUmVxdWVzdC5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS51bnBpcGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5waXBlKHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmcmVxdWVudGx5Q2hlY2tJZk5ld0NyZWF0ZVJlYWRTdHJlYW1OZWNlc3NhcnksIENIRUNLX0lGX05FV19DUkVBVEVfUkVBRFNUUkVBTV9ORUNFU1NBUllfSU5URVJWQUwpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gICBcclxuICAgICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICBmdW5jdGlvbiBjZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSh0aGlzUmVxdWVzdCl7XHJcbiAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJBdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW06IFwiICsgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSk7XHJcbiAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJJbiBjZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSBvZiB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlciArICBcIi4gdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbTogXCIgKyB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtICsgXCIgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQjogXCIgKyB0aGlzUmVxdWVzdC5jdXJyZW50Q0IpO1xyXG4gICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QuY3VycmVudENCICYmICgodGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA+PSBUSFJFU0hPTERfRk9SX1JFVFVSTklOR19PRl9BTlNXRVJfU1RSRUFNKSB8fCAodGhpc1JlcXVlc3Quc3RhcnQgPj0gU0laRV9PRl9WSURFT19GSUxFKSkpe1xyXG4gICAgICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW0gUmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyICsgXCIgYW5kIENCIG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LkNCTnVtYmVyICsgXCIgZ2V0cyByZXR1cm5lZFwiKTtcclxuICAgICAgICAgICAgICAgLy8gLy8vLy8vY29uc29sZS5sb2coXCJSZXR1cmluZyBhbnN3ZXJTdHJlYW0gb3V0IG9mIGNlY2tJZkFuc3dlclN0cmVhbVJlYWR5KClcIik7XHJcbiAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFja0Z1bmN0aW9uID0gdGhpc1JlcXVlc3QuY3VycmVudENCO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0pe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwfSk7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgQ0Igd2l0aCBkYXRhIG91dCBvZiBhbnN3ZXJTdHJlYW0gZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrRnVuY3Rpb24obnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICBmdW5jdGlvbiBjaG9rZUlmTmVjZXNzYXJ5KCl7XHJcbiAgICAgICAgICAgICAgIGlmICh0aGVUb3JyZW50ICYmIHRoZVRvcnJlbnQudXBsb2FkZWQgPj0gdGhlVG9ycmVudC5kb3dubG9hZGVkICogVVBMT0FEX0xJTUlUICsgQURESVRJT05fVE9fVVBMT0FEX0xJTUlUKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8qIG1hY2hlIGljaCBzY2hvbiBpbiBlaW5lciBhbmRlcmVuIGZyZXF1ZW50IG1ldGhvZGVcclxuICAgICAgICAgICAgICAgICAgaWYodmlkZW9Db21wbGV0ZWx5TG9hZGVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgdGhlVG9ycmVudC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3ZWJUb3JyZW50Q2xpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICBlbmRTdHJlYW1pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHdpcmVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkkgY2hva2VkIGEgcGVlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgd2lyZXNbaV0uY2hva2UoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hva2VJZk5lY2Vzc2FyeSwgQ0hPS0VfSUZfTkVDRVNTQVJZX0lOVEVSVkFMKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2hhcnQoKXtcclxuICAgICAgICAgICAgICAgaWYoZW5kU3RyZWFtaW5nKXtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGlmKHRoZVRvcnJlbnQgJiYgd2ViVG9ycmVudEZpbGUpe1xyXG4gICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIldlYlRvcnJlbnQtcmVjZWl2ZWRcIikuaW5uZXJIVE1MID0gXCJ3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgd2ViVG9ycmVudEZpbGUubGVuZ3RoICsgXCJcXG4gdG9ycmVudC5kb3dubG9hZGVkOiBcIiArIHRoZVRvcnJlbnQuZG93bmxvYWRlZCArIFwiXFxuIHRvcnJlbnQudXBsb2FkZWQ6IFwiICsgdGhlVG9ycmVudC51cGxvYWRlZCArIFwiXFxuIHRvcnJlbnQucHJvZ3Jlc3M6IFwiICsgdGhlVG9ycmVudC5wcm9ncmVzcyArIFwiXFxuIEJ5dGVzIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIiArIGJ5dGVzUmVjZWl2ZWRGcm9tU2VydmVyICsgXCJcXG4gQnl0ZXMgdGFrZW4gZnJvbSBzZXJ2ZXIgZGVsaXZlcnk6IFwiICsgYnl0ZXNUYWtlbkZyb21TZXJ2ZXIgKyBcIlxcbiBCeXRlcyB0YWtlbiBmcm9tIFdlYlRvcnJlbnQgZGVsaXZlcnk6IFwiICsgYnl0ZXNUYWtlbkZyb21XZWJUb3JyZW50O1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQodXBkYXRlQ2hhcnQsIFVQREFURV9DSEFSVF9JTlRFUlZBTCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICBmdW5jdGlvbiBWaWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyKHJlYWRTdHJlYW1OdW1iZXIsIG9wdHMsIHNlbGYpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkU3RyZWFtTnVtYmVyID0gcmVhZFN0cmVhbU51bWJlcjtcclxuICAgICAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcclxuICAgICAgICAgICAgdGhpcy5zdGFydCA9IG9wdHMuc3RhcnQgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5vbGRTdGFydFdlYlRvcnJlbnQgPSAtNDI7XHJcbiAgICAgICAgICAgIHRoaXMub2xkU3RhcnRTZXJ2ZXIgPSAtNDI7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENCID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5DQk51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMud2ViVG9ycmVudFN0cmVhbSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IDUwMDAwMDB9KTtcclxuICAgICAgICAgICAgdGhpcy5ieXRlc0luQW5zd2VyU3RyZWFtID0gMDtcclxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0b3JTdHJlYW1Gb3JXZWJ0b3JyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5YSFJDb25kdWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSAtNDI7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZiA9IHNlbGY7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNUYWtlbkZyb21XZWJUb3JyZW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5ieXRlc1Rha2VuRnJvbVNlcnZlciA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubm9Nb3JlRGF0YSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnJlcSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEVuZENyZWF0ZVJlYWRTdHJlYW0gPSAtNDI7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGZ1bmN0aW9uIGZyZXF1ZW50bHlDZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSgpe1xyXG4gICAgICAgICAgICAgICBpZih2aWRlb0NvbXBsZXRlbHlMb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNlY2tJZkFuc3dlclN0cmVhbVJlYWR5KHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2ldKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZyZXF1ZW50bHlDZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSwgQ0hFQ0tfSUZfQU5TV0VSU1RSRUFNX1JFQURZX0lOVEVSVkFMKTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgZnVuY3Rpb24gY2hlY2tJZkJ1ZmZlckZ1bGxFbm91Z2goKXtcclxuICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoIGlzIGNhbGxlZFwiKTtcclxuICAgICAgICAgICAgICAgaWYodmlkZW9Db21wbGV0ZWx5TG9hZGVkKXtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJ2aWRlby5kdXJhdGlvbjogXCIgKyBteVZpZGVvLmR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgaWYobXlWaWRlby5kdXJhdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB0aW1lUmFuZ2VzID0gbXlWaWRlby5idWZmZXJlZDtcclxuICAgICAgICAgICAgICAgICAgaWYodGltZVJhbmdlcy5sZW5ndGggPj0gMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJ0aW1lUmFuZ2VzLnN0YXJ0KDApOiBcIiArIHRpbWVSYW5nZXMuc3RhcnQoMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidGltZVJhbmdlcy5lbmQoMCk6IFwiICsgdGltZVJhbmdlcy5lbmQoMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgaWYodGltZVJhbmdlcy5zdGFydCgwKSA9PSAwICYmIHRpbWVSYW5nZXMuZW5kKDApID09IG15VmlkZW8uZHVyYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiSW4gY2hlY2tJZkJ1ZmZlckZ1bGxFbm91Z2g6IGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvQ29tcGxldGVseUxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZW5kSWZWaWRlb0xvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoZVRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZW5kSWZWaWRlb0xvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoZVRvcnJlbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVUb3JyZW50LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdlYlRvcnJlbnRDbGllbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3RyZWFtaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpbkNyaXRpY2FsID0gdHJ1ZTsgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGltZVJhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiVGltZSByYW5nZSBudW1iZXIgXCIgKyBpICsgXCI6IHN0YXJ0KFwiICsgdGltZVJhbmdlcy5zdGFydChpKSArIFwiKSBlbmQoXCIgKyB0aW1lUmFuZ2VzLmVuZChpKSArIFwiKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgaWYgKG15VmlkZW8uY3VycmVudFRpbWUgPj0gdGltZVJhbmdlcy5zdGFydChpKSAmJiBteVZpZGVvLmN1cnJlbnRUaW1lIDw9IHRpbWVSYW5nZXMuZW5kKGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lUmFuZ2VzLmVuZChpKSAtIG15VmlkZW8uY3VycmVudFRpbWUgPj0gRE9XTkxPQURfRlJPTV9TRVJWRVJfVElNRV9SQU5HRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpbkNyaXRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJJIHNldCBpbkNyaXRpY2FsIHRvIGZhbHNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoZGVsaXZlcnlCeVNlcnZlciAmJiBpbkNyaXRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW5ndGggPSB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVycy5sZW5ndGg7IGogPCBsZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnNbal0uY3VycmVudENCICE9PSBudWxsICYmIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2pdLlhIUkNvbmR1Y3RlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZHVjdFhIUih2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVja0lmQnVmZmVyRnVsbEVub3VnaCwgQ0hFQ0tfSUZfQlVGRkVSX0ZVTExfRU5PVUdIX0lOVEVSVkFMKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgZnVuY3Rpb24gY29uZHVjdFhIUih0aGlzUmVxdWVzdCkge1xyXG4gICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpc1JlcXVlc3QuWEhSQ29uZHVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHJlcVN0YXJ0ID0gdGhpc1JlcXVlc3Quc3RhcnQ7XHJcbiAgICAgICAgICAgIHZhciByZXFFbmQgPSByZXFTdGFydCArIFhIUl9SRVFVRVNUX1NJWkU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QuZW5kID49IDAgJiYgcmVxRW5kID4gdGhpc1JlcXVlc3QuZW5kKSB7XHJcbiAgICAgICAgICAgICAgIHJlcUVuZCA9IHRoaXNSZXF1ZXN0LmVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVxU3RhcnQgPj0gcmVxRW5kKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LnJlcSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgY2IobnVsbCxudWxsKVwiKTtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQihudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyogZ2xhdWJlIGljaCB1bm7DtnRpZ2VyIHVuZC9vZGVyIGdlZsOkaHJsaWNoZXIgbcO8bGxcclxuICAgICAgICAgICAgaWYgKHJlcVN0YXJ0ID49IHJlcUVuZCkge1xyXG4gICAgICAgICAgICByZXEgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1JlcXVlc3QuY3VycmVudENCKG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlQ291bnRlciA8IDEwMDAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgIC8vLy8vLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgIHZpZGVvU3RyZWFtIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlciArIFwiICBDQiBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5DQk51bWJlciArIFwiICAgIHJlcVN0YXJ0OiBcIiArIHJlcVN0YXJ0KTtcclxuICAgICAgICAgICAgICAgLy8vLy8vLy8vL2NvbnNvbGUubG9nKGNvbnNvbGVDb3VudGVyKysgKyBcIiAgTXVsdGlzdHJlYW0gXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyICsgXCIgICBDQiBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5DQk51bWJlciArIFwiICAgIHJlcUVuZDogXCIgKyByZXFFbmQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgWEhSRGF0YUhhbmRsZXIgPSBmdW5jdGlvbiAoY2h1bmspe1xyXG4gICAgICAgICAgICAgICBieXRlc1JlY2VpdmVkRnJvbVNlcnZlciArPSBjaHVuay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSZWFkYWJsZVN0cmVhbSByZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIgKyBcIiByZWNlaXZlZCBhIGNodW5rIG9mIGxlbmd0aCBcIiArIGNodW5rLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0Lm5vTW9yZURhdGEpe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlciArPSBjaHVuay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3Quc3RhcnQgLSB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlciA8IGNodW5rLmxlbmd0aCl7ICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIGJ5dGVzVGFrZW5Gcm9tU2VydmVyICs9IGNodW5rLmxlbmd0aCAtICh0aGlzUmVxdWVzdC5zdGFydCAtIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0U2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQgLSB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBteUJ1ZmZlciA9IGNodW5rLnNsaWNlKHRoaXNSZXF1ZXN0LnN0YXJ0IC0gdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIsIGNodW5rLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJJbiBYSFJEYXRhSGFuZGxlciAgIG15QnVmZmVyLmxlbmd0aDogXCIgKyBteUJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgU3RyZWFtSGFzTWVtb3J5TGVmdCA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKG15QnVmZmVyKTsgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgaWYoIVN0cmVhbUhhc01lbW9yeUxlZnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5jdXJyZW50Q0IgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRDQjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudENCID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0gPSBuZXcgTXlSZWFkYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogNTAwMDAwMH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7IFxyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ub01vcmVEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdC5zdGFydCA+PSBTSVpFX09GX1ZJREVPX0ZJTEUgJiYgdGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrRnVuY3Rpb24gPSB0aGlzUmVxdWVzdC5jdXJyZW50Q0I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IDUwMDAwMDB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhbGxlZCBDQiB3aXRoIGRhdGEgb3V0IG9mIGFuc3dlclN0cmVhbSBmcm9tIHZpZGVvc3RyZWFtUmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2tGdW5jdGlvbihudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LnN0YXJ0ICs9IGNodW5rLmxlbmd0aCAtICh0aGlzUmVxdWVzdC5zdGFydCAtIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0U2VydmVyKTsgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlciArPSBjaHVuay5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBYSFJFbmQgPSBmdW5jdGlvbiAoKXtcclxuICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJlYWRhYmxlU3RyZWFtIHJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlciArIFwiIFhIUkVuZFwiKTtcclxuICAgICAgICAgICAgICAgaWYgKGNvbnNvbGVDb3VudGVyIDwgMTAwMDAwMDAwMDAwMCl7XHJcbiAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9jb25zb2xlLmxvZyhcIlhIUkVuZCBmcm9tIHZpZGVvc3RyZWFtUmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID4gMCAmJiB0aGlzUmVxdWVzdC5jdXJyZW50Q0IgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwfSk7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFja0Z1bmN0aW9uID0gdGhpc1JlcXVlc3QuY3VycmVudENCO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiWEhSRW5kOiBjYWxsZWQgQ0Igd2l0aCBkYXRhIG91dCBvZiBhbnN3ZXJTdHJlYW0gZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrRnVuY3Rpb24obnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5YSFJDb25kdWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlciA9IHJlcVN0YXJ0O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkF0IGh0dG8uZ2V0ICAgcmVxU3RhcnQ6IFwiICsgcmVxU3RhcnQgKyBcIiAgICAgcmVxRW5kOiBcIiArIHJlcUVuZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIFhIUk9wdGlvbk9iamVjdCA9IHtcclxuICAgICAgICAgICAgICAgcGF0aDogdGhpc1JlcXVlc3Quc2VsZi5wYXRoVG9GaWxlT25YSFJTZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgcmFuZ2U6ICdieXRlcz0nICsgcmVxU3RhcnQgKyAnLScgKyAocmVxRW5kLTEpXHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYoWEhSU2VydmVyVVJMKXtcclxuICAgICAgICAgICAgICAgWEhST3B0aW9uT2JqZWN0Lmhvc3RuYW1lID0gWEhSU2VydmVyVVJMO1xyXG4gICAgICAgICAgICAgICBYSFJPcHRpb25PYmplY3QucG9ydCA9IFhIUl9QT1JUO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5yZXEgPSBodHRwLmdldChYSFJPcHRpb25PYmplY3QsIGZ1bmN0aW9uIChyZXMpe1xyXG4gICAgICAgICAgICAgICAgICB2YXIgY29udGVudFJhbmdlID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5maWxlU2l6ZSA9IHBhcnNlSW50KGNvbnRlbnRSYW5nZS5zcGxpdCgnLycpWzFdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL2NvbnNvbGUubG9nKFwiSSByZXR1cm4gY3VycmVudENCIHdpdGggaHR0cCByZXNwb25zZSBzdHJlYW1cIik7XHJcbiAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vL2NvbnNvbGUubG9nKFwiZnVuY3Rpb24ocmVzKSBpcyBleGVjdXRlZCBmcm9tIHJlYWRzdHJlYW0gbnVtYmVyIFwiICsgY3JlYXRlUmVhZFN0cmVhbUNvdW50ZXIgKyBcIiBhbmQgQ0IgbnVtYmVyIFwiICsgdGhpc0NCTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCBYSFJFbmQpO1xyXG4gICAgICAgICAgICAgICAgICByZXMub24oJ2RhdGEnLCBYSFJEYXRhSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBmcmVxdWVudGx5Q2hlY2tJZk5ld0NyZWF0ZVJlYWRTdHJlYW1OZWNlc3NhcnkoKTtcclxuICAgICAgICAgY2hva2VJZk5lY2Vzc2FyeSgpO1xyXG4gICAgICAgICB1cGRhdGVDaGFydCgpO1xyXG4gICAgICAgICBmcmVxdWVudGx5Q2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkoKTtcclxuICAgICAgICAgY2hlY2tJZkJ1ZmZlckZ1bGxFbm91Z2goKTtcclxuXHJcbiAgICAgICAgIC8vLy8vL2NvbnNvbGUubG9nKFwiSSBjYWxsIFZpZGVvc3RyZWFtIGNvbnN0cnVjdG9yXCIpO1xyXG4gICAgICAgICBpZihoYXNoVmFsdWUpe1xyXG4gICAgICAgICAgICBWaWRlb3N0cmVhbShuZXcgZmlsZUxpa2VPYmplY3QoaGFzaFZhbHVlKSwgbXlWaWRlbyk7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFZpZGVvc3RyZWFtKG5ldyBmaWxlTGlrZU9iamVjdChwYXRoVG9GaWxlT25YSFJTZXJ2ZXIpLCBteVZpZGVvKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgZnVuY3Rpb24gYWRkU2ltcGxlUGVlckluc3RhbmNlKHNpbXBsZVBlZXJJbnN0YW5jZSwgb3B0aW9ucywgY2FsbGJhY2spe1xyXG4gICAgICAgICAvLyBUaGUgbWV0aG9kIGFkZCBhIHNpbXBsZVBlZXIgdG8gdGhlIFdlYlRvcnJlbnQgc3dhcm0gaW5zdGFuY2VcclxuICAgICAgICAgaWYodGhlVG9ycmVudCl7XHJcbiAgICAgICAgICAgIGlmKHRoZVRvcnJlbnQuaW5mb0hhc2gpe1xyXG4gICAgICAgICAgICAgICB0aGVUb3JyZW50LmFkZFBlZXIoc2ltcGxlUGVlckluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHRoZVRvcnJlbnQub24oJ2luZm9IYXNoJywgZnVuY3Rpb24oKSB7dGhlVG9ycmVudC5hZGRQZWVyKHNpbXBsZVBlZXJJbnN0YW5jZSk7IGlmKGNhbGxiYWNrKXtjYWxsYmFjaygpfX0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwYWlyID0gW107XHJcbiAgICAgICAgICAgIHBhaXIucHVzaChzaW1wbGVQZWVySW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBwYWlyLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgICAgICBwZWVyc1RvQWRkLnB1c2gocGFpcik7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9KSgpO1xyXG59IiwidmFyIEFERFJfUkUgPSAvXlxcWz8oW15cXF1dKylcXF0/OihcXGQrKSQvIC8vIGlwdjQvaXB2Ni9ob3N0bmFtZSArIHBvcnRcblxudmFyIGNhY2hlID0ge31cblxuLy8gcmVzZXQgY2FjaGUgd2hlbiBpdCBnZXRzIHRvIDEwMCwwMDAgZWxlbWVudHMgKH4gNjAwS0Igb2YgaXB2NCBhZGRyZXNzZXMpXG4vLyBzbyBpdCB3aWxsIG5vdCBncm93IHRvIGNvbnN1bWUgYWxsIG1lbW9yeSBpbiBsb25nLXJ1bm5pbmcgcHJvY2Vzc2VzXG52YXIgc2l6ZSA9IDBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRyVG9JUFBvcnQgKGFkZHIpIHtcbiAgaWYgKHNpemUgPT09IDEwMDAwMCkgbW9kdWxlLmV4cG9ydHMucmVzZXQoKVxuICBpZiAoIWNhY2hlW2FkZHJdKSB7XG4gICAgdmFyIG0gPSBBRERSX1JFLmV4ZWMoYWRkcilcbiAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZGRyOiAnICsgYWRkcilcbiAgICBjYWNoZVthZGRyXSA9IFsgbVsxXSwgTnVtYmVyKG1bMl0pIF1cbiAgICBzaXplICs9IDFcbiAgfVxuICByZXR1cm4gY2FjaGVbYWRkcl1cbn1cblxubW9kdWxlLmV4cG9ydHMucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoKSB7XG4gIGNhY2hlID0ge31cbiAgc2l6ZSA9IDBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXVxuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xufVxuXG5pbml0KClcblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKipcbiAqIERlY29kZXMgYmVuY29kZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGRhdGFcbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnQgKG9wdGlvbmFsKVxuICogQHBhcmFtICB7TnVtYmVyfSBlbmQgKG9wdGlvbmFsKVxuICogQHBhcmFtICB7U3RyaW5nfSBlbmNvZGluZyAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtPYmplY3R8QXJyYXl8QnVmZmVyfFN0cmluZ3xOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZSAoZGF0YSwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicgJiYgZW5jb2RpbmcgPT0gbnVsbCkge1xuICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICBzdGFydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwpIHtcbiAgICBlbmNvZGluZyA9IGVuZFxuICAgIGVuZCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uID0gMFxuICBkZWNvZGUuZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBudWxsXG5cbiAgZGVjb2RlLmRhdGEgPSAhKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICA/IG5ldyBCdWZmZXIoZGF0YSlcbiAgICA6IGRhdGEuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBkZWNvZGUuYnl0ZXMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcblxuICByZXR1cm4gZGVjb2RlLm5leHQoKVxufVxuXG5kZWNvZGUuYnl0ZXMgPSAwXG5kZWNvZGUucG9zaXRpb24gPSAwXG5kZWNvZGUuZGF0YSA9IG51bGxcbmRlY29kZS5lbmNvZGluZyA9IG51bGxcblxuZGVjb2RlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHN3aXRjaCAoZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSkge1xuICAgIGNhc2UgMHg2NDpcbiAgICAgIHJldHVybiBkZWNvZGUuZGljdGlvbmFyeSgpXG4gICAgY2FzZSAweDZDOlxuICAgICAgcmV0dXJuIGRlY29kZS5saXN0KClcbiAgICBjYXNlIDB4Njk6XG4gICAgICByZXR1cm4gZGVjb2RlLmludGVnZXIoKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGVjb2RlLmJ1ZmZlcigpXG4gIH1cbn1cblxuZGVjb2RlLmZpbmQgPSBmdW5jdGlvbiAoY2hyKSB7XG4gIHZhciBpID0gZGVjb2RlLnBvc2l0aW9uXG4gIHZhciBjID0gZGVjb2RlLmRhdGEubGVuZ3RoXG4gIHZhciBkID0gZGVjb2RlLmRhdGFcblxuICB3aGlsZSAoaSA8IGMpIHtcbiAgICBpZiAoZFtpXSA9PT0gY2hyKSByZXR1cm4gaVxuICAgIGkrK1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdJbnZhbGlkIGRhdGE6IE1pc3NpbmcgZGVsaW1pdGVyIFwiJyArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgJ1wiIFsweCcgK1xuICAgIGNoci50b1N0cmluZygxNikgKyAnXSdcbiAgKVxufVxuXG5kZWNvZGUuZGljdGlvbmFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgZGljdCA9IHt9XG5cbiAgd2hpbGUgKGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gIT09IDB4NjUpIHtcbiAgICBkaWN0W2RlY29kZS5idWZmZXIoKV0gPSBkZWNvZGUubmV4dCgpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBkaWN0XG59XG5cbmRlY29kZS5saXN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBsc3QgPSBbXVxuXG4gIHdoaWxlIChkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1KSB7XG4gICAgbHN0LnB1c2goZGVjb2RlLm5leHQoKSlcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGxzdFxufVxuXG5kZWNvZGUuaW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVuZCA9IGRlY29kZS5maW5kKDB4NjUpXG4gIHZhciBudW1iZXIgPSBkZWNvZGUuZGF0YS50b1N0cmluZygnYXNjaWknLCBkZWNvZGUucG9zaXRpb24gKyAxLCBlbmQpXG5cbiAgZGVjb2RlLnBvc2l0aW9uICs9IGVuZCArIDEgLSBkZWNvZGUucG9zaXRpb25cblxuICByZXR1cm4gcGFyc2VJbnQobnVtYmVyLCAxMClcbn1cblxuZGVjb2RlLmJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlcCA9IGRlY29kZS5maW5kKDB4M0EpXG4gIHZhciBsZW5ndGggPSBwYXJzZUludChkZWNvZGUuZGF0YS50b1N0cmluZygnYXNjaWknLCBkZWNvZGUucG9zaXRpb24sIHNlcCksIDEwKVxuICB2YXIgZW5kID0gKytzZXAgKyBsZW5ndGhcblxuICBkZWNvZGUucG9zaXRpb24gPSBlbmRcblxuICByZXR1cm4gZGVjb2RlLmVuY29kaW5nXG4gICAgPyBkZWNvZGUuZGF0YS50b1N0cmluZyhkZWNvZGUuZW5jb2RpbmcsIHNlcCwgZW5kKVxuICAgIDogZGVjb2RlLmRhdGEuc2xpY2Uoc2VwLCBlbmQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlXG4iLCIvKipcbiAqIEVuY29kZXMgZGF0YSBpbiBiZW5jb2RlLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcnxBcnJheXxTdHJpbmd8T2JqZWN0fE51bWJlcnxCb29sZWFufSBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZSAoZGF0YSwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXVxuICB2YXIgcmVzdWx0ID0gbnVsbFxuXG4gIGVuY29kZS5fZW5jb2RlKGJ1ZmZlcnMsIGRhdGEpXG4gIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycylcbiAgZW5jb2RlLmJ5dGVzID0gcmVzdWx0Lmxlbmd0aFxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIHJlc3VsdC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KVxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZW5jb2RlLmJ5dGVzID0gLTFcbmVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSBmYWxzZVxuXG5lbmNvZGUuX2VuY29kZSA9IGZ1bmN0aW9uIChidWZmZXJzLCBkYXRhKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICBidWZmZXJzLnB1c2gobmV3IEJ1ZmZlcihkYXRhLmxlbmd0aCArICc6JykpXG4gICAgYnVmZmVycy5wdXNoKGRhdGEpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiBkYXRhKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGVuY29kZS5idWZmZXIoYnVmZmVycywgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGVuY29kZS5udW1iZXIoYnVmZmVycywgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGRhdGEuY29uc3RydWN0b3IgPT09IEFycmF5XG4gICAgICAgID8gZW5jb2RlLmxpc3QoYnVmZmVycywgZGF0YSlcbiAgICAgICAgOiBlbmNvZGUuZGljdChidWZmZXJzLCBkYXRhKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGVuY29kZS5udW1iZXIoYnVmZmVycywgZGF0YSA/IDEgOiAwKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG52YXIgYnVmZkUgPSBuZXcgQnVmZmVyKCdlJylcbnZhciBidWZmRCA9IG5ldyBCdWZmZXIoJ2QnKVxudmFyIGJ1ZmZMID0gbmV3IEJ1ZmZlcignbCcpXG5cbmVuY29kZS5idWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVycywgZGF0YSkge1xuICBidWZmZXJzLnB1c2gobmV3IEJ1ZmZlcihCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSArICc6JyArIGRhdGEpKVxufVxuXG5lbmNvZGUubnVtYmVyID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgdmFyIG1heExvID0gMHg4MDAwMDAwMFxuICB2YXIgaGkgPSAoZGF0YSAvIG1heExvKSA8PCAwXG4gIHZhciBsbyA9IChkYXRhICUgbWF4TG8pIDw8IDBcbiAgdmFyIHZhbCA9IGhpICogbWF4TG8gKyBsb1xuXG4gIGJ1ZmZlcnMucHVzaChuZXcgQnVmZmVyKCdpJyArIHZhbCArICdlJykpXG5cbiAgaWYgKHZhbCAhPT0gZGF0YSAmJiAhZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCkge1xuICAgIGVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSB0cnVlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dBUk5JTkc6IFBvc3NpYmxlIGRhdGEgY29ycnVwdGlvbiBkZXRlY3RlZCB3aXRoIHZhbHVlIFwiJyArIGRhdGEgKyAnXCI6JyxcbiAgICAgICdCZW5jb2Rpbmcgb25seSBkZWZpbmVzIHN1cHBvcnQgZm9yIGludGVnZXJzLCB2YWx1ZSB3YXMgY29udmVydGVkIHRvIFwiJyArIHZhbCArICdcIidcbiAgICApXG4gICAgY29uc29sZS50cmFjZSgpXG4gIH1cbn1cblxuZW5jb2RlLmRpY3QgPSBmdW5jdGlvbiAoYnVmZmVycywgZGF0YSkge1xuICBidWZmZXJzLnB1c2goYnVmZkQpXG5cbiAgdmFyIGogPSAwXG4gIHZhciBrXG4gIC8vIGZpeCBmb3IgaXNzdWUgIzEzIC0gc29ydGVkIGRpY3RzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSkuc29ydCgpXG4gIHZhciBrbCA9IGtleXMubGVuZ3RoXG5cbiAgZm9yICg7IGogPCBrbDsgaisrKSB7XG4gICAgayA9IGtleXNbal1cbiAgICBlbmNvZGUuYnVmZmVyKGJ1ZmZlcnMsIGspXG4gICAgZW5jb2RlLl9lbmNvZGUoYnVmZmVycywgZGF0YVtrXSlcbiAgfVxuXG4gIGJ1ZmZlcnMucHVzaChidWZmRSlcbn1cblxuZW5jb2RlLmxpc3QgPSBmdW5jdGlvbiAoYnVmZmVycywgZGF0YSkge1xuICB2YXIgaSA9IDBcbiAgdmFyIGMgPSBkYXRhLmxlbmd0aFxuICBidWZmZXJzLnB1c2goYnVmZkwpXG5cbiAgZm9yICg7IGkgPCBjOyBpKyspIHtcbiAgICBlbmNvZGUuX2VuY29kZShidWZmZXJzLCBkYXRhW2ldKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKGJ1ZmZFKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuIiwidmFyIGJlbmNvZGUgPSBtb2R1bGUuZXhwb3J0c1xuXG5iZW5jb2RlLmVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJylcbmJlbmNvZGUuZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGFtb3VudCBvZiBieXRlc1xuICogbmVlZGVkIHRvIGVuY29kZSB0aGUgZ2l2ZW4gdmFsdWVcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcnxCb29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfSBieXRlQ291bnRcbiAqL1xuYmVuY29kZS5ieXRlTGVuZ3RoID0gYmVuY29kZS5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gYmVuY29kZS5lbmNvZGUodmFsdWUpLmxlbmd0aFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoYXlzdGFjaywgbmVlZGxlLCBjb21wYXJhdG9yLCBsb3csIGhpZ2gpIHtcbiAgdmFyIG1pZCwgY21wO1xuXG4gIGlmKGxvdyA9PT0gdW5kZWZpbmVkKVxuICAgIGxvdyA9IDA7XG5cbiAgZWxzZSB7XG4gICAgbG93ID0gbG93fDA7XG4gICAgaWYobG93IDwgMCB8fCBsb3cgPj0gaGF5c3RhY2subGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGxvd2VyIGJvdW5kXCIpO1xuICB9XG5cbiAgaWYoaGlnaCA9PT0gdW5kZWZpbmVkKVxuICAgIGhpZ2ggPSBoYXlzdGFjay5sZW5ndGggLSAxO1xuXG4gIGVsc2Uge1xuICAgIGhpZ2ggPSBoaWdofDA7XG4gICAgaWYoaGlnaCA8IGxvdyB8fCBoaWdoID49IGhheXN0YWNrLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCB1cHBlciBib3VuZFwiKTtcbiAgfVxuXG4gIHdoaWxlKGxvdyA8PSBoaWdoKSB7XG4gICAgLyogTm90ZSB0aGF0IFwiKGxvdyArIGhpZ2gpID4+PiAxXCIgbWF5IG92ZXJmbG93LCBhbmQgcmVzdWx0cyBpbiBhIHR5cGVjYXN0XG4gICAgICogdG8gZG91YmxlICh3aGljaCBnaXZlcyB0aGUgd3JvbmcgcmVzdWx0cykuICovXG4gICAgbWlkID0gbG93ICsgKGhpZ2ggLSBsb3cgPj4gMSk7XG4gICAgY21wID0gK2NvbXBhcmF0b3IoaGF5c3RhY2tbbWlkXSwgbmVlZGxlLCBtaWQsIGhheXN0YWNrKTtcblxuICAgIC8qIFRvbyBsb3cuICovXG4gICAgaWYoY21wIDwgMC4wKVxuICAgICAgbG93ICA9IG1pZCArIDE7XG5cbiAgICAvKiBUb28gaGlnaC4gKi9cbiAgICBlbHNlIGlmKGNtcCA+IDAuMClcbiAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuXG4gICAgLyogS2V5IGZvdW5kLiAqL1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBtaWQ7XG4gIH1cblxuICAvKiBLZXkgbm90IGZvdW5kLiAqL1xuICByZXR1cm4gfmxvdztcbn1cbiIsInZhciBDb250YWluZXIgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiID8gQnVmZmVyIC8vaW4gbm9kZSwgdXNlIGJ1ZmZlcnNcclxuXHRcdDogdHlwZW9mIEludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IEludDhBcnJheSAvL2luIG5ld2VyIGJyb3dzZXJzLCB1c2Ugd2ViZ2wgaW50OGFycmF5c1xyXG5cdFx0OiBmdW5jdGlvbihsKXsgdmFyIGEgPSBuZXcgQXJyYXkobCk7IGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGFbaV09MDsgfTsgLy9lbHNlLCBkbyBzb21ldGhpbmcgc2ltaWxhclxyXG5cclxuZnVuY3Rpb24gQml0RmllbGQoZGF0YSwgb3B0cyl7XHJcblx0aWYoISh0aGlzIGluc3RhbmNlb2YgQml0RmllbGQpKSB7XHJcblx0XHRyZXR1cm4gbmV3IEJpdEZpZWxkKGRhdGEsIG9wdHMpO1xyXG5cdH1cclxuXHJcblx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCl7XHJcblx0XHRkYXRhID0gMDtcclxuXHR9XHJcblxyXG5cdHRoaXMuZ3JvdyA9IG9wdHMgJiYgKGlzRmluaXRlKG9wdHMuZ3JvdykgJiYgZ2V0Qnl0ZVNpemUob3B0cy5ncm93KSB8fCBvcHRzLmdyb3cpIHx8IDA7XHJcblxyXG5cdGlmKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IGRhdGEgPT09IHVuZGVmaW5lZCl7XHJcblx0XHRkYXRhID0gbmV3IENvbnRhaW5lcihnZXRCeXRlU2l6ZShkYXRhKSk7XHJcblx0XHRpZihkYXRhLmZpbGwgJiYgIWRhdGEuX2lzQnVmZmVyKSBkYXRhLmZpbGwoMCk7IC8vIGNsZWFyIG5vZGUgYnVmZmVycyBvZiBnYXJiYWdlXHJcblx0fVxyXG5cdHRoaXMuYnVmZmVyID0gZGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Qnl0ZVNpemUobnVtKXtcclxuXHR2YXIgb3V0ID0gbnVtID4+IDM7XHJcblx0aWYobnVtICUgOCAhPT0gMCkgb3V0Kys7XHJcblx0cmV0dXJuIG91dDtcclxufVxyXG5cclxuQml0RmllbGQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGkpe1xyXG5cdHZhciBqID0gaSA+PiAzO1xyXG5cdHJldHVybiAoaiA8IHRoaXMuYnVmZmVyLmxlbmd0aCkgJiZcclxuXHRcdCEhKHRoaXMuYnVmZmVyW2pdICYgKDEyOCA+PiAoaSAlIDgpKSk7XHJcbn07XHJcblxyXG5CaXRGaWVsZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgYil7XHJcblx0dmFyIGogPSBpID4+IDM7XHJcblx0aWYgKGIgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSl7XHJcblx0XHRpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgaiArIDEpIHRoaXMuX2dyb3coTWF0aC5tYXgoaiArIDEsIE1hdGgubWluKDIgKiB0aGlzLmJ1ZmZlci5sZW5ndGgsIHRoaXMuZ3JvdykpKTtcclxuXHRcdC8vIFNldFxyXG5cdFx0dGhpcy5idWZmZXJbal0gfD0gMTI4ID4+IChpICUgOCk7XHJcblx0fSBlbHNlIGlmIChqIDwgdGhpcy5idWZmZXIubGVuZ3RoKSB7XHJcblx0XHQvLy8gQ2xlYXJcclxuXHRcdHRoaXMuYnVmZmVyW2pdICY9IH4oMTI4ID4+IChpICUgOCkpO1xyXG5cdH1cclxufTtcclxuXHJcbkJpdEZpZWxkLnByb3RvdHlwZS5fZ3JvdyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPCBsZW5ndGggJiYgbGVuZ3RoIDw9IHRoaXMuZ3Jvdykge1xyXG5cdFx0dmFyIG5ld0J1ZmZlciA9IG5ldyBDb250YWluZXIobGVuZ3RoKTtcclxuXHRcdGlmIChuZXdCdWZmZXIuZmlsbCkgbmV3QnVmZmVyLmZpbGwoMCk7XHJcblx0XHRpZiAodGhpcy5idWZmZXIuY29weSkgdGhpcy5idWZmZXIuY29weShuZXdCdWZmZXIsIDApO1xyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdG5ld0J1ZmZlcltpXSA9IHRoaXMuYnVmZmVyW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcclxuXHR9XHJcbn07XHJcblxyXG5pZih0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IEJpdEZpZWxkO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFdpcmVcblxudmFyIGJlbmNvZGUgPSByZXF1aXJlKCdiZW5jb2RlJylcbnZhciBCaXRGaWVsZCA9IHJlcXVpcmUoJ2JpdGZpZWxkJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYml0dG9ycmVudC1wcm90b2NvbCcpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGhhdCA9IHJlcXVpcmUoJ2hhdCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3BlZWRvbWV0ZXIgPSByZXF1aXJlKCdzcGVlZG9tZXRlcicpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxudmFyIEJJVEZJRUxEX0dST1cgPSA0MDAwMDBcbnZhciBLRUVQX0FMSVZFX1RJTUVPVVQgPSA1NTAwMFxuXG52YXIgTUVTU0FHRV9QUk9UT0NPTCA9IEJ1ZmZlci5mcm9tKCdcXHUwMDEzQml0VG9ycmVudCBwcm90b2NvbCcpXG52YXIgTUVTU0FHRV9LRUVQX0FMSVZFID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKVxudmFyIE1FU1NBR0VfQ0hPS0UgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMF0pXG52YXIgTUVTU0FHRV9VTkNIT0tFID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDFdKVxudmFyIE1FU1NBR0VfSU5URVJFU1RFRCA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAyXSlcbnZhciBNRVNTQUdFX1VOSU5URVJFU1RFRCA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAzXSlcblxudmFyIE1FU1NBR0VfUkVTRVJWRUQgPSBbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF1cbnZhciBNRVNTQUdFX1BPUlQgPSBbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgMHgwOSwgMHgwMCwgMHgwMF1cblxuZnVuY3Rpb24gUmVxdWVzdCAocGllY2UsIG9mZnNldCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuICB0aGlzLnBpZWNlID0gcGllY2VcbiAgdGhpcy5vZmZzZXQgPSBvZmZzZXRcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG59XG5cbmluaGVyaXRzKFdpcmUsIHN0cmVhbS5EdXBsZXgpXG5cbmZ1bmN0aW9uIFdpcmUgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2lyZSkpIHJldHVybiBuZXcgV2lyZSgpXG4gIHN0cmVhbS5EdXBsZXguY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2RlYnVnSWQgPSBoYXQoMzIpXG4gIHRoaXMuX2RlYnVnKCduZXcgd2lyZScpXG5cbiAgdGhpcy5wZWVySWQgPSBudWxsIC8vIHJlbW90ZSBwZWVyIGlkIChoZXggc3RyaW5nKVxuICB0aGlzLnBlZXJJZEJ1ZmZlciA9IG51bGwgLy8gcmVtb3RlIHBlZXIgaWQgKGJ1ZmZlcilcbiAgdGhpcy50eXBlID0gbnVsbCAvLyBjb25uZWN0aW9uIHR5cGUgKCd3ZWJydGMnLCAndGNwSW5jb21pbmcnLCAndGNwT3V0Z29pbmcnLCAnd2ViU2VlZCcpXG5cbiAgdGhpcy5hbUNob2tpbmcgPSB0cnVlIC8vIGFyZSB3ZSBjaG9raW5nIHRoZSBwZWVyP1xuICB0aGlzLmFtSW50ZXJlc3RlZCA9IGZhbHNlIC8vIGFyZSB3ZSBpbnRlcmVzdGVkIGluIHRoZSBwZWVyP1xuXG4gIHRoaXMucGVlckNob2tpbmcgPSB0cnVlIC8vIGlzIHRoZSBwZWVyIGNob2tpbmcgdXM/XG4gIHRoaXMucGVlckludGVyZXN0ZWQgPSBmYWxzZSAvLyBpcyB0aGUgcGVlciBpbnRlcmVzdGVkIGluIHVzP1xuXG4gIC8vIFRoZSBsYXJnZXN0IHRvcnJlbnQgdGhhdCBJIGtub3cgb2YgKHRoZSBHZW9jaXRpZXMgYXJjaGl2ZSkgaXMgfjY0MSBHQiBhbmQgaGFzXG4gIC8vIH40MSwwMDAgcGllY2VzLiBUaGVyZWZvcmUsIGNhcCBiaXRmaWVsZCB0byAxMHggbGFyZ2VyICg0MDAsMDAwIGJpdHMpIHRvIHN1cHBvcnQgYWxsXG4gIC8vIHBvc3NpYmxlIHRvcnJlbnRzIGJ1dCBwcmV2ZW50IG1hbGljaW91cyBwZWVycyBmcm9tIGdyb3dpbmcgYml0ZmllbGQgdG8gZmlsbCBtZW1vcnkuXG4gIHRoaXMucGVlclBpZWNlcyA9IG5ldyBCaXRGaWVsZCgwLCB7IGdyb3c6IEJJVEZJRUxEX0dST1cgfSlcblxuICB0aGlzLnBlZXJFeHRlbnNpb25zID0ge31cblxuICB0aGlzLnJlcXVlc3RzID0gW10gLy8gb3V0Z29pbmdcbiAgdGhpcy5wZWVyUmVxdWVzdHMgPSBbXSAvLyBpbmNvbWluZ1xuXG4gIHRoaXMuZXh0ZW5kZWRNYXBwaW5nID0ge30gLy8gbnVtYmVyIC0+IHN0cmluZywgZXg6IDEgLT4gJ3V0X21ldGFkYXRhJ1xuICB0aGlzLnBlZXJFeHRlbmRlZE1hcHBpbmcgPSB7fSAvLyBzdHJpbmcgLT4gbnVtYmVyLCBleDogOSAtPiAndXRfbWV0YWRhdGEnXG5cbiAgLy8gVGhlIGV4dGVuZGVkIGhhbmRzaGFrZSB0byBzZW5kLCBtaW51cyB0aGUgXCJtXCIgZmllbGQsIHdoaWNoIGdldHMgYXV0b21hdGljYWxseVxuICAvLyBmaWxsZWQgZnJvbSBgdGhpcy5leHRlbmRlZE1hcHBpbmdgXG4gIHRoaXMuZXh0ZW5kZWRIYW5kc2hha2UgPSB7fVxuXG4gIHRoaXMucGVlckV4dGVuZGVkSGFuZHNoYWtlID0ge30gLy8gcmVtb3RlIHBlZXIncyBleHRlbmRlZCBoYW5kc2hha2VcblxuICB0aGlzLl9leHQgPSB7fSAgLy8gc3RyaW5nIC0+IGZ1bmN0aW9uLCBleCAndXRfbWV0YWRhdGEnIC0+IHV0X21ldGFkYXRhKClcbiAgdGhpcy5fbmV4dEV4dCA9IDFcblxuICB0aGlzLnVwbG9hZGVkID0gMFxuICB0aGlzLmRvd25sb2FkZWQgPSAwXG4gIHRoaXMudXBsb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG4gIHRoaXMuZG93bmxvYWRTcGVlZCA9IHNwZWVkb21ldGVyKClcblxuICB0aGlzLl9rZWVwQWxpdmVJbnRlcnZhbCA9IG51bGxcbiAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgdGhpcy5fdGltZW91dE1zID0gMFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2UgLy8gd2FzIHRoZSB3aXJlIGVuZGVkIGJ5IGNhbGxpbmcgYGRlc3Ryb3lgP1xuICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlXG5cbiAgdGhpcy5fcGFyc2VyU2l6ZSA9IDAgLy8gbnVtYmVyIG9mIG5lZWRlZCBieXRlcyB0byBwYXJzZSBuZXh0IG1lc3NhZ2UgZnJvbSByZW1vdGUgcGVlclxuICB0aGlzLl9wYXJzZXIgPSBudWxsIC8vIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSBgdGhpcy5fcGFyc2VyU2l6ZWAgYnl0ZXMgYXJlIGF2YWlsYWJsZVxuXG4gIHRoaXMuX2J1ZmZlciA9IFtdIC8vIGluY29tcGxldGUgbWVzc2FnZSBkYXRhXG4gIHRoaXMuX2J1ZmZlclNpemUgPSAwIC8vIGNhY2hlZCB0b3RhbCBsZW5ndGggb2YgYnVmZmVycyBpbiBgdGhpcy5fYnVmZmVyYFxuXG4gIHRoaXMub24oJ2ZpbmlzaCcsIHRoaXMuX29uRmluaXNoKVxuXG4gIHRoaXMuX3BhcnNlSGFuZHNoYWtlKClcbn1cblxuLyoqXG4gKiBTZXQgd2hldGhlciB0byBzZW5kIGEgXCJrZWVwLWFsaXZlXCIgcGluZyAoc2VudCBldmVyeSA1NXMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZVxuICovXG5XaXJlLnByb3RvdHlwZS5zZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoZW5hYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZWJ1Zygnc2V0S2VlcEFsaXZlICVzJywgZW5hYmxlKVxuICBjbGVhckludGVydmFsKHNlbGYuX2tlZXBBbGl2ZUludGVydmFsKVxuICBpZiAoZW5hYmxlID09PSBmYWxzZSkgcmV0dXJuXG4gIHNlbGYuX2tlZXBBbGl2ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYua2VlcEFsaXZlKClcbiAgfSwgS0VFUF9BTElWRV9USU1FT1VUKVxufVxuXG4vKipcbiAqIFNldCB0aGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgY29uc2lkZXJpbmcgYSByZXF1ZXN0IHRvIGJlIFwidGltZWQgb3V0XCJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xuICogQHBhcmFtIHtib29sZWFuPX0gdW5yZWYgKHNob3VsZCB0aGUgdGltZXIgYmUgdW5yZWYnZD8gZGVmYXVsdDogZmFsc2UpXG4gKi9cbldpcmUucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIHVucmVmKSB7XG4gIHRoaXMuX2RlYnVnKCdzZXRUaW1lb3V0IG1zPSVkIHVucmVmPSVzJywgbXMsIHVucmVmKVxuICB0aGlzLl9jbGVhclRpbWVvdXQoKVxuICB0aGlzLl90aW1lb3V0TXMgPSBtc1xuICB0aGlzLl90aW1lb3V0VW5yZWYgPSAhIXVucmVmXG4gIHRoaXMuX3VwZGF0ZVRpbWVvdXQoKVxufVxuXG5XaXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgdGhpcy5fZGVidWcoJ2Rlc3Ryb3knKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgdGhpcy5lbmQoKVxufVxuXG5XaXJlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2RlYnVnKCdlbmQnKVxuICB0aGlzLl9vblVuaW50ZXJlc3RlZCgpXG4gIHRoaXMuX29uQ2hva2UoKVxuICBzdHJlYW0uRHVwbGV4LnByb3RvdHlwZS5lbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG4vKipcbiAqIFVzZSB0aGUgc3BlY2lmaWVkIHByb3RvY29sIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBFeHRlbnNpb25cbiAqL1xuV2lyZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKEV4dGVuc2lvbikge1xuICB2YXIgbmFtZSA9IEV4dGVuc2lvbi5wcm90b3R5cGUubmFtZVxuICBpZiAoIW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBjbGFzcyByZXF1aXJlcyBhIFwibmFtZVwiIHByb3BlcnR5IG9uIHRoZSBwcm90b3R5cGUnKVxuICB9XG4gIHRoaXMuX2RlYnVnKCd1c2UgZXh0ZW5zaW9uLm5hbWU9JXMnLCBuYW1lKVxuXG4gIHZhciBleHQgPSB0aGlzLl9uZXh0RXh0XG4gIHZhciBoYW5kbGVyID0gbmV3IEV4dGVuc2lvbih0aGlzKVxuXG4gIGZ1bmN0aW9uIG5vb3AgKCkge31cblxuICBpZiAodHlwZW9mIGhhbmRsZXIub25IYW5kc2hha2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICBoYW5kbGVyLm9uSGFuZHNoYWtlID0gbm9vcFxuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkV4dGVuZGVkSGFuZHNoYWtlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFuZGxlci5vbkV4dGVuZGVkSGFuZHNoYWtlID0gbm9vcFxuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbk1lc3NhZ2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICBoYW5kbGVyLm9uTWVzc2FnZSA9IG5vb3BcbiAgfVxuXG4gIHRoaXMuZXh0ZW5kZWRNYXBwaW5nW2V4dF0gPSBuYW1lXG4gIHRoaXMuX2V4dFtuYW1lXSA9IGhhbmRsZXJcbiAgdGhpc1tuYW1lXSA9IGhhbmRsZXJcblxuICB0aGlzLl9uZXh0RXh0ICs9IDFcbn1cblxuLy9cbi8vIE9VVEdPSU5HIE1FU1NBR0VTXG4vL1xuXG4vKipcbiAqIE1lc3NhZ2UgXCJrZWVwLWFsaXZlXCI6IDxsZW49MDAwMD5cbiAqL1xuV2lyZS5wcm90b3R5cGUua2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kZWJ1Zygna2VlcC1hbGl2ZScpXG4gIHRoaXMuX3B1c2goTUVTU0FHRV9LRUVQX0FMSVZFKVxufVxuXG4vKipcbiAqIE1lc3NhZ2U6IFwiaGFuZHNoYWtlXCIgPHBzdHJsZW4+PHBzdHI+PHJlc2VydmVkPjxpbmZvX2hhc2g+PHBlZXJfaWQ+XG4gKiBAcGFyYW0gIHtCdWZmZXJ8c3RyaW5nfSBpbmZvSGFzaCAoYXMgQnVmZmVyIG9yICpoZXgqIHN0cmluZylcbiAqIEBwYXJhbSAge0J1ZmZlcnxzdHJpbmd9IHBlZXJJZFxuICogQHBhcmFtICB7T2JqZWN0fSBleHRlbnNpb25zXG4gKi9cbldpcmUucHJvdG90eXBlLmhhbmRzaGFrZSA9IGZ1bmN0aW9uIChpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKSB7XG4gIHZhciBpbmZvSGFzaEJ1ZmZlciwgcGVlcklkQnVmZmVyXG4gIGlmICh0eXBlb2YgaW5mb0hhc2ggPT09ICdzdHJpbmcnKSB7XG4gICAgaW5mb0hhc2hCdWZmZXIgPSBCdWZmZXIuZnJvbShpbmZvSGFzaCwgJ2hleCcpXG4gIH0gZWxzZSB7XG4gICAgaW5mb0hhc2hCdWZmZXIgPSBpbmZvSGFzaFxuICAgIGluZm9IYXNoID0gaW5mb0hhc2hCdWZmZXIudG9TdHJpbmcoJ2hleCcpXG4gIH1cbiAgaWYgKHR5cGVvZiBwZWVySWQgPT09ICdzdHJpbmcnKSB7XG4gICAgcGVlcklkQnVmZmVyID0gQnVmZmVyLmZyb20ocGVlcklkLCAnaGV4JylcbiAgfSBlbHNlIHtcbiAgICBwZWVySWRCdWZmZXIgPSBwZWVySWRcbiAgICBwZWVySWQgPSBwZWVySWRCdWZmZXIudG9TdHJpbmcoJ2hleCcpXG4gIH1cblxuICBpZiAoaW5mb0hhc2hCdWZmZXIubGVuZ3RoICE9PSAyMCB8fCBwZWVySWRCdWZmZXIubGVuZ3RoICE9PSAyMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5mb0hhc2ggYW5kIHBlZXJJZCBNVVNUIGhhdmUgbGVuZ3RoIDIwJylcbiAgfVxuXG4gIHRoaXMuX2RlYnVnKCdoYW5kc2hha2UgaT0lcyBwPSVzIGV4dHM9JW8nLCBpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKVxuXG4gIHZhciByZXNlcnZlZCA9IEJ1ZmZlci5mcm9tKE1FU1NBR0VfUkVTRVJWRUQpXG5cbiAgLy8gZW5hYmxlIGV4dGVuZGVkIG1lc3NhZ2VcbiAgcmVzZXJ2ZWRbNV0gfD0gMHgxMFxuXG4gIGlmIChleHRlbnNpb25zICYmIGV4dGVuc2lvbnMuZGh0KSByZXNlcnZlZFs3XSB8PSAxXG5cbiAgdGhpcy5fcHVzaChCdWZmZXIuY29uY2F0KFtNRVNTQUdFX1BST1RPQ09MLCByZXNlcnZlZCwgaW5mb0hhc2hCdWZmZXIsIHBlZXJJZEJ1ZmZlcl0pKVxuICB0aGlzLl9oYW5kc2hha2VTZW50ID0gdHJ1ZVxuXG4gIGlmICh0aGlzLnBlZXJFeHRlbnNpb25zLmV4dGVuZGVkICYmICF0aGlzLl9leHRlbmRlZEhhbmRzaGFrZVNlbnQpIHtcbiAgICAvLyBQZWVyJ3MgaGFuZHNoYWtlIGluZGljYXRlZCBzdXBwb3J0IGFscmVhZHlcbiAgICAvLyAoaW5jb21pbmcgY29ubmVjdGlvbilcbiAgICB0aGlzLl9zZW5kRXh0ZW5kZWRIYW5kc2hha2UoKVxuICB9XG59XG5cbi8qIFBlZXIgc3VwcG9ydHMgQkVQLTAwMTAsIHNlbmQgZXh0ZW5kZWQgaGFuZHNoYWtlLlxuICpcbiAqIFRoaXMgY29tZXMgYWZ0ZXIgdGhlICdoYW5kc2hha2UnIGV2ZW50IHRvIGdpdmUgdGhlIHVzZXIgYSBjaGFuY2UgdG8gcG9wdWxhdGVcbiAqIGB0aGlzLmV4dGVuZGVkSGFuZHNoYWtlYCBhbmQgYHRoaXMuZXh0ZW5kZWRNYXBwaW5nYCBiZWZvcmUgdGhlIGV4dGVuZGVkIGhhbmRzaGFrZVxuICogaXMgc2VudCB0byB0aGUgcmVtb3RlIHBlZXIuXG4gKi9cbldpcmUucHJvdG90eXBlLl9zZW5kRXh0ZW5kZWRIYW5kc2hha2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENyZWF0ZSBleHRlbmRlZCBtZXNzYWdlIG9iamVjdCBmcm9tIHJlZ2lzdGVyZWQgZXh0ZW5zaW9uc1xuICB2YXIgbXNnID0gZXh0ZW5kKHRoaXMuZXh0ZW5kZWRIYW5kc2hha2UpXG4gIG1zZy5tID0ge31cbiAgZm9yICh2YXIgZXh0IGluIHRoaXMuZXh0ZW5kZWRNYXBwaW5nKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdXG4gICAgbXNnLm1bbmFtZV0gPSBOdW1iZXIoZXh0KVxuICB9XG5cbiAgLy8gU2VuZCBleHRlbmRlZCBoYW5kc2hha2VcbiAgdGhpcy5leHRlbmRlZCgwLCBiZW5jb2RlLmVuY29kZShtc2cpKVxuICB0aGlzLl9leHRlbmRlZEhhbmRzaGFrZVNlbnQgPSB0cnVlXG59XG5cbi8qKlxuICogTWVzc2FnZSBcImNob2tlXCI6IDxsZW49MDAwMT48aWQ9MD5cbiAqL1xuV2lyZS5wcm90b3R5cGUuY2hva2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFtQ2hva2luZykgcmV0dXJuXG4gIHRoaXMuYW1DaG9raW5nID0gdHJ1ZVxuICB0aGlzLl9kZWJ1ZygnY2hva2UnKVxuICB0aGlzLnBlZXJSZXF1ZXN0cy5zcGxpY2UoMCwgdGhpcy5wZWVyUmVxdWVzdHMubGVuZ3RoKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfQ0hPS0UpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcInVuY2hva2VcIjogPGxlbj0wMDAxPjxpZD0xPlxuICovXG5XaXJlLnByb3RvdHlwZS51bmNob2tlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuYW1DaG9raW5nKSByZXR1cm5cbiAgdGhpcy5hbUNob2tpbmcgPSBmYWxzZVxuICB0aGlzLl9kZWJ1ZygndW5jaG9rZScpXG4gIHRoaXMuX3B1c2goTUVTU0FHRV9VTkNIT0tFKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJpbnRlcmVzdGVkXCI6IDxsZW49MDAwMT48aWQ9Mj5cbiAqL1xuV2lyZS5wcm90b3R5cGUuaW50ZXJlc3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYW1JbnRlcmVzdGVkKSByZXR1cm5cbiAgdGhpcy5hbUludGVyZXN0ZWQgPSB0cnVlXG4gIHRoaXMuX2RlYnVnKCdpbnRlcmVzdGVkJylcbiAgdGhpcy5fcHVzaChNRVNTQUdFX0lOVEVSRVNURUQpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcInVuaW50ZXJlc3RlZFwiOiA8bGVuPTAwMDE+PGlkPTM+XG4gKi9cbldpcmUucHJvdG90eXBlLnVuaW50ZXJlc3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmFtSW50ZXJlc3RlZCkgcmV0dXJuXG4gIHRoaXMuYW1JbnRlcmVzdGVkID0gZmFsc2VcbiAgdGhpcy5fZGVidWcoJ3VuaW50ZXJlc3RlZCcpXG4gIHRoaXMuX3B1c2goTUVTU0FHRV9VTklOVEVSRVNURUQpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcImhhdmVcIjogPGxlbj0wMDA1PjxpZD00PjxwaWVjZSBpbmRleD5cbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqL1xuV2lyZS5wcm90b3R5cGUuaGF2ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB0aGlzLl9kZWJ1ZygnaGF2ZSAlZCcsIGluZGV4KVxuICB0aGlzLl9tZXNzYWdlKDQsIFtpbmRleF0sIG51bGwpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcImJpdGZpZWxkXCI6IDxsZW49MDAwMStYPjxpZD01PjxiaXRmaWVsZD5cbiAqIEBwYXJhbSAge0JpdEZpZWxkfEJ1ZmZlcn0gYml0ZmllbGRcbiAqL1xuV2lyZS5wcm90b3R5cGUuYml0ZmllbGQgPSBmdW5jdGlvbiAoYml0ZmllbGQpIHtcbiAgdGhpcy5fZGVidWcoJ2JpdGZpZWxkJylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYml0ZmllbGQpKSBiaXRmaWVsZCA9IGJpdGZpZWxkLmJ1ZmZlclxuICB0aGlzLl9tZXNzYWdlKDUsIFtdLCBiaXRmaWVsZClcbn1cblxuLyoqXG4gKiBNZXNzYWdlIFwicmVxdWVzdFwiOiA8bGVuPTAwMTM+PGlkPTY+PGluZGV4PjxiZWdpbj48bGVuZ3RoPlxuICogQHBhcmFtICB7bnVtYmVyfSAgIGluZGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgb2Zmc2V0XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgbGVuZ3RoXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2JcbiAqL1xuV2lyZS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGNiKSB7XG4gIGlmICghY2IpIGNiID0gZnVuY3Rpb24gKCkge31cbiAgaWYgKHRoaXMuX2ZpbmlzaGVkKSByZXR1cm4gY2IobmV3IEVycm9yKCd3aXJlIGlzIGNsb3NlZCcpKVxuICBpZiAodGhpcy5wZWVyQ2hva2luZykgcmV0dXJuIGNiKG5ldyBFcnJvcigncGVlciBpcyBjaG9raW5nJykpXG5cbiAgdGhpcy5fZGVidWcoJ3JlcXVlc3QgaW5kZXg9JWQgb2Zmc2V0PSVkIGxlbmd0aD0lZCcsIGluZGV4LCBvZmZzZXQsIGxlbmd0aClcblxuICB0aGlzLnJlcXVlc3RzLnB1c2gobmV3IFJlcXVlc3QoaW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYikpXG4gIHRoaXMuX3VwZGF0ZVRpbWVvdXQoKVxuICB0aGlzLl9tZXNzYWdlKDYsIFtpbmRleCwgb2Zmc2V0LCBsZW5ndGhdLCBudWxsKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJwaWVjZVwiOiA8bGVuPTAwMDkrWD48aWQ9Nz48aW5kZXg+PGJlZ2luPjxibG9jaz5cbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGJ1ZmZlclxuICovXG5XaXJlLnByb3RvdHlwZS5waWVjZSA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBidWZmZXIpIHtcbiAgdGhpcy5fZGVidWcoJ3BpZWNlIGluZGV4PSVkIG9mZnNldD0lZCcsIGluZGV4LCBvZmZzZXQpXG4gIHRoaXMudXBsb2FkZWQgKz0gYnVmZmVyLmxlbmd0aFxuICB0aGlzLnVwbG9hZFNwZWVkKGJ1ZmZlci5sZW5ndGgpXG4gIHRoaXMuZW1pdCgndXBsb2FkJywgYnVmZmVyLmxlbmd0aClcbiAgdGhpcy5fbWVzc2FnZSg3LCBbaW5kZXgsIG9mZnNldF0sIGJ1ZmZlcilcbn1cblxuLyoqXG4gKiBNZXNzYWdlIFwiY2FuY2VsXCI6IDxsZW49MDAxMz48aWQ9OD48aW5kZXg+PGJlZ2luPjxsZW5ndGg+XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtICB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuV2lyZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGluZGV4LCBvZmZzZXQsIGxlbmd0aCkge1xuICB0aGlzLl9kZWJ1ZygnY2FuY2VsIGluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQnLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG4gIHRoaXMuX2NhbGxiYWNrKFxuICAgIHB1bGwodGhpcy5yZXF1ZXN0cywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKSxcbiAgICBuZXcgRXJyb3IoJ3JlcXVlc3Qgd2FzIGNhbmNlbGxlZCcpLFxuICAgIG51bGxcbiAgKVxuICB0aGlzLl9tZXNzYWdlKDgsIFtpbmRleCwgb2Zmc2V0LCBsZW5ndGhdLCBudWxsKVxufVxuXG4vKipcbiAqIE1lc3NhZ2U6IFwicG9ydFwiIDxsZW49MDAwMz48aWQ9OT48bGlzdGVuLXBvcnQ+XG4gKiBAcGFyYW0ge051bWJlcn0gcG9ydFxuICovXG5XaXJlLnByb3RvdHlwZS5wb3J0ID0gZnVuY3Rpb24gKHBvcnQpIHtcbiAgdGhpcy5fZGVidWcoJ3BvcnQgJWQnLCBwb3J0KVxuICB2YXIgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKE1FU1NBR0VfUE9SVClcbiAgbWVzc2FnZS53cml0ZVVJbnQxNkJFKHBvcnQsIDUpXG4gIHRoaXMuX3B1c2gobWVzc2FnZSlcbn1cblxuLyoqXG4gKiBNZXNzYWdlOiBcImV4dGVuZGVkXCIgPGxlbj0wMDA1K1g+PGlkPTIwPjxleHQtbnVtYmVyPjxwYXlsb2FkPlxuICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gZXh0XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICovXG5XaXJlLnByb3RvdHlwZS5leHRlbmRlZCA9IGZ1bmN0aW9uIChleHQsIG9iaikge1xuICB0aGlzLl9kZWJ1ZygnZXh0ZW5kZWQgZXh0PSVzJywgZXh0KVxuICBpZiAodHlwZW9mIGV4dCA9PT0gJ3N0cmluZycgJiYgdGhpcy5wZWVyRXh0ZW5kZWRNYXBwaW5nW2V4dF0pIHtcbiAgICBleHQgPSB0aGlzLnBlZXJFeHRlbmRlZE1hcHBpbmdbZXh0XVxuICB9XG4gIGlmICh0eXBlb2YgZXh0ID09PSAnbnVtYmVyJykge1xuICAgIHZhciBleHRJZCA9IEJ1ZmZlci5mcm9tKFtleHRdKVxuICAgIHZhciBidWYgPSBCdWZmZXIuaXNCdWZmZXIob2JqKSA/IG9iaiA6IGJlbmNvZGUuZW5jb2RlKG9iailcblxuICAgIHRoaXMuX21lc3NhZ2UoMjAsIFtdLCBCdWZmZXIuY29uY2F0KFtleHRJZCwgYnVmXSkpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgZXh0ZW5zaW9uOiAnICsgZXh0KVxuICB9XG59XG5cbi8qKlxuICogRHVwbGV4IHN0cmVhbSBtZXRob2QuIENhbGxlZCB3aGVuZXZlciB0aGUgcmVtb3RlIHBlZXIgc3RyZWFtIHdhbnRzIGRhdGEuIE5vLW9wXG4gKiBzaW5jZSB3ZSdsbCBqdXN0IHB1c2ggZGF0YSB3aGVuZXZlciB3ZSBnZXQgaXQuXG4gKi9cbldpcmUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge31cblxuLyoqXG4gKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgcmVtb3RlIHBlZXIuXG4gKi9cbldpcmUucHJvdG90eXBlLl9tZXNzYWdlID0gZnVuY3Rpb24gKGlkLCBudW1iZXJzLCBkYXRhKSB7XG4gIHZhciBkYXRhTGVuZ3RoID0gZGF0YSA/IGRhdGEubGVuZ3RoIDogMFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDUgKyA0ICogbnVtYmVycy5sZW5ndGgpXG5cbiAgYnVmZmVyLndyaXRlVUludDMyQkUoYnVmZmVyLmxlbmd0aCArIGRhdGFMZW5ndGggLSA0LCAwKVxuICBidWZmZXJbNF0gPSBpZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShudW1iZXJzW2ldLCA1ICsgNCAqIGkpXG4gIH1cblxuICB0aGlzLl9wdXNoKGJ1ZmZlcilcbiAgaWYgKGRhdGEpIHRoaXMuX3B1c2goZGF0YSlcbn1cblxuV2lyZS5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICBpZiAodGhpcy5fZmluaXNoZWQpIHJldHVyblxuICByZXR1cm4gdGhpcy5wdXNoKGRhdGEpXG59XG5cbi8vXG4vLyBJTkNPTUlORyBNRVNTQUdFU1xuLy9cblxuV2lyZS5wcm90b3R5cGUuX29uS2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kZWJ1ZygnZ290IGtlZXAtYWxpdmUnKVxuICB0aGlzLmVtaXQoJ2tlZXAtYWxpdmUnKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25IYW5kc2hha2UgPSBmdW5jdGlvbiAoaW5mb0hhc2hCdWZmZXIsIHBlZXJJZEJ1ZmZlciwgZXh0ZW5zaW9ucykge1xuICB2YXIgaW5mb0hhc2ggPSBpbmZvSGFzaEJ1ZmZlci50b1N0cmluZygnaGV4JylcbiAgdmFyIHBlZXJJZCA9IHBlZXJJZEJ1ZmZlci50b1N0cmluZygnaGV4JylcblxuICB0aGlzLl9kZWJ1ZygnZ290IGhhbmRzaGFrZSBpPSVzIHA9JXMgZXh0cz0lbycsIGluZm9IYXNoLCBwZWVySWQsIGV4dGVuc2lvbnMpXG5cbiAgdGhpcy5wZWVySWQgPSBwZWVySWRcbiAgdGhpcy5wZWVySWRCdWZmZXIgPSBwZWVySWRCdWZmZXJcbiAgdGhpcy5wZWVyRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnNcblxuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGluZm9IYXNoLCBwZWVySWQsIGV4dGVuc2lvbnMpXG5cbiAgdmFyIG5hbWVcbiAgZm9yIChuYW1lIGluIHRoaXMuX2V4dCkge1xuICAgIHRoaXMuX2V4dFtuYW1lXS5vbkhhbmRzaGFrZShpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMuZXh0ZW5kZWQgJiYgdGhpcy5faGFuZHNoYWtlU2VudCAmJlxuICAgICAgIXRoaXMuX2V4dGVuZGVkSGFuZHNoYWtlU2VudCkge1xuICAgIC8vIG91dGdvaW5nIGNvbm5lY3Rpb25cbiAgICB0aGlzLl9zZW5kRXh0ZW5kZWRIYW5kc2hha2UoKVxuICB9XG59XG5cbldpcmUucHJvdG90eXBlLl9vbkNob2tlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBlZXJDaG9raW5nID0gdHJ1ZVxuICB0aGlzLl9kZWJ1ZygnZ290IGNob2tlJylcbiAgdGhpcy5lbWl0KCdjaG9rZScpXG4gIHdoaWxlICh0aGlzLnJlcXVlc3RzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMucmVxdWVzdHMuc2hpZnQoKSwgbmV3IEVycm9yKCdwZWVyIGlzIGNob2tpbmcnKSwgbnVsbClcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25VbmNob2tlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBlZXJDaG9raW5nID0gZmFsc2VcbiAgdGhpcy5fZGVidWcoJ2dvdCB1bmNob2tlJylcbiAgdGhpcy5lbWl0KCd1bmNob2tlJylcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uSW50ZXJlc3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVySW50ZXJlc3RlZCA9IHRydWVcbiAgdGhpcy5fZGVidWcoJ2dvdCBpbnRlcmVzdGVkJylcbiAgdGhpcy5lbWl0KCdpbnRlcmVzdGVkJylcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uVW5pbnRlcmVzdGVkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBlZXJJbnRlcmVzdGVkID0gZmFsc2VcbiAgdGhpcy5fZGVidWcoJ2dvdCB1bmludGVyZXN0ZWQnKVxuICB0aGlzLmVtaXQoJ3VuaW50ZXJlc3RlZCcpXG59XG5cbldpcmUucHJvdG90eXBlLl9vbkhhdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgaWYgKHRoaXMucGVlclBpZWNlcy5nZXQoaW5kZXgpKSByZXR1cm5cbiAgdGhpcy5fZGVidWcoJ2dvdCBoYXZlICVkJywgaW5kZXgpXG5cbiAgdGhpcy5wZWVyUGllY2VzLnNldChpbmRleCwgdHJ1ZSlcbiAgdGhpcy5lbWl0KCdoYXZlJywgaW5kZXgpXG59XG5cbldpcmUucHJvdG90eXBlLl9vbkJpdEZpZWxkID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB0aGlzLnBlZXJQaWVjZXMgPSBuZXcgQml0RmllbGQoYnVmZmVyKVxuICB0aGlzLl9kZWJ1ZygnZ290IGJpdGZpZWxkJylcbiAgdGhpcy5lbWl0KCdiaXRmaWVsZCcsIHRoaXMucGVlclBpZWNlcylcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uUmVxdWVzdCA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmFtQ2hva2luZykgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdnb3QgcmVxdWVzdCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuXG4gIHZhciByZXNwb25kID0gZnVuY3Rpb24gKGVyciwgYnVmZmVyKSB7XG4gICAgaWYgKHJlcXVlc3QgIT09IHB1bGwoc2VsZi5wZWVyUmVxdWVzdHMsIGluZGV4LCBvZmZzZXQsIGxlbmd0aCkpIHJldHVyblxuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLl9kZWJ1ZygnZXJyb3Igc2F0aXNmeWluZyByZXF1ZXN0IGluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQgKCVzKScsIGluZGV4LCBvZmZzZXQsIGxlbmd0aCwgZXJyLm1lc3NhZ2UpXG4gICAgc2VsZi5waWVjZShpbmRleCwgb2Zmc2V0LCBidWZmZXIpXG4gIH1cblxuICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGluZGV4LCBvZmZzZXQsIGxlbmd0aCwgcmVzcG9uZClcbiAgc2VsZi5wZWVyUmVxdWVzdHMucHVzaChyZXF1ZXN0KVxuICBzZWxmLmVtaXQoJ3JlcXVlc3QnLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIHJlc3BvbmQpXG59XG5cbldpcmUucHJvdG90eXBlLl9vblBpZWNlID0gZnVuY3Rpb24gKGluZGV4LCBvZmZzZXQsIGJ1ZmZlcikge1xuICB0aGlzLl9kZWJ1ZygnZ290IHBpZWNlIGluZGV4PSVkIG9mZnNldD0lZCcsIGluZGV4LCBvZmZzZXQpXG4gIHRoaXMuX2NhbGxiYWNrKHB1bGwodGhpcy5yZXF1ZXN0cywgaW5kZXgsIG9mZnNldCwgYnVmZmVyLmxlbmd0aCksIG51bGwsIGJ1ZmZlcilcbiAgdGhpcy5kb3dubG9hZGVkICs9IGJ1ZmZlci5sZW5ndGhcbiAgdGhpcy5kb3dubG9hZFNwZWVkKGJ1ZmZlci5sZW5ndGgpXG4gIHRoaXMuZW1pdCgnZG93bmxvYWQnLCBidWZmZXIubGVuZ3RoKVxuICB0aGlzLmVtaXQoJ3BpZWNlJywgaW5kZXgsIG9mZnNldCwgYnVmZmVyKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25DYW5jZWwgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHRoaXMuX2RlYnVnKCdnb3QgY2FuY2VsIGluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQnLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG4gIHB1bGwodGhpcy5wZWVyUmVxdWVzdHMsIGluZGV4LCBvZmZzZXQsIGxlbmd0aClcbiAgdGhpcy5lbWl0KCdjYW5jZWwnLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbldpcmUucHJvdG90eXBlLl9vblBvcnQgPSBmdW5jdGlvbiAocG9ydCkge1xuICB0aGlzLl9kZWJ1ZygnZ290IHBvcnQgJWQnLCBwb3J0KVxuICB0aGlzLmVtaXQoJ3BvcnQnLCBwb3J0KVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25FeHRlbmRlZCA9IGZ1bmN0aW9uIChleHQsIGJ1Zikge1xuICBpZiAoZXh0ID09PSAwKSB7XG4gICAgdmFyIGluZm9cbiAgICB0cnkge1xuICAgICAgaW5mbyA9IGJlbmNvZGUuZGVjb2RlKGJ1ZilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2RlYnVnKCdpZ25vcmluZyBpbnZhbGlkIGV4dGVuZGVkIGhhbmRzaGFrZTogJXMnLCBlcnIubWVzc2FnZSB8fCBlcnIpXG4gICAgfVxuXG4gICAgaWYgKCFpbmZvKSByZXR1cm5cbiAgICB0aGlzLnBlZXJFeHRlbmRlZEhhbmRzaGFrZSA9IGluZm9cblxuICAgIHZhciBuYW1lXG4gICAgaWYgKHR5cGVvZiBpbmZvLm0gPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKG5hbWUgaW4gaW5mby5tKSB7XG4gICAgICAgIHRoaXMucGVlckV4dGVuZGVkTWFwcGluZ1tuYW1lXSA9IE51bWJlcihpbmZvLm1bbmFtZV0udG9TdHJpbmcoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHRoaXMuX2V4dCkge1xuICAgICAgaWYgKHRoaXMucGVlckV4dGVuZGVkTWFwcGluZ1tuYW1lXSkge1xuICAgICAgICB0aGlzLl9leHRbbmFtZV0ub25FeHRlbmRlZEhhbmRzaGFrZSh0aGlzLnBlZXJFeHRlbmRlZEhhbmRzaGFrZSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGVidWcoJ2dvdCBleHRlbmRlZCBoYW5kc2hha2UnKVxuICAgIHRoaXMuZW1pdCgnZXh0ZW5kZWQnLCAnaGFuZHNoYWtlJywgdGhpcy5wZWVyRXh0ZW5kZWRIYW5kc2hha2UpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZXh0ZW5kZWRNYXBwaW5nW2V4dF0pIHtcbiAgICAgIGV4dCA9IHRoaXMuZXh0ZW5kZWRNYXBwaW5nW2V4dF0gLy8gZnJpZW5kbHkgbmFtZSBmb3IgZXh0ZW5zaW9uXG4gICAgICBpZiAodGhpcy5fZXh0W2V4dF0pIHtcbiAgICAgICAgLy8gdGhlcmUgaXMgYW4gcmVnaXN0ZXJlZCBleHRlbnNpb24gaGFuZGxlciwgc28gY2FsbCBpdFxuICAgICAgICB0aGlzLl9leHRbZXh0XS5vbk1lc3NhZ2UoYnVmKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9kZWJ1ZygnZ290IGV4dGVuZGVkIG1lc3NhZ2UgZXh0PSVzJywgZXh0KVxuICAgIHRoaXMuZW1pdCgnZXh0ZW5kZWQnLCBleHQsIGJ1ZilcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kZWJ1ZygncmVxdWVzdCB0aW1lZCBvdXQnKVxuICB0aGlzLl9jYWxsYmFjayh0aGlzLnJlcXVlc3RzLnNoaWZ0KCksIG5ldyBFcnJvcigncmVxdWVzdCBoYXMgdGltZWQgb3V0JyksIG51bGwpXG4gIHRoaXMuZW1pdCgndGltZW91dCcpXG59XG5cbi8qKlxuICogRHVwbGV4IHN0cmVhbSBtZXRob2QuIENhbGxlZCB3aGVuZXZlciB0aGUgcmVtb3RlIHBlZXIgaGFzIGRhdGEgZm9yIHVzLiBEYXRhIHRoYXQgdGhlXG4gKiByZW1vdGUgcGVlciBzZW5kcyBnZXRzIGJ1ZmZlcmVkIChpLmUuIG5vdCBhY3R1YWxseSBwcm9jZXNzZWQpIHVudGlsIHRoZSByaWdodCBudW1iZXJcbiAqIG9mIGJ5dGVzIGhhdmUgYXJyaXZlZCwgZGV0ZXJtaW5lZCBieSB0aGUgbGFzdCBjYWxsIHRvIGB0aGlzLl9wYXJzZShudW1iZXIsIGNhbGxiYWNrKWAuXG4gKiBPbmNlIGVub3VnaCBieXRlcyBoYXZlIGFycml2ZWQgdG8gcHJvY2VzcyB0aGUgbWVzc2FnZSwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAoaS5lLiBgdGhpcy5fcGFyc2VyYCkgZ2V0cyBjYWxsZWQgd2l0aCB0aGUgZnVsbCBidWZmZXIgb2YgZGF0YS5cbiAqIEBwYXJhbSAge0J1ZmZlcn0gZGF0YVxuICogQHBhcmFtICB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbldpcmUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5fYnVmZmVyU2l6ZSArPSBkYXRhLmxlbmd0aFxuICB0aGlzLl9idWZmZXIucHVzaChkYXRhKVxuXG4gIHdoaWxlICh0aGlzLl9idWZmZXJTaXplID49IHRoaXMuX3BhcnNlclNpemUpIHtcbiAgICB2YXIgYnVmZmVyID0gKHRoaXMuX2J1ZmZlci5sZW5ndGggPT09IDEpXG4gICAgICA/IHRoaXMuX2J1ZmZlclswXVxuICAgICAgOiBCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZmZlcilcbiAgICB0aGlzLl9idWZmZXJTaXplIC09IHRoaXMuX3BhcnNlclNpemVcbiAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXJTaXplXG4gICAgICA/IFtidWZmZXIuc2xpY2UodGhpcy5fcGFyc2VyU2l6ZSldXG4gICAgICA6IFtdXG4gICAgdGhpcy5fcGFyc2VyKGJ1ZmZlci5zbGljZSgwLCB0aGlzLl9wYXJzZXJTaXplKSlcbiAgfVxuXG4gIGNiKG51bGwpIC8vIFNpZ25hbCB0aGF0IHdlJ3JlIHJlYWR5IGZvciBtb3JlIGRhdGFcbn1cblxuV2lyZS5wcm90b3R5cGUuX2NhbGxiYWNrID0gZnVuY3Rpb24gKHJlcXVlc3QsIGVyciwgYnVmZmVyKSB7XG4gIGlmICghcmVxdWVzdCkgcmV0dXJuXG5cbiAgdGhpcy5fY2xlYXJUaW1lb3V0KClcblxuICBpZiAoIXRoaXMucGVlckNob2tpbmcgJiYgIXRoaXMuX2ZpbmlzaGVkKSB0aGlzLl91cGRhdGVUaW1lb3V0KClcbiAgcmVxdWVzdC5jYWxsYmFjayhlcnIsIGJ1ZmZlcilcbn1cblxuV2lyZS5wcm90b3R5cGUuX2NsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl90aW1lb3V0KSByZXR1cm5cblxuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcbiAgdGhpcy5fdGltZW91dCA9IG51bGxcbn1cblxuV2lyZS5wcm90b3R5cGUuX3VwZGF0ZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuX3RpbWVvdXRNcyB8fCAhc2VsZi5yZXF1ZXN0cy5sZW5ndGggfHwgc2VsZi5fdGltZW91dCkgcmV0dXJuXG5cbiAgc2VsZi5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uVGltZW91dCgpXG4gIH0sIHNlbGYuX3RpbWVvdXRNcylcbiAgaWYgKHNlbGYuX3RpbWVvdXRVbnJlZiAmJiBzZWxmLl90aW1lb3V0LnVucmVmKSBzZWxmLl90aW1lb3V0LnVucmVmKClcbn1cblxuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBvZiBieXRlcyB0aGF0IHRoZSBsb2NhbCBwZWVyIGlzIHdhaXRpbmcgdG8gcmVjZWl2ZSBmcm9tIHRoZSByZW1vdGUgcGVlclxuICogaW4gb3JkZXIgdG8gcGFyc2UgYSBjb21wbGV0ZSBtZXNzYWdlLCBhbmQgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBlbm91Z2hcbiAqIGJ5dGVzIGhhdmUgYXJyaXZlZC5cbiAqIEBwYXJhbSAge251bWJlcn0gc2l6ZVxuICogQHBhcmFtICB7ZnVuY3Rpb259IHBhcnNlclxuICovXG5XaXJlLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiAoc2l6ZSwgcGFyc2VyKSB7XG4gIHRoaXMuX3BhcnNlclNpemUgPSBzaXplXG4gIHRoaXMuX3BhcnNlciA9IHBhcnNlclxufVxuXG4vKipcbiAqIEhhbmRsZSB0aGUgZmlyc3QgNCBieXRlcyBvZiBhIG1lc3NhZ2UsIHRvIGRldGVybWluZSB0aGUgbGVuZ3RoIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZVxuICogd2FpdGVkIGZvciBpbiBvcmRlciB0byBoYXZlIHRoZSB3aG9sZSBtZXNzYWdlLlxuICogQHBhcmFtICB7QnVmZmVyfSBidWZmZXJcbiAqL1xuV2lyZS5wcm90b3R5cGUuX29uTWVzc2FnZUxlbmd0aCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoMClcbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9wYXJzZShsZW5ndGgsIHRoaXMuX29uTWVzc2FnZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9vbktlZXBBbGl2ZSgpXG4gICAgdGhpcy5fcGFyc2UoNCwgdGhpcy5fb25NZXNzYWdlTGVuZ3RoKVxuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGEgbWVzc2FnZSBmcm9tIHRoZSByZW1vdGUgcGVlci5cbiAqIEBwYXJhbSAge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbldpcmUucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHRoaXMuX3BhcnNlKDQsIHRoaXMuX29uTWVzc2FnZUxlbmd0aClcbiAgc3dpdGNoIChidWZmZXJbMF0pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gdGhpcy5fb25DaG9rZSgpXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHRoaXMuX29uVW5jaG9rZSgpXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHRoaXMuX29uSW50ZXJlc3RlZCgpXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHRoaXMuX29uVW5pbnRlcmVzdGVkKClcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gdGhpcy5fb25IYXZlKGJ1ZmZlci5yZWFkVUludDMyQkUoMSkpXG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIHRoaXMuX29uQml0RmllbGQoYnVmZmVyLnNsaWNlKDEpKVxuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiB0aGlzLl9vblJlcXVlc3QoYnVmZmVyLnJlYWRVSW50MzJCRSgxKSxcbiAgICAgICAgICBidWZmZXIucmVhZFVJbnQzMkJFKDUpLCBidWZmZXIucmVhZFVJbnQzMkJFKDkpKVxuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBpZWNlKGJ1ZmZlci5yZWFkVUludDMyQkUoMSksXG4gICAgICAgICAgYnVmZmVyLnJlYWRVSW50MzJCRSg1KSwgYnVmZmVyLnNsaWNlKDkpKVxuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiB0aGlzLl9vbkNhbmNlbChidWZmZXIucmVhZFVJbnQzMkJFKDEpLFxuICAgICAgICAgIGJ1ZmZlci5yZWFkVUludDMyQkUoNSksIGJ1ZmZlci5yZWFkVUludDMyQkUoOSkpXG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIHRoaXMuX29uUG9ydChidWZmZXIucmVhZFVJbnQxNkJFKDEpKVxuICAgIGNhc2UgMjA6XG4gICAgICByZXR1cm4gdGhpcy5fb25FeHRlbmRlZChidWZmZXIucmVhZFVJbnQ4KDEpLCBidWZmZXIuc2xpY2UoMikpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuX2RlYnVnKCdnb3QgdW5rbm93biBtZXNzYWdlJylcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ3Vua25vd25tZXNzYWdlJywgYnVmZmVyKVxuICB9XG59XG5cbldpcmUucHJvdG90eXBlLl9wYXJzZUhhbmRzaGFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX3BhcnNlKDEsIGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICB2YXIgcHN0cmxlbiA9IGJ1ZmZlci5yZWFkVUludDgoMClcbiAgICBzZWxmLl9wYXJzZShwc3RybGVuICsgNDgsIGZ1bmN0aW9uIChoYW5kc2hha2UpIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IGhhbmRzaGFrZS5zbGljZSgwLCBwc3RybGVuKVxuICAgICAgaWYgKHByb3RvY29sLnRvU3RyaW5nKCkgIT09ICdCaXRUb3JyZW50IHByb3RvY29sJykge1xuICAgICAgICBzZWxmLl9kZWJ1ZygnRXJyb3I6IHdpcmUgbm90IHNwZWFraW5nIEJpdFRvcnJlbnQgcHJvdG9jb2wgKCVzKScsIHByb3RvY29sLnRvU3RyaW5nKCkpXG4gICAgICAgIHNlbGYuZW5kKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBoYW5kc2hha2UgPSBoYW5kc2hha2Uuc2xpY2UocHN0cmxlbilcbiAgICAgIHNlbGYuX29uSGFuZHNoYWtlKGhhbmRzaGFrZS5zbGljZSg4LCAyOCksIGhhbmRzaGFrZS5zbGljZSgyOCwgNDgpLCB7XG4gICAgICAgIGRodDogISEoaGFuZHNoYWtlWzddICYgMHgwMSksIC8vIHNlZSBiZXBfMDAwNVxuICAgICAgICBleHRlbmRlZDogISEoaGFuZHNoYWtlWzVdICYgMHgxMCkgLy8gc2VlIGJlcF8wMDEwXG4gICAgICB9KVxuICAgICAgc2VsZi5fcGFyc2UoNCwgc2VsZi5fb25NZXNzYWdlTGVuZ3RoKVxuICAgIH0pXG4gIH0pXG59XG5cbldpcmUucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZmluaXNoZWQgPSB0cnVlXG5cbiAgdGhpcy5wdXNoKG51bGwpIC8vIHN0cmVhbSBjYW5ub3QgYmUgaGFsZiBvcGVuLCBzbyBzaWduYWwgdGhlIGVuZCBvZiBpdFxuICB3aGlsZSAodGhpcy5yZWFkKCkpIHt9IC8vIGNvbnN1bWUgYW5kIGRpc2NhcmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmVhbSBkYXRhXG5cbiAgY2xlYXJJbnRlcnZhbCh0aGlzLl9rZWVwQWxpdmVJbnRlcnZhbClcbiAgdGhpcy5fcGFyc2UoTnVtYmVyLk1BWF9WQUxVRSwgZnVuY3Rpb24gKCkge30pXG4gIHRoaXMucGVlclJlcXVlc3RzID0gW11cbiAgd2hpbGUgKHRoaXMucmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sodGhpcy5yZXF1ZXN0cy5zaGlmdCgpLCBuZXcgRXJyb3IoJ3dpcmUgd2FzIGNsb3NlZCcpLCBudWxsKVxuICB9XG59XG5cbldpcmUucHJvdG90eXBlLl9kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgYXJnc1swXSA9ICdbJyArIHRoaXMuX2RlYnVnSWQgKyAnXSAnICsgYXJnc1swXVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmdzKVxufVxuXG5mdW5jdGlvbiBwdWxsIChyZXF1ZXN0cywgcGllY2UsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVxID0gcmVxdWVzdHNbaV1cbiAgICBpZiAocmVxLnBpZWNlICE9PSBwaWVjZSB8fCByZXEub2Zmc2V0ICE9PSBvZmZzZXQgfHwgcmVxLmxlbmd0aCAhPT0gbGVuZ3RoKSBjb250aW51ZVxuXG4gICAgaWYgKGkgPT09IDApIHJlcXVlc3RzLnNoaWZ0KClcbiAgICBlbHNlIHJlcXVlc3RzLnNwbGljZShpLCAxKVxuXG4gICAgcmV0dXJuIHJlcVxuICB9XG4gIHJldHVybiBudWxsXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IENsaWVudFxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2JpdHRvcnJlbnQtdHJhY2tlcicpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbnZhciBwYXJhbGxlbCA9IHJlcXVpcmUoJ3J1bi1wYXJhbGxlbCcpXG52YXIgUGVlciA9IHJlcXVpcmUoJ3NpbXBsZS1wZWVyJylcbnZhciB1bmlxID0gcmVxdWlyZSgndW5pcScpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vbGliL2NvbW1vbicpXG52YXIgSFRUUFRyYWNrZXIgPSByZXF1aXJlKCcuL2xpYi9jbGllbnQvaHR0cC10cmFja2VyJykgLy8gZW1wdHkgb2JqZWN0IGluIGJyb3dzZXJcbnZhciBVRFBUcmFja2VyID0gcmVxdWlyZSgnLi9saWIvY2xpZW50L3VkcC10cmFja2VyJykgLy8gZW1wdHkgb2JqZWN0IGluIGJyb3dzZXJcbnZhciBXZWJTb2NrZXRUcmFja2VyID0gcmVxdWlyZSgnLi9saWIvY2xpZW50L3dlYnNvY2tldC10cmFja2VyJylcblxuaW5oZXJpdHMoQ2xpZW50LCBFdmVudEVtaXR0ZXIpXG5cbi8qKlxuICogQml0VG9ycmVudCB0cmFja2VyIGNsaWVudC5cbiAqXG4gKiBGaW5kIHRvcnJlbnQgcGVlcnMsIHRvIGhlbHAgYSB0b3JyZW50IGNsaWVudCBwYXJ0aWNpcGF0ZSBpbiBhIHRvcnJlbnQgc3dhcm0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IG9wdHMuaW5mb0hhc2ggICAgICAgICAgdG9ycmVudCBpbmZvIGhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gb3B0cy5wZWVySWQgICAgICAgICAgICBwZWVyIGlkXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gb3B0cy5hbm5vdW5jZSAgYW5ub3VuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnBvcnQgICAgICAgICAgICAgICAgICAgICB0b3JyZW50IGNsaWVudCBsaXN0ZW5pbmcgcG9ydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0cy5nZXRBbm5vdW5jZU9wdHMgICAgICAgIGNhbGxiYWNrIHRvIHByb3ZpZGUgZGF0YSB0byB0cmFja2VyXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5ydGNDb25maWcgICAgICAgICAgICAgICAgUlRDUGVlckNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLndydGMgICAgICAgICAgICAgICAgICAgICBjdXN0b20gd2VicnRjIGltcGwgKHVzZWZ1bCBpbiBub2RlLmpzKVxuICovXG5mdW5jdGlvbiBDbGllbnQgKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBDbGllbnQpKSByZXR1cm4gbmV3IENsaWVudChvcHRzKVxuICBFdmVudEVtaXR0ZXIuY2FsbChzZWxmKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIGlmICghb3B0cy5wZWVySWQpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBwZWVySWRgIGlzIHJlcXVpcmVkJylcbiAgaWYgKCFvcHRzLmluZm9IYXNoKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgaW5mb0hhc2hgIGlzIHJlcXVpcmVkJylcbiAgaWYgKCFvcHRzLmFubm91bmNlKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgYW5ub3VuY2VgIGlzIHJlcXVpcmVkJylcbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgIW9wdHMucG9ydCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYHBvcnRgIGlzIHJlcXVpcmVkJylcblxuICAvLyByZXF1aXJlZFxuICBzZWxmLnBlZXJJZCA9IHR5cGVvZiBvcHRzLnBlZXJJZCA9PT0gJ3N0cmluZydcbiAgICA/IG9wdHMucGVlcklkXG4gICAgOiBvcHRzLnBlZXJJZC50b1N0cmluZygnaGV4JylcbiAgc2VsZi5fcGVlcklkQnVmZmVyID0gQnVmZmVyLmZyb20oc2VsZi5wZWVySWQsICdoZXgnKVxuICBzZWxmLl9wZWVySWRCaW5hcnkgPSBzZWxmLl9wZWVySWRCdWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpXG5cbiAgc2VsZi5pbmZvSGFzaCA9IHR5cGVvZiBvcHRzLmluZm9IYXNoID09PSAnc3RyaW5nJ1xuICAgID8gb3B0cy5pbmZvSGFzaFxuICAgIDogb3B0cy5pbmZvSGFzaC50b1N0cmluZygnaGV4JylcbiAgc2VsZi5faW5mb0hhc2hCdWZmZXIgPSBCdWZmZXIuZnJvbShzZWxmLmluZm9IYXNoLCAnaGV4JylcbiAgc2VsZi5faW5mb0hhc2hCaW5hcnkgPSBzZWxmLl9pbmZvSGFzaEJ1ZmZlci50b1N0cmluZygnYmluYXJ5JylcblxuICBzZWxmLl9wb3J0ID0gb3B0cy5wb3J0XG5cbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIHNlbGYuX3J0Y0NvbmZpZyA9IG9wdHMucnRjQ29uZmlnXG4gIHNlbGYuX3dydGMgPSBvcHRzLndydGNcbiAgc2VsZi5fZ2V0QW5ub3VuY2VPcHRzID0gb3B0cy5nZXRBbm5vdW5jZU9wdHNcblxuICBkZWJ1ZygnbmV3IGNsaWVudCAlcycsIHNlbGYuaW5mb0hhc2gpXG5cbiAgdmFyIHdlYnJ0Y1N1cHBvcnQgPSBzZWxmLl93cnRjICE9PSBmYWxzZSAmJiAoISFzZWxmLl93cnRjIHx8IFBlZXIuV0VCUlRDX1NVUFBPUlQpXG5cbiAgdmFyIGFubm91bmNlID0gKHR5cGVvZiBvcHRzLmFubm91bmNlID09PSAnc3RyaW5nJylcbiAgICA/IFsgb3B0cy5hbm5vdW5jZSBdXG4gICAgOiBvcHRzLmFubm91bmNlID09IG51bGxcbiAgICAgID8gW11cbiAgICAgIDogb3B0cy5hbm5vdW5jZVxuXG4gIGFubm91bmNlID0gYW5ub3VuY2UubWFwKGZ1bmN0aW9uIChhbm5vdW5jZVVybCkge1xuICAgIGFubm91bmNlVXJsID0gYW5ub3VuY2VVcmwudG9TdHJpbmcoKVxuICAgIGlmIChhbm5vdW5jZVVybFthbm5vdW5jZVVybC5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2ggZnJvbSB0cmFja2VycyB0byBjYXRjaCBkdXBsaWNhdGVzXG4gICAgICBhbm5vdW5jZVVybCA9IGFubm91bmNlVXJsLnN1YnN0cmluZygwLCBhbm5vdW5jZVVybC5sZW5ndGggLSAxKVxuICAgIH1cbiAgICByZXR1cm4gYW5ub3VuY2VVcmxcbiAgfSlcblxuICBhbm5vdW5jZSA9IHVuaXEoYW5ub3VuY2UpXG5cbiAgc2VsZi5fdHJhY2tlcnMgPSBhbm5vdW5jZVxuICAgIC5tYXAoZnVuY3Rpb24gKGFubm91bmNlVXJsKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB1cmwucGFyc2UoYW5ub3VuY2VVcmwpLnByb3RvY29sXG4gICAgICBpZiAoKHByb3RvY29sID09PSAnaHR0cDonIHx8IHByb3RvY29sID09PSAnaHR0cHM6JykgJiZcbiAgICAgICAgICB0eXBlb2YgSFRUUFRyYWNrZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIVFRQVHJhY2tlcihzZWxmLCBhbm5vdW5jZVVybClcbiAgICAgIH0gZWxzZSBpZiAocHJvdG9jb2wgPT09ICd1ZHA6JyAmJiB0eXBlb2YgVURQVHJhY2tlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFVEUFRyYWNrZXIoc2VsZiwgYW5ub3VuY2VVcmwpXG4gICAgICB9IGVsc2UgaWYgKChwcm90b2NvbCA9PT0gJ3dzOicgfHwgcHJvdG9jb2wgPT09ICd3c3M6JykgJiYgd2VicnRjU3VwcG9ydCkge1xuICAgICAgICAvLyBTa2lwIHdzOi8vIHRyYWNrZXJzIG9uIGh0dHBzOi8vIHNpdGVzIGJlY2F1c2UgdGhleSB0aHJvdyBTZWN1cml0eUVycm9yXG4gICAgICAgIGlmIChwcm90b2NvbCA9PT0gJ3dzOicgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICBuZXh0VGlja1dhcm4obmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0cmFja2VyIHByb3RvY29sOiAnICsgYW5ub3VuY2VVcmwpKVxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXZWJTb2NrZXRUcmFja2VyKHNlbGYsIGFubm91bmNlVXJsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFRpY2tXYXJuKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHJhY2tlciBwcm90b2NvbDogJyArIGFubm91bmNlVXJsKSlcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9KVxuICAgIC5maWx0ZXIoQm9vbGVhbilcblxuICBmdW5jdGlvbiBuZXh0VGlja1dhcm4gKGVycikge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCd3YXJuaW5nJywgZXJyKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2NyYXBlIGEgdHJhY2tlciBmb3IgYW4gaW5mbyBoYXNoIHdpdGhvdXQgbmVlZGluZyB0b1xuICogY3JlYXRlIGEgQ2xpZW50LCBwYXNzIGl0IGEgcGFyc2VkIHRvcnJlbnQsIGV0Yy4gU3VwcG9ydCBzY3JhcGluZyBhIHRyYWNrZXIgZm9yIG11bHRpcGxlXG4gKiB0b3JyZW50cyBhdCB0aGUgc2FtZSB0aW1lLlxuICogQHBhcmFtcyB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IG9wdHMuaW5mb0hhc2hcbiAqIEBwYXJhbSAge3N0cmluZ30gb3B0cy5hbm5vdW5jZVxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbkNsaWVudC5zY3JhcGUgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgY2IgPSBvbmNlKGNiKVxuXG4gIGlmICghb3B0cy5pbmZvSGFzaCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGluZm9IYXNoYCBpcyByZXF1aXJlZCcpXG4gIGlmICghb3B0cy5hbm5vdW5jZSkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGFubm91bmNlYCBpcyByZXF1aXJlZCcpXG5cbiAgdmFyIGNsaWVudE9wdHMgPSBleHRlbmQob3B0cywge1xuICAgIGluZm9IYXNoOiBBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpID8gb3B0cy5pbmZvSGFzaFswXSA6IG9wdHMuaW5mb0hhc2gsXG4gICAgcGVlcklkOiBCdWZmZXIuZnJvbSgnMDEyMzQ1Njc4OTAxMjM0NTY3ODknKSwgLy8gZHVtbXkgdmFsdWVcbiAgICBwb3J0OiA2ODgxIC8vIGR1bW15IHZhbHVlXG4gIH0pXG5cbiAgdmFyIGNsaWVudCA9IG5ldyBDbGllbnQoY2xpZW50T3B0cylcbiAgY2xpZW50Lm9uY2UoJ2Vycm9yJywgY2IpXG5cbiAgdmFyIGxlbiA9IEFycmF5LmlzQXJyYXkob3B0cy5pbmZvSGFzaCkgPyBvcHRzLmluZm9IYXNoLmxlbmd0aCA6IDFcbiAgdmFyIHJlc3VsdHMgPSB7fVxuICBjbGllbnQub24oJ3NjcmFwZScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgbGVuIC09IDFcbiAgICByZXN1bHRzW2RhdGEuaW5mb0hhc2hdID0gZGF0YVxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIGNsaWVudC5kZXN0cm95KClcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVzdWx0cylcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjYihudWxsLCByZXN1bHRzW2tleXNbMF1dKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgcmVzdWx0cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgb3B0cy5pbmZvSGFzaCA9IEFycmF5LmlzQXJyYXkob3B0cy5pbmZvSGFzaClcbiAgICA/IG9wdHMuaW5mb0hhc2gubWFwKGZ1bmN0aW9uIChpbmZvSGFzaCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGluZm9IYXNoLCAnaGV4JylcbiAgICB9KVxuICAgIDogQnVmZmVyLmZyb20ob3B0cy5pbmZvSGFzaCwgJ2hleCcpXG4gIGNsaWVudC5zY3JhcGUoeyBpbmZvSGFzaDogb3B0cy5pbmZvSGFzaCB9KVxuICByZXR1cm4gY2xpZW50XG59XG5cbi8qKlxuICogU2VuZCBhIGBzdGFydGAgYW5ub3VuY2UgdG8gdGhlIHRyYWNrZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy51cGxvYWRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmRvd25sb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5sZWZ0IChpZiBub3Qgc2V0LCBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkpXG4gKi9cbkNsaWVudC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NlbmQgYHN0YXJ0YCcpXG4gIG9wdHMgPSBzZWxmLl9kZWZhdWx0QW5ub3VuY2VPcHRzKG9wdHMpXG4gIG9wdHMuZXZlbnQgPSAnc3RhcnRlZCdcbiAgc2VsZi5fYW5ub3VuY2Uob3B0cylcblxuICAvLyBzdGFydCBhbm5vdW5jaW5nIG9uIGludGVydmFsc1xuICBzZWxmLl90cmFja2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja2VyKSB7XG4gICAgdHJhY2tlci5zZXRJbnRlcnZhbCgpXG4gIH0pXG59XG5cbi8qKlxuICogU2VuZCBhIGBzdG9wYCBhbm5vdW5jZSB0byB0aGUgdHJhY2tlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLnVwbG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMuZG93bmxvYWRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLm51bXdhbnRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5sZWZ0IChpZiBub3Qgc2V0LCBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkpXG4gKi9cbkNsaWVudC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2VuZCBgc3RvcGAnKVxuICBvcHRzID0gc2VsZi5fZGVmYXVsdEFubm91bmNlT3B0cyhvcHRzKVxuICBvcHRzLmV2ZW50ID0gJ3N0b3BwZWQnXG4gIHNlbGYuX2Fubm91bmNlKG9wdHMpXG59XG5cbi8qKlxuICogU2VuZCBhIGBjb21wbGV0ZWAgYW5ub3VuY2UgdG8gdGhlIHRyYWNrZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy51cGxvYWRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmRvd25sb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5udW13YW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubGVmdCAoaWYgbm90IHNldCwgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5KVxuICovXG5DbGllbnQucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKCdzZW5kIGBjb21wbGV0ZWAnKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBvcHRzID0gc2VsZi5fZGVmYXVsdEFubm91bmNlT3B0cyhvcHRzKVxuICBvcHRzLmV2ZW50ID0gJ2NvbXBsZXRlZCdcbiAgc2VsZi5fYW5ub3VuY2Uob3B0cylcbn1cblxuLyoqXG4gKiBTZW5kIGEgYHVwZGF0ZWAgYW5ub3VuY2UgdG8gdGhlIHRyYWNrZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy51cGxvYWRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmRvd25sb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5udW13YW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubGVmdCAoaWYgbm90IHNldCwgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5KVxuICovXG5DbGllbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2VuZCBgdXBkYXRlYCcpXG4gIG9wdHMgPSBzZWxmLl9kZWZhdWx0QW5ub3VuY2VPcHRzKG9wdHMpXG4gIGlmIChvcHRzLmV2ZW50KSBkZWxldGUgb3B0cy5ldmVudFxuICBzZWxmLl9hbm5vdW5jZShvcHRzKVxufVxuXG5DbGllbnQucHJvdG90eXBlLl9hbm5vdW5jZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl90cmFja2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja2VyKSB7XG4gICAgLy8gdHJhY2tlciBzaG91bGQgbm90IG1vZGlmeSBgb3B0c2Agb2JqZWN0LCBpdCdzIHBhc3NlZCB0byBhbGwgdHJhY2tlcnNcbiAgICB0cmFja2VyLmFubm91bmNlKG9wdHMpXG4gIH0pXG59XG5cbi8qKlxuICogU2VuZCBhIHNjcmFwZSByZXF1ZXN0IHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbkNsaWVudC5wcm90b3R5cGUuc2NyYXBlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKCdzZW5kIGBzY3JhcGVgJylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIC8vIHRyYWNrZXIgc2hvdWxkIG5vdCBtb2RpZnkgYG9wdHNgIG9iamVjdCwgaXQncyBwYXNzZWQgdG8gYWxsIHRyYWNrZXJzXG4gICAgdHJhY2tlci5zY3JhcGUob3B0cylcbiAgfSlcbn1cblxuQ2xpZW50LnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIChpbnRlcnZhbE1zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2V0SW50ZXJ2YWwgJWQnLCBpbnRlcnZhbE1zKVxuICBzZWxmLl90cmFja2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja2VyKSB7XG4gICAgdHJhY2tlci5zZXRJbnRlcnZhbChpbnRlcnZhbE1zKVxuICB9KVxufVxuXG5DbGllbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuICBkZWJ1ZygnZGVzdHJveScpXG5cbiAgdmFyIHRhc2tzID0gc2VsZi5fdHJhY2tlcnMubWFwKGZ1bmN0aW9uICh0cmFja2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgdHJhY2tlci5kZXN0cm95KGNiKVxuICAgIH1cbiAgfSlcblxuICBwYXJhbGxlbCh0YXNrcywgY2IpXG5cbiAgc2VsZi5fdHJhY2tlcnMgPSBbXVxuICBzZWxmLl9nZXRBbm5vdW5jZU9wdHMgPSBudWxsXG59XG5cbkNsaWVudC5wcm90b3R5cGUuX2RlZmF1bHRBbm5vdW5jZU9wdHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBpZiAob3B0cy5udW13YW50ID09IG51bGwpIG9wdHMubnVtd2FudCA9IGNvbW1vbi5ERUZBVUxUX0FOTk9VTkNFX1BFRVJTXG5cbiAgaWYgKG9wdHMudXBsb2FkZWQgPT0gbnVsbCkgb3B0cy51cGxvYWRlZCA9IDBcbiAgaWYgKG9wdHMuZG93bmxvYWRlZCA9PSBudWxsKSBvcHRzLmRvd25sb2FkZWQgPSAwXG5cbiAgaWYgKHNlbGYuX2dldEFubm91bmNlT3B0cykgb3B0cyA9IGV4dGVuZChvcHRzLCBzZWxmLl9nZXRBbm5vdW5jZU9wdHMoKSlcbiAgcmV0dXJuIG9wdHNcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gVHJhY2tlclxuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmluaGVyaXRzKFRyYWNrZXIsIEV2ZW50RW1pdHRlcilcblxuZnVuY3Rpb24gVHJhY2tlciAoY2xpZW50LCBhbm5vdW5jZVVybCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcbiAgc2VsZi5jbGllbnQgPSBjbGllbnRcbiAgc2VsZi5hbm5vdW5jZVVybCA9IGFubm91bmNlVXJsXG5cbiAgc2VsZi5pbnRlcnZhbCA9IG51bGxcbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxufVxuXG5UcmFja2VyLnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIChpbnRlcnZhbE1zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoaW50ZXJ2YWxNcyA9PSBudWxsKSBpbnRlcnZhbE1zID0gc2VsZi5ERUZBVUxUX0FOTk9VTkNFX0lOVEVSVkFMXG5cbiAgY2xlYXJJbnRlcnZhbChzZWxmLmludGVydmFsKVxuXG4gIGlmIChpbnRlcnZhbE1zKSB7XG4gICAgc2VsZi5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuYW5ub3VuY2Uoc2VsZi5jbGllbnQuX2RlZmF1bHRBbm5vdW5jZU9wdHMoKSlcbiAgICB9LCBpbnRlcnZhbE1zKVxuICAgIGlmIChzZWxmLmludGVydmFsLnVucmVmKSBzZWxmLmludGVydmFsLnVucmVmKClcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFja2VyXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2JpdHRvcnJlbnQtdHJhY2tlcjp3ZWJzb2NrZXQtdHJhY2tlcicpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGhhdCA9IHJlcXVpcmUoJ2hhdCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgUGVlciA9IHJlcXVpcmUoJ3NpbXBsZS1wZWVyJylcbnZhciBTb2NrZXQgPSByZXF1aXJlKCdzaW1wbGUtd2Vic29ja2V0JylcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpXG52YXIgVHJhY2tlciA9IHJlcXVpcmUoJy4vdHJhY2tlcicpXG5cbi8vIFVzZSBhIHNvY2tldCBwb29sLCBzbyB0cmFja2VyIGNsaWVudHMgc2hhcmUgV2ViU29ja2V0IG9iamVjdHMgZm9yIHRoZSBzYW1lIHNlcnZlci5cbi8vIEluIHByYWN0aWNlLCBXZWJTb2NrZXRzIGFyZSBwcmV0dHkgc2xvdyB0byBlc3RhYmxpc2gsIHNvIHRoaXMgZ2l2ZXMgYSBuaWNlIHBlcmZvcm1hbmNlXG4vLyBib29zdCwgYW5kIHNhdmVzIGJyb3dzZXIgcmVzb3VyY2VzLlxudmFyIHNvY2tldFBvb2wgPSB7fVxuXG52YXIgUkVDT05ORUNUX01JTklNVU0gPSAxNSAqIDEwMDBcbnZhciBSRUNPTk5FQ1RfTUFYSU1VTSA9IDMwICogNjAgKiAxMDAwXG52YXIgUkVDT05ORUNUX1ZBUklBTkNFID0gMzAgKiAxMDAwXG52YXIgT0ZGRVJfVElNRU9VVCA9IDUwICogMTAwMFxuXG5pbmhlcml0cyhXZWJTb2NrZXRUcmFja2VyLCBUcmFja2VyKVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFja2VyIChjbGllbnQsIGFubm91bmNlVXJsLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBUcmFja2VyLmNhbGwoc2VsZiwgY2xpZW50LCBhbm5vdW5jZVVybClcbiAgZGVidWcoJ25ldyB3ZWJzb2NrZXQgdHJhY2tlciAlcycsIGFubm91bmNlVXJsKVxuXG4gIHNlbGYucGVlcnMgPSB7fSAvLyBwZWVycyAob2ZmZXIgaWQgLT4gcGVlcilcbiAgc2VsZi5zb2NrZXQgPSBudWxsXG5cbiAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZVxuICBzZWxmLnJldHJpZXMgPSAwXG4gIHNlbGYucmVjb25uZWN0VGltZXIgPSBudWxsXG5cbiAgc2VsZi5fb3BlblNvY2tldCgpXG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLkRFRkFVTFRfQU5OT1VOQ0VfSU5URVJWQUwgPSAzMCAqIDEwMDAgLy8gMzAgc2Vjb25kc1xuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5hbm5vdW5jZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQgfHwgc2VsZi5yZWNvbm5lY3RpbmcpIHJldHVyblxuICBpZiAoIXNlbGYuc29ja2V0LmNvbm5lY3RlZCkge1xuICAgIHNlbGYuc29ja2V0Lm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmFubm91bmNlKG9wdHMpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBwYXJhbXMgPSBleHRlbmQob3B0cywge1xuICAgIGFjdGlvbjogJ2Fubm91bmNlJyxcbiAgICBpbmZvX2hhc2g6IHNlbGYuY2xpZW50Ll9pbmZvSGFzaEJpbmFyeSxcbiAgICBwZWVyX2lkOiBzZWxmLmNsaWVudC5fcGVlcklkQmluYXJ5XG4gIH0pXG4gIGlmIChzZWxmLl90cmFja2VySWQpIHBhcmFtcy50cmFja2VyaWQgPSBzZWxmLl90cmFja2VySWRcblxuICBpZiAob3B0cy5ldmVudCA9PT0gJ3N0b3BwZWQnKSB7XG4gICAgLy8gRG9uJ3QgaW5jbHVkZSBvZmZlcnMgd2l0aCAnc3RvcHBlZCcgZXZlbnRcbiAgICBzZWxmLl9zZW5kKHBhcmFtcylcbiAgfSBlbHNlIHtcbiAgICAvLyBMaW1pdCB0aGUgbnVtYmVyIG9mIG9mZmVycyB0aGF0IGFyZSBnZW5lcmF0ZWQsIHNpbmNlIGl0IGNhbiBiZSBzbG93XG4gICAgdmFyIG51bXdhbnQgPSBNYXRoLm1pbihvcHRzLm51bXdhbnQsIDUpXG5cbiAgICBzZWxmLl9nZW5lcmF0ZU9mZmVycyhudW13YW50LCBmdW5jdGlvbiAob2ZmZXJzKSB7XG4gICAgICBwYXJhbXMubnVtd2FudCA9IG51bXdhbnRcbiAgICAgIHBhcmFtcy5vZmZlcnMgPSBvZmZlcnNcbiAgICAgIHNlbGYuX3NlbmQocGFyYW1zKVxuICAgIH0pXG4gIH1cbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuc2NyYXBlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCB8fCBzZWxmLnJlY29ubmVjdGluZykgcmV0dXJuXG4gIGlmICghc2VsZi5zb2NrZXQuY29ubmVjdGVkKSB7XG4gICAgc2VsZi5zb2NrZXQub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuc2NyYXBlKG9wdHMpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBpbmZvSGFzaGVzID0gKEFycmF5LmlzQXJyYXkob3B0cy5pbmZvSGFzaCkgJiYgb3B0cy5pbmZvSGFzaC5sZW5ndGggPiAwKVxuICAgID8gb3B0cy5pbmZvSGFzaC5tYXAoZnVuY3Rpb24gKGluZm9IYXNoKSB7XG4gICAgICByZXR1cm4gaW5mb0hhc2gudG9TdHJpbmcoJ2JpbmFyeScpXG4gICAgfSlcbiAgICA6IChvcHRzLmluZm9IYXNoICYmIG9wdHMuaW5mb0hhc2gudG9TdHJpbmcoJ2JpbmFyeScpKSB8fCBzZWxmLmNsaWVudC5faW5mb0hhc2hCaW5hcnlcbiAgdmFyIHBhcmFtcyA9IHtcbiAgICBhY3Rpb246ICdzY3JhcGUnLFxuICAgIGluZm9faGFzaDogaW5mb0hhc2hlc1xuICB9XG5cbiAgc2VsZi5fc2VuZChwYXJhbXMpXG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghY2IpIGNiID0gbm9vcFxuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYihudWxsKVxuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5pbnRlcnZhbClcbiAgY2xlYXJUaW1lb3V0KHNlbGYucmVjb25uZWN0VGltZXIpXG5cbiAgaWYgKHNlbGYuc29ja2V0KSB7XG4gICAgc2VsZi5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBzZWxmLl9vblNvY2tldENvbm5lY3RCb3VuZClcbiAgICBzZWxmLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNlbGYuX29uU29ja2V0RGF0YUJvdW5kKVxuICAgIHNlbGYuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNlbGYuX29uU29ja2V0Q2xvc2VCb3VuZClcbiAgICBzZWxmLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9vblNvY2tldEVycm9yQm91bmQpXG4gIH1cblxuICBzZWxmLl9vblNvY2tldENvbm5lY3RCb3VuZCA9IG51bGxcbiAgc2VsZi5fb25Tb2NrZXRFcnJvckJvdW5kID0gbnVsbFxuICBzZWxmLl9vblNvY2tldERhdGFCb3VuZCA9IG51bGxcbiAgc2VsZi5fb25Tb2NrZXRDbG9zZUJvdW5kID0gbnVsbFxuXG4gIC8vIERlc3Ryb3kgcGVlcnNcbiAgZm9yICh2YXIgcGVlcklkIGluIHNlbGYucGVlcnMpIHtcbiAgICB2YXIgcGVlciA9IHNlbGYucGVlcnNbcGVlcklkXVxuICAgIGNsZWFyVGltZW91dChwZWVyLnRyYWNrZXJUaW1lb3V0KVxuICAgIHBlZXIuZGVzdHJveSgpXG4gIH1cbiAgc2VsZi5wZWVycyA9IG51bGxcblxuICBpZiAoc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXSkge1xuICAgIHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0uY29uc3VtZXJzIC09IDFcbiAgfVxuXG4gIGlmIChzb2NrZXRQb29sW3NlbGYuYW5ub3VuY2VVcmxdLmNvbnN1bWVycyA9PT0gMCkge1xuICAgIGRlbGV0ZSBzb2NrZXRQb29sW3NlbGYuYW5ub3VuY2VVcmxdXG5cbiAgICB0cnkge1xuICAgICAgc2VsZi5zb2NrZXQub24oJ2Vycm9yJywgbm9vcCkgLy8gaWdub3JlIGFsbCBmdXR1cmUgZXJyb3JzXG4gICAgICBzZWxmLnNvY2tldC5kZXN0cm95KGNiKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIHNlbGYuc29ja2V0ID0gbnVsbFxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fb3BlblNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcblxuICBpZiAoIXNlbGYucGVlcnMpIHNlbGYucGVlcnMgPSB7fVxuXG4gIHNlbGYuX29uU29ja2V0Q29ubmVjdEJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uU29ja2V0Q29ubmVjdCgpXG4gIH1cbiAgc2VsZi5fb25Tb2NrZXRFcnJvckJvdW5kID0gZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX29uU29ja2V0RXJyb3IoZXJyKVxuICB9XG4gIHNlbGYuX29uU29ja2V0RGF0YUJvdW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLl9vblNvY2tldERhdGEoZGF0YSlcbiAgfVxuICBzZWxmLl9vblNvY2tldENsb3NlQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25Tb2NrZXRDbG9zZSgpXG4gIH1cblxuICBzZWxmLnNvY2tldCA9IHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF1cbiAgaWYgKHNlbGYuc29ja2V0KSB7XG4gICAgc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXS5jb25zdW1lcnMgKz0gMVxuICB9IGVsc2Uge1xuICAgIHNlbGYuc29ja2V0ID0gc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXSA9IG5ldyBTb2NrZXQoc2VsZi5hbm5vdW5jZVVybClcbiAgICBzZWxmLnNvY2tldC5jb25zdW1lcnMgPSAxXG4gICAgc2VsZi5zb2NrZXQub24oJ2Nvbm5lY3QnLCBzZWxmLl9vblNvY2tldENvbm5lY3RCb3VuZClcbiAgfVxuXG4gIHNlbGYuc29ja2V0Lm9uKCdkYXRhJywgc2VsZi5fb25Tb2NrZXREYXRhQm91bmQpXG4gIHNlbGYuc29ja2V0Lm9uKCdjbG9zZScsIHNlbGYuX29uU29ja2V0Q2xvc2VCb3VuZClcbiAgc2VsZi5zb2NrZXQub24oJ2Vycm9yJywgc2VsZi5fb25Tb2NrZXRFcnJvckJvdW5kKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fb25Tb2NrZXRDb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBpZiAoc2VsZi5yZWNvbm5lY3RpbmcpIHtcbiAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlXG4gICAgc2VsZi5yZXRyaWVzID0gMFxuICAgIHNlbGYuYW5ub3VuY2Uoc2VsZi5jbGllbnQuX2RlZmF1bHRBbm5vdW5jZU9wdHMoKSlcbiAgfVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fb25Tb2NrZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgdHJ5IHtcbiAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzZWxmLmNsaWVudC5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdJbnZhbGlkIHRyYWNrZXIgcmVzcG9uc2UnKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChkYXRhLmFjdGlvbiA9PT0gJ2Fubm91bmNlJykge1xuICAgIHNlbGYuX29uQW5ub3VuY2VSZXNwb25zZShkYXRhKVxuICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uID09PSAnc2NyYXBlJykge1xuICAgIHNlbGYuX29uU2NyYXBlUmVzcG9uc2UoZGF0YSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9vblNvY2tldEVycm9yKG5ldyBFcnJvcignaW52YWxpZCBhY3Rpb24gaW4gV1MgcmVzcG9uc2U6ICcgKyBkYXRhLmFjdGlvbikpXG4gIH1cbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uQW5ub3VuY2VSZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChkYXRhLmluZm9faGFzaCAhPT0gc2VsZi5jbGllbnQuX2luZm9IYXNoQmluYXJ5KSB7XG4gICAgZGVidWcoXG4gICAgICAnaWdub3Jpbmcgd2Vic29ja2V0IGRhdGEgZnJvbSAlcyBmb3IgJXMgKGxvb2tpbmcgZm9yICVzOiByZXVzZWQgc29ja2V0KScsXG4gICAgICBzZWxmLmFubm91bmNlVXJsLCBjb21tb24uYmluYXJ5VG9IZXgoZGF0YS5pbmZvX2hhc2gpLCBzZWxmLmNsaWVudC5pbmZvSGFzaFxuICAgIClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChkYXRhLnBlZXJfaWQgJiYgZGF0YS5wZWVyX2lkID09PSBzZWxmLmNsaWVudC5fcGVlcklkQmluYXJ5KSB7XG4gICAgLy8gaWdub3JlIG9mZmVycy9hbnN3ZXJzIGZyb20gdGhpcyBjbGllbnRcbiAgICByZXR1cm5cbiAgfVxuXG4gIGRlYnVnKFxuICAgICdyZWNlaXZlZCAlcyBmcm9tICVzIGZvciAlcycsXG4gICAgSlNPTi5zdHJpbmdpZnkoZGF0YSksIHNlbGYuYW5ub3VuY2VVcmwsIHNlbGYuY2xpZW50LmluZm9IYXNoXG4gIClcblxuICB2YXIgZmFpbHVyZSA9IGRhdGFbJ2ZhaWx1cmUgcmVhc29uJ11cbiAgaWYgKGZhaWx1cmUpIHJldHVybiBzZWxmLmNsaWVudC5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKGZhaWx1cmUpKVxuXG4gIHZhciB3YXJuaW5nID0gZGF0YVsnd2FybmluZyBtZXNzYWdlJ11cbiAgaWYgKHdhcm5pbmcpIHNlbGYuY2xpZW50LmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3Iod2FybmluZykpXG5cbiAgdmFyIGludGVydmFsID0gZGF0YS5pbnRlcnZhbCB8fCBkYXRhWydtaW4gaW50ZXJ2YWwnXVxuICBpZiAoaW50ZXJ2YWwpIHNlbGYuc2V0SW50ZXJ2YWwoaW50ZXJ2YWwgKiAxMDAwKVxuXG4gIHZhciB0cmFja2VySWQgPSBkYXRhWyd0cmFja2VyIGlkJ11cbiAgaWYgKHRyYWNrZXJJZCkge1xuICAgIC8vIElmIGFic2VudCwgZG8gbm90IGRpc2NhcmQgcHJldmlvdXMgdHJhY2tlcklkIHZhbHVlXG4gICAgc2VsZi5fdHJhY2tlcklkID0gdHJhY2tlcklkXG4gIH1cblxuICBpZiAoZGF0YS5jb21wbGV0ZSAhPSBudWxsKSB7XG4gICAgc2VsZi5jbGllbnQuZW1pdCgndXBkYXRlJywge1xuICAgICAgYW5ub3VuY2U6IHNlbGYuYW5ub3VuY2VVcmwsXG4gICAgICBjb21wbGV0ZTogZGF0YS5jb21wbGV0ZSxcbiAgICAgIGluY29tcGxldGU6IGRhdGEuaW5jb21wbGV0ZVxuICAgIH0pXG4gIH1cblxuICB2YXIgcGVlclxuICBpZiAoZGF0YS5vZmZlciAmJiBkYXRhLnBlZXJfaWQpIHtcbiAgICBkZWJ1ZygnY3JlYXRpbmcgcGVlciAoZnJvbSByZW1vdGUgb2ZmZXIpJylcbiAgICBwZWVyID0gbmV3IFBlZXIoe1xuICAgICAgdHJpY2tsZTogZmFsc2UsXG4gICAgICBjb25maWc6IHNlbGYuY2xpZW50Ll9ydGNDb25maWcsXG4gICAgICB3cnRjOiBzZWxmLmNsaWVudC5fd3J0Y1xuICAgIH0pXG4gICAgcGVlci5pZCA9IGNvbW1vbi5iaW5hcnlUb0hleChkYXRhLnBlZXJfaWQpXG4gICAgcGVlci5vbmNlKCdzaWduYWwnLCBmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBhY3Rpb246ICdhbm5vdW5jZScsXG4gICAgICAgIGluZm9faGFzaDogc2VsZi5jbGllbnQuX2luZm9IYXNoQmluYXJ5LFxuICAgICAgICBwZWVyX2lkOiBzZWxmLmNsaWVudC5fcGVlcklkQmluYXJ5LFxuICAgICAgICB0b19wZWVyX2lkOiBkYXRhLnBlZXJfaWQsXG4gICAgICAgIGFuc3dlcjogYW5zd2VyLFxuICAgICAgICBvZmZlcl9pZDogZGF0YS5vZmZlcl9pZFxuICAgICAgfVxuICAgICAgaWYgKHNlbGYuX3RyYWNrZXJJZCkgcGFyYW1zLnRyYWNrZXJpZCA9IHNlbGYuX3RyYWNrZXJJZFxuICAgICAgc2VsZi5fc2VuZChwYXJhbXMpXG4gICAgfSlcbiAgICBwZWVyLnNpZ25hbChkYXRhLm9mZmVyKVxuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3BlZXInLCBwZWVyKVxuICB9XG5cbiAgaWYgKGRhdGEuYW5zd2VyICYmIGRhdGEucGVlcl9pZCkge1xuICAgIHZhciBvZmZlcklkID0gY29tbW9uLmJpbmFyeVRvSGV4KGRhdGEub2ZmZXJfaWQpXG4gICAgcGVlciA9IHNlbGYucGVlcnNbb2ZmZXJJZF1cbiAgICBpZiAocGVlcikge1xuICAgICAgcGVlci5pZCA9IGNvbW1vbi5iaW5hcnlUb0hleChkYXRhLnBlZXJfaWQpXG4gICAgICBwZWVyLnNpZ25hbChkYXRhLmFuc3dlcilcbiAgICAgIHNlbGYuY2xpZW50LmVtaXQoJ3BlZXInLCBwZWVyKVxuXG4gICAgICBjbGVhclRpbWVvdXQocGVlci50cmFja2VyVGltZW91dClcbiAgICAgIHBlZXIudHJhY2tlclRpbWVvdXQgPSBudWxsXG4gICAgICBkZWxldGUgc2VsZi5wZWVyc1tvZmZlcklkXVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnZ290IHVuZXhwZWN0ZWQgYW5zd2VyOiAnICsgSlNPTi5zdHJpbmdpZnkoZGF0YS5hbnN3ZXIpKVxuICAgIH1cbiAgfVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fb25TY3JhcGVSZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkYXRhID0gZGF0YS5maWxlcyB8fCB7fVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgc2VsZi5jbGllbnQuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignaW52YWxpZCBzY3JhcGUgcmVzcG9uc2UnKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mb0hhc2gpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBkYXRhW2luZm9IYXNoXVxuICAgIC8vIFRPRE86IG9wdGlvbmFsbHkgaGFuZGxlIGRhdGEuZmxhZ3MubWluX3JlcXVlc3RfaW50ZXJ2YWxcbiAgICAvLyAoc2VwYXJhdGUgZnJvbSBhbm5vdW5jZSBpbnRlcnZhbClcbiAgICBzZWxmLmNsaWVudC5lbWl0KCdzY3JhcGUnLCB7XG4gICAgICBhbm5vdW5jZTogc2VsZi5hbm5vdW5jZVVybCxcbiAgICAgIGluZm9IYXNoOiBjb21tb24uYmluYXJ5VG9IZXgoaW5mb0hhc2gpLFxuICAgICAgY29tcGxldGU6IHJlc3BvbnNlLmNvbXBsZXRlLFxuICAgICAgaW5jb21wbGV0ZTogcmVzcG9uc2UuaW5jb21wbGV0ZSxcbiAgICAgIGRvd25sb2FkZWQ6IHJlc3BvbnNlLmRvd25sb2FkZWRcbiAgICB9KVxuICB9KVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fb25Tb2NrZXRDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveSgpXG4gIHNlbGYuX3N0YXJ0UmVjb25uZWN0VGltZXIoKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fb25Tb2NrZXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveSgpXG4gIC8vIGVycm9ycyB3aWxsIG9mdGVuIGhhcHBlbiBpZiBhIHRyYWNrZXIgaXMgb2ZmbGluZSwgc28gZG9uJ3QgdHJlYXQgaXQgYXMgZmF0YWxcbiAgc2VsZi5jbGllbnQuZW1pdCgnd2FybmluZycsIGVycilcbiAgc2VsZi5fc3RhcnRSZWNvbm5lY3RUaW1lcigpXG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLl9zdGFydFJlY29ubmVjdFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG1zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogUkVDT05ORUNUX1ZBUklBTkNFKSArIE1hdGgubWluKE1hdGgucG93KDIsIHNlbGYucmV0cmllcykgKiBSRUNPTk5FQ1RfTUlOSU1VTSwgUkVDT05ORUNUX01BWElNVU0pXG5cbiAgc2VsZi5yZWNvbm5lY3RpbmcgPSB0cnVlXG4gIGNsZWFyVGltZW91dChzZWxmLnJlY29ubmVjdFRpbWVyKVxuICBzZWxmLnJlY29ubmVjdFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5yZXRyaWVzKytcbiAgICBzZWxmLl9vcGVuU29ja2V0KClcbiAgfSwgbXMpXG4gIGlmIChzZWxmLnJlY29ubmVjdFRpbWVyLnVucmVmKSBzZWxmLnJlY29ubmVjdFRpbWVyLnVucmVmKClcblxuICBkZWJ1ZygncmVjb25uZWN0aW5nIHNvY2tldCBpbiAlcyBtcycsIG1zKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgdmFyIG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMpXG4gIGRlYnVnKCdzZW5kICVzJywgbWVzc2FnZSlcbiAgc2VsZi5zb2NrZXQuc2VuZChtZXNzYWdlKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fZ2VuZXJhdGVPZmZlcnMgPSBmdW5jdGlvbiAobnVtd2FudCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBvZmZlcnMgPSBbXVxuICBkZWJ1ZygnZ2VuZXJhdGluZyAlcyBvZmZlcnMnLCBudW13YW50KVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtd2FudDsgKytpKSB7XG4gICAgZ2VuZXJhdGVPZmZlcigpXG4gIH1cbiAgY2hlY2tEb25lKClcblxuICBmdW5jdGlvbiBnZW5lcmF0ZU9mZmVyICgpIHtcbiAgICB2YXIgb2ZmZXJJZCA9IGhhdCgxNjApXG4gICAgZGVidWcoJ2NyZWF0aW5nIHBlZXIgKGZyb20gX2dlbmVyYXRlT2ZmZXJzKScpXG4gICAgdmFyIHBlZXIgPSBzZWxmLnBlZXJzW29mZmVySWRdID0gbmV3IFBlZXIoe1xuICAgICAgaW5pdGlhdG9yOiB0cnVlLFxuICAgICAgdHJpY2tsZTogZmFsc2UsXG4gICAgICBjb25maWc6IHNlbGYuY2xpZW50Ll9ydGNDb25maWcsXG4gICAgICB3cnRjOiBzZWxmLmNsaWVudC5fd3J0Y1xuICAgIH0pXG4gICAgcGVlci5vbmNlKCdzaWduYWwnLCBmdW5jdGlvbiAob2ZmZXIpIHtcbiAgICAgIG9mZmVycy5wdXNoKHtcbiAgICAgICAgb2ZmZXI6IG9mZmVyLFxuICAgICAgICBvZmZlcl9pZDogY29tbW9uLmhleFRvQmluYXJ5KG9mZmVySWQpXG4gICAgICB9KVxuICAgICAgY2hlY2tEb25lKClcbiAgICB9KVxuICAgIHBlZXIudHJhY2tlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlYnVnKCd0cmFja2VyIHRpbWVvdXQ6IGRlc3Ryb3lpbmcgcGVlcicpXG4gICAgICBwZWVyLnRyYWNrZXJUaW1lb3V0ID0gbnVsbFxuICAgICAgZGVsZXRlIHNlbGYucGVlcnNbb2ZmZXJJZF1cbiAgICAgIHBlZXIuZGVzdHJveSgpXG4gICAgfSwgT0ZGRVJfVElNRU9VVClcbiAgICBpZiAocGVlci50cmFja2VyVGltZW91dC51bnJlZikgcGVlci50cmFja2VyVGltZW91dC51bnJlZigpXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0RvbmUgKCkge1xuICAgIGlmIChvZmZlcnMubGVuZ3RoID09PSBudW13YW50KSB7XG4gICAgICBkZWJ1ZygnZ2VuZXJhdGVkICVzIG9mZmVycycsIG51bXdhbnQpXG4gICAgICBjYihvZmZlcnMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbiIsIi8qKlxuICogRnVuY3Rpb25zL2NvbnN0YW50cyBuZWVkZWQgYnkgYm90aCB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIuXG4gKi9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQvbXV0YWJsZScpXG5cbmV4cG9ydHMuREVGQVVMVF9BTk5PVU5DRV9QRUVSUyA9IDUwXG5leHBvcnRzLk1BWF9BTk5PVU5DRV9QRUVSUyA9IDgyXG5cbmV4cG9ydHMuYmluYXJ5VG9IZXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHN0ciA9IFN0cmluZyhzdHIpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ2JpbmFyeScpLnRvU3RyaW5nKCdoZXgnKVxufVxuXG5leHBvcnRzLmhleFRvQmluYXJ5ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKVxuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICdoZXgnKS50b1N0cmluZygnYmluYXJ5Jylcbn1cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29tbW9uLW5vZGUnKVxuZXh0ZW5kKGV4cG9ydHMsIGNvbmZpZylcbiIsIi8qIGdsb2JhbCBCbG9iLCBGaWxlUmVhZGVyICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvYlRvQnVmZmVyIChibG9iLCBjYikge1xuICBpZiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8ICEoYmxvYiBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgQmxvYicpXG4gIH1cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cblxuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuXG4gIGZ1bmN0aW9uIG9uTG9hZEVuZCAoZSkge1xuICAgIHJlYWRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgb25Mb2FkRW5kLCBmYWxzZSlcbiAgICBpZiAoZS5lcnJvcikgY2IoZS5lcnJvcilcbiAgICBlbHNlIGNiKG51bGwsIG5ldyBCdWZmZXIocmVhZGVyLnJlc3VsdCkpXG4gIH1cblxuICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG9uTG9hZEVuZCwgZmFsc2UpXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxufVxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm07XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJ2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbG9jaztcbmluaGVyaXRzKEJsb2NrLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBCbG9jayAoc2l6ZSwgb3B0cykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCbG9jaykpIHJldHVybiBuZXcgQmxvY2soc2l6ZSwgb3B0cyk7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcyk7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0gc2l6ZTtcbiAgICAgICAgc2l6ZSA9IG9wdHMuc2l6ZTtcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZSB8fCA1MTI7XG4gICAgXG4gICAgaWYgKG9wdHMubm9wYWQpIHRoaXMuX3plcm9QYWRkaW5nID0gZmFsc2U7XG4gICAgZWxzZSB0aGlzLl96ZXJvUGFkZGluZyA9IGRlZmluZWQob3B0cy56ZXJvUGFkZGluZywgdHJ1ZSk7XG4gICAgXG4gICAgdGhpcy5fYnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbn1cblxuQmxvY2sucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoYnVmLCBlbmMsIG5leHQpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVyZWQucHVzaChidWYpO1xuICAgIFxuICAgIHdoaWxlICh0aGlzLl9idWZmZXJlZEJ5dGVzID49IHRoaXMuc2l6ZSkge1xuICAgICAgICB2YXIgYiA9IEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmZmVyZWQpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHRoaXMuc2l6ZTtcbiAgICAgICAgdGhpcy5wdXNoKGIuc2xpY2UoMCwgdGhpcy5zaXplKSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkID0gWyBiLnNsaWNlKHRoaXMuc2l6ZSwgYi5sZW5ndGgpIF07XG4gICAgfVxuICAgIG5leHQoKTtcbn07XG5cbkJsb2NrLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgJiYgdGhpcy5femVyb1BhZGRpbmcpIHtcbiAgICAgICAgdmFyIHplcm9lcyA9IG5ldyBCdWZmZXIodGhpcy5zaXplIC0gdGhpcy5fYnVmZmVyZWRCeXRlcyk7XG4gICAgICAgIHplcm9lcy5maWxsKDApO1xuICAgICAgICB0aGlzLl9idWZmZXJlZC5wdXNoKHplcm9lcyk7XG4gICAgICAgIHRoaXMucHVzaChCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZmZlcmVkKSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcykge1xuICAgICAgICB0aGlzLnB1c2goQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXJlZCkpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucHVzaChudWxsKTtcbn07XG4iLCIiLCIndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyO1xudmFyIFNsb3dCdWZmZXIgPSBidWZmZXIuU2xvd0J1ZmZlcjtcbnZhciBNQVhfTEVOID0gYnVmZmVyLmtNYXhMZW5ndGggfHwgMjE0NzQ4MzY0NztcbmV4cG9ydHMuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBub3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHZhciBlbmMgPSBlbmNvZGluZztcbiAgdmFyIF9maWxsID0gZmlsbDtcbiAgaWYgKF9maWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmMgPSB1bmRlZmluZWQ7XG4gICAgX2ZpbGwgPSAwO1xuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICBpZiAodHlwZW9mIF9maWxsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBmaWxsQnVmID0gbmV3IEJ1ZmZlcihfZmlsbCwgZW5jKTtcbiAgICB2YXIgZmxlbiA9IGZpbGxCdWYubGVuZ3RoO1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IHNpemUpIHtcbiAgICAgIGJ1ZltpXSA9IGZpbGxCdWZbaSAlIGZsZW5dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbChfZmlsbCk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG59XG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiAoIWdsb2JhbC5VaW50OEFycmF5IHx8IFVpbnQ4QXJyYXkuZnJvbSAhPT0gQnVmZmVyLmZyb20pKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBvZmZzZXQgPSBlbmNvZGluZ09yT2Zmc2V0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGxlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPj0gdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChsZW4gPiB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgdmFsdWUuY29weShvdXQsIDAsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsICcgKyAnQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKTtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gYWxsb2NVbnNhZmVTbG93KHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3coc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID49IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc2l6ZSk7XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgZm91bmRJbmRleCA9IC0xXG4gIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlYWQoYXJyLCBieXRlT2Zmc2V0ICsgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIChieXRlT2Zmc2V0ICsgZm91bmRJbmRleCkgKiBpbmRleFNpemVcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZylcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgaSsrKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCIxMDBcIjogXCJDb250aW51ZVwiLFxuICBcIjEwMVwiOiBcIlN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgXCIxMDJcIjogXCJQcm9jZXNzaW5nXCIsXG4gIFwiMjAwXCI6IFwiT0tcIixcbiAgXCIyMDFcIjogXCJDcmVhdGVkXCIsXG4gIFwiMjAyXCI6IFwiQWNjZXB0ZWRcIixcbiAgXCIyMDNcIjogXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLFxuICBcIjIwNFwiOiBcIk5vIENvbnRlbnRcIixcbiAgXCIyMDVcIjogXCJSZXNldCBDb250ZW50XCIsXG4gIFwiMjA2XCI6IFwiUGFydGlhbCBDb250ZW50XCIsXG4gIFwiMjA3XCI6IFwiTXVsdGktU3RhdHVzXCIsXG4gIFwiMjA4XCI6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICBcIjIyNlwiOiBcIklNIFVzZWRcIixcbiAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gIFwiMzAxXCI6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgXCIzMDJcIjogXCJGb3VuZFwiLFxuICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICBcIjMwNFwiOiBcIk5vdCBNb2RpZmllZFwiLFxuICBcIjMwNVwiOiBcIlVzZSBQcm94eVwiLFxuICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICBcIjMwOFwiOiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICBcIjQwMFwiOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gIFwiNDAyXCI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICBcIjQwM1wiOiBcIkZvcmJpZGRlblwiLFxuICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICBcIjQwNVwiOiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICBcIjQwNlwiOiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MDhcIjogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgXCI0MDlcIjogXCJDb25mbGljdFwiLFxuICBcIjQxMFwiOiBcIkdvbmVcIixcbiAgXCI0MTFcIjogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgXCI0MTJcIjogXCJQcmVjb25kaXRpb24gRmFpbGVkXCIsXG4gIFwiNDEzXCI6IFwiUGF5bG9hZCBUb28gTGFyZ2VcIixcbiAgXCI0MTRcIjogXCJVUkkgVG9vIExvbmdcIixcbiAgXCI0MTVcIjogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gIFwiNDE2XCI6IFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gIFwiNDE3XCI6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gIFwiNDE4XCI6IFwiSSdtIGEgdGVhcG90XCIsXG4gIFwiNDIxXCI6IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiLFxuICBcIjQyMlwiOiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXG4gIFwiNDIzXCI6IFwiTG9ja2VkXCIsXG4gIFwiNDI0XCI6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgXCI0MjVcIjogXCJVbm9yZGVyZWQgQ29sbGVjdGlvblwiLFxuICBcIjQyNlwiOiBcIlVwZ3JhZGUgUmVxdWlyZWRcIixcbiAgXCI0MjhcIjogXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MjlcIjogXCJUb28gTWFueSBSZXF1ZXN0c1wiLFxuICBcIjQzMVwiOiBcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcIixcbiAgXCI1MDBcIjogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgXCI1MDFcIjogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgXCI1MDJcIjogXCJCYWQgR2F0ZXdheVwiLFxuICBcIjUwM1wiOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgXCI1MDRcIjogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICBcIjUwNlwiOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gIFwiNTA3XCI6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgXCI1MDhcIjogXCJMb29wIERldGVjdGVkXCIsXG4gIFwiNTA5XCI6IFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXCIsXG4gIFwiNTEwXCI6IFwiTm90IEV4dGVuZGVkXCIsXG4gIFwiNTExXCI6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IENodW5rU3RvcmVXcml0ZVN0cmVhbVxuXG52YXIgQmxvY2tTdHJlYW0gPSByZXF1aXJlKCdibG9jay1zdHJlYW0yJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG5pbmhlcml0cyhDaHVua1N0b3JlV3JpdGVTdHJlYW0sIHN0cmVhbS5Xcml0YWJsZSlcblxuZnVuY3Rpb24gQ2h1bmtTdG9yZVdyaXRlU3RyZWFtIChzdG9yZSwgY2h1bmtMZW5ndGgsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBDaHVua1N0b3JlV3JpdGVTdHJlYW0pKSB7XG4gICAgcmV0dXJuIG5ldyBDaHVua1N0b3JlV3JpdGVTdHJlYW0oc3RvcmUsIGNodW5rTGVuZ3RoLCBvcHRzKVxuICB9XG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYsIG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgaWYgKCFzdG9yZSB8fCAhc3RvcmUucHV0IHx8ICFzdG9yZS5nZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gYWJzdHJhY3QtY2h1bmstc3RvcmUgY29tcGxpYW50IHN0b3JlJylcbiAgfVxuICBjaHVua0xlbmd0aCA9IE51bWJlcihjaHVua0xlbmd0aClcbiAgaWYgKCFjaHVua0xlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGNodW5rIGxlbmd0aCcpXG5cbiAgc2VsZi5fYmxvY2tzdHJlYW0gPSBuZXcgQmxvY2tTdHJlYW0oY2h1bmtMZW5ndGgsIHsgemVyb1BhZGRpbmc6IGZhbHNlIH0pXG5cbiAgc2VsZi5fYmxvY2tzdHJlYW1cbiAgICAub24oJ2RhdGEnLCBvbkRhdGEpXG4gICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5kZXN0cm95KGVycikgfSlcblxuICB2YXIgaW5kZXggPSAwXG4gIGZ1bmN0aW9uIG9uRGF0YSAoY2h1bmspIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHN0b3JlLnB1dChpbmRleCwgY2h1bmspXG4gICAgaW5kZXggKz0gMVxuICB9XG5cbiAgc2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkgeyB0aGlzLl9ibG9ja3N0cmVhbS5lbmQoKSB9KVxufVxuXG5DaHVua1N0b3JlV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX2Jsb2Nrc3RyZWFtLndyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spXG59XG5cbkNodW5rU3RvcmVXcml0ZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgbnVtYmVycykge1xuICB2YXIgY2xvc2VzdCA9IEluZmluaXR5XG4gIHZhciBkaWZmZXJlbmNlID0gMFxuICB2YXIgd2lubmVyID0gbnVsbFxuXG4gIG51bWJlcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiXG4gIH0pXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBudW1iZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyAgXG4gICAgZGlmZmVyZW5jZSA9IE1hdGguYWJzKHRhcmdldCAtIG51bWJlcnNbaV0pXG4gICAgaWYgKGRpZmZlcmVuY2UgPj0gY2xvc2VzdCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2xvc2VzdCA9IGRpZmZlcmVuY2VcbiAgICB3aW5uZXIgPSBudW1iZXJzW2ldXG4gIH1cblxuICByZXR1cm4gd2lubmVyXG59XG4iLCJ2YXIgaXBhZGRyID0gcmVxdWlyZSgnaXBhZGRyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFjdDJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHN3aXRjaChidWYubGVuZ3RoKSB7XG4gIGNhc2UgNjpcbiAgICByZXR1cm4gYnVmWzBdICsgXCIuXCIgKyBidWZbMV0gKyBcIi5cIiArIGJ1ZlsyXSArIFwiLlwiICsgYnVmWzNdICsgXCI6XCIgKyBidWYucmVhZFVJbnQxNkJFKDQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDE4OlxuICAgIHZhciBoZXhHcm91cHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBoZXhHcm91cHMucHVzaChidWYucmVhZFVJbnQxNkJFKGkgKiAyKS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICB2YXIgaG9zdCA9IGlwYWRkci5wYXJzZShoZXhHcm91cHMuam9pbihcIjpcIikpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIFwiW1wiICsgaG9zdCArIFwiXTpcIiArIGJ1Zi5yZWFkVUludDE2QkUoMTYpO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQ29tcGFjdCBJUC9QT1JULCBJdCBzaG91bGQgY29udGFpbiA2IG9yIDE4IGJ5dGVzXCIpO1xuICB9XG59O1xuXG5jb21wYWN0MnN0cmluZy5tdWx0aSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYoYnVmLmxlbmd0aCAlIDYgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmIGxlbmd0aCBpc24ndCBtdWx0aXBsZSBvZiBjb21wYWN0IElQL1BPUlRzICg2IGJ5dGVzKVwiKTtcblxuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGJ1Zi5sZW5ndGggLSAxOyBpID0gaSArIDYpIHtcbiAgICBvdXRwdXQucHVzaChjb21wYWN0MnN0cmluZyhidWYuc2xpY2UoaSwgaSArIDYpKSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29tcGFjdDJzdHJpbmcubXVsdGk2ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZihidWYubGVuZ3RoICUgMTggIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmIGxlbmd0aCBpc24ndCBtdWx0aXBsZSBvZiBjb21wYWN0IElQNi9QT1JUcyAoMTggYnl0ZXMpXCIpO1xuXG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYnVmLmxlbmd0aCAtIDE7IGkgPSBpICsgMTgpIHtcbiAgICBvdXRwdXQucHVzaChjb21wYWN0MnN0cmluZyhidWYuc2xpY2UoaSwgaSArIDE4KSkpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRvcnJlbnRcbm1vZHVsZS5leHBvcnRzLnBhcnNlSW5wdXQgPSBwYXJzZUlucHV0XG5cbm1vZHVsZS5leHBvcnRzLmFubm91bmNlTGlzdCA9IFtcbiAgWyAndWRwOi8vdHJhY2tlci5vcGVuYml0dG9ycmVudC5jb206ODAnIF0sXG4gIFsgJ3VkcDovL3RyYWNrZXIuaW50ZXJuZXR3YXJyaW9ycy5uZXQ6MTMzNycgXSxcbiAgWyAndWRwOi8vdHJhY2tlci5sZWVjaGVycy1wYXJhZGlzZS5vcmc6Njk2OScgXSxcbiAgWyAndWRwOi8vdHJhY2tlci5jb3BwZXJzdXJmZXIudGs6Njk2OScgXSxcbiAgWyAndWRwOi8vZXhvZHVzLmRlc3luYy5jb206Njk2OScgXSxcbiAgWyAnd3NzOi8vdHJhY2tlci53ZWJ0b3JyZW50LmlvJyBdLFxuICBbICd3c3M6Ly90cmFja2VyLmJ0b3JyZW50Lnh5eicgXSxcbiAgWyAnd3NzOi8vdHJhY2tlci5vcGVud2VidG9ycmVudC5jb20nIF0sXG4gIFsgJ3dzczovL3RyYWNrZXIuZmFzdGNhc3QubnonIF1cbl1cblxudmFyIGJlbmNvZGUgPSByZXF1aXJlKCdiZW5jb2RlJylcbnZhciBCbG9ja1N0cmVhbSA9IHJlcXVpcmUoJ2Jsb2NrLXN0cmVhbTInKVxudmFyIGNhbGNQaWVjZUxlbmd0aCA9IHJlcXVpcmUoJ3BpZWNlLWxlbmd0aCcpXG52YXIgY29yZVBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgRmlsZVJlYWRTdHJlYW0gPSByZXF1aXJlKCdmaWxlc3RyZWFtL3JlYWQnKVxudmFyIGZsYXR0ZW4gPSByZXF1aXJlKCdmbGF0dGVuJylcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBpc0ZpbGUgPSByZXF1aXJlKCdpcy1maWxlJylcbnZhciBqdW5rID0gcmVxdWlyZSgnanVuaycpXG52YXIgTXVsdGlTdHJlYW0gPSByZXF1aXJlKCdtdWx0aXN0cmVhbScpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIHBhcmFsbGVsID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbi8qKlxuICogQ3JlYXRlIGEgdG9ycmVudC5cbiAqIEBwYXJhbSAge3N0cmluZ3xGaWxlfEZpbGVMaXN0fEJ1ZmZlcnxTdHJlYW18QXJyYXkuPHN0cmluZ3xGaWxlfEJ1ZmZlcnxTdHJlYW0+fSBpbnB1dFxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0gIHtzdHJpbmc9fSBvcHRzLm5hbWVcbiAqIEBwYXJhbSAge0RhdGU9fSBvcHRzLmNyZWF0aW9uRGF0ZVxuICogQHBhcmFtICB7c3RyaW5nPX0gb3B0cy5jb21tZW50XG4gKiBAcGFyYW0gIHtzdHJpbmc9fSBvcHRzLmNyZWF0ZWRCeVxuICogQHBhcmFtICB7Ym9vbGVhbnxudW1iZXI9fSBvcHRzLnByaXZhdGVcbiAqIEBwYXJhbSAge251bWJlcj19IG9wdHMucGllY2VMZW5ndGhcbiAqIEBwYXJhbSAge0FycmF5LjxBcnJheS48c3RyaW5nPj49fSBvcHRzLmFubm91bmNlTGlzdFxuICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz49fSBvcHRzLnVybExpc3RcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICogQHJldHVybiB7QnVmZmVyfSBidWZmZXIgb2YgLnRvcnJlbnQgZmlsZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvcnJlbnQgKGlucHV0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBjcmVhdGVUb3JyZW50KGlucHV0LCBudWxsLCBvcHRzKVxuICBvcHRzID0gb3B0cyA/IGV4dGVuZChvcHRzKSA6IHt9XG5cbiAgX3BhcnNlSW5wdXQoaW5wdXQsIG9wdHMsIGZ1bmN0aW9uIChlcnIsIGZpbGVzLCBzaW5nbGVGaWxlVG9ycmVudCkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgb3B0cy5zaW5nbGVGaWxlVG9ycmVudCA9IHNpbmdsZUZpbGVUb3JyZW50XG4gICAgb25GaWxlcyhmaWxlcywgb3B0cywgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSW5wdXQgKGlucHV0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBwYXJzZUlucHV0KGlucHV0LCBudWxsLCBvcHRzKVxuICBvcHRzID0gb3B0cyA/IGV4dGVuZChvcHRzKSA6IHt9XG4gIF9wYXJzZUlucHV0KGlucHV0LCBvcHRzLCBjYilcbn1cblxuLyoqXG4gKiBQYXJzZSBpbnB1dCBmaWxlIGFuZCByZXR1cm4gZmlsZSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gX3BhcnNlSW5wdXQgKGlucHV0LCBvcHRzLCBjYikge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdHlwZScpXG5cbiAgaWYgKGlzRmlsZUxpc3QoaW5wdXQpKSBpbnB1dCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGlucHV0KVxuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSBpbnB1dCA9IFsgaW5wdXQgXVxuXG4gIC8vIEluIEVsZWN0cm9uLCB1c2UgdGhlIHRydWUgZmlsZSBwYXRoXG4gIGlucHV0ID0gaW5wdXQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGlzQmxvYihpdGVtKSAmJiB0eXBlb2YgaXRlbS5wYXRoID09PSAnc3RyaW5nJykgcmV0dXJuIGl0ZW0ucGF0aFxuICAgIHJldHVybiBpdGVtXG4gIH0pXG5cbiAgLy8gSWYgdGhlcmUncyBqdXN0IG9uZSBmaWxlLCBhbGxvdyB0aGUgbmFtZSB0byBiZSBzZXQgYnkgYG9wdHMubmFtZWBcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnICYmICFpbnB1dFswXS5uYW1lKSBpbnB1dFswXS5uYW1lID0gb3B0cy5uYW1lXG5cbiAgdmFyIGNvbW1vblByZWZpeCA9IG51bGxcbiAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBwYXRoID0gaXRlbS5mdWxsUGF0aCB8fCBpdGVtLm5hbWVcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHBhdGggPSAnVW5rbm93biBGaWxlICcgKyAoaSArIDEpXG4gICAgICBpdGVtLnVua25vd25OYW1lID0gdHJ1ZVxuICAgIH1cblxuICAgIGl0ZW0ucGF0aCA9IHBhdGguc3BsaXQoJy8nKVxuXG4gICAgLy8gUmVtb3ZlIGluaXRpYWwgc2xhc2hcbiAgICBpZiAoIWl0ZW0ucGF0aFswXSkge1xuICAgICAgaXRlbS5wYXRoLnNoaWZ0KClcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5wYXRoLmxlbmd0aCA8IDIpIHsgLy8gTm8gcmVhbCBwcmVmaXhcbiAgICAgIGNvbW1vblByZWZpeCA9IG51bGxcbiAgICB9IGVsc2UgaWYgKGkgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMSkgeyAvLyBUaGUgZmlyc3QgZmlsZSBoYXMgYSBwcmVmaXhcbiAgICAgIGNvbW1vblByZWZpeCA9IGl0ZW0ucGF0aFswXVxuICAgIH0gZWxzZSBpZiAoaXRlbS5wYXRoWzBdICE9PSBjb21tb25QcmVmaXgpIHsgLy8gVGhlIHByZWZpeCBkb2Vzbid0IG1hdGNoXG4gICAgICBjb21tb25QcmVmaXggPSBudWxsXG4gICAgfVxuICB9KVxuXG4gIC8vIHJlbW92ZSBqdW5rIGZpbGVzXG4gIGlucHV0ID0gaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgdmFyIGZpbGVuYW1lID0gaXRlbS5wYXRoW2l0ZW0ucGF0aC5sZW5ndGggLSAxXVxuICAgIHJldHVybiBub3RIaWRkZW4oZmlsZW5hbWUpICYmIGp1bmsubm90KGZpbGVuYW1lKVxuICB9KVxuXG4gIGlmIChjb21tb25QcmVmaXgpIHtcbiAgICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcGF0aGxlc3MgPSAoQnVmZmVyLmlzQnVmZmVyKGl0ZW0pIHx8IGlzUmVhZGFibGUoaXRlbSkpICYmICFpdGVtLnBhdGhcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgcGF0aGxlc3MpIHJldHVyblxuICAgICAgaXRlbS5wYXRoLnNoaWZ0KClcbiAgICB9KVxuICB9XG5cbiAgaWYgKCFvcHRzLm5hbWUgJiYgY29tbW9uUHJlZml4KSB7XG4gICAgb3B0cy5uYW1lID0gY29tbW9uUHJlZml4XG4gIH1cblxuICBpZiAoIW9wdHMubmFtZSkge1xuICAgIC8vIHVzZSBmaXJzdCB1c2VyLXNldCBmaWxlIG5hbWVcbiAgICBpbnB1dC5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdHMubmFtZSA9IGNvcmVQYXRoLmJhc2VuYW1lKGl0ZW0pXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKCFpdGVtLnVua25vd25OYW1lKSB7XG4gICAgICAgIG9wdHMubmFtZSA9IGl0ZW0ucGF0aFtpdGVtLnBhdGgubGVuZ3RoIC0gMV1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKCFvcHRzLm5hbWUpIHtcbiAgICBvcHRzLm5hbWUgPSAnVW5uYW1lZCBUb3JyZW50ICcgKyBEYXRlLm5vdygpXG4gIH1cblxuICB2YXIgbnVtUGF0aHMgPSBpbnB1dC5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgaXRlbSkge1xuICAgIHJldHVybiBzdW0gKyBOdW1iZXIodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKVxuICB9LCAwKVxuXG4gIHZhciBpc1NpbmdsZUZpbGVUb3JyZW50ID0gKGlucHV0Lmxlbmd0aCA9PT0gMSlcblxuICBpZiAoaW5wdXQubGVuZ3RoID09PSAxICYmIHR5cGVvZiBpbnB1dFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIGZzLnN0YXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZXN5c3RlbSBwYXRocyBkbyBub3Qgd29yayBpbiB0aGUgYnJvd3NlcicpXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3MgYSBzaW5nbGUgcGF0aCwgdmVyaWZ5IGl0J3MgYSBmaWxlIGJlZm9yZSBkZWNpZGluZyB0aGlzIGlzIGEgc2luZ2xlXG4gICAgLy8gZmlsZSB0b3JyZW50XG4gICAgaXNGaWxlKGlucHV0WzBdLCBmdW5jdGlvbiAoZXJyLCBwYXRoSXNGaWxlKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaXNTaW5nbGVGaWxlVG9ycmVudCA9IHBhdGhJc0ZpbGVcbiAgICAgIHByb2Nlc3NJbnB1dCgpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3NJbnB1dCgpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJbnB1dCAoKSB7XG4gICAgcGFyYWxsZWwoaW5wdXQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBmaWxlID0ge31cblxuICAgICAgICBpZiAoaXNCbG9iKGl0ZW0pKSB7XG4gICAgICAgICAgZmlsZS5nZXRTdHJlYW0gPSBnZXRCbG9iU3RyZWFtKGl0ZW0pXG4gICAgICAgICAgZmlsZS5sZW5ndGggPSBpdGVtLnNpemVcbiAgICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoaXRlbSkpIHtcbiAgICAgICAgICBmaWxlLmdldFN0cmVhbSA9IGdldEJ1ZmZlclN0cmVhbShpdGVtKVxuICAgICAgICAgIGZpbGUubGVuZ3RoID0gaXRlbS5sZW5ndGhcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlYWRhYmxlKGl0ZW0pKSB7XG4gICAgICAgICAgZmlsZS5nZXRTdHJlYW0gPSBnZXRTdHJlYW1TdHJlYW0oaXRlbSwgZmlsZSlcbiAgICAgICAgICBmaWxlLmxlbmd0aCA9IDBcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZzLnN0YXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZXN5c3RlbSBwYXRocyBkbyBub3Qgd29yayBpbiB0aGUgYnJvd3NlcicpXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrZWVwUm9vdCA9IG51bVBhdGhzID4gMSB8fCBpc1NpbmdsZUZpbGVUb3JyZW50XG4gICAgICAgICAgZ2V0RmlsZXMoaXRlbSwga2VlcFJvb3QsIGNiKVxuICAgICAgICAgIHJldHVybiAvLyBlYXJseSByZXR1cm4hXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIGZpbGUucGF0aCA9IGl0ZW0ucGF0aFxuICAgICAgICBjYihudWxsLCBmaWxlKVxuICAgICAgfVxuICAgIH0pLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGZpbGVzID0gZmxhdHRlbihmaWxlcylcbiAgICAgIGNiKG51bGwsIGZpbGVzLCBpc1NpbmdsZUZpbGVUb3JyZW50KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RmlsZXMgKHBhdGgsIGtlZXBSb290LCBjYikge1xuICB0cmF2ZXJzZVBhdGgocGF0aCwgZ2V0RmlsZUluZm8sIGZ1bmN0aW9uIChlcnIsIGZpbGVzKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGVzKSkgZmlsZXMgPSBmbGF0dGVuKGZpbGVzKVxuICAgIGVsc2UgZmlsZXMgPSBbIGZpbGVzIF1cblxuICAgIHBhdGggPSBjb3JlUGF0aC5ub3JtYWxpemUocGF0aClcbiAgICBpZiAoa2VlcFJvb3QpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHBhdGgubGFzdEluZGV4T2YoY29yZVBhdGguc2VwKSArIDEpXG4gICAgfVxuICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gIT09IGNvcmVQYXRoLnNlcCkgcGF0aCArPSBjb3JlUGF0aC5zZXBcblxuICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIGZpbGUuZ2V0U3RyZWFtID0gZ2V0RmlsZVBhdGhTdHJlYW0oZmlsZS5wYXRoKVxuICAgICAgZmlsZS5wYXRoID0gZmlsZS5wYXRoLnJlcGxhY2UocGF0aCwgJycpLnNwbGl0KGNvcmVQYXRoLnNlcClcbiAgICB9KVxuICAgIGNiKG51bGwsIGZpbGVzKVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRGaWxlSW5mbyAocGF0aCwgY2IpIHtcbiAgY2IgPSBvbmNlKGNiKVxuICBmcy5zdGF0KHBhdGgsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHZhciBpbmZvID0ge1xuICAgICAgbGVuZ3RoOiBzdGF0LnNpemUsXG4gICAgICBwYXRoOiBwYXRoXG4gICAgfVxuICAgIGNiKG51bGwsIGluZm8pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlUGF0aCAocGF0aCwgZm4sIGNiKSB7XG4gIGZzLnJlYWRkaXIocGF0aCwgZnVuY3Rpb24gKGVyciwgZW50cmllcykge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgLy8gdGhpcyBpcyBhIGZpbGVcbiAgICAgIGZuKHBhdGgsIGNiKVxuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAvLyByZWFsIGVycm9yXG4gICAgICBjYihlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBmb2xkZXJcbiAgICAgIHBhcmFsbGVsKGVudHJpZXMuZmlsdGVyKG5vdEhpZGRlbikuZmlsdGVyKGp1bmsubm90KS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICB0cmF2ZXJzZVBhdGgoY29yZVBhdGguam9pbihwYXRoLCBlbnRyeSksIGZuLCBjYilcbiAgICAgICAgfVxuICAgICAgfSksIGNiKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gbm90SGlkZGVuIChmaWxlKSB7XG4gIHJldHVybiBmaWxlWzBdICE9PSAnLidcbn1cblxuZnVuY3Rpb24gZ2V0UGllY2VMaXN0IChmaWxlcywgcGllY2VMZW5ndGgsIGNiKSB7XG4gIGNiID0gb25jZShjYilcbiAgdmFyIHBpZWNlcyA9IFtdXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgdmFyIHN0cmVhbXMgPSBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICByZXR1cm4gZmlsZS5nZXRTdHJlYW1cbiAgfSlcblxuICB2YXIgcmVtYWluaW5nSGFzaGVzID0gMFxuICB2YXIgcGllY2VOdW0gPSAwXG4gIHZhciBlbmRlZCA9IGZhbHNlXG5cbiAgdmFyIG11bHRpc3RyZWFtID0gbmV3IE11bHRpU3RyZWFtKHN0cmVhbXMpXG4gIHZhciBibG9ja3N0cmVhbSA9IG5ldyBCbG9ja1N0cmVhbShwaWVjZUxlbmd0aCwgeyB6ZXJvUGFkZGluZzogZmFsc2UgfSlcblxuICBtdWx0aXN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKVxuXG4gIG11bHRpc3RyZWFtXG4gICAgLnBpcGUoYmxvY2tzdHJlYW0pXG4gICAgLm9uKCdkYXRhJywgb25EYXRhKVxuICAgIC5vbignZW5kJywgb25FbmQpXG4gICAgLm9uKCdlcnJvcicsIG9uRXJyb3IpXG5cbiAgZnVuY3Rpb24gb25EYXRhIChjaHVuaykge1xuICAgIGxlbmd0aCArPSBjaHVuay5sZW5ndGhcblxuICAgIHZhciBpID0gcGllY2VOdW1cbiAgICBzaGExKGNodW5rLCBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcGllY2VzW2ldID0gaGFzaFxuICAgICAgcmVtYWluaW5nSGFzaGVzIC09IDFcbiAgICAgIG1heWJlRG9uZSgpXG4gICAgfSlcbiAgICByZW1haW5pbmdIYXNoZXMgKz0gMVxuICAgIHBpZWNlTnVtICs9IDFcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kICgpIHtcbiAgICBlbmRlZCA9IHRydWVcbiAgICBtYXliZURvbmUoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgY2xlYW51cCgpXG4gICAgY2IoZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgbXVsdGlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICBibG9ja3N0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSlcbiAgICBibG9ja3N0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpXG4gICAgYmxvY2tzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlRG9uZSAoKSB7XG4gICAgaWYgKGVuZGVkICYmIHJlbWFpbmluZ0hhc2hlcyA9PT0gMCkge1xuICAgICAgY2xlYW51cCgpXG4gICAgICBjYihudWxsLCBuZXcgQnVmZmVyKHBpZWNlcy5qb2luKCcnKSwgJ2hleCcpLCBsZW5ndGgpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uRmlsZXMgKGZpbGVzLCBvcHRzLCBjYikge1xuICB2YXIgYW5ub3VuY2VMaXN0ID0gb3B0cy5hbm5vdW5jZUxpc3RcblxuICBpZiAoIWFubm91bmNlTGlzdCkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy5hbm5vdW5jZSA9PT0gJ3N0cmluZycpIGFubm91bmNlTGlzdCA9IFsgWyBvcHRzLmFubm91bmNlIF0gXVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5hbm5vdW5jZSkpIHtcbiAgICAgIGFubm91bmNlTGlzdCA9IG9wdHMuYW5ub3VuY2UubWFwKGZ1bmN0aW9uICh1KSB7IHJldHVybiBbIHUgXSB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghYW5ub3VuY2VMaXN0KSBhbm5vdW5jZUxpc3QgPSBbXVxuXG4gIGlmIChnbG9iYWwuV0VCVE9SUkVOVF9BTk5PVU5DRSkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbm5vdW5jZUxpc3QucHVzaChbIFsgZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UgXSBdKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShnbG9iYWwuV0VCVE9SUkVOVF9BTk5PVU5DRSkpIHtcbiAgICAgIGFubm91bmNlTGlzdCA9IGFubm91bmNlTGlzdC5jb25jYXQoZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UubWFwKGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIHJldHVybiBbIHUgXVxuICAgICAgfSkpXG4gICAgfVxuICB9XG5cbiAgLy8gV2hlbiBubyB0cmFja2VycyBzcGVjaWZpZWQsIHVzZSBzb21lIHJlYXNvbmFibGUgZGVmYXVsdHNcbiAgaWYgKG9wdHMuYW5ub3VuY2UgPT09IHVuZGVmaW5lZCAmJiBvcHRzLmFubm91bmNlTGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYW5ub3VuY2VMaXN0ID0gYW5ub3VuY2VMaXN0LmNvbmNhdChtb2R1bGUuZXhwb3J0cy5hbm5vdW5jZUxpc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMudXJsTGlzdCA9PT0gJ3N0cmluZycpIG9wdHMudXJsTGlzdCA9IFsgb3B0cy51cmxMaXN0IF1cblxuICB2YXIgdG9ycmVudCA9IHtcbiAgICBpbmZvOiB7XG4gICAgICBuYW1lOiBvcHRzLm5hbWVcbiAgICB9LFxuICAgICdjcmVhdGlvbiBkYXRlJzogTWF0aC5jZWlsKChOdW1iZXIob3B0cy5jcmVhdGlvbkRhdGUpIHx8IERhdGUubm93KCkpIC8gMTAwMCksXG4gICAgZW5jb2Rpbmc6ICdVVEYtOCdcbiAgfVxuXG4gIGlmIChhbm5vdW5jZUxpc3QubGVuZ3RoICE9PSAwKSB7XG4gICAgdG9ycmVudC5hbm5vdW5jZSA9IGFubm91bmNlTGlzdFswXVswXVxuICAgIHRvcnJlbnRbJ2Fubm91bmNlLWxpc3QnXSA9IGFubm91bmNlTGlzdFxuICB9XG5cbiAgaWYgKG9wdHMuY29tbWVudCAhPT0gdW5kZWZpbmVkKSB0b3JyZW50LmNvbW1lbnQgPSBvcHRzLmNvbW1lbnRcblxuICBpZiAob3B0cy5jcmVhdGVkQnkgIT09IHVuZGVmaW5lZCkgdG9ycmVudFsnY3JlYXRlZCBieSddID0gb3B0cy5jcmVhdGVkQnlcblxuICBpZiAob3B0cy5wcml2YXRlICE9PSB1bmRlZmluZWQpIHRvcnJlbnQuaW5mby5wcml2YXRlID0gTnVtYmVyKG9wdHMucHJpdmF0ZSlcblxuICAvLyBcInNzbC1jZXJ0XCIga2V5IGlzIGZvciBTU0wgdG9ycmVudHMsIHNlZTpcbiAgLy8gICAtIGh0dHA6Ly9ibG9nLmxpYnRvcnJlbnQub3JnLzIwMTIvMDEvYml0dG9ycmVudC1vdmVyLXNzbC9cbiAgLy8gICAtIGh0dHA6Ly93d3cubGlidG9ycmVudC5vcmcvbWFudWFsLXJlZi5odG1sI3NzbC10b3JyZW50c1xuICAvLyAgIC0gaHR0cDovL3d3dy5saWJ0b3JyZW50Lm9yZy9yZWZlcmVuY2UtQ3JlYXRlX1RvcnJlbnRzLmh0bWxcbiAgaWYgKG9wdHMuc3NsQ2VydCAhPT0gdW5kZWZpbmVkKSB0b3JyZW50LmluZm9bJ3NzbC1jZXJ0J10gPSBvcHRzLnNzbENlcnRcblxuICBpZiAob3B0cy51cmxMaXN0ICE9PSB1bmRlZmluZWQpIHRvcnJlbnRbJ3VybC1saXN0J10gPSBvcHRzLnVybExpc3RcblxuICB2YXIgcGllY2VMZW5ndGggPSBvcHRzLnBpZWNlTGVuZ3RoIHx8IGNhbGNQaWVjZUxlbmd0aChmaWxlcy5yZWR1Y2Uoc3VtTGVuZ3RoLCAwKSlcbiAgdG9ycmVudC5pbmZvWydwaWVjZSBsZW5ndGgnXSA9IHBpZWNlTGVuZ3RoXG5cbiAgZ2V0UGllY2VMaXN0KGZpbGVzLCBwaWVjZUxlbmd0aCwgZnVuY3Rpb24gKGVyciwgcGllY2VzLCB0b3JyZW50TGVuZ3RoKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICB0b3JyZW50LmluZm8ucGllY2VzID0gcGllY2VzXG5cbiAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICBkZWxldGUgZmlsZS5nZXRTdHJlYW1cbiAgICB9KVxuXG4gICAgaWYgKG9wdHMuc2luZ2xlRmlsZVRvcnJlbnQpIHtcbiAgICAgIHRvcnJlbnQuaW5mby5sZW5ndGggPSB0b3JyZW50TGVuZ3RoXG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcnJlbnQuaW5mby5maWxlcyA9IGZpbGVzXG4gICAgfVxuXG4gICAgY2IobnVsbCwgYmVuY29kZS5lbmNvZGUodG9ycmVudCkpXG4gIH0pXG59XG5cbi8qKlxuICogQWNjdW11bGF0b3IgdG8gc3VtIGZpbGUgbGVuZ3Roc1xuICogQHBhcmFtICB7bnVtYmVyfSBzdW1cbiAqIEBwYXJhbSAge09iamVjdH0gZmlsZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzdW1MZW5ndGggKHN1bSwgZmlsZSkge1xuICByZXR1cm4gc3VtICsgZmlsZS5sZW5ndGhcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIFczQyBgQmxvYmAgb2JqZWN0ICh3aGljaCBgRmlsZWAgaW5oZXJpdHMgZnJvbSlcbiAqIEBwYXJhbSAgeyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNCbG9iIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBCbG9iXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBXM0MgYEZpbGVMaXN0YCBvYmplY3RcbiAqIEBwYXJhbSAgeyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGaWxlTGlzdCAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgRmlsZUxpc3QgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgRmlsZUxpc3Rcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIG5vZGUgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUmVhZGFibGUgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nXG59XG5cbi8qKlxuICogQ29udmVydCBhIGBGaWxlYCB0byBhIGxhenkgcmVhZGFibGUgc3RyZWFtLlxuICogQHBhcmFtICB7RmlsZXxCbG9ifSBmaWxlXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmxvYlN0cmVhbSAoZmlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmlsZVJlYWRTdHJlYW0oZmlsZSlcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBgQnVmZmVyYCB0byBhIGxhenkgcmVhZGFibGUgc3RyZWFtLlxuICogQHBhcmFtICB7QnVmZmVyfSBidWZmZXJcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRCdWZmZXJTdHJlYW0gKGJ1ZmZlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpXG4gICAgcy5lbmQoYnVmZmVyKVxuICAgIHJldHVybiBzXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgZmlsZSBwYXRoIHRvIGEgbGF6eSByZWFkYWJsZSBzdHJlYW0uXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRGaWxlUGF0aFN0cmVhbSAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgpXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcmVhZGFibGUgc3RyZWFtIHRvIGEgbGF6eSByZWFkYWJsZSBzdHJlYW0uIEFkZHMgaW5zdHJ1bWVudGF0aW9uIHRvIHRyYWNrXG4gKiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBzdHJlYW0gYW5kIHNldCBgZmlsZS5sZW5ndGhgLlxuICpcbiAqIEBwYXJhbSAge1N0cmVhbX0gc3RyZWFtXG4gKiBAcGFyYW0gIHtPYmplY3R9IGZpbGVcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRTdHJlYW1TdHJlYW0gKHJlYWRhYmxlLCBmaWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBuZXcgc3RyZWFtLlRyYW5zZm9ybSgpXG4gICAgY291bnRlci5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGJ1ZiwgZW5jLCBkb25lKSB7XG4gICAgICBmaWxlLmxlbmd0aCArPSBidWYubGVuZ3RoXG4gICAgICB0aGlzLnB1c2goYnVmKVxuICAgICAgZG9uZSgpXG4gICAgfVxuICAgIHJlYWRhYmxlLnBpcGUoY291bnRlcilcbiAgICByZXR1cm4gY291bnRlclxuICB9XG59XG4iLCJ2YXIgYmVuY29kZSA9IG1vZHVsZS5leHBvcnRzXG5cbmJlbmNvZGUuZW5jb2RlID0gcmVxdWlyZSggJy4vbGliL2VuY29kZScgKVxuYmVuY29kZS5kZWNvZGUgPSByZXF1aXJlKCAnLi9saWIvZGVjb2RlJyApXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYW1vdW50IG9mIGJ5dGVzXG4gKiBuZWVkZWQgdG8gZW5jb2RlIHRoZSBnaXZlbiB2YWx1ZVxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fEJ1ZmZlcnxTdHJpbmd8TnVtYmVyfEJvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGJ5dGVDb3VudFxuICovXG5iZW5jb2RlLmJ5dGVMZW5ndGggPSBiZW5jb2RlLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24oIHZhbHVlICkge1xuICByZXR1cm4gYmVuY29kZS5lbmNvZGUoIHZhbHVlICkubGVuZ3RoXG59XG4iLCJ2YXIgRGljdCA9IHJlcXVpcmUoXCIuL2RpY3RcIilcblxuLyoqXG4gKiBEZWNvZGVzIGJlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtICB7QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0IChvcHRpb25hbClcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kIChvcHRpb25hbClcbiAqIEBwYXJhbSAge1N0cmluZ30gZW5jb2RpbmcgKG9wdGlvbmFsKVxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fEJ1ZmZlcnxTdHJpbmd8TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWNvZGUoIGRhdGEsIHN0YXJ0LCBlbmQsIGVuY29kaW5nICkge1xuICBcbiAgaWYoIHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicgJiYgZW5jb2RpbmcgPT0gbnVsbCApIHtcbiAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgc3RhcnQgPSB1bmRlZmluZWRcbiAgfVxuICBcbiAgaWYoIHR5cGVvZiBlbmQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBlbmRcbiAgICBlbmQgPSB1bmRlZmluZWRcbiAgfVxuICBcbiAgZGVjb2RlLnBvc2l0aW9uID0gMFxuICBkZWNvZGUuZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBudWxsXG5cbiAgZGVjb2RlLmRhdGEgPSAhKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKVxuICAgID8gbmV3IEJ1ZmZlciggZGF0YSApXG4gICAgOiBkYXRhLnNsaWNlKCBzdGFydCwgZW5kIClcbiAgXG4gIGRlY29kZS5ieXRlcyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICBcbiAgcmV0dXJuIGRlY29kZS5uZXh0KClcblxufVxuXG5kZWNvZGUuYnl0ZXMgPSAwXG5kZWNvZGUucG9zaXRpb24gPSAwXG5kZWNvZGUuZGF0YSAgICAgPSBudWxsXG5kZWNvZGUuZW5jb2RpbmcgPSBudWxsXG5cbmRlY29kZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG5cbiAgc3dpdGNoKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICkge1xuICAgIGNhc2UgMHg2NDogcmV0dXJuIGRlY29kZS5kaWN0aW9uYXJ5KCk7IGJyZWFrXG4gICAgY2FzZSAweDZDOiByZXR1cm4gZGVjb2RlLmxpc3QoKTsgYnJlYWtcbiAgICBjYXNlIDB4Njk6IHJldHVybiBkZWNvZGUuaW50ZWdlcigpOyBicmVha1xuICAgIGRlZmF1bHQ6ICAgcmV0dXJuIGRlY29kZS5idWZmZXIoKTsgYnJlYWtcbiAgfVxuXG59XG5cbmRlY29kZS5maW5kID0gZnVuY3Rpb24oIGNociApIHtcblxuICB2YXIgaSA9IGRlY29kZS5wb3NpdGlvblxuICB2YXIgYyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICB2YXIgZCA9IGRlY29kZS5kYXRhXG5cbiAgd2hpbGUoIGkgPCBjICkge1xuICAgIGlmKCBkW2ldID09PSBjaHIgKVxuICAgICAgcmV0dXJuIGlcbiAgICBpKytcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YWxpZCBkYXRhOiBNaXNzaW5nIGRlbGltaXRlciBcIicgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoIGNociApICsgJ1wiIFsweCcgK1xuICAgIGNoci50b1N0cmluZyggMTYgKSArICddJ1xuICApXG5cbn1cblxuZGVjb2RlLmRpY3Rpb25hcnkgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBkaWN0ID0gbmV3IERpY3QoKVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGRpY3QuYmluYXJ5U2V0KGRlY29kZS5idWZmZXIoKSwgZGVjb2RlLm5leHQoKSlcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGRpY3RcblxufVxuXG5kZWNvZGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGxzdCA9IFtdXG5cbiAgd2hpbGUoIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gIT09IDB4NjUgKSB7XG4gICAgbHN0LnB1c2goIGRlY29kZS5uZXh0KCkgKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gbHN0XG5cbn1cblxuZGVjb2RlLmludGVnZXIgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZW5kICAgID0gZGVjb2RlLmZpbmQoIDB4NjUgKVxuICB2YXIgbnVtYmVyID0gZGVjb2RlLmRhdGEudG9TdHJpbmcoICdhc2NpaScsIGRlY29kZS5wb3NpdGlvbiArIDEsIGVuZCApXG5cbiAgZGVjb2RlLnBvc2l0aW9uICs9IGVuZCArIDEgLSBkZWNvZGUucG9zaXRpb25cblxuICByZXR1cm4gcGFyc2VJbnQoIG51bWJlciwgMTAgKVxuXG59XG5cbmRlY29kZS5idWZmZXIgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgc2VwICAgID0gZGVjb2RlLmZpbmQoIDB4M0EgKVxuICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoIGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24sIHNlcCApLCAxMCApXG4gIHZhciBlbmQgICAgPSArK3NlcCArIGxlbmd0aFxuXG4gIGRlY29kZS5wb3NpdGlvbiA9IGVuZFxuXG4gIHJldHVybiBkZWNvZGUuZW5jb2RpbmdcbiAgICA/IGRlY29kZS5kYXRhLnRvU3RyaW5nKCBkZWNvZGUuZW5jb2RpbmcsIHNlcCwgZW5kIClcbiAgICA6IGRlY29kZS5kYXRhLnNsaWNlKCBzZXAsIGVuZCApXG5cbn1cblxuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGVcbiIsInZhciBEaWN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEaWN0KCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5c1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IFtdLFxuICB9KVxufVxuXG5EaWN0LnByb3RvdHlwZS5iaW5hcnlLZXlzID0gZnVuY3Rpb24gYmluYXJ5S2V5cygpIHtcbiAgcmV0dXJuIHRoaXMuX2tleXMuc2xpY2UoKVxufVxuXG5EaWN0LnByb3RvdHlwZS5iaW5hcnlTZXQgPSBmdW5jdGlvbiBiaW5hcnlTZXQoa2V5LCB2YWx1ZSkge1xuICB0aGlzLl9rZXlzLnB1c2goa2V5KVxuXG4gIHRoaXNba2V5XSA9IHZhbHVlXG59XG4iLCIvKipcbiAqIEVuY29kZXMgZGF0YSBpbiBiZW5jb2RlLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcnxBcnJheXxTdHJpbmd8T2JqZWN0fE51bWJlcnxCb29sZWFufSBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZSggZGF0YSwgYnVmZmVyLCBvZmZzZXQgKSB7XG4gIFxuICB2YXIgYnVmZmVycyA9IFtdXG4gIHZhciByZXN1bHQgPSBudWxsXG4gIFxuICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YSApXG4gIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoIGJ1ZmZlcnMgKVxuICBlbmNvZGUuYnl0ZXMgPSByZXN1bHQubGVuZ3RoXG4gIFxuICBpZiggQnVmZmVyLmlzQnVmZmVyKCBidWZmZXIgKSApIHtcbiAgICByZXN1bHQuY29weSggYnVmZmVyLCBvZmZzZXQgKVxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdFxuICBcbn1cblxuZW5jb2RlLmJ5dGVzID0gLTFcbmVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSBmYWxzZVxuXG5lbmNvZGUuX2VuY29kZSA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGlmKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCggdHlwZW9mIGRhdGEgKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGVuY29kZS5idWZmZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KCBidWZmZXJzLCBkYXRhIClcbiAgICAgICAgOiBlbmNvZGUuZGljdCggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSA/IDEgOiAwIClcbiAgICAgIGJyZWFrXG4gIH1cblxufVxuXG52YXIgYnVmZl9lID0gbmV3IEJ1ZmZlcignZScpXG4gICwgYnVmZl9kID0gbmV3IEJ1ZmZlcignZCcpXG4gICwgYnVmZl9sID0gbmV3IEJ1ZmZlcignbCcpXG5cbmVuY29kZS5idWZmZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoIGRhdGEgKSArICc6JyArIGRhdGEpIClcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuICB2YXIgbWF4TG8gPSAweDgwMDAwMDAwXG4gIHZhciBoaSA9ICggZGF0YSAvIG1heExvICkgPDwgMFxuICB2YXIgbG8gPSAoIGRhdGEgJSBtYXhMbyAgKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoICdpJyArIHZhbCArICdlJyApKVxuXG4gIGlmKCB2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgKSB7XG4gICAgZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCA9IHRydWVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV0FSTklORzogUG9zc2libGUgZGF0YSBjb3JydXB0aW9uIGRldGVjdGVkIHdpdGggdmFsdWUgXCInK2RhdGErJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicrdmFsKydcIidcbiAgICApXG4gICAgY29uc29sZS50cmFjZSgpXG4gIH1cblxufVxuXG5lbmNvZGUuZGljdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9kIClcblxuICB2YXIgaiA9IDBcbiAgdmFyIGtcbiAgLy8gZml4IGZvciBpc3N1ZSAjMTMgLSBzb3J0ZWQgZGljdHNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZGF0YSApLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciggOyBqIDwga2wgOyBqKyspIHtcbiAgICBrPWtleXNbal1cbiAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBrIClcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtrXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgdmFyIGkgPSAwLCBqID0gMVxuICB2YXIgYyA9IGRhdGEubGVuZ3RoXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9sIClcblxuICBmb3IoIDsgaSA8IGM7IGkrKyApIHtcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtpXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG5cbn1cblxuLy8gRXhwb3NlXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJndW1lbnRzW2ldICE9PSB1bmRlZmluZWQpIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgfVxufTtcbiIsInZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRyZXR1cm4gc3RyZWFtLnN0ZGlvICYmIEFycmF5LmlzQXJyYXkoc3RyZWFtLnN0ZGlvKSAmJiBzdHJlYW0uc3RkaW8ubGVuZ3RoID09PSAzXG59O1xuXG52YXIgZW9zID0gZnVuY3Rpb24oc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcblx0aWYgKCFvcHRzKSBvcHRzID0ge307XG5cblx0Y2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuXG5cdHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblx0dmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXHR2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IChvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGUpO1xuXHR2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IChvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGUpO1xuXG5cdHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuXHR9O1xuXG5cdHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHdyaXRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCFyZWFkYWJsZSkgY2FsbGJhY2soKTtcblx0fTtcblxuXHR2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcblx0XHRyZWFkYWJsZSA9IGZhbHNlO1xuXHRcdGlmICghd3JpdGFibGUpIGNhbGxiYWNrKCk7XG5cdH07XG5cblx0dmFyIG9uZXhpdCA9IGZ1bmN0aW9uKGV4aXRDb2RlKSB7XG5cdFx0Y2FsbGJhY2soZXhpdENvZGUgPyBuZXcgRXJyb3IoJ2V4aXRlZCB3aXRoIGVycm9yIGNvZGU6ICcgKyBleGl0Q29kZSkgOiBudWxsKTtcblx0fTtcblxuXHR2YXIgb25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChyZWFkYWJsZSAmJiAhKHJzICYmIHJzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHRcdGlmICh3cml0YWJsZSAmJiAhKHdzICYmIHdzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHR9O1xuXG5cdHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdH07XG5cblx0aWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG5cdFx0c3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO1xuXHRcdGVsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0fSBlbHNlIGlmICh3cml0YWJsZSAmJiAhd3MpIHsgLy8gbGVnYWN5IHN0cmVhbXNcblx0XHRzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHR9XG5cblx0aWYgKGlzQ2hpbGRQcm9jZXNzKHN0cmVhbSkpIHN0cmVhbS5vbignZXhpdCcsIG9uZXhpdCk7XG5cblx0c3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG5cdHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHRpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBjYWxsYmFjayk7XG5cdHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25leGl0KTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgY2FsbGJhY2spO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsInZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciByZUV4dGVuc2lvbiA9IC9eLipcXC4oXFx3KykkLztcbnZhciB0b0J1ZmZlciA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktdG8tYnVmZmVyJyk7XG5cbmZ1bmN0aW9uIEZpbGVSZWFkU3RyZWFtKGZpbGUsIG9wdHMpIHtcbiAgdmFyIHJlYWRTdHJlYW0gPSB0aGlzO1xuICBpZiAoISAodGhpcyBpbnN0YW5jZW9mIEZpbGVSZWFkU3RyZWFtKSkge1xuICAgIHJldHVybiBuZXcgRmlsZVJlYWRTdHJlYW0oZmlsZSwgb3B0cyk7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgLy8gaW5oZXJpdCByZWFkYWJsZVxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIC8vIHNhdmUgdGhlIHJlYWQgb2Zmc2V0XG4gIHRoaXMuX29mZnNldCA9IDA7XG4gIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gIHRoaXMuX2ZpbGUgPSBmaWxlO1xuICB0aGlzLl9zaXplID0gZmlsZS5zaXplO1xuICB0aGlzLl9jaHVua1NpemUgPSBvcHRzLmNodW5rU2l6ZSB8fCBNYXRoLm1heCh0aGlzLl9zaXplIC8gMTAwMCwgMjAwICogMTAyNCk7XG5cbiAgLy8gY3JlYXRlIHRoZSByZWFkZXJcbiAgdGhpcy5yZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gIC8vIGdlbmVyYXRlIHRoZSBoZWFkZXIgYmxvY2tzIHRoYXQgd2Ugd2lsbCBzZW5kIGFzIHBhcnQgb2YgdGhlIGluaXRpYWwgcGF5bG9hZFxuICB0aGlzLl9nZW5lcmF0ZUhlYWRlckJsb2NrcyhmaWxlLCBvcHRzLCBmdW5jdGlvbihlcnIsIGJsb2Nrcykge1xuICAgIC8vIGlmIHdlIGVuY291bnRlcmVkIGFuIGVycm9yLCBlbWl0IGl0XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIHJlYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cblxuICAgIC8vIHB1c2ggdGhlIGhlYWRlciBibG9ja3Mgb3V0IHRvIHRoZSBzdHJlYW1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9ja3MpKSB7XG4gICAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgcmVhZFN0cmVhbS5wdXNoKGJsb2NrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlYWRTdHJlYW0uX3JlYWR5ID0gdHJ1ZTtcbiAgICByZWFkU3RyZWFtLmVtaXQoJ19yZWFkeScpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoRmlsZVJlYWRTdHJlYW0sIFJlYWRhYmxlKTtcbm1vZHVsZS5leHBvcnRzID0gRmlsZVJlYWRTdHJlYW07XG5cbkZpbGVSZWFkU3RyZWFtLnByb3RvdHlwZS5fZ2VuZXJhdGVIZWFkZXJCbG9ja3MgPSBmdW5jdGlvbihmaWxlLCBvcHRzLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCBbXSk7XG59O1xuXG5GaWxlUmVhZFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yZWFkeSkge1xuICAgIHRoaXMub25jZSgnX3JlYWR5JywgdGhpcy5fcmVhZC5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlYWRTdHJlYW0gPSB0aGlzO1xuICB2YXIgcmVhZGVyID0gdGhpcy5yZWFkZXI7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuICB2YXIgZW5kT2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5fY2h1bmtTaXplO1xuICBpZiAoZW5kT2Zmc2V0ID4gdGhpcy5fc2l6ZSkgZW5kT2Zmc2V0ID0gdGhpcy5fc2l6ZTtcblxuICBpZiAoc3RhcnRPZmZzZXQgPT09IHRoaXMuX3NpemUpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwZGF0ZSB0aGUgc3RyZWFtIG9mZnNldFxuICAgIHJlYWRTdHJlYW0uX29mZnNldCA9IGVuZE9mZnNldDtcblxuICAgIC8vIGdldCB0aGUgZGF0YSBjaHVua1xuICAgIHJlYWRTdHJlYW0ucHVzaCh0b0J1ZmZlcihyZWFkZXIucmVzdWx0KSk7XG4gIH1cbiAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICByZWFkU3RyZWFtLmVtaXQoJ2Vycm9yJywgcmVhZGVyLmVycm9yKTtcbiAgfVxuXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih0aGlzLl9maWxlLnNsaWNlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpKTtcbn07XG5cbkZpbGVSZWFkU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZpbGUgPSBudWxsO1xuICBpZiAodGhpcy5yZWFkZXIpIHtcbiAgICB0aGlzLnJlYWRlci5vbmxvYWQgPSBudWxsO1xuICAgIHRoaXMucmVhZGVyLm9uZXJyb3IgPSBudWxsO1xuICAgIHRyeSB7IHRoaXMucmVhZGVyLmFib3J0KCk7IH0gY2F0Y2ggKGUpIHt9O1xuICB9XG4gIHRoaXMucmVhZGVyID0gbnVsbDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmxhdHRlbihsaXN0LCBkZXB0aCkge1xuICBkZXB0aCA9ICh0eXBlb2YgZGVwdGggPT0gJ251bWJlcicpID8gZGVwdGggOiBJbmZpbml0eTtcblxuICBpZiAoIWRlcHRoKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZXR1cm4gX2ZsYXR0ZW4obGlzdCwgMSk7XG5cbiAgZnVuY3Rpb24gX2ZsYXR0ZW4obGlzdCwgZCkge1xuICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSAmJiBkIDwgZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoX2ZsYXR0ZW4oaXRlbSwgZCArIDEpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChpdGVtKTtcbiAgICAgIH1cbiAgICB9LCBbXSk7XG4gIH1cbn07XG4iLCIvLyBvcmlnaW5hbGx5IHB1bGxlZCBvdXQgb2Ygc2ltcGxlLXBlZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCcm93c2VyUlRDICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbFxuICB2YXIgd3J0YyA9IHtcbiAgICBSVENQZWVyQ29ubmVjdGlvbjogd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLFxuICAgIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fFxuICAgICAgd2luZG93Lm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICAgIFJUQ0ljZUNhbmRpZGF0ZTogd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cubW96UlRDSWNlQ2FuZGlkYXRlIHx8XG4gICAgICB3aW5kb3cud2Via2l0UlRDSWNlQ2FuZGlkYXRlXG4gIH1cbiAgaWYgKCF3cnRjLlJUQ1BlZXJDb25uZWN0aW9uKSByZXR1cm4gbnVsbFxuICByZXR1cm4gd3J0Y1xufVxuIiwidmFyIGhhdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdHMsIGJhc2UpIHtcbiAgICBpZiAoIWJhc2UpIGJhc2UgPSAxNjtcbiAgICBpZiAoYml0cyA9PT0gdW5kZWZpbmVkKSBiaXRzID0gMTI4O1xuICAgIGlmIChiaXRzIDw9IDApIHJldHVybiAnMCc7XG4gICAgXG4gICAgdmFyIGRpZ2l0cyA9IE1hdGgubG9nKE1hdGgucG93KDIsIGJpdHMpKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgIGZvciAodmFyIGkgPSAyOyBkaWdpdHMgPT09IEluZmluaXR5OyBpICo9IDIpIHtcbiAgICAgICAgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cyAvIGkpKSAvIE1hdGgubG9nKGJhc2UpICogaTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlbSA9IGRpZ2l0cyAtIE1hdGguZmxvb3IoZGlnaXRzKTtcbiAgICBcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLmZsb29yKGRpZ2l0cyk7IGkrKykge1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICByZXMgPSB4ICsgcmVzO1xuICAgIH1cbiAgICBcbiAgICBpZiAocmVtKSB7XG4gICAgICAgIHZhciBiID0gTWF0aC5wb3coYmFzZSwgcmVtKTtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBiKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgcmVzID0geCArIHJlcztcbiAgICB9XG4gICAgXG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHJlcywgYmFzZSk7XG4gICAgaWYgKHBhcnNlZCAhPT0gSW5maW5pdHkgJiYgcGFyc2VkID49IE1hdGgucG93KDIsIGJpdHMpKSB7XG4gICAgICAgIHJldHVybiBoYXQoYml0cywgYmFzZSlcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gcmVzO1xufTtcblxuaGF0LnJhY2sgPSBmdW5jdGlvbiAoYml0cywgYmFzZSwgZXhwYW5kQnkpIHtcbiAgICB2YXIgZm4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgaXRlcnMgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoaXRlcnMgKysgPiAxMCkge1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRCeSkgYml0cyArPSBleHBhbmRCeTtcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgSUQgY29sbGlzaW9ucywgdXNlIG1vcmUgYml0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpZCA9IGhhdChiaXRzLCBiYXNlKTtcbiAgICAgICAgfSB3aGlsZSAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoaGF0cywgaWQpKTtcbiAgICAgICAgXG4gICAgICAgIGhhdHNbaWRdID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG4gICAgdmFyIGhhdHMgPSBmbi5oYXRzID0ge307XG4gICAgXG4gICAgZm4uZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBmbi5oYXRzW2lkXTtcbiAgICB9O1xuICAgIFxuICAgIGZuLnNldCA9IGZ1bmN0aW9uIChpZCwgdmFsdWUpIHtcbiAgICAgICAgZm4uaGF0c1tpZF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgXG4gICAgZm4uYml0cyA9IGJpdHMgfHwgMTI4O1xuICAgIGZuLmJhc2UgPSBiYXNlIHx8IDE2O1xuICAgIHJldHVybiBmbjtcbn07XG4iLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHM7XG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gICAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XTtcbn07XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBwYXJhbXMuc2NoZW1lID0gJ2h0dHBzJztcbiAgICBwYXJhbXMucHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYik7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gSW1tZWRpYXRlU3RvcmVcblxuZnVuY3Rpb24gSW1tZWRpYXRlU3RvcmUgKHN0b3JlKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbW1lZGlhdGVTdG9yZSkpIHJldHVybiBuZXcgSW1tZWRpYXRlU3RvcmUoc3RvcmUpXG5cbiAgdGhpcy5zdG9yZSA9IHN0b3JlXG4gIHRoaXMuY2h1bmtMZW5ndGggPSBzdG9yZS5jaHVua0xlbmd0aFxuXG4gIGlmICghdGhpcy5zdG9yZSB8fCAhdGhpcy5zdG9yZS5nZXQgfHwgIXRoaXMuc3RvcmUucHV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFic3RyYWN0LWNodW5rLXN0b3JlIGNvbXBsaWFudCcpXG4gIH1cblxuICB0aGlzLm1lbSA9IFtdXG59XG5cbkltbWVkaWF0ZVN0b3JlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoaW5kZXgsIGJ1ZiwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYubWVtW2luZGV4XSA9IGJ1ZlxuICBzZWxmLnN0b3JlLnB1dChpbmRleCwgYnVmLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5tZW1baW5kZXhdID0gbnVsbFxuICAgIGlmIChjYikgY2IoZXJyKVxuICB9KVxufVxuXG5JbW1lZGlhdGVTdG9yZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmdldChpbmRleCwgbnVsbCwgb3B0cylcblxuICB2YXIgc3RhcnQgPSAob3B0cyAmJiBvcHRzLm9mZnNldCkgfHwgMFxuICB2YXIgZW5kID0gb3B0cyAmJiBvcHRzLmxlbmd0aCAmJiAoc3RhcnQgKyBvcHRzLmxlbmd0aClcblxuICB2YXIgYnVmID0gdGhpcy5tZW1baW5kZXhdXG4gIGlmIChidWYpIHJldHVybiBuZXh0VGljayhjYiwgbnVsbCwgb3B0cyA/IGJ1Zi5zbGljZShzdGFydCwgZW5kKSA6IGJ1ZilcblxuICB0aGlzLnN0b3JlLmdldChpbmRleCwgb3B0cywgY2IpXG59XG5cbkltbWVkaWF0ZVN0b3JlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYikge1xuICB0aGlzLnN0b3JlLmNsb3NlKGNiKVxufVxuXG5JbW1lZGlhdGVTdG9yZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICB0aGlzLnN0b3JlLmRlc3Ryb3koY2IpXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgZXJyLCB2YWwpIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSBjYihlcnIsIHZhbClcbiAgfSlcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgZXhwYW5kSVB2NiwgaXBhZGRyLCBpcHY0UGFydCwgaXB2NFJlZ2V4ZXMsIGlwdjZQYXJ0LCBpcHY2UmVnZXhlcywgbWF0Y2hDSURSLCByb290O1xuXG4gIGlwYWRkciA9IHt9O1xuXG4gIHJvb3QgPSB0aGlzO1xuXG4gIGlmICgodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUgIT09IG51bGwpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpcGFkZHI7XG4gIH0gZWxzZSB7XG4gICAgcm9vdFsnaXBhZGRyJ10gPSBpcGFkZHI7XG4gIH1cblxuICBtYXRjaENJRFIgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kLCBwYXJ0U2l6ZSwgY2lkckJpdHMpIHtcbiAgICB2YXIgcGFydCwgc2hpZnQ7XG4gICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBjYW5ub3QgbWF0Y2ggQ0lEUiBmb3Igb2JqZWN0cyB3aXRoIGRpZmZlcmVudCBsZW5ndGhzXCIpO1xuICAgIH1cbiAgICBwYXJ0ID0gMDtcbiAgICB3aGlsZSAoY2lkckJpdHMgPiAwKSB7XG4gICAgICBzaGlmdCA9IHBhcnRTaXplIC0gY2lkckJpdHM7XG4gICAgICBpZiAoc2hpZnQgPCAwKSB7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdFtwYXJ0XSA+PiBzaGlmdCAhPT0gc2Vjb25kW3BhcnRdID4+IHNoaWZ0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNpZHJCaXRzIC09IHBhcnRTaXplO1xuICAgICAgcGFydCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBpcGFkZHIuc3VibmV0TWF0Y2ggPSBmdW5jdGlvbihhZGRyZXNzLCByYW5nZUxpc3QsIGRlZmF1bHROYW1lKSB7XG4gICAgdmFyIHJhbmdlTmFtZSwgcmFuZ2VTdWJuZXRzLCBzdWJuZXQsIF9pLCBfbGVuO1xuICAgIGlmIChkZWZhdWx0TmFtZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0TmFtZSA9ICd1bmljYXN0JztcbiAgICB9XG4gICAgZm9yIChyYW5nZU5hbWUgaW4gcmFuZ2VMaXN0KSB7XG4gICAgICByYW5nZVN1Ym5ldHMgPSByYW5nZUxpc3RbcmFuZ2VOYW1lXTtcbiAgICAgIGlmIChyYW5nZVN1Ym5ldHNbMF0gJiYgIShyYW5nZVN1Ym5ldHNbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcmFuZ2VTdWJuZXRzID0gW3JhbmdlU3VibmV0c107XG4gICAgICB9XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHJhbmdlU3VibmV0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBzdWJuZXQgPSByYW5nZVN1Ym5ldHNbX2ldO1xuICAgICAgICBpZiAoYWRkcmVzcy5tYXRjaC5hcHBseShhZGRyZXNzLCBzdWJuZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdE5hbWU7XG4gIH07XG5cbiAgaXBhZGRyLklQdjQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSVB2NChvY3RldHMpIHtcbiAgICAgIHZhciBvY3RldCwgX2ksIF9sZW47XG4gICAgICBpZiAob2N0ZXRzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGlwdjQgb2N0ZXQgY291bnQgc2hvdWxkIGJlIDRcIik7XG4gICAgICB9XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9jdGV0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvY3RldCA9IG9jdGV0c1tfaV07XG4gICAgICAgIGlmICghKCgwIDw9IG9jdGV0ICYmIG9jdGV0IDw9IDI1NSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBpcHY0IG9jdGV0IHNob3VsZCBmaXQgaW4gOCBiaXRzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9jdGV0cyA9IG9jdGV0cztcbiAgICB9XG5cbiAgICBJUHY0LnByb3RvdHlwZS5raW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ2lwdjQnO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2N0ZXRzLmpvaW4oXCIuXCIpO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2N0ZXRzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKG90aGVyLCBjaWRyUmFuZ2UpIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgaWYgKGNpZHJSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9yZWYgPSBvdGhlciwgb3RoZXIgPSBfcmVmWzBdLCBjaWRyUmFuZ2UgPSBfcmVmWzFdO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyLmtpbmQoKSAhPT0gJ2lwdjQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogY2Fubm90IG1hdGNoIGlwdjQgYWRkcmVzcyB3aXRoIG5vbi1pcHY0IG9uZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaENJRFIodGhpcy5vY3RldHMsIG90aGVyLm9jdGV0cywgOCwgY2lkclJhbmdlKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUuU3BlY2lhbFJhbmdlcyA9IHtcbiAgICAgIHVuc3BlY2lmaWVkOiBbW25ldyBJUHY0KFswLCAwLCAwLCAwXSksIDhdXSxcbiAgICAgIGJyb2FkY2FzdDogW1tuZXcgSVB2NChbMjU1LCAyNTUsIDI1NSwgMjU1XSksIDMyXV0sXG4gICAgICBtdWx0aWNhc3Q6IFtbbmV3IElQdjQoWzIyNCwgMCwgMCwgMF0pLCA0XV0sXG4gICAgICBsaW5rTG9jYWw6IFtbbmV3IElQdjQoWzE2OSwgMjU0LCAwLCAwXSksIDE2XV0sXG4gICAgICBsb29wYmFjazogW1tuZXcgSVB2NChbMTI3LCAwLCAwLCAwXSksIDhdXSxcbiAgICAgIFwicHJpdmF0ZVwiOiBbW25ldyBJUHY0KFsxMCwgMCwgMCwgMF0pLCA4XSwgW25ldyBJUHY0KFsxNzIsIDE2LCAwLCAwXSksIDEyXSwgW25ldyBJUHY0KFsxOTIsIDE2OCwgMCwgMF0pLCAxNl1dLFxuICAgICAgcmVzZXJ2ZWQ6IFtbbmV3IElQdjQoWzE5MiwgMCwgMCwgMF0pLCAyNF0sIFtuZXcgSVB2NChbMTkyLCAwLCAyLCAwXSksIDI0XSwgW25ldyBJUHY0KFsxOTIsIDg4LCA5OSwgMF0pLCAyNF0sIFtuZXcgSVB2NChbMTk4LCA1MSwgMTAwLCAwXSksIDI0XSwgW25ldyBJUHY0KFsyMDMsIDAsIDExMywgMF0pLCAyNF0sIFtuZXcgSVB2NChbMjQwLCAwLCAwLCAwXSksIDRdXVxuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlwYWRkci5zdWJuZXRNYXRjaCh0aGlzLCB0aGlzLlNwZWNpYWxSYW5nZXMpO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS50b0lQdjRNYXBwZWRBZGRyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXBhZGRyLklQdjYucGFyc2UoXCI6OmZmZmY6XCIgKyAodGhpcy50b1N0cmluZygpKSk7XG4gICAgfTtcblxuICAgIElQdjQucHJvdG90eXBlLnByZWZpeExlbmd0aEZyb21TdWJuZXRNYXNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2lkciwgaSwgb2N0ZXQsIHN0b3AsIHplcm9zLCB6ZXJvdGFibGUsIF9pO1xuICAgICAgemVyb3RhYmxlID0ge1xuICAgICAgICAwOiA4LFxuICAgICAgICAxMjg6IDcsXG4gICAgICAgIDE5MjogNixcbiAgICAgICAgMjI0OiA1LFxuICAgICAgICAyNDA6IDQsXG4gICAgICAgIDI0ODogMyxcbiAgICAgICAgMjUyOiAyLFxuICAgICAgICAyNTQ6IDEsXG4gICAgICAgIDI1NTogMFxuICAgICAgfTtcbiAgICAgIGNpZHIgPSAwO1xuICAgICAgc3RvcCA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gX2kgPSAzOyBfaSA+PSAwOyBpID0gX2kgKz0gLTEpIHtcbiAgICAgICAgb2N0ZXQgPSB0aGlzLm9jdGV0c1tpXTtcbiAgICAgICAgaWYgKG9jdGV0IGluIHplcm90YWJsZSkge1xuICAgICAgICAgIHplcm9zID0gemVyb3RhYmxlW29jdGV0XTtcbiAgICAgICAgICBpZiAoc3RvcCAmJiB6ZXJvcyAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh6ZXJvcyAhPT0gOCkge1xuICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNpZHIgKz0gemVyb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAzMiAtIGNpZHI7XG4gICAgfTtcblxuICAgIHJldHVybiBJUHY0O1xuXG4gIH0pKCk7XG5cbiAgaXB2NFBhcnQgPSBcIigwP1xcXFxkK3wweFthLWYwLTldKylcIjtcblxuICBpcHY0UmVnZXhlcyA9IHtcbiAgICBmb3VyT2N0ZXQ6IG5ldyBSZWdFeHAoXCJeXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiJFwiLCAnaScpLFxuICAgIGxvbmdWYWx1ZTogbmV3IFJlZ0V4cChcIl5cIiArIGlwdjRQYXJ0ICsgXCIkXCIsICdpJylcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5wYXJzZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2gsIHBhcnNlSW50QXV0bywgcGFydCwgc2hpZnQsIHZhbHVlO1xuICAgIHBhcnNlSW50QXV0byA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZ1swXSA9PT0gXCIwXCIgJiYgc3RyaW5nWzFdICE9PSBcInhcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCA4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChzdHJpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjRSZWdleGVzLmZvdXJPY3RldCkpIHtcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSBtYXRjaC5zbGljZSgxLCA2KTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcGFydCA9IF9yZWZbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGFyc2VJbnRBdXRvKHBhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaXB2NFJlZ2V4ZXMubG9uZ1ZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBwYXJzZUludEF1dG8obWF0Y2hbMV0pO1xuICAgICAgaWYgKHZhbHVlID4gMHhmZmZmZmZmZiB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBhZGRyZXNzIG91dHNpZGUgZGVmaW5lZCByYW5nZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHNoaWZ0ID0gX2kgPSAwOyBfaSA8PSAyNDsgc2hpZnQgPSBfaSArPSA4KSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCgodmFsdWUgPj4gc2hpZnQpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSkucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLklQdjYgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSVB2NihwYXJ0cykge1xuICAgICAgdmFyIGksIHBhcnQsIF9pLCBfaiwgX2xlbiwgX3JlZjtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDE2KSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gX2kgPSAwOyBfaSA8PSAxNDsgaSA9IF9pICs9IDIpIHtcbiAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goKHBhcnRzW2ldIDw8IDgpIHwgcGFydHNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBpcHY2IHBhcnQgY291bnQgc2hvdWxkIGJlIDggb3IgMTZcIik7XG4gICAgICB9XG4gICAgICBfcmVmID0gdGhpcy5wYXJ0cztcbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjsgX2orKykge1xuICAgICAgICBwYXJ0ID0gX3JlZltfal07XG4gICAgICAgIGlmICghKCgwIDw9IHBhcnQgJiYgcGFydCA8PSAweGZmZmYpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogaXB2NiBwYXJ0IHNob3VsZCBmaXQgaW4gMTYgYml0c1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIElQdjYucHJvdG90eXBlLmtpbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnaXB2Nic7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcGFjdFN0cmluZ1BhcnRzLCBwYXJ0LCBwdXNoUGFydCwgc3RhdGUsIHN0cmluZ1BhcnRzLCBfaSwgX2xlbjtcbiAgICAgIHN0cmluZ1BhcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gdGhpcy5wYXJ0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcGFydCA9IF9yZWZbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGFydC50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICBjb21wYWN0U3RyaW5nUGFydHMgPSBbXTtcbiAgICAgIHB1c2hQYXJ0ID0gZnVuY3Rpb24ocGFydCkge1xuICAgICAgICByZXR1cm4gY29tcGFjdFN0cmluZ1BhcnRzLnB1c2gocGFydCk7XG4gICAgICB9O1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzdHJpbmdQYXJ0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJ0ID0gc3RyaW5nUGFydHNbX2ldO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcwJykge1xuICAgICAgICAgICAgICBwdXNoUGFydCgnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwdXNoUGFydChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHVzaFBhcnQocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgIHB1c2hQYXJ0KCcnKTtcbiAgICAgICAgICAgICAgcHVzaFBhcnQocGFydCk7XG4gICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHB1c2hQYXJ0KHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IDIpIHtcbiAgICAgICAgcHVzaFBhcnQoJycpO1xuICAgICAgICBwdXNoUGFydCgnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcGFjdFN0cmluZ1BhcnRzLmpvaW4oXCI6XCIpO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJ5dGVzLCBwYXJ0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGJ5dGVzID0gW107XG4gICAgICBfcmVmID0gdGhpcy5wYXJ0cztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJ0ID0gX3JlZltfaV07XG4gICAgICAgIGJ5dGVzLnB1c2gocGFydCA+PiA4KTtcbiAgICAgICAgYnl0ZXMucHVzaChwYXJ0ICYgMHhmZik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvTm9ybWFsaXplZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnQ7XG4gICAgICByZXR1cm4gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMucGFydHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHBhcnQgPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnQudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpKS5qb2luKFwiOlwiKTtcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgY2lkclJhbmdlKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGlmIChjaWRyUmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgICBfcmVmID0gb3RoZXIsIG90aGVyID0gX3JlZlswXSwgY2lkclJhbmdlID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlci5raW5kKCkgIT09ICdpcHY2Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGNhbm5vdCBtYXRjaCBpcHY2IGFkZHJlc3Mgd2l0aCBub24taXB2NiBvbmVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hDSURSKHRoaXMucGFydHMsIG90aGVyLnBhcnRzLCAxNiwgY2lkclJhbmdlKTtcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUuU3BlY2lhbFJhbmdlcyA9IHtcbiAgICAgIHVuc3BlY2lmaWVkOiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMTI4XSxcbiAgICAgIGxpbmtMb2NhbDogW25ldyBJUHY2KFsweGZlODAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMTBdLFxuICAgICAgbXVsdGljYXN0OiBbbmV3IElQdjYoWzB4ZmYwMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCA4XSxcbiAgICAgIGxvb3BiYWNrOiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDFdKSwgMTI4XSxcbiAgICAgIHVuaXF1ZUxvY2FsOiBbbmV3IElQdjYoWzB4ZmMwMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCA3XSxcbiAgICAgIGlwdjRNYXBwZWQ6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMCwgMHhmZmZmLCAwLCAwXSksIDk2XSxcbiAgICAgIHJmYzYxNDU6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMHhmZmZmLCAwLCAwLCAwXSksIDk2XSxcbiAgICAgIHJmYzYwNTI6IFtuZXcgSVB2NihbMHg2NCwgMHhmZjliLCAwLCAwLCAwLCAwLCAwLCAwXSksIDk2XSxcbiAgICAgICc2dG80JzogW25ldyBJUHY2KFsweDIwMDIsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMTZdLFxuICAgICAgdGVyZWRvOiBbbmV3IElQdjYoWzB4MjAwMSwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAzMl0sXG4gICAgICByZXNlcnZlZDogW1tuZXcgSVB2NihbMHgyMDAxLCAweGRiOCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAzMl1dXG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXBhZGRyLnN1Ym5ldE1hdGNoKHRoaXMsIHRoaXMuU3BlY2lhbFJhbmdlcyk7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLmlzSVB2NE1hcHBlZEFkZHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlKCkgPT09ICdpcHY0TWFwcGVkJztcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUudG9JUHY0QWRkcmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhpZ2gsIGxvdywgX3JlZjtcbiAgICAgIGlmICghdGhpcy5pc0lQdjRNYXBwZWRBZGRyZXNzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiB0cnlpbmcgdG8gY29udmVydCBhIGdlbmVyaWMgaXB2NiBhZGRyZXNzIHRvIGlwdjRcIik7XG4gICAgICB9XG4gICAgICBfcmVmID0gdGhpcy5wYXJ0cy5zbGljZSgtMiksIGhpZ2ggPSBfcmVmWzBdLCBsb3cgPSBfcmVmWzFdO1xuICAgICAgcmV0dXJuIG5ldyBpcGFkZHIuSVB2NChbaGlnaCA+PiA4LCBoaWdoICYgMHhmZiwgbG93ID4+IDgsIGxvdyAmIDB4ZmZdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElQdjY7XG5cbiAgfSkoKTtcblxuICBpcHY2UGFydCA9IFwiKD86WzAtOWEtZl0rOjo/KStcIjtcblxuICBpcHY2UmVnZXhlcyA9IHtcbiAgICBcIm5hdGl2ZVwiOiBuZXcgUmVnRXhwKFwiXig6Oik/KFwiICsgaXB2NlBhcnQgKyBcIik/KFswLTlhLWZdKyk/KDo6KT8kXCIsICdpJyksXG4gICAgdHJhbnNpdGlvbmFsOiBuZXcgUmVnRXhwKChcIl4oKD86XCIgKyBpcHY2UGFydCArIFwiKXwoPzo6OikoPzpcIiArIGlwdjZQYXJ0ICsgXCIpPylcIikgKyAoXCJcIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCIkXCIpLCAnaScpXG4gIH07XG5cbiAgZXhwYW5kSVB2NiA9IGZ1bmN0aW9uKHN0cmluZywgcGFydHMpIHtcbiAgICB2YXIgY29sb25Db3VudCwgbGFzdENvbG9uLCBwYXJ0LCByZXBsYWNlbWVudCwgcmVwbGFjZW1lbnRDb3VudDtcbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJzo6JykgIT09IHN0cmluZy5sYXN0SW5kZXhPZignOjonKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbG9uQ291bnQgPSAwO1xuICAgIGxhc3RDb2xvbiA9IC0xO1xuICAgIHdoaWxlICgobGFzdENvbG9uID0gc3RyaW5nLmluZGV4T2YoJzonLCBsYXN0Q29sb24gKyAxKSkgPj0gMCkge1xuICAgICAgY29sb25Db3VudCsrO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nLnN1YnN0cigwLCAyKSA9PT0gJzo6Jykge1xuICAgICAgY29sb25Db3VudC0tO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nLnN1YnN0cigtMiwgMikgPT09ICc6OicpIHtcbiAgICAgIGNvbG9uQ291bnQtLTtcbiAgICB9XG4gICAgaWYgKGNvbG9uQ291bnQgPiBwYXJ0cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlcGxhY2VtZW50Q291bnQgPSBwYXJ0cyAtIGNvbG9uQ291bnQ7XG4gICAgcmVwbGFjZW1lbnQgPSAnOic7XG4gICAgd2hpbGUgKHJlcGxhY2VtZW50Q291bnQtLSkge1xuICAgICAgcmVwbGFjZW1lbnQgKz0gJzA6JztcbiAgICB9XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoJzo6JywgcmVwbGFjZW1lbnQpO1xuICAgIGlmIChzdHJpbmdbMF0gPT09ICc6Jykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJzonKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSBzdHJpbmcuc3BsaXQoXCI6XCIpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJ0ID0gX3JlZltfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2gocGFyc2VJbnQocGFydCwgMTYpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY2LnBhcnNlciA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBtYXRjaCwgb2N0ZXQsIG9jdGV0cywgcGFydHMsIF9pLCBfbGVuO1xuICAgIGlmIChzdHJpbmcubWF0Y2goaXB2NlJlZ2V4ZXNbJ25hdGl2ZSddKSkge1xuICAgICAgcmV0dXJuIGV4cGFuZElQdjYoc3RyaW5nLCA4KTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjZSZWdleGVzWyd0cmFuc2l0aW9uYWwnXSkpIHtcbiAgICAgIHBhcnRzID0gZXhwYW5kSVB2NihtYXRjaFsxXS5zbGljZSgwLCAtMSksIDYpO1xuICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIG9jdGV0cyA9IFtwYXJzZUludChtYXRjaFsyXSksIHBhcnNlSW50KG1hdGNoWzNdKSwgcGFyc2VJbnQobWF0Y2hbNF0pLCBwYXJzZUludChtYXRjaFs1XSldO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9jdGV0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIG9jdGV0ID0gb2N0ZXRzW19pXTtcbiAgICAgICAgICBpZiAoISgoMCA8PSBvY3RldCAmJiBvY3RldCA8PSAyNTUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2gob2N0ZXRzWzBdIDw8IDggfCBvY3RldHNbMV0pO1xuICAgICAgICBwYXJ0cy5wdXNoKG9jdGV0c1syXSA8PCA4IHwgb2N0ZXRzWzNdKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5pc0lQdjQgPSBpcGFkZHIuSVB2Ni5pc0lQdjYgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZXIoc3RyaW5nKSAhPT0gbnVsbDtcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5pc1ZhbGlkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGU7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyB0aGlzKHRoaXMucGFyc2VyKHN0cmluZykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuSVB2Ni5pc1ZhbGlkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09IFwic3RyaW5nXCIgJiYgc3RyaW5nLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbmV3IHRoaXModGhpcy5wYXJzZXIoc3RyaW5nKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGUgPSBfZXJyb3I7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5JUHY0LnBhcnNlID0gaXBhZGRyLklQdjYucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcGFydHM7XG4gICAgcGFydHMgPSB0aGlzLnBhcnNlcihzdHJpbmcpO1xuICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBzdHJpbmcgaXMgbm90IGZvcm1hdHRlZCBsaWtlIGlwIGFkZHJlc3NcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhwYXJ0cyk7XG4gIH07XG5cbiAgaXBhZGRyLklQdjQucGFyc2VDSURSID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIG1hc2tMZW5ndGgsIG1hdGNoO1xuICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiguKylcXC8oXFxkKykkLykpIHtcbiAgICAgIG1hc2tMZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICBpZiAobWFza0xlbmd0aCA+PSAwICYmIG1hc2tMZW5ndGggPD0gMzIpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnBhcnNlKG1hdGNoWzFdKSwgbWFza0xlbmd0aF07XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBhbiBJUHY0IENJRFIgcmFuZ2VcIik7XG4gIH07XG5cbiAgaXBhZGRyLklQdjYucGFyc2VDSURSID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIG1hc2tMZW5ndGgsIG1hdGNoO1xuICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiguKylcXC8oXFxkKykkLykpIHtcbiAgICAgIG1hc2tMZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICBpZiAobWFza0xlbmd0aCA+PSAwICYmIG1hc2tMZW5ndGggPD0gMTI4KSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5wYXJzZShtYXRjaFsxXSksIG1hc2tMZW5ndGhdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHN0cmluZyBpcyBub3QgZm9ybWF0dGVkIGxpa2UgYW4gSVB2NiBDSURSIHJhbmdlXCIpO1xuICB9O1xuXG4gIGlwYWRkci5pc1ZhbGlkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGlwYWRkci5JUHY2LmlzVmFsaWQoc3RyaW5nKSB8fCBpcGFkZHIuSVB2NC5pc1ZhbGlkKHN0cmluZyk7XG4gIH07XG5cbiAgaXBhZGRyLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKGlwYWRkci5JUHY2LmlzVmFsaWQoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LnBhcnNlKHN0cmluZyk7XG4gICAgfSBlbHNlIGlmIChpcGFkZHIuSVB2NC5pc1ZhbGlkKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBpcGFkZHIuSVB2NC5wYXJzZShzdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHRoZSBhZGRyZXNzIGhhcyBuZWl0aGVyIElQdjYgbm9yIElQdjQgZm9ybWF0XCIpO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIucGFyc2VDSURSID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBpcGFkZHIuSVB2Ni5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGUgPSBfZXJyb3I7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaXBhZGRyLklQdjQucGFyc2VDSURSKHN0cmluZyk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiB0aGUgYWRkcmVzcyBoYXMgbmVpdGhlciBJUHY2IG5vciBJUHY0IENJRFIgZm9ybWF0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuZnJvbUJ5dGVBcnJheSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgdmFyIGxlbmd0aDtcbiAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIG5ldyBpcGFkZHIuSVB2NChieXRlcyk7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPT09IDE2KSB7XG4gICAgICByZXR1cm4gbmV3IGlwYWRkci5JUHY2KGJ5dGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiB0aGUgYmluYXJ5IGlucHV0IGlzIG5laXRoZXIgYW4gSVB2NiBub3IgSVB2NCBhZGRyZXNzXCIpO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIucHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBhZGRyO1xuICAgIGFkZHIgPSB0aGlzLnBhcnNlKHN0cmluZyk7XG4gICAgaWYgKGFkZHIua2luZCgpID09PSAnaXB2NicgJiYgYWRkci5pc0lQdjRNYXBwZWRBZGRyZXNzKCkpIHtcbiAgICAgIHJldHVybiBhZGRyLnRvSVB2NEFkZHJlc3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZHI7XG4gICAgfVxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLyogKGMpIDIwMTYgQXJpIFBvcmFkIChAYXJpcG9yYWQpIDxodHRwOi8vYXJpcG9yYWQuY29tPi4gTGljZW5zZTogYXJpcG9yYWQubWl0LWxpY2Vuc2Uub3JnICovXG5cbi8vIFBhcnRpYWxseSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk0MDQ5LzE5Mjg0ODQsIGFuZCBmcm9tIGFub3RoZXIgU08gYW5zd2VyLCB3aGljaCB0b2xkIG1lIHRoYXQgdGhlIGhpZ2hlc3Rcbi8vIGNoYXIgY29kZSB0aGF0J3MgYXNjaWkgaXMgMTI3LCBidXQgSSBjYW4ndCBmaW5kIHRoZSBsaW5rIGZvci4gU29ycnkuXG5cbnZhciBNQVhfQVNDSUlfQ0hBUl9DT0RFID0gMTI3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXNjaWkoc3RyKSB7XG4gIGZvciAodmFyIGkgPSAwLCBzdHJMZW4gPSBzdHIubGVuZ3RoOyBpIDwgc3RyTGVuOyArK2kpIHtcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPiBNQVhfQVNDSUlfQ0hBUl9DT0RFKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIEJ1ZmZlclxuICpcbiAqIEF1dGhvcjogICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogTGljZW5zZTogIE1JVFxuICpcbiAqIGBucG0gaW5zdGFsbCBpcy1idWZmZXJgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJlxuICAgIChvYmouX2lzQnVmZmVyIHx8IC8vIEZvciBTYWZhcmkgNS03IChtaXNzaW5nIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAob2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSlcbiAgICApKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRmlsZShwYXRoLCBjYil7XG4gIGlmKCFjYilyZXR1cm4gaXNGaWxlU3luYyhwYXRoKTtcblxuICBmcy5zdGF0KHBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdHMpe1xuICAgIGlmKGVycilyZXR1cm4gY2IoZXJyKTtcbiAgICByZXR1cm4gY2IobnVsbCwgc3RhdHMuaXNGaWxlKCkpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSBpc0ZpbGVTeW5jO1xuXG5mdW5jdGlvbiBpc0ZpbGVTeW5jKHBhdGgpe1xuICByZXR1cm4gZnMuZXhpc3RzU3luYyhwYXRoKSAmJiBmcy5zdGF0U3luYyhwYXRoKS5pc0ZpbGUoKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzICAgICAgPSBpc1R5cGVkQXJyYXlcbmlzVHlwZWRBcnJheS5zdHJpY3QgPSBpc1N0cmljdFR5cGVkQXJyYXlcbmlzVHlwZWRBcnJheS5sb29zZSAgPSBpc0xvb3NlVHlwZWRBcnJheVxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgbmFtZXMgPSB7XG4gICAgJ1tvYmplY3QgSW50OEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBJbnQxNkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBJbnQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50OEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDE2QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIChcbiAgICAgICBpc1N0cmljdFR5cGVkQXJyYXkoYXJyKVxuICAgIHx8IGlzTG9vc2VUeXBlZEFycmF5KGFycilcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1N0cmljdFR5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgICAgYXJyIGluc3RhbmNlb2YgSW50OEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgSW50MTZBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEludDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50MTZBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG4gIClcbn1cblxuZnVuY3Rpb24gaXNMb29zZVR5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiBuYW1lc1t0b1N0cmluZy5jYWxsKGFycildXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLy8gQWxsXG4vLyAvXm5wbS1kZWJ1Z1xcLmxvZyQvLCAgIC8vIG5wbSBlcnJvciBsb2dcbi8vIC9eXFwuLipcXC5zd3AkLywgICAgICAgIC8vIHZpbSBzdGF0ZVxuLy8gLy8gT1MgWFxuLy8gL15cXC5EU19TdG9yZSQvLCAgICAgICAvLyBzdG9yZXMgY3VzdG9tIGZvbGRlciBhdHRyaWJ1dGVzXG4vLyAvXlxcLkFwcGxlRG91YmxlJC8sICAgIC8vIHN0b3JlcyBhZGRpdGlvbmFsIGZpbGUgcmVzb3VyY2VzXG4vLyAvXlxcLkxTT3ZlcnJpZGUkLywgICAgIC8vIGNvbnRhaW5zIHRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBhcHAgdG8gYmUgdXNlZFxuLy8gL15JY29uW1xcclxcP10/LywgICAgICAgLy8gY3VzdG9tIEZpbmRlciBpY29uXG4vLyAvXlxcLl8uKi8sICAgICAgICAgICAgIC8vIHRodW1ibmFpbFxuLy8gL15cXC5TcG90bGlnaHQtVjEwMCQvLCAgLy8gZmlsZSB0aGF0IG1pZ2h0IGFwcGVhciBvbiBleHRlcm5hbCBkaXNrXG4vLyAvXFwuVHJhc2hlcy8sICAgICAgICAgIC8vIGZpbGUgdGhhdCBtaWdodCBhcHBlYXIgb24gZXh0ZXJuYWwgZGlza1xuLy8gL15fX01BQ09TWCQvLCAgICAgICAgIC8vIHJlc291cmNlIGZvcmtcbi8vIC8vIExpbnV4XG4vLyAvfiQvLCAgICAgICAgICAgICAgICAgLy8gYmFja3VwIGZpbGVcbi8vIC8vIFdpbmRvd3Ncbi8vIC9eVGh1bWJzXFwuZGIkLywgICAgICAgLy8gaW1hZ2UgZmlsZSBjYWNoZVxuLy8gL15laHRodW1ic1xcLmRiJC8sICAgICAvLyBmb2xkZXIgY29uZmlnIGZpbGVcbi8vIC9eRGVza3RvcFxcLmluaSQvICAgICAgLy8gc3RvcmVzIGN1c3RvbSBmb2xkZXIgYXR0cmlidXRlc1xuXG5leHBvcnRzLnJlID0gL15ucG0tZGVidWdcXC5sb2ckfF5cXC4uKlxcLnN3cCR8XlxcLkRTX1N0b3JlJHxeXFwuQXBwbGVEb3VibGUkfF5cXC5MU092ZXJyaWRlJHxeSWNvbltcXHJcXD9dP3xeXFwuXy4qfF5cXC5TcG90bGlnaHQtVjEwMCR8XFwuVHJhc2hlc3xeX19NQUNPU1gkfH4kfF5UaHVtYnNcXC5kYiR8XmVodGh1bWJzXFwuZGIkfF5EZXNrdG9wXFwuaW5pJC87XG5cbmV4cG9ydHMuaXMgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcblx0cmV0dXJuIGV4cG9ydHMucmUudGVzdChmaWxlbmFtZSk7XG59O1xuXG5leHBvcnRzLm5vdCA9IGV4cG9ydHMuaXNudCA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuXHRyZXR1cm4gIWV4cG9ydHMuaXMoZmlsZW5hbWUpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gbWFnbmV0VVJJRGVjb2RlXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBtYWduZXRVUklEZWNvZGVcbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IG1hZ25ldFVSSUVuY29kZVxuXG52YXIgYmFzZTMyID0gcmVxdWlyZSgndGhpcnR5LXR3bycpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcblxuLyoqXG4gKiBQYXJzZSBhIG1hZ25ldCBVUkkgYW5kIHJldHVybiBhbiBvYmplY3Qgb2Yga2V5cy92YWx1ZXNcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVyaVxuICogQHJldHVybiB7T2JqZWN0fSBwYXJzZWQgdXJpXG4gKi9cbmZ1bmN0aW9uIG1hZ25ldFVSSURlY29kZSAodXJpKSB7XG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIC8vIFN1cHBvcnQgJ21hZ25ldDonIGFuZCAnc3RyZWFtLW1hZ25ldDonIHVyaXNcbiAgdmFyIGRhdGEgPSB1cmkuc3BsaXQoJ21hZ25ldDo/JylbMV1cblxuICB2YXIgcGFyYW1zID0gKGRhdGEgJiYgZGF0YS5sZW5ndGggPj0gMClcbiAgICA/IGRhdGEuc3BsaXQoJyYnKVxuICAgIDogW11cblxuICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIga2V5dmFsID0gcGFyYW0uc3BsaXQoJz0nKVxuXG4gICAgLy8gVGhpcyBrZXl2YWwgaXMgaW52YWxpZCwgc2tpcCBpdFxuICAgIGlmIChrZXl2YWwubGVuZ3RoICE9PSAyKSByZXR1cm5cblxuICAgIHZhciBrZXkgPSBrZXl2YWxbMF1cbiAgICB2YXIgdmFsID0ga2V5dmFsWzFdXG5cbiAgICAvLyBDbGVhbiB1cCB0b3JyZW50IG5hbWVcbiAgICBpZiAoa2V5ID09PSAnZG4nKSB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQodmFsKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuXG4gICAgLy8gQWRkcmVzcyB0cmFja2VyICh0ciksIGV4YWN0IHNvdXJjZSAoeHMpLCBhbmQgYWNjZXB0YWJsZSBzb3VyY2UgKGFzKSBhcmUgZW5jb2RlZFxuICAgIC8vIFVSSXMsIHNvIGRlY29kZSB0aGVtXG4gICAgaWYgKGtleSA9PT0gJ3RyJyB8fCBrZXkgPT09ICd4cycgfHwga2V5ID09PSAnYXMnIHx8IGtleSA9PT0gJ3dzJykge1xuICAgICAgdmFsID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbClcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4ga2V5d29yZHMgYXMgYW4gYXJyYXlcbiAgICBpZiAoa2V5ID09PSAna3QnKSB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQodmFsKS5zcGxpdCgnKycpXG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgcmVwZWF0ZWQgcGFyYW1ldGVycywgcmV0dXJuIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgIGlmIChyZXN1bHRba2V5XSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9sZCA9IHJlc3VsdFtrZXldXG4gICAgICAgIHJlc3VsdFtrZXldID0gW29sZCwgdmFsXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbFxuICAgIH1cbiAgfSlcblxuICAvLyBDb252ZW5pZW5jZSBwcm9wZXJ0aWVzIGZvciBwYXJpdHkgd2l0aCBgcGFyc2UtdG9ycmVudC1maWxlYCBtb2R1bGVcbiAgdmFyIG1cbiAgaWYgKHJlc3VsdC54dCkge1xuICAgIHZhciB4dHMgPSBBcnJheS5pc0FycmF5KHJlc3VsdC54dCkgPyByZXN1bHQueHQgOiBbIHJlc3VsdC54dCBdXG4gICAgeHRzLmZvckVhY2goZnVuY3Rpb24gKHh0KSB7XG4gICAgICBpZiAoKG0gPSB4dC5tYXRjaCgvXnVybjpidGloOiguezQwfSkvKSkpIHtcbiAgICAgICAgcmVzdWx0LmluZm9IYXNoID0gbVsxXS50b0xvd2VyQ2FzZSgpXG4gICAgICB9IGVsc2UgaWYgKChtID0geHQubWF0Y2goL151cm46YnRpaDooLnszMn0pLykpKSB7XG4gICAgICAgIHZhciBkZWNvZGVkU3RyID0gYmFzZTMyLmRlY29kZShtWzFdKVxuICAgICAgICByZXN1bHQuaW5mb0hhc2ggPSBuZXcgQnVmZmVyKGRlY29kZWRTdHIsICdiaW5hcnknKS50b1N0cmluZygnaGV4JylcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGlmIChyZXN1bHQuaW5mb0hhc2gpIHJlc3VsdC5pbmZvSGFzaEJ1ZmZlciA9IG5ldyBCdWZmZXIocmVzdWx0LmluZm9IYXNoLCAnaGV4JylcblxuICBpZiAocmVzdWx0LmRuKSByZXN1bHQubmFtZSA9IHJlc3VsdC5kblxuICBpZiAocmVzdWx0Lmt0KSByZXN1bHQua2V5d29yZHMgPSByZXN1bHQua3RcblxuICBpZiAodHlwZW9mIHJlc3VsdC50ciA9PT0gJ3N0cmluZycpIHJlc3VsdC5hbm5vdW5jZSA9IFsgcmVzdWx0LnRyIF1cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQudHIpKSByZXN1bHQuYW5ub3VuY2UgPSByZXN1bHQudHJcbiAgZWxzZSByZXN1bHQuYW5ub3VuY2UgPSBbXVxuXG4gIHJlc3VsdC51cmxMaXN0ID0gW11cbiAgaWYgKHR5cGVvZiByZXN1bHQuYXMgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkocmVzdWx0LmFzKSkge1xuICAgIHJlc3VsdC51cmxMaXN0ID0gcmVzdWx0LnVybExpc3QuY29uY2F0KHJlc3VsdC5hcylcbiAgfVxuICBpZiAodHlwZW9mIHJlc3VsdC53cyA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQud3MpKSB7XG4gICAgcmVzdWx0LnVybExpc3QgPSByZXN1bHQudXJsTGlzdC5jb25jYXQocmVzdWx0LndzKVxuICB9XG5cbiAgdW5pcShyZXN1bHQuYW5ub3VuY2UpXG4gIHVuaXEocmVzdWx0LnVybExpc3QpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBtYWduZXRVUklFbmNvZGUgKG9iaikge1xuICBvYmogPSBleHRlbmQob2JqKSAvLyBjbG9uZSBvYmosIHNvIHdlIGNhbiBtdXRhdGUgaXRcblxuICAvLyBzdXBwb3J0IHVzaW5nIGNvbnZlbmllbmNlIG5hbWVzLCBpbiBhZGRpdGlvbiB0byBzcGVjIG5hbWVzXG4gIC8vIChleGFtcGxlOiBgaW5mb0hhc2hgIGZvciBgeHRgLCBgbmFtZWAgZm9yIGBkbmApXG4gIGlmIChvYmouaW5mb0hhc2hCdWZmZXIpIG9iai54dCA9ICd1cm46YnRpaDonICsgb2JqLmluZm9IYXNoQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICBpZiAob2JqLmluZm9IYXNoKSBvYmoueHQgPSAndXJuOmJ0aWg6JyArIG9iai5pbmZvSGFzaFxuICBpZiAob2JqLm5hbWUpIG9iai5kbiA9IG9iai5uYW1lXG4gIGlmIChvYmoua2V5d29yZHMpIG9iai5rdCA9IG9iai5rZXl3b3Jkc1xuICBpZiAob2JqLmFubm91bmNlKSBvYmoudHIgPSBvYmouYW5ub3VuY2VcbiAgaWYgKG9iai51cmxMaXN0KSB7XG4gICAgb2JqLndzID0gb2JqLnVybExpc3RcbiAgICBkZWxldGUgb2JqLmFzXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJ21hZ25ldDo/J1xuICBPYmplY3Qua2V5cyhvYmopXG4gICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMlxuICAgIH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgdmFyIHZhbHVlcyA9IEFycmF5LmlzQXJyYXkob2JqW2tleV0pID8gb2JqW2tleV0gOiBbIG9ialtrZXldIF1cbiAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGopIHtcbiAgICAgICAgaWYgKChpID4gMCB8fCBqID4gMCkgJiYgKGtleSAhPT0gJ2t0JyB8fCBqID09PSAwKSkgcmVzdWx0ICs9ICcmJ1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdkbicpIHZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLnJlcGxhY2UoLyUyMC9nLCAnKycpXG4gICAgICAgIGlmIChrZXkgPT09ICd0cicgfHwga2V5ID09PSAneHMnIHx8IGtleSA9PT0gJ2FzJyB8fCBrZXkgPT09ICd3cycpIHtcbiAgICAgICAgICB2YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsKVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdrdCcpIHZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpXG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2t0JyAmJiBqID4gMCkgcmVzdWx0ICs9ICcrJyArIHZhbFxuICAgICAgICBlbHNlIHJlc3VsdCArPSBrZXkgKyAnPScgKyB2YWxcbiAgICAgIH0pXG4gICAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE1lZGlhRWxlbWVudFdyYXBwZXJcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgdG9BcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ3RvLWFycmF5YnVmZmVyJylcblxudmFyIE1lZGlhU291cmNlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1lZGlhU291cmNlXG5cbnZhciBERUZBVUxUX0JVRkZFUl9EVVJBVElPTiA9IDYwIC8vIHNlY29uZHNcblxuZnVuY3Rpb24gTWVkaWFFbGVtZW50V3JhcHBlciAoZWxlbSwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIE1lZGlhRWxlbWVudFdyYXBwZXIpKSByZXR1cm4gbmV3IE1lZGlhRWxlbWVudFdyYXBwZXIoZWxlbSwgb3B0cylcblxuICBpZiAoIU1lZGlhU291cmNlKSB0aHJvdyBuZXcgRXJyb3IoJ3dlYiBicm93c2VyIGxhY2tzIE1lZGlhU291cmNlIHN1cHBvcnQnKVxuXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHNlbGYuX2J1ZmZlckR1cmF0aW9uID0gb3B0cy5idWZmZXJEdXJhdGlvbiB8fCBERUZBVUxUX0JVRkZFUl9EVVJBVElPTlxuICBzZWxmLl9lbGVtID0gZWxlbVxuICBzZWxmLl9tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpXG4gIHNlbGYuX3N0cmVhbXMgPSBbXVxuICBzZWxmLmRldGFpbGVkRXJyb3IgPSBudWxsXG5cbiAgc2VsZi5fZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2VsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckhhbmRsZXIpXG4gICAgdmFyIHN0cmVhbXMgPSBzZWxmLl9zdHJlYW1zLnNsaWNlKClcbiAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmRlc3Ryb3koc2VsZi5fZWxlbS5lcnJvcilcbiAgICB9KVxuICB9XG4gIHNlbGYuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckhhbmRsZXIpXG5cbiAgc2VsZi5fZWxlbS5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzZWxmLl9tZWRpYVNvdXJjZSlcbn1cblxuLypcbiAqIGBvYmpgIGNhbiBiZSBhIHByZXZpb3VzIHZhbHVlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb25cbiAqIG9yIGEgc3RyaW5nXG4gKi9cbk1lZGlhRWxlbWVudFdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZVdyaXRlU3RyZWFtID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICByZXR1cm4gbmV3IE1lZGlhU291cmNlU3RyZWFtKHNlbGYsIG9iailcbn1cblxuLypcbiAqIFVzZSB0byB0cmlnZ2VyIGFuIGVycm9yIG9uIHRoZSB1bmRlcmx5aW5nIG1lZGlhIGVsZW1lbnRcbiAqL1xuTWVkaWFFbGVtZW50V3JhcHBlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIC8vIGJlIGNhcmVmdWwgbm90IHRvIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgZGV0YWlsZWRFcnJvciB2YWx1ZXNcbiAgaWYgKCFzZWxmLmRldGFpbGVkRXJyb3IpIHtcbiAgICBzZWxmLmRldGFpbGVkRXJyb3IgPSBlcnJcbiAgfVxuICB0cnkge1xuICAgIHNlbGYuX21lZGlhU291cmNlLmVuZE9mU3RyZWFtKCdkZWNvZGUnKVxuICB9IGNhdGNoIChlcnIpIHt9XG59XG5cbmluaGVyaXRzKE1lZGlhU291cmNlU3RyZWFtLCBzdHJlYW0uV3JpdGFibGUpXG5cbmZ1bmN0aW9uIE1lZGlhU291cmNlU3RyZWFtICh3cmFwcGVyLCBvYmopIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cbiAgc2VsZi5fd3JhcHBlciA9IHdyYXBwZXJcbiAgc2VsZi5fZWxlbSA9IHdyYXBwZXIuX2VsZW1cbiAgc2VsZi5fbWVkaWFTb3VyY2UgPSB3cmFwcGVyLl9tZWRpYVNvdXJjZVxuICBzZWxmLl9hbGxTdHJlYW1zID0gd3JhcHBlci5fc3RyZWFtc1xuICBzZWxmLl9hbGxTdHJlYW1zLnB1c2goc2VsZilcbiAgc2VsZi5fYnVmZmVyRHVyYXRpb24gPSB3cmFwcGVyLl9idWZmZXJEdXJhdGlvblxuICBzZWxmLl9zb3VyY2VCdWZmZXIgPSBudWxsXG5cbiAgc2VsZi5fb3BlbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25Tb3VyY2VPcGVuKClcbiAgfVxuICBzZWxmLl9mbG93SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9mbG93KClcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHNlbGYuX3R5cGUgPSBvYmpcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBzb3VyY2VCdWZmZXJcbiAgICBpZiAoc2VsZi5fbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICBzZWxmLl9jcmVhdGVTb3VyY2VCdWZmZXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2VsZi5fb3BlbkhhbmRsZXIpXG4gICAgfVxuICB9IGVsc2UgaWYgKG9iai5fc291cmNlQnVmZmVyID09PSBudWxsKSB7XG4gICAgb2JqLmRlc3Ryb3koKVxuICAgIHNlbGYuX3R5cGUgPSBvYmouX3R5cGUgLy8gVGhlIG9sZCBzdHJlYW0gd2FzIGNyZWF0ZWQgYnV0IGhhc24ndCBmaW5pc2hlZCBpbml0aWFsaXppbmdcbiAgICBzZWxmLl9tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2VsZi5fb3BlbkhhbmRsZXIpXG4gIH0gZWxzZSBpZiAob2JqLl9zb3VyY2VCdWZmZXIpIHtcbiAgICBvYmouZGVzdHJveSgpXG4gICAgc2VsZi5fdHlwZSA9IG9iai5fdHlwZVxuICAgIHNlbGYuX3NvdXJjZUJ1ZmZlciA9IG9iai5fc291cmNlQnVmZmVyIC8vIENvcHkgb3ZlciB0aGUgb2xkIHNvdXJjZUJ1ZmZlclxuICAgIHNlbGYuX3NvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCBzZWxmLl9mbG93SGFuZGxlcilcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhcmd1bWVudCB0byBNZWRpYUVsZW1lbnRXcmFwcGVyLmNyZWF0ZVdyaXRlU3RyZWFtIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBwcmV2aW91cyBzdHJlYW0gcmV0dXJuZWQgZnJvbSB0aGF0IGZ1bmN0aW9uJylcbiAgfVxuXG4gIHNlbGYuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHNlbGYuX2Zsb3dIYW5kbGVyKVxuXG4gIHNlbGYub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX3dyYXBwZXIuZXJyb3IoZXJyKVxuICB9KVxuXG4gIHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHNlbGYuX2ZpbmlzaGVkID0gdHJ1ZVxuICAgIGlmIChzZWxmLl9hbGxTdHJlYW1zLmV2ZXJ5KGZ1bmN0aW9uIChvdGhlcikgeyByZXR1cm4gb3RoZXIuX2ZpbmlzaGVkIH0pKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLl9tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgfVxuICB9KVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuX29uU291cmNlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHNlbGYuX29wZW5IYW5kbGVyKVxuICBzZWxmLl9jcmVhdGVTb3VyY2VCdWZmZXIoKVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIC8vIFJlbW92ZSBmcm9tIGFsbFN0cmVhbXNcbiAgc2VsZi5fYWxsU3RyZWFtcy5zcGxpY2Uoc2VsZi5fYWxsU3RyZWFtcy5pbmRleE9mKHNlbGYpLCAxKVxuXG4gIHNlbGYuX21lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCBzZWxmLl9vcGVuSGFuZGxlcilcbiAgc2VsZi5fZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gIGlmIChzZWxmLl9zb3VyY2VCdWZmZXIpIHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gICAgaWYgKHNlbGYuX21lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgc2VsZi5fc291cmNlQnVmZmVyLmFib3J0KClcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICBzZWxmLmVtaXQoJ2Nsb3NlJylcbn1cblxuTWVkaWFTb3VyY2VTdHJlYW0ucHJvdG90eXBlLl9jcmVhdGVTb3VyY2VCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIGlmIChNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoc2VsZi5fdHlwZSkpIHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIgPSBzZWxmLl9tZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIoc2VsZi5fdHlwZSlcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gICAgaWYgKHNlbGYuX2NiKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSBudWxsXG4gICAgICBjYigpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgfVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmICghc2VsZi5fc291cmNlQnVmZmVyKSB7XG4gICAgc2VsZi5fY2IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgc2VsZi5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYilcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZi5fc291cmNlQnVmZmVyLnVwZGF0aW5nKSB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ2Fubm90IGFwcGVuZCBidWZmZXIgd2hpbGUgc291cmNlIGJ1ZmZlciB1cGRhdGluZycpKVxuICB9XG5cbiAgdHJ5IHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIuYXBwZW5kQnVmZmVyKHRvQXJyYXlCdWZmZXIoY2h1bmspKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBhcHBlbmRCdWZmZXIgY2FuIHRocm93IGZvciBhIG51bWJlciBvZiByZWFzb25zLCBtb3N0IG5vdGFibHkgd2hlbiB0aGUgZGF0YVxuICAgIC8vIGJlaW5nIGFwcGVuZGVkIGlzIGludmFsaWQgb3IgaWYgYXBwZW5kQnVmZmVyIGlzIGNhbGxlZCBhZnRlciBhbm90aGVyIGVycm9yXG4gICAgLy8gYWxyZWFkeSBvY2N1cnJlZCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gSW4gQ2hyb21lLCB0aGVyZSBtYXkgYmUgdXNlZnVsIGRlYnVnZ2luZ1xuICAgIC8vIGluZm8gaW4gY2hyb21lOi8vbWVkaWEtaW50ZXJuYWxzXG4gICAgc2VsZi5kZXN0cm95KGVycilcbiAgICByZXR1cm5cbiAgfVxuICBzZWxmLl9jYiA9IGNiXG59XG5cbk1lZGlhU291cmNlU3RyZWFtLnByb3RvdHlwZS5fZmxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYuZGVzdHJveWVkIHx8ICFzZWxmLl9zb3VyY2VCdWZmZXIgfHwgc2VsZi5fc291cmNlQnVmZmVyLnVwZGF0aW5nKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZi5fbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgLy8gY2hlY2sgYnVmZmVyIHNpemVcbiAgICBpZiAoc2VsZi5fZ2V0QnVmZmVyRHVyYXRpb24oKSA+IHNlbGYuX2J1ZmZlckR1cmF0aW9uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5fY2IpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgIHNlbGYuX2NiID0gbnVsbFxuICAgIGNiKClcbiAgfVxufVxuXG4vLyBUT0RPOiBpZiB6ZXJvIGFjdHVhbGx5IHdvcmtzIGluIGFsbCBicm93c2VycywgcmVtb3ZlIHRoZSBsb2dpYyBhc3NvY2lhdGVkIHdpdGggdGhpcyBiZWxvd1xudmFyIEVQU0lMT04gPSAwXG5cbk1lZGlhU291cmNlU3RyZWFtLnByb3RvdHlwZS5fZ2V0QnVmZmVyRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBidWZmZXJlZCA9IHNlbGYuX3NvdXJjZUJ1ZmZlci5idWZmZXJlZFxuICB2YXIgY3VycmVudFRpbWUgPSBzZWxmLl9lbGVtLmN1cnJlbnRUaW1lXG4gIHZhciBidWZmZXJFbmQgPSAtMSAvLyBlbmQgb2YgdGhlIGJ1ZmZlclxuICAvLyBUaGlzIGlzIGEgbGl0dGxlIG92ZXIgY29tcGxleCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgc2VlbSB0byBzZXBhcmF0ZSB0aGVcbiAgLy8gYnVmZmVyZWQgcmVnaW9uIGludG8gbXVsdGlwbGUgc2VjdGlvbnMgd2l0aCBzbGlnaHQgZ2Fwcy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpXG4gICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKSArIEVQU0lMT05cblxuICAgIGlmIChzdGFydCA+IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBSZWFjaGVkIHBhc3QgdGhlIGpvaW5lZCBidWZmZXJcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChidWZmZXJFbmQgPj0gMCB8fCBjdXJyZW50VGltZSA8PSBlbmQpIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBzdGFydC9jb250aW51YXRpb24gb2YgdGhlIGpvaW5lZCBidWZmZXJcbiAgICAgIGJ1ZmZlckVuZCA9IGVuZFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXJlZFRpbWUgPSBidWZmZXJFbmQgLSBjdXJyZW50VGltZVxuICBpZiAoYnVmZmVyZWRUaW1lIDwgMCkge1xuICAgIGJ1ZmZlcmVkVGltZSA9IDBcbiAgfVxuXG4gIHJldHVybiBidWZmZXJlZFRpbWVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gU3RvcmFnZVxuXG5mdW5jdGlvbiBTdG9yYWdlIChjaHVua0xlbmd0aCwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RvcmFnZSkpIHJldHVybiBuZXcgU3RvcmFnZShjaHVua0xlbmd0aCwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB0aGlzLmNodW5rTGVuZ3RoID0gTnVtYmVyKGNodW5rTGVuZ3RoKVxuICBpZiAoIXRoaXMuY2h1bmtMZW5ndGgpIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNodW5rIGxlbmd0aCcpXG5cbiAgdGhpcy5jaHVua3MgPSBbXVxuICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gIHRoaXMubGVuZ3RoID0gTnVtYmVyKG9wdHMubGVuZ3RoKSB8fCBJbmZpbml0eVxuXG4gIGlmICh0aGlzLmxlbmd0aCAhPT0gSW5maW5pdHkpIHtcbiAgICB0aGlzLmxhc3RDaHVua0xlbmd0aCA9ICh0aGlzLmxlbmd0aCAlIHRoaXMuY2h1bmtMZW5ndGgpIHx8IHRoaXMuY2h1bmtMZW5ndGhcbiAgICB0aGlzLmxhc3RDaHVua0luZGV4ID0gTWF0aC5jZWlsKHRoaXMubGVuZ3RoIC8gdGhpcy5jaHVua0xlbmd0aCkgLSAxXG4gIH1cbn1cblxuU3RvcmFnZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGluZGV4LCBidWYsIGNiKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuIG5leHRUaWNrKGNiLCBuZXcgRXJyb3IoJ1N0b3JhZ2UgaXMgY2xvc2VkJykpXG5cbiAgdmFyIGlzTGFzdENodW5rID0gKGluZGV4ID09PSB0aGlzLmxhc3RDaHVua0luZGV4KVxuICBpZiAoaXNMYXN0Q2h1bmsgJiYgYnVmLmxlbmd0aCAhPT0gdGhpcy5sYXN0Q2h1bmtMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignTGFzdCBjaHVuayBsZW5ndGggbXVzdCBiZSAnICsgdGhpcy5sYXN0Q2h1bmtMZW5ndGgpKVxuICB9XG4gIGlmICghaXNMYXN0Q2h1bmsgJiYgYnVmLmxlbmd0aCAhPT0gdGhpcy5jaHVua0xlbmd0aCkge1xuICAgIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdDaHVuayBsZW5ndGggbXVzdCBiZSAnICsgdGhpcy5jaHVua0xlbmd0aCkpXG4gIH1cbiAgdGhpcy5jaHVua3NbaW5kZXhdID0gYnVmXG4gIG5leHRUaWNrKGNiLCBudWxsKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZ2V0KGluZGV4LCBudWxsLCBvcHRzKVxuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdTdG9yYWdlIGlzIGNsb3NlZCcpKVxuICB2YXIgYnVmID0gdGhpcy5jaHVua3NbaW5kZXhdXG4gIGlmICghYnVmKSByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignQ2h1bmsgbm90IGZvdW5kJykpXG4gIGlmICghb3B0cykgcmV0dXJuIG5leHRUaWNrKGNiLCBudWxsLCBidWYpXG4gIHZhciBvZmZzZXQgPSBvcHRzLm9mZnNldCB8fCAwXG4gIHZhciBsZW4gPSBvcHRzLmxlbmd0aCB8fCAoYnVmLmxlbmd0aCAtIG9mZnNldClcbiAgbmV4dFRpY2soY2IsIG51bGwsIGJ1Zi5zbGljZShvZmZzZXQsIGxlbiArIG9mZnNldCkpXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLmNsb3NlID0gU3RvcmFnZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdTdG9yYWdlIGlzIGNsb3NlZCcpKVxuICB0aGlzLmNsb3NlZCA9IHRydWVcbiAgdGhpcy5jaHVua3MgPSBudWxsXG4gIG5leHRUaWNrKGNiLCBudWxsKVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGVyciwgdmFsKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikgY2IoZXJyLCB2YWwpXG4gIH0pXG59XG4iLCIvLyBUaGlzIGlzIGFuIGludGVudGlvbmFsbHkgcmVjdXJzaXZlIHJlcXVpcmUuIEkgZG9uJ3QgbGlrZSBpdCBlaXRoZXIuXG52YXIgQm94ID0gcmVxdWlyZSgnLi9pbmRleCcpXG52YXIgRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vZGVzY3JpcHRvcicpXG5cbnZhciBUSU1FX09GRlNFVCA9IDIwODI4NDQ4MDAwMDBcblxuLypcblRPRE86XG50ZXN0IHRoZXNlXG5hZGQgbmV3IGJveCB2ZXJzaW9uc1xuKi9cblxuLy8gVGhlc2UgaGF2ZSAndmVyc2lvbicgYW5kICdmbGFncycgZmllbGRzIGluIHRoZSBoZWFkZXJzXG5leHBvcnRzLmZ1bGxCb3hlcyA9IHt9XG52YXIgZnVsbEJveGVzID0gW1xuICAnbXZoZCcsXG4gICd0a2hkJyxcbiAgJ21kaGQnLFxuICAndm1oZCcsXG4gICdzbWhkJyxcbiAgJ3N0c2QnLFxuICAnZXNkcycsXG4gICdzdHN6JyxcbiAgJ3N0Y28nLFxuICAnc3RzcycsXG4gICdzdHRzJyxcbiAgJ2N0dHMnLFxuICAnc3RzYycsXG4gICdkcmVmJyxcbiAgJ2Vsc3QnLFxuICAnaGRscicsXG4gICdtZWhkJyxcbiAgJ3RyZXgnLFxuICAnbWZoZCcsXG4gICd0ZmhkJyxcbiAgJ3RmZHQnLFxuICAndHJ1bidcbl1cbmZ1bGxCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIGV4cG9ydHMuZnVsbEJveGVzW3R5cGVdID0gdHJ1ZVxufSlcblxuZXhwb3J0cy5mdHlwID0ge31cbmV4cG9ydHMuZnR5cC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5mdHlwLmVuY29kaW5nTGVuZ3RoKGJveCkpXG4gIHZhciBicmFuZHMgPSBib3guY29tcGF0aWJsZUJyYW5kcyB8fCBbXVxuICBidWYud3JpdGUoYm94LmJyYW5kLCAwLCA0LCAnYXNjaWknKVxuICBidWYud3JpdGVVSW50MzJCRShib3guYnJhbmRWZXJzaW9uLCA0KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJyYW5kcy5sZW5ndGg7IGkrKykgYnVmLndyaXRlKGJyYW5kc1tpXSwgOCArIChpICogNCksIDQsICdhc2NpaScpXG4gIGV4cG9ydHMuZnR5cC5lbmNvZGUuYnl0ZXMgPSA4ICsgYnJhbmRzLmxlbmd0aCAqIDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5mdHlwLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgYnJhbmQgPSBidWYudG9TdHJpbmcoJ2FzY2lpJywgMCwgNClcbiAgdmFyIHZlcnNpb24gPSBidWYucmVhZFVJbnQzMkJFKDQpXG4gIHZhciBjb21wYXRpYmxlQnJhbmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDg7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIGNvbXBhdGlibGVCcmFuZHMucHVzaChidWYudG9TdHJpbmcoJ2FzY2lpJywgaSwgaSArIDQpKVxuICByZXR1cm4ge1xuICAgIGJyYW5kOiBicmFuZCxcbiAgICBicmFuZFZlcnNpb246IHZlcnNpb24sXG4gICAgY29tcGF0aWJsZUJyYW5kczogY29tcGF0aWJsZUJyYW5kc1xuICB9XG59XG5leHBvcnRzLmZ0eXAuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA4ICsgKGJveC5jb21wYXRpYmxlQnJhbmRzIHx8IFtdKS5sZW5ndGggKiA0XG59XG5cbmV4cG9ydHMubXZoZCA9IHt9XG5leHBvcnRzLm12aGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDk2KVxuICB3cml0ZURhdGUoYm94LmN0aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgMClcbiAgd3JpdGVEYXRlKGJveC5tdGltZSB8fCBuZXcgRGF0ZSgpLCBidWYsIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50aW1lU2NhbGUgfHwgMCwgOClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmR1cmF0aW9uIHx8IDAsIDEyKVxuICB3cml0ZUZpeGVkMzIoYm94LnByZWZlcnJlZFJhdGUgfHwgMCwgYnVmLCAxNilcbiAgd3JpdGVGaXhlZDE2KGJveC5wcmVmZXJyZWRWb2x1bWUgfHwgMCwgYnVmLCAyMClcbiAgd3JpdGVSZXNlcnZlZChidWYsIDIyLCAzMilcbiAgd3JpdGVNYXRyaXgoYm94Lm1hdHJpeCwgYnVmLCAzMilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnByZXZpZXdUaW1lIHx8IDAsIDY4KVxuICBidWYud3JpdGVVSW50MzJCRShib3gucHJldmlld0R1cmF0aW9uIHx8IDAsIDcyKVxuICBidWYud3JpdGVVSW50MzJCRShib3gucG9zdGVyVGltZSB8fCAwLCA3NilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnNlbGVjdGlvblRpbWUgfHwgMCwgODApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zZWxlY3Rpb25EdXJhdGlvbiB8fCAwLCA4NClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmN1cnJlbnRUaW1lIHx8IDAsIDg4KVxuICBidWYud3JpdGVVSW50MzJCRShib3gubmV4dFRyYWNrSWQgfHwgMCwgOTIpXG4gIGV4cG9ydHMubXZoZC5lbmNvZGUuYnl0ZXMgPSA5NlxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm12aGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgY3RpbWU6IHJlYWREYXRlKGJ1ZiwgMCksXG4gICAgbXRpbWU6IHJlYWREYXRlKGJ1ZiwgNCksXG4gICAgdGltZVNjYWxlOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDEyKSxcbiAgICBwcmVmZXJyZWRSYXRlOiByZWFkRml4ZWQzMihidWYsIDE2KSxcbiAgICBwcmVmZXJyZWRWb2x1bWU6IHJlYWRGaXhlZDE2KGJ1ZiwgMjApLFxuICAgIG1hdHJpeDogcmVhZE1hdHJpeChidWYuc2xpY2UoMzIsIDY4KSksXG4gICAgcHJldmlld1RpbWU6IGJ1Zi5yZWFkVUludDMyQkUoNjgpLFxuICAgIHByZXZpZXdEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSg3MiksXG4gICAgcG9zdGVyVGltZTogYnVmLnJlYWRVSW50MzJCRSg3NiksXG4gICAgc2VsZWN0aW9uVGltZTogYnVmLnJlYWRVSW50MzJCRSg4MCksXG4gICAgc2VsZWN0aW9uRHVyYXRpb246IGJ1Zi5yZWFkVUludDMyQkUoODQpLFxuICAgIGN1cnJlbnRUaW1lOiBidWYucmVhZFVJbnQzMkJFKDg4KSxcbiAgICBuZXh0VHJhY2tJZDogYnVmLnJlYWRVSW50MzJCRSg5MilcbiAgfVxufVxuZXhwb3J0cy5tdmhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gOTZcbn1cblxuZXhwb3J0cy50a2hkID0ge31cbmV4cG9ydHMudGtoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoODApXG4gIHdyaXRlRGF0ZShib3guY3RpbWUgfHwgbmV3IERhdGUoKSwgYnVmLCAwKVxuICB3cml0ZURhdGUoYm94Lm10aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgNClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRyYWNrSWQgfHwgMCwgOClcbiAgd3JpdGVSZXNlcnZlZChidWYsIDEyLCAxNilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmR1cmF0aW9uIHx8IDAsIDE2KVxuICB3cml0ZVJlc2VydmVkKGJ1ZiwgMjAsIDI4KVxuICBidWYud3JpdGVVSW50MTZCRShib3gubGF5ZXIgfHwgMCwgMjgpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5hbHRlcm5hdGVHcm91cCB8fCAwLCAzMClcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LnZvbHVtZSB8fCAwLCAzMilcbiAgd3JpdGVNYXRyaXgoYm94Lm1hdHJpeCwgYnVmLCAzNilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRyYWNrV2lkdGggfHwgMCwgNzIpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50cmFja0hlaWdodCB8fCAwLCA3NilcbiAgZXhwb3J0cy50a2hkLmVuY29kZS5ieXRlcyA9IDgwXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMudGtoZC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgcmV0dXJuIHtcbiAgICBjdGltZTogcmVhZERhdGUoYnVmLCAwKSxcbiAgICBtdGltZTogcmVhZERhdGUoYnVmLCA0KSxcbiAgICB0cmFja0lkOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDE2KSxcbiAgICBsYXllcjogYnVmLnJlYWRVSW50MTZCRSgyOCksXG4gICAgYWx0ZXJuYXRlR3JvdXA6IGJ1Zi5yZWFkVUludDE2QkUoMzApLFxuICAgIHZvbHVtZTogYnVmLnJlYWRVSW50MTZCRSgzMiksXG4gICAgbWF0cml4OiByZWFkTWF0cml4KGJ1Zi5zbGljZSgzNiwgNzIpKSxcbiAgICB0cmFja1dpZHRoOiBidWYucmVhZFVJbnQzMkJFKDcyKSxcbiAgICB0cmFja0hlaWdodDogYnVmLnJlYWRVSW50MzJCRSg3NilcbiAgfVxufVxuZXhwb3J0cy50a2hkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gODBcbn1cblxuZXhwb3J0cy5tZGhkID0ge31cbmV4cG9ydHMubWRoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoMjApXG4gIHdyaXRlRGF0ZShib3guY3RpbWUgfHwgbmV3IERhdGUoKSwgYnVmLCAwKVxuICB3cml0ZURhdGUoYm94Lm10aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgNClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRpbWVTY2FsZSB8fCAwLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShib3guZHVyYXRpb24gfHwgMCwgMTIpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5sYW5ndWFnZSB8fCAwLCAxNilcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LnF1YWxpdHkgfHwgMCwgMTgpXG4gIGV4cG9ydHMubWRoZC5lbmNvZGUuYnl0ZXMgPSAyMFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1kaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgY3RpbWU6IHJlYWREYXRlKGJ1ZiwgMCksXG4gICAgbXRpbWU6IHJlYWREYXRlKGJ1ZiwgNCksXG4gICAgdGltZVNjYWxlOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDEyKSxcbiAgICBsYW5ndWFnZTogYnVmLnJlYWRVSW50MTZCRSgxNiksXG4gICAgcXVhbGl0eTogYnVmLnJlYWRVSW50MTZCRSgxOClcbiAgfVxufVxuZXhwb3J0cy5tZGhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gMjBcbn1cblxuZXhwb3J0cy52bWhkID0ge31cbmV4cG9ydHMudm1oZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoOClcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LmdyYXBoaWNzTW9kZSB8fCAwLCAwKVxuICB2YXIgb3Bjb2xvciA9IGJveC5vcGNvbG9yIHx8IFswLCAwLCAwXVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzBdLCAyKVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzFdLCA0KVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzJdLCA2KVxuICBleHBvcnRzLnZtaGQuZW5jb2RlLmJ5dGVzID0gOFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnZtaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgZ3JhcGhpY3NNb2RlOiBidWYucmVhZFVJbnQxNkJFKDApLFxuICAgIG9wY29sb3I6IFtidWYucmVhZFVJbnQxNkJFKDIpLCBidWYucmVhZFVJbnQxNkJFKDQpLCBidWYucmVhZFVJbnQxNkJFKDYpXVxuICB9XG59XG5leHBvcnRzLnZtaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA4XG59XG5cbmV4cG9ydHMuc21oZCA9IHt9XG5leHBvcnRzLnNtaGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDQpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5iYWxhbmNlIHx8IDAsIDApXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAyLCA0KVxuICBleHBvcnRzLnNtaGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnNtaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgYmFsYW5jZTogYnVmLnJlYWRVSW50MTZCRSgwKVxuICB9XG59XG5leHBvcnRzLnNtaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMuc3RzZCA9IHt9XG5leHBvcnRzLnN0c2QuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuc3RzZC5lbmNvZGluZ0xlbmd0aChib3gpKVxuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgdmFyIHB0ciA9IDRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXVxuICAgIEJveC5lbmNvZGUoZW50cnksIGJ1ZiwgcHRyKVxuICAgIHB0ciArPSBCb3guZW5jb2RlLmJ5dGVzXG4gIH1cblxuICBleHBvcnRzLnN0c2QuZW5jb2RlLmJ5dGVzID0gcHRyXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3RzZC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG4gIHZhciBwdHIgPSA0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBlbnRyeSA9IEJveC5kZWNvZGUoYnVmLCBwdHIsIGVuZClcbiAgICBlbnRyaWVzW2ldID0gZW50cnlcbiAgICBwdHIgKz0gZW50cnkubGVuZ3RoXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHNkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICB2YXIgdG90YWxTaXplID0gNFxuICBpZiAoIWJveC5lbnRyaWVzKSByZXR1cm4gdG90YWxTaXplXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm94LmVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbFNpemUgKz0gQm94LmVuY29kaW5nTGVuZ3RoKGJveC5lbnRyaWVzW2ldKVxuICB9XG4gIHJldHVybiB0b3RhbFNpemVcbn1cblxuZXhwb3J0cy5hdmMxID0gZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeSA9IHt9XG5leHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcihleHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgd3JpdGVSZXNlcnZlZChidWYsIDAsIDYpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5kYXRhUmVmZXJlbmNlSW5kZXggfHwgMCwgNilcbiAgd3JpdGVSZXNlcnZlZChidWYsIDgsIDI0KVxuICBidWYud3JpdGVVSW50MTZCRShib3gud2lkdGggfHwgMCwgMjQpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5oZWlnaHQgfHwgMCwgMjYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5oUmVzb2x1dGlvbiB8fCAweDQ4MDAwMCwgMjgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC52UmVzb2x1dGlvbiB8fCAweDQ4MDAwMCwgMzIpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAzNiwgNDApXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5mcmFtZUNvdW50IHx8IDEsIDQwKVxuICB2YXIgY29tcHJlc3Nvck5hbWUgPSBib3guY29tcHJlc3Nvck5hbWUgfHwgJydcbiAgdmFyIG5hbWVMZW4gPSBNYXRoLm1pbihjb21wcmVzc29yTmFtZS5sZW5ndGgsIDMxKVxuICBidWYud3JpdGVVSW50OChuYW1lTGVuLCA0MilcbiAgYnVmLndyaXRlKGNvbXByZXNzb3JOYW1lLCA0MywgbmFtZUxlbiwgJ3V0ZjgnKVxuICBidWYud3JpdGVVSW50MTZCRShib3guZGVwdGggfHwgMHgxOCwgNzQpXG4gIGJ1Zi53cml0ZUludDE2QkUoLTEsIDc2KVxuXG4gIHZhciBwdHIgPSA3OFxuICB2YXIgY2hpbGRyZW4gPSBib3guY2hpbGRyZW4gfHwgW11cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBCb3guZW5jb2RlKGNoaWxkLCBidWYsIHB0cilcbiAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICB9KVxuICBleHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kZS5ieXRlcyA9IHB0clxufVxuZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0XG4gIHZhciBuYW1lTGVuID0gTWF0aC5taW4oYnVmLnJlYWRVSW50OCg0MiksIDMxKVxuICB2YXIgYm94ID0ge1xuICAgIGRhdGFSZWZlcmVuY2VJbmRleDogYnVmLnJlYWRVSW50MTZCRSg2KSxcbiAgICB3aWR0aDogYnVmLnJlYWRVSW50MTZCRSgyNCksXG4gICAgaGVpZ2h0OiBidWYucmVhZFVJbnQxNkJFKDI2KSxcbiAgICBoUmVzb2x1dGlvbjogYnVmLnJlYWRVSW50MzJCRSgyOCksXG4gICAgdlJlc29sdXRpb246IGJ1Zi5yZWFkVUludDMyQkUoMzIpLFxuICAgIGZyYW1lQ291bnQ6IGJ1Zi5yZWFkVUludDE2QkUoNDApLFxuICAgIGNvbXByZXNzb3JOYW1lOiBidWYudG9TdHJpbmcoJ3V0ZjgnLCA0MywgNDMgKyBuYW1lTGVuKSxcbiAgICBkZXB0aDogYnVmLnJlYWRVSW50MTZCRSg3NCksXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cblxuICB2YXIgcHRyID0gNzhcbiAgd2hpbGUgKGxlbmd0aCAtIHB0ciA+PSA4KSB7XG4gICAgdmFyIGNoaWxkID0gQm94LmRlY29kZShidWYsIHB0ciwgbGVuZ3RoKVxuICAgIGJveC5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIGJveFtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgcHRyICs9IGNoaWxkLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIGJveFxufVxuZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgdmFyIGxlbiA9IDc4XG4gIHZhciBjaGlsZHJlbiA9IGJveC5jaGlsZHJlbiB8fCBbXVxuICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGxlbiArPSBCb3guZW5jb2RpbmdMZW5ndGgoY2hpbGQpXG4gIH0pXG4gIHJldHVybiBsZW5cbn1cblxuZXhwb3J0cy5hdmNDID0ge31cbmV4cG9ydHMuYXZjQy5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IEJ1ZmZlcihib3guYnVmZmVyLmxlbmd0aClcblxuICBib3guYnVmZmVyLmNvcHkoYnVmKVxuICBleHBvcnRzLmF2Y0MuZW5jb2RlLmJ5dGVzID0gYm94LmJ1ZmZlci5sZW5ndGhcbn1cbmV4cG9ydHMuYXZjQy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0LCBlbmQpXG5cbiAgcmV0dXJuIHtcbiAgICBtaW1lQ29kZWM6IGJ1Zi50b1N0cmluZygnaGV4JywgMSwgNCksXG4gICAgYnVmZmVyOiBuZXcgQnVmZmVyKGJ1ZilcbiAgfVxufVxuZXhwb3J0cy5hdmNDLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gYm94LmJ1ZmZlci5sZW5ndGhcbn1cblxuZXhwb3J0cy5tcDRhID0gZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5ID0ge31cbmV4cG9ydHMuQXVkaW9TYW1wbGVFbnRyeS5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgd3JpdGVSZXNlcnZlZChidWYsIDAsIDYpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5kYXRhUmVmZXJlbmNlSW5kZXggfHwgMCwgNilcbiAgd3JpdGVSZXNlcnZlZChidWYsIDgsIDE2KVxuICBidWYud3JpdGVVSW50MTZCRShib3guY2hhbm5lbENvdW50IHx8IDIsIDE2KVxuICBidWYud3JpdGVVSW50MTZCRShib3guc2FtcGxlU2l6ZSB8fCAxNiwgMTgpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAyMCwgMjQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zYW1wbGVSYXRlIHx8IDAsIDI0KVxuXG4gIHZhciBwdHIgPSAyOFxuICB2YXIgY2hpbGRyZW4gPSBib3guY2hpbGRyZW4gfHwgW11cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBCb3guZW5jb2RlKGNoaWxkLCBidWYsIHB0cilcbiAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICB9KVxuICBleHBvcnRzLkF1ZGlvU2FtcGxlRW50cnkuZW5jb2RlLmJ5dGVzID0gcHRyXG59XG5leHBvcnRzLkF1ZGlvU2FtcGxlRW50cnkuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldCwgZW5kKVxuICB2YXIgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0XG4gIHZhciBib3ggPSB7XG4gICAgZGF0YVJlZmVyZW5jZUluZGV4OiBidWYucmVhZFVJbnQxNkJFKDYpLFxuICAgIGNoYW5uZWxDb3VudDogYnVmLnJlYWRVSW50MTZCRSgxNiksXG4gICAgc2FtcGxlU2l6ZTogYnVmLnJlYWRVSW50MTZCRSgxOCksXG4gICAgc2FtcGxlUmF0ZTogYnVmLnJlYWRVSW50MzJCRSgyNCksXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cblxuICB2YXIgcHRyID0gMjhcbiAgd2hpbGUgKGxlbmd0aCAtIHB0ciA+PSA4KSB7XG4gICAgdmFyIGNoaWxkID0gQm94LmRlY29kZShidWYsIHB0ciwgbGVuZ3RoKVxuICAgIGJveC5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIGJveFtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgcHRyICs9IGNoaWxkLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIGJveFxufVxuZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICB2YXIgbGVuID0gMjhcbiAgdmFyIGNoaWxkcmVuID0gYm94LmNoaWxkcmVuIHx8IFtdXG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgbGVuICs9IEJveC5lbmNvZGluZ0xlbmd0aChjaGlsZClcbiAgfSlcbiAgcmV0dXJuIGxlblxufVxuXG5leHBvcnRzLmVzZHMgPSB7fVxuZXhwb3J0cy5lc2RzLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogQnVmZmVyKGJveC5idWZmZXIubGVuZ3RoKVxuXG4gIGJveC5idWZmZXIuY29weShidWYsIDApXG4gIGV4cG9ydHMuZXNkcy5lbmNvZGUuYnl0ZXMgPSBib3guYnVmZmVyLmxlbmd0aFxufVxuZXhwb3J0cy5lc2RzLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgZW5kKSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQsIGVuZClcblxuICB2YXIgZGVzYyA9IERlc2NyaXB0b3IuRGVzY3JpcHRvci5kZWNvZGUoYnVmLCAwLCBidWYubGVuZ3RoKVxuICB2YXIgZXNkID0gKGRlc2MudGFnTmFtZSA9PT0gJ0VTRGVzY3JpcHRvcicpID8gZGVzYyA6IHt9XG4gIHZhciBkY2QgPSBlc2QuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IgfHwge31cbiAgdmFyIG90aSA9IGRjZC5vdGkgfHwgMFxuICB2YXIgZHNpID0gZGNkLkRlY29kZXJTcGVjaWZpY0luZm9cbiAgdmFyIGF1ZGlvQ29uZmlnID0gZHNpID8gKGRzaS5idWZmZXIucmVhZFVJbnQ4KDApICYgMHhmOCkgPj4gMyA6IDBcblxuICB2YXIgbWltZUNvZGVjID0gbnVsbFxuICBpZiAob3RpKSB7XG4gICAgbWltZUNvZGVjID0gb3RpLnRvU3RyaW5nKDE2KVxuICAgIGlmIChhdWRpb0NvbmZpZykge1xuICAgICAgbWltZUNvZGVjICs9ICcuJyArIGF1ZGlvQ29uZmlnXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW1lQ29kZWM6IG1pbWVDb2RlYyxcbiAgICBidWZmZXI6IG5ldyBCdWZmZXIoYnVmLnNsaWNlKDApKVxuICB9XG59XG5leHBvcnRzLmVzZHMuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiBib3guYnVmZmVyLmxlbmd0aFxufVxuXG4vLyBUT0RPOiBpbnRlZ3JhdGUgdGhlIHR3byB2ZXJzaW9ucyBpbiBhIHNhbmVyIHdheVxuZXhwb3J0cy5zdHN6ID0ge31cbmV4cG9ydHMuc3Rzei5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogQnVmZmVyKGV4cG9ydHMuc3Rzei5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKDAsIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCA0KVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0sIGkgKiA0ICsgOClcbiAgfVxuXG4gIGV4cG9ydHMuc3Rzei5lbmNvZGUuYnl0ZXMgPSA4ICsgZW50cmllcy5sZW5ndGggKiA0XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3Rzei5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIHNpemUgPSBidWYucmVhZFVJbnQzMkJFKDApXG4gIHZhciBudW0gPSBidWYucmVhZFVJbnQzMkJFKDQpXG4gIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KG51bSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIGVudHJpZXNbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0ICsgOClcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cmllc1tpXSA9IHNpemVcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHN6LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gOCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDRcbn1cblxuZXhwb3J0cy5zdHNzID1cbmV4cG9ydHMuc3RjbyA9IHt9XG5leHBvcnRzLnN0Y28uZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5zdGNvLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXSwgaSAqIDQgKyA0KVxuICB9XG5cbiAgZXhwb3J0cy5zdGNvLmVuY29kZS5ieXRlcyA9IDQgKyBlbnRyaWVzLmxlbmd0aCAqIDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdGNvLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGVudHJpZXNbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50cmllczogZW50cmllc1xuICB9XG59XG5leHBvcnRzLnN0Y28uZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0ICsgYm94LmVudHJpZXMubGVuZ3RoICogNFxufVxuXG5leHBvcnRzLnN0dHMgPSB7fVxuZXhwb3J0cy5zdHRzLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBlbnRyaWVzID0gYm94LmVudHJpZXMgfHwgW11cbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuc3R0cy5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogOCArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmNvdW50IHx8IDAsIHB0cilcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmR1cmF0aW9uIHx8IDAsIHB0ciArIDQpXG4gIH1cblxuICBleHBvcnRzLnN0dHMuZW5jb2RlLmJ5dGVzID0gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDhcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdHRzLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogOCArIDRcbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgY291bnQ6IGJ1Zi5yZWFkVUludDMyQkUocHRyKSxcbiAgICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKHB0ciArIDQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuc3R0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDQgKyBib3guZW50cmllcy5sZW5ndGggKiA4XG59XG5cbmV4cG9ydHMuY3R0cyA9IHt9XG5leHBvcnRzLmN0dHMuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5jdHRzLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiA4ICsgNFxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uY291bnQgfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uY29tcG9zaXRpb25PZmZzZXQgfHwgMCwgcHRyICsgNClcbiAgfVxuXG4gIGV4cG9ydHMuY3R0cy5lbmNvZGUuYnl0ZXMgPSA0ICsgZW50cmllcy5sZW5ndGggKiA4XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuY3R0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgcHRyID0gaSAqIDggKyA0XG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIGNvdW50OiBidWYucmVhZFVJbnQzMkJFKHB0ciksXG4gICAgICBjb21wb3NpdGlvbk9mZnNldDogYnVmLnJlYWRJbnQzMkJFKHB0ciArIDQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuY3R0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDQgKyBib3guZW50cmllcy5sZW5ndGggKiA4XG59XG5cbmV4cG9ydHMuc3RzYyA9IHt9XG5leHBvcnRzLnN0c2MuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5zdHNjLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmZpcnN0Q2h1bmsgfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uc2FtcGxlc1BlckNodW5rIHx8IDAsIHB0ciArIDQpXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXS5zYW1wbGVEZXNjcmlwdGlvbklkIHx8IDAsIHB0ciArIDgpXG4gIH1cblxuICBleHBvcnRzLnN0c2MuZW5jb2RlLmJ5dGVzID0gNCArIGVudHJpZXMubGVuZ3RoICogMTJcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdHNjLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogMTIgKyA0XG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIGZpcnN0Q2h1bms6IGJ1Zi5yZWFkVUludDMyQkUocHRyKSxcbiAgICAgIHNhbXBsZXNQZXJDaHVuazogYnVmLnJlYWRVSW50MzJCRShwdHIgKyA0KSxcbiAgICAgIHNhbXBsZURlc2NyaXB0aW9uSWQ6IGJ1Zi5yZWFkVUludDMyQkUocHRyICsgOClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHNjLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDEyXG59XG5cbmV4cG9ydHMuZHJlZiA9IHt9XG5leHBvcnRzLmRyZWYuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuZHJlZi5lbmNvZGluZ0xlbmd0aChib3gpKVxuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgdmFyIHB0ciA9IDRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXVxuICAgIHZhciBzaXplID0gKGVudHJ5LmJ1ZiA/IGVudHJ5LmJ1Zi5sZW5ndGggOiAwKSArIDQgKyA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShzaXplLCBwdHIpXG4gICAgcHRyICs9IDRcblxuICAgIGJ1Zi53cml0ZShlbnRyeS50eXBlLCBwdHIsIDQsICdhc2NpaScpXG4gICAgcHRyICs9IDRcblxuICAgIGlmIChlbnRyeS5idWYpIHtcbiAgICAgIGVudHJ5LmJ1Zi5jb3B5KGJ1ZiwgcHRyKVxuICAgICAgcHRyICs9IGVudHJ5LmJ1Zi5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmRyZWYuZW5jb2RlLmJ5dGVzID0gcHRyXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuZHJlZi5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuICB2YXIgcHRyID0gNFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgc2l6ZSA9IGJ1Zi5yZWFkVUludDMyQkUocHRyKVxuICAgIHZhciB0eXBlID0gYnVmLnRvU3RyaW5nKCdhc2NpaScsIHB0ciArIDQsIHB0ciArIDgpXG4gICAgdmFyIHRtcCA9IGJ1Zi5zbGljZShwdHIgKyA4LCBwdHIgKyBzaXplKVxuICAgIHB0ciArPSBzaXplXG5cbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGJ1ZjogdG1wXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuZHJlZi5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgdmFyIHRvdGFsU2l6ZSA9IDRcbiAgaWYgKCFib3guZW50cmllcykgcmV0dXJuIHRvdGFsU2l6ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveC5lbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGJveC5lbnRyaWVzW2ldLmJ1ZlxuICAgIHRvdGFsU2l6ZSArPSAoYnVmID8gYnVmLmxlbmd0aCA6IDApICsgNCArIDRcbiAgfVxuICByZXR1cm4gdG90YWxTaXplXG59XG5cbmV4cG9ydHMuZWxzdCA9IHt9XG5leHBvcnRzLmVsc3QuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5lbHN0LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLnRyYWNrRHVyYXRpb24gfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0ubWVkaWFUaW1lIHx8IDAsIHB0ciArIDQpXG4gICAgd3JpdGVGaXhlZDMyKGVudHJpZXNbaV0ubWVkaWFSYXRlIHx8IDAsIGJ1ZiwgcHRyICsgOClcbiAgfVxuXG4gIGV4cG9ydHMuZWxzdC5lbmNvZGUuYnl0ZXMgPSA0ICsgZW50cmllcy5sZW5ndGggKiAxMlxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLmVsc3QuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHZhciBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApXG4gIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KG51bSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgdHJhY2tEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRShwdHIpLFxuICAgICAgbWVkaWFUaW1lOiBidWYucmVhZEludDMyQkUocHRyICsgNCksXG4gICAgICBtZWRpYVJhdGU6IHJlYWRGaXhlZDMyKGJ1ZiwgcHRyICsgOClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5lbHN0LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDEyXG59XG5cbmV4cG9ydHMuaGRsciA9IHt9XG5leHBvcnRzLmhkbHIuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuaGRsci5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIHZhciBsZW4gPSAyMSArIChib3gubmFtZSB8fCAnJykubGVuZ3RoXG4gIGJ1Zi5maWxsKDAsIDAsIGxlbilcblxuICBidWYud3JpdGUoYm94LmhhbmRsZXJUeXBlIHx8ICcnLCA0LCA0LCAnYXNjaWknKVxuICB3cml0ZVN0cmluZyhib3gubmFtZSB8fCAnJywgYnVmLCAyMClcblxuICBleHBvcnRzLmhkbHIuZW5jb2RlLmJ5dGVzID0gbGVuXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuaGRsci5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICByZXR1cm4ge1xuICAgIGhhbmRsZXJUeXBlOiBidWYudG9TdHJpbmcoJ2FzY2lpJywgNCwgOCksXG4gICAgbmFtZTogcmVhZFN0cmluZyhidWYsIDIwLCBlbmQpXG4gIH1cbn1cbmV4cG9ydHMuaGRsci5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDIxICsgKGJveC5uYW1lIHx8ICcnKS5sZW5ndGhcbn1cblxuZXhwb3J0cy5tZWhkID0ge31cbmV4cG9ydHMubWVoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoNClcblxuICBidWYud3JpdGVVSW50MzJCRShib3guZnJhZ21lbnREdXJhdGlvbiB8fCAwLCAwKVxuICBleHBvcnRzLm1laGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1laGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgZnJhZ21lbnREdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSgwKVxuICB9XG59XG5leHBvcnRzLm1laGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudHJleCA9IHt9XG5leHBvcnRzLnRyZXguZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDIwKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50cmFja0lkIHx8IDAsIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleCB8fCAwLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShib3guZGVmYXVsdFNhbXBsZUR1cmF0aW9uIHx8IDAsIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kZWZhdWx0U2FtcGxlU2l6ZSB8fCAwLCAxMilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmRlZmF1bHRTYW1wbGVGbGFncyB8fCAwLCAxNilcbiAgZXhwb3J0cy50cmV4LmVuY29kZS5ieXRlcyA9IDIwXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMudHJleC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgcmV0dXJuIHtcbiAgICB0cmFja0lkOiBidWYucmVhZFVJbnQzMkJFKDApLFxuICAgIGRlZmF1bHRTYW1wbGVEZXNjcmlwdGlvbkluZGV4OiBidWYucmVhZFVJbnQzMkJFKDQpLFxuICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBkZWZhdWx0U2FtcGxlU2l6ZTogYnVmLnJlYWRVSW50MzJCRSgxMiksXG4gICAgZGVmYXVsdFNhbXBsZUZsYWdzOiBidWYucmVhZFVJbnQzMkJFKDE2KVxuICB9XG59XG5leHBvcnRzLnRyZXguZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiAyMFxufVxuXG5leHBvcnRzLm1maGQgPSB7fVxuZXhwb3J0cy5tZmhkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig0KVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zZXF1ZW5jZU51bWJlciB8fCAwLCAwKVxuICBleHBvcnRzLm1maGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1maGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIHJldHVybiB7XG4gICAgc2VxdWVuY2VOdW1iZXI6IGJ1Zi5yZWFkVWludDMyQkUoMClcbiAgfVxufVxuZXhwb3J0cy5tZmhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNFxufVxuXG5leHBvcnRzLnRmaGQgPSB7fVxuZXhwb3J0cy50ZmhkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig0KVxuICBidWYud3JpdGVVSW50MzJCRShib3gudHJhY2tJZCwgMClcbiAgZXhwb3J0cy50ZmhkLmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy50ZmhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAvLyBUT0RPOiB0aGlzXG59XG5leHBvcnRzLnRmaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIC8vIFRPRE86IHRoaXMgaXMgd3JvbmchXG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudGZkdCA9IHt9XG5leHBvcnRzLnRmZHQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDQpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmJhc2VNZWRpYURlY29kZVRpbWUgfHwgMCwgMClcbiAgZXhwb3J0cy50ZmR0LmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy50ZmR0LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAvLyBUT0RPOiB0aGlzXG59XG5leHBvcnRzLnRmZHQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudHJ1biA9IHt9XG5leHBvcnRzLnRydW4uZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDggKyBib3guZW50cmllcy5sZW5ndGggKiAxNilcblxuICAvLyBUT0RPOiB0aGlzIGlzIHdyb25nXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5lbnRyaWVzLmxlbmd0aCwgMClcbiAgYnVmLndyaXRlSW50MzJCRShib3guZGF0YU9mZnNldCwgNClcbiAgdmFyIHB0ciA9IDhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3guZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbnRyeSA9IGJveC5lbnRyaWVzW2ldXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cnkuc2FtcGxlRHVyYXRpb24sIHB0cilcbiAgICBwdHIgKz0gNFxuXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cnkuc2FtcGxlU2l6ZSwgcHRyKVxuICAgIHB0ciArPSA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyeS5zYW1wbGVGbGFncywgcHRyKVxuICAgIHB0ciArPSA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyeS5zYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQsIHB0cilcbiAgICBwdHIgKz0gNFxuICB9XG4gIGV4cG9ydHMudHJ1bi5lbmNvZGUuYnl0ZXMgPSBwdHJcbn1cbmV4cG9ydHMudHJ1bi5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgLy8gVE9ETzogdGhpc1xufVxuZXhwb3J0cy50cnVuLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICAvLyBUT0RPOiB0aGlzIGlzIHdyb25nXG4gIHJldHVybiA4ICsgYm94LmVudHJpZXMubGVuZ3RoICogMTZcbn1cblxuZXhwb3J0cy5tZGF0ID0ge31cbmV4cG9ydHMubWRhdC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBpZiAoYm94LmJ1ZmZlcikge1xuICAgIGJveC5idWZmZXIuY29weShidWYsIG9mZnNldClcbiAgICBleHBvcnRzLm1kYXQuZW5jb2RlLmJ5dGVzID0gYm94LmJ1ZmZlci5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLm1kYXQuZW5jb2RlLmJ5dGVzID0gZXhwb3J0cy5tZGF0LmVuY29kaW5nTGVuZ3RoKGJveClcbiAgfVxufVxuZXhwb3J0cy5tZGF0LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHtcbiAgICBidWZmZXI6IG5ldyBCdWZmZXIoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5leHBvcnRzLm1kYXQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiBib3guYnVmZmVyID8gYm94LmJ1ZmZlci5sZW5ndGggOiBib3guY29udGVudExlbmd0aFxufVxuXG5mdW5jdGlvbiB3cml0ZVJlc2VydmVkIChidWYsIG9mZnNldCwgZW5kKSB7XG4gIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykgYnVmW2ldID0gMFxufVxuXG5mdW5jdGlvbiB3cml0ZURhdGUgKGRhdGUsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1Zi53cml0ZVVJbnQzMkJFKE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpICsgVElNRV9PRkZTRVQpIC8gMTAwMCksIG9mZnNldClcbn1cblxuLy8gVE9ETzogdGhpbmsgc29tZXRoaW5nIGlzIHdyb25nIGhlcmVcbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMiAobnVtLCBidWYsIG9mZnNldCkge1xuICBidWYud3JpdGVVSW50MTZCRShNYXRoLmZsb29yKG51bSkgJSAoMjU2ICogMjU2KSwgb2Zmc2V0KVxuICBidWYud3JpdGVVSW50MTZCRShNYXRoLmZsb29yKG51bSAqIDI1NiAqIDI1NikgJSAoMjU2ICogMjU2KSwgb2Zmc2V0ICsgMilcbn1cblxuZnVuY3Rpb24gd3JpdGVGaXhlZDE2IChudW0sIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZltvZmZzZXRdID0gTWF0aC5mbG9vcihudW0pICUgMjU2XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IE1hdGguZmxvb3IobnVtICogMjU2KSAlIDI1NlxufVxuXG5mdW5jdGlvbiB3cml0ZU1hdHJpeCAobGlzdCwgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKCFsaXN0KSBsaXN0ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlRml4ZWQzMihsaXN0W2ldLCBidWYsIG9mZnNldCArIGkgKiA0KVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nIChzdHIsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBzdHJCdWZmZXIgPSBuZXcgQnVmZmVyKHN0ciwgJ3V0ZjgnKVxuICBzdHJCdWZmZXIuY29weShidWYsIG9mZnNldClcbiAgYnVmW29mZnNldCArIHN0ckJ1ZmZlci5sZW5ndGhdID0gMFxufVxuXG5mdW5jdGlvbiByZWFkTWF0cml4IChidWYpIHtcbiAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoYnVmLmxlbmd0aCAvIDQpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgbGlzdFtpXSA9IHJlYWRGaXhlZDMyKGJ1ZiwgaSAqIDQpXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHJlYWREYXRlIChidWYsIG9mZnNldCkge1xuICByZXR1cm4gbmV3IERhdGUoYnVmLnJlYWRVSW50MzJCRShvZmZzZXQpICogMTAwMCAtIFRJTUVfT0ZGU0VUKVxufVxuXG5mdW5jdGlvbiByZWFkRml4ZWQzMiAoYnVmLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0KSArIGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0ICsgMikgLyAoMjU2ICogMjU2KVxufVxuXG5mdW5jdGlvbiByZWFkRml4ZWQxNiAoYnVmLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1ZltvZmZzZXRdICsgYnVmW29mZnNldCArIDFdIC8gMjU2XG59XG5cbmZ1bmN0aW9uIHJlYWRTdHJpbmcgKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltvZmZzZXQgKyBpXSA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIG9mZnNldCwgb2Zmc2V0ICsgaSlcbn1cbiIsInZhciB0YWdUb05hbWUgPSB7XG4gIDB4MDM6ICdFU0Rlc2NyaXB0b3InLFxuICAweDA0OiAnRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3InLFxuICAweDA1OiAnRGVjb2RlclNwZWNpZmljSW5mbycsXG4gIDB4MDY6ICdTTENvbmZpZ0Rlc2NyaXB0b3InXG59XG5cbmV4cG9ydHMuRGVzY3JpcHRvciA9IHt9XG5leHBvcnRzLkRlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgdGFnID0gYnVmLnJlYWRVSW50OChzdGFydClcbiAgdmFyIHB0ciA9IHN0YXJ0ICsgMVxuICB2YXIgbGVuQnl0ZVxuICB2YXIgbGVuID0gMFxuICBkbyB7XG4gICAgbGVuQnl0ZSA9IGJ1Zi5yZWFkVUludDgocHRyKyspXG4gICAgbGVuID0gKGxlbiA8PCA3KSB8IChsZW5CeXRlICYgMHg3ZilcbiAgfSB3aGlsZSAobGVuQnl0ZSAmIDB4ODApXG5cbiAgdmFyIG9ialxuICB2YXIgdGFnTmFtZSA9IHRhZ1RvTmFtZVt0YWddIC8vIE1heSBiZSB1bmRlZmluZWQ7IHRoYXQncyBva1xuICBpZiAoZXhwb3J0c1t0YWdOYW1lXSkge1xuICAgIG9iaiA9IGV4cG9ydHNbdGFnTmFtZV0uZGVjb2RlKGJ1ZiwgcHRyLCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgb2JqID0ge1xuICAgICAgYnVmZmVyOiBuZXcgQnVmZmVyKGJ1Zi5zbGljZShwdHIsIHB0ciArIGxlbikpXG4gICAgfVxuICB9XG5cbiAgb2JqLnRhZyA9IHRhZ1xuICBvYmoudGFnTmFtZSA9IHRhZ05hbWVcbiAgb2JqLmxlbmd0aCA9IChwdHIgLSBzdGFydCkgKyBsZW5cbiAgb2JqLmNvbnRlbnRzTGVuID0gbGVuXG4gIHJldHVybiBvYmpcbn1cblxuZXhwb3J0cy5EZXNjcmlwdG9yQXJyYXkgPSB7fVxuZXhwb3J0cy5EZXNjcmlwdG9yQXJyYXkuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcHRyID0gc3RhcnRcbiAgdmFyIG9iaiA9IHt9XG4gIHdoaWxlIChwdHIgKyAyIDw9IGVuZCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yLmRlY29kZShidWYsIHB0ciwgZW5kKVxuICAgIHB0ciArPSBkZXNjcmlwdG9yLmxlbmd0aFxuICAgIHZhciB0YWdOYW1lID0gdGFnVG9OYW1lW2Rlc2NyaXB0b3IudGFnXSB8fCAoJ0Rlc2NyaXB0b3InICsgZGVzY3JpcHRvci50YWcpXG4gICAgb2JqW3RhZ05hbWVdID0gZGVzY3JpcHRvclxuICB9XG4gIHJldHVybiBvYmpcbn1cblxuZXhwb3J0cy5FU0Rlc2NyaXB0b3IgPSB7fVxuZXhwb3J0cy5FU0Rlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgZmxhZ3MgPSBidWYucmVhZFVJbnQ4KHN0YXJ0ICsgMilcbiAgdmFyIHB0ciA9IHN0YXJ0ICsgM1xuICBpZiAoZmxhZ3MgJiAweDgwKSB7XG4gICAgcHRyICs9IDJcbiAgfVxuICBpZiAoZmxhZ3MgJiAweDQwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5yZWFkVUludDgocHRyKVxuICAgIHB0ciArPSBsZW4gKyAxXG4gIH1cbiAgaWYgKGZsYWdzICYgMHgyMCkge1xuICAgIHB0ciArPSAyXG4gIH1cbiAgcmV0dXJuIGV4cG9ydHMuRGVzY3JpcHRvckFycmF5LmRlY29kZShidWYsIHB0ciwgZW5kKVxufVxuXG5leHBvcnRzLkRlY29kZXJDb25maWdEZXNjcmlwdG9yID0ge31cbmV4cG9ydHMuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgb3RpID0gYnVmLnJlYWRVSW50OChzdGFydClcbiAgdmFyIG9iaiA9IGV4cG9ydHMuRGVzY3JpcHRvckFycmF5LmRlY29kZShidWYsIHN0YXJ0ICsgMTMsIGVuZClcbiAgb2JqLm90aSA9IG90aVxuICByZXR1cm4gb2JqXG59XG4iLCIvLyB2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciB1aW50NjRiZSA9IHJlcXVpcmUoJ3VpbnQ2NGJlJylcblxudmFyIGJveGVzID0gcmVxdWlyZSgnLi9ib3hlcycpXG5cbnZhciBVSU5UMzJfTUFYID0gNDI5NDk2NzI5NVxuXG52YXIgQm94ID0gZXhwb3J0c1xuXG4vKlxuICogTGlzdHMgdGhlIHByb3BlciBvcmRlciBmb3IgYm94ZXMgaW5zaWRlIGNvbnRhaW5lcnMuXG4gKiBGaXZlLWNoYXJhY3RlciBuYW1lcyBlbmRpbmcgaW4gJ3MnIGluZGljYXRlIGFycmF5cyBpbnN0ZWFkIG9mIHNpbmdsZSBlbGVtZW50cy5cbiAqL1xudmFyIGNvbnRhaW5lcnMgPSBleHBvcnRzLmNvbnRhaW5lcnMgPSB7XG4gICdtb292JzogWydtdmhkJywgJ21ldGEnLCAndHJha3MnLCAnbXZleCddLFxuICAndHJhayc6IFsndGtoZCcsICd0cmVmJywgJ3RyZ3InLCAnZWR0cycsICdtZXRhJywgJ21kaWEnLCAndWR0YSddLFxuICAnZWR0cyc6IFsnZWxzdCddLFxuICAnbWRpYSc6IFsnbWRoZCcsICdoZGxyJywgJ2VsbmcnLCAnbWluZiddLFxuICAnbWluZic6IFsndm1oZCcsICdzbWhkJywgJ2htaGQnLCAnc3RoZCcsICdubWhkJywgJ2RpbmYnLCAnc3RibCddLFxuICAnZGluZic6IFsnZHJlZiddLFxuICAnc3RibCc6IFsnc3RzZCcsICdzdHRzJywgJ2N0dHMnLCAnY3NsZycsICdzdHNjJywgJ3N0c3onLCAnc3R6MicsICdzdGNvJywgJ2NvNjQnLCAnc3RzcycsICdzdHNoJywgJ3BhZGInLCAnc3RkcCcsICdzZHRwJywgJ3NiZ3BzJywgJ3NncGRzJywgJ3N1YnNzJywgJ3NhaXpzJywgJ3NhaW9zJ10sXG4gICdtdmV4JzogWydtZWhkJywgJ3RyZXhzJywgJ2xldmEnXSxcbiAgJ21vb2YnOiBbJ21maGQnLCAnbWV0YScsICd0cmFmcyddLFxuICAndHJhZic6IFsndGZoZCcsICd0cnVuJywgJ3NiZ3BzJywgJ3NncGRzJywgJ3N1YnNzJywgJ3NhaXpzJywgJ3NhaW9zJywgJ3RmZHQnLCAnbWV0YSddXG59XG5cbkJveC5lbmNvZGUgPSBmdW5jdGlvbiAob2JqLCBidWZmZXIsIG9mZnNldCkge1xuICBCb3guZW5jb2RpbmdMZW5ndGgob2JqKSAvLyBzZXRzIGV2ZXJ5IGxldmVsIGFwcHJvcHJpYXRlbHlcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBCdWZmZXIob2JqLmxlbmd0aClcbiAgcmV0dXJuIEJveC5fZW5jb2RlKG9iaiwgYnVmZmVyLCBvZmZzZXQpXG59XG5cbkJveC5fZW5jb2RlID0gZnVuY3Rpb24gKG9iaiwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgdmFyIHR5cGUgPSBvYmoudHlwZVxuICB2YXIgbGVuID0gb2JqLmxlbmd0aFxuICBpZiAobGVuID4gVUlOVDMyX01BWCkge1xuICAgIGxlbiA9IDFcbiAgfVxuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldClcbiAgYnVmZmVyLndyaXRlKG9iai50eXBlLCBvZmZzZXQgKyA0LCA0LCAnYXNjaWknKVxuICB2YXIgcHRyID0gb2Zmc2V0ICsgOFxuICBpZiAobGVuID09PSAxKSB7XG4gICAgdWludDY0YmUuZW5jb2RlKG9iai5sZW5ndGgsIGJ1ZmZlciwgcHRyKVxuICAgIHB0ciArPSA4XG4gIH1cbiAgaWYgKGJveGVzLmZ1bGxCb3hlc1t0eXBlXSkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9iai5mbGFncyB8fCAwLCBwdHIpXG4gICAgYnVmZmVyLndyaXRlVUludDgob2JqLnZlcnNpb24gfHwgMCwgcHRyKVxuICAgIHB0ciArPSA0XG4gIH1cblxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIHZhciBjb250ZW50cyA9IGNvbnRhaW5lcnNbdHlwZV1cbiAgICBjb250ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFR5cGUpIHtcbiAgICAgIGlmIChjaGlsZFR5cGUubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGNoaWxkVHlwZSA9IGNoaWxkVHlwZS5zdWJzdHIoMCwgNClcbiAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBCb3guX2VuY29kZShjaGlsZCwgYnVmZmVyLCBwdHIpXG4gICAgICAgICAgcHRyICs9IEJveC5lbmNvZGUuYnl0ZXNcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAob2JqW2NoaWxkVHlwZV0pIHtcbiAgICAgICAgQm94Ll9lbmNvZGUob2JqW2NoaWxkVHlwZV0sIGJ1ZmZlciwgcHRyKVxuICAgICAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKG9iai5vdGhlckJveGVzKSB7XG4gICAgICBvYmoub3RoZXJCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBCb3guX2VuY29kZShjaGlsZCwgYnVmZmVyLCBwdHIpXG4gICAgICAgIHB0ciArPSBCb3guZW5jb2RlLmJ5dGVzXG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIGlmIChib3hlc1t0eXBlXSkge1xuICAgIHZhciBlbmNvZGUgPSBib3hlc1t0eXBlXS5lbmNvZGVcbiAgICBlbmNvZGUob2JqLCBidWZmZXIsIHB0cilcbiAgICBwdHIgKz0gZW5jb2RlLmJ5dGVzXG4gIH0gZWxzZSBpZiAob2JqLmJ1ZmZlcikge1xuICAgIHZhciBidWYgPSBvYmouYnVmZmVyXG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwdHIpXG4gICAgcHRyICs9IG9iai5idWZmZXIubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgYHR5cGVgIG11c3QgYmUgc2V0IHRvIGEga25vd24gdHlwZSAobm90XFwnJyArIHR5cGUgKyAnXFwnKSBvciBgYnVmZmVyYCBtdXN0IGJlIHNldCcpXG4gIH1cblxuICBCb3guZW5jb2RlLmJ5dGVzID0gcHRyIC0gb2Zmc2V0XG4gIC8vIGFzc2VydC5lcXVhbChwdHIgLSBvZmZzZXQsIG9iai5sZW5ndGgsICdFcnJvciBlbmNvZGluZyBcXCcnICsgdHlwZSArICdcXCc6IHdyb3RlICcgKyBwdHIgLSBvZmZzZXQgKyAnIGJ5dGVzLCBleHBlY3RpbmcgJyArIG9iai5sZW5ndGgpXG4gIHJldHVybiBidWZmZXJcbn1cblxuLypcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHR5cGVgIGFuZCBgc2l6ZWAgZmllbGRzLFxuICogb3IgaWYgdGhlcmUgaXNuJ3QgZW5vdWdoIGRhdGEsIHJldHVybnMgdGhlIHRvdGFsXG4gKiBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIHJlYWQgdGhlIGhlYWRlcnNcbiAqL1xuQm94LnJlYWRIZWFkZXJzID0gZnVuY3Rpb24gKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgZW5kID0gZW5kIHx8IGJ1ZmZlci5sZW5ndGhcbiAgaWYgKGVuZCAtIHN0YXJ0IDwgOCkge1xuICAgIHJldHVybiA4XG4gIH1cblxuICB2YXIgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShzdGFydClcbiAgdmFyIHR5cGUgPSBidWZmZXIudG9TdHJpbmcoJ2FzY2lpJywgc3RhcnQgKyA0LCBzdGFydCArIDgpXG4gIHZhciBwdHIgPSBzdGFydCArIDhcblxuICBpZiAobGVuID09PSAxKSB7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDwgMTYpIHtcbiAgICAgIHJldHVybiAxNlxuICAgIH1cblxuICAgIGxlbiA9IHVpbnQ2NGJlLmRlY29kZShidWZmZXIsIHB0cilcbiAgICBwdHIgKz0gOFxuICB9XG5cbiAgdmFyIHZlcnNpb25cbiAgdmFyIGZsYWdzXG4gIGlmIChib3hlcy5mdWxsQm94ZXNbdHlwZV0pIHtcbiAgICB2ZXJzaW9uID0gYnVmZmVyLnJlYWRVSW50OChwdHIpXG4gICAgZmxhZ3MgPSBidWZmZXIucmVhZFVJbnQzMkJFKHB0cikgJiAweGZmZmZmZlxuICAgIHB0ciArPSA0XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogbGVuLFxuICAgIGhlYWRlcnNMZW46IHB0ciAtIHN0YXJ0LFxuICAgIGNvbnRlbnRMZW46IGxlbiAtIChwdHIgLSBzdGFydCksXG4gICAgdHlwZTogdHlwZSxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGZsYWdzOiBmbGFnc1xuICB9XG59XG5cbkJveC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBlbmQgPSBlbmQgfHwgYnVmZmVyLmxlbmd0aFxuICB2YXIgaGVhZGVycyA9IEJveC5yZWFkSGVhZGVycyhidWZmZXIsIHN0YXJ0LCBlbmQpXG4gIGlmICghaGVhZGVycyB8fCBoZWFkZXJzLmxlbmd0aCA+IGVuZCAtIHN0YXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIHRvbyBzaG9ydCcpXG4gIH1cblxuICByZXR1cm4gQm94LmRlY29kZVdpdGhvdXRIZWFkZXJzKGhlYWRlcnMsIGJ1ZmZlciwgc3RhcnQgKyBoZWFkZXJzLmhlYWRlcnNMZW4sIHN0YXJ0ICsgaGVhZGVycy5sZW5ndGgpXG59XG5cbkJveC5kZWNvZGVXaXRob3V0SGVhZGVycyA9IGZ1bmN0aW9uIChoZWFkZXJzLCBidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IGVuZCB8fCBidWZmZXIubGVuZ3RoXG4gIHZhciB0eXBlID0gaGVhZGVycy50eXBlXG4gIHZhciBvYmogPSB7fVxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIG9iai5vdGhlckJveGVzID0gW11cbiAgICB2YXIgY29udGVudHMgPSBjb250YWluZXJzW3R5cGVdXG4gICAgdmFyIHB0ciA9IHN0YXJ0XG4gICAgd2hpbGUgKGVuZCAtIHB0ciA+PSA4KSB7XG4gICAgICB2YXIgY2hpbGQgPSBCb3guZGVjb2RlKGJ1ZmZlciwgcHRyLCBlbmQpXG4gICAgICBwdHIgKz0gY2hpbGQubGVuZ3RoXG4gICAgICBpZiAoY29udGVudHMuaW5kZXhPZihjaGlsZC50eXBlKSA+PSAwKSB7XG4gICAgICAgIG9ialtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnRzLmluZGV4T2YoY2hpbGQudHlwZSArICdzJykgPj0gMCkge1xuICAgICAgICB2YXIgY2hpbGRUeXBlID0gY2hpbGQudHlwZSArICdzJ1xuICAgICAgICB2YXIgZW50cnkgPSBvYmpbY2hpbGRUeXBlXSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGVudHJ5LnB1c2goY2hpbGQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmoub3RoZXJCb3hlcy5wdXNoKGNoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChib3hlc1t0eXBlXSkge1xuICAgIHZhciBkZWNvZGUgPSBib3hlc1t0eXBlXS5kZWNvZGVcbiAgICBvYmogPSBkZWNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIG9iai5idWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxuXG4gIG9iai5sZW5ndGggPSBoZWFkZXJzLmxlbmd0aFxuICBvYmouY29udGVudExlbiA9IGhlYWRlcnMuY29udGVudExlblxuICBvYmoudHlwZSA9IGhlYWRlcnMudHlwZVxuICBvYmoudmVyc2lvbiA9IGhlYWRlcnMudmVyc2lvblxuICBvYmouZmxhZ3MgPSBoZWFkZXJzLmZsYWdzXG4gIHJldHVybiBvYmpcbn1cblxuQm94LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgdHlwZSA9IG9iai50eXBlXG5cbiAgdmFyIGxlbiA9IDhcbiAgaWYgKGJveGVzLmZ1bGxCb3hlc1t0eXBlXSkge1xuICAgIGxlbiArPSA0XG4gIH1cblxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIHZhciBjb250ZW50cyA9IGNvbnRhaW5lcnNbdHlwZV1cbiAgICBjb250ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFR5cGUpIHtcbiAgICAgIGlmIChjaGlsZFR5cGUubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGNoaWxkVHlwZSA9IGNoaWxkVHlwZS5zdWJzdHIoMCwgNClcbiAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBjaGlsZC50eXBlID0gY2hpbGRUeXBlXG4gICAgICAgICAgbGVuICs9IEJveC5lbmNvZGluZ0xlbmd0aChjaGlsZClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAob2JqW2NoaWxkVHlwZV0pIHtcbiAgICAgICAgdmFyIGNoaWxkID0gb2JqW2NoaWxkVHlwZV1cbiAgICAgICAgY2hpbGQudHlwZSA9IGNoaWxkVHlwZVxuICAgICAgICBsZW4gKz0gQm94LmVuY29kaW5nTGVuZ3RoKGNoaWxkKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKG9iai5vdGhlckJveGVzKSB7XG4gICAgICBvYmoub3RoZXJCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBsZW4gKz0gQm94LmVuY29kaW5nTGVuZ3RoKGNoaWxkKVxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm94ZXNbdHlwZV0pIHtcbiAgICBsZW4gKz0gYm94ZXNbdHlwZV0uZW5jb2RpbmdMZW5ndGgob2JqKVxuICB9IGVsc2UgaWYgKG9iai5idWZmZXIpIHtcbiAgICBsZW4gKz0gb2JqLmJ1ZmZlci5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBgdHlwZWAgbXVzdCBiZSBzZXQgdG8gYSBrbm93biB0eXBlIChub3RcXCcnICsgdHlwZSArICdcXCcpIG9yIGBidWZmZXJgIG11c3QgYmUgc2V0JylcbiAgfVxuXG4gIGlmIChsZW4gPiBVSU5UMzJfTUFYKSB7XG4gICAgbGVuICs9IDhcbiAgfVxuXG4gIG9iai5sZW5ndGggPSBsZW5cbiAgcmV0dXJuIGxlblxufVxuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbmV4dEV2ZW50ID0gcmVxdWlyZSgnbmV4dC1ldmVudCcpXG52YXIgQm94ID0gcmVxdWlyZSgnbXA0LWJveC1lbmNvZGluZycpXG5cbnZhciBFTVBUWSA9IG5ldyBCdWZmZXIoMClcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvZGVyXG5cbmZ1bmN0aW9uIERlY29kZXIgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVjb2RlcikpIHJldHVybiBuZXcgRGVjb2RlcigpXG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIHRoaXMuX3BlbmRpbmcgPSAwXG4gIHRoaXMuX21pc3NpbmcgPSAwXG4gIHRoaXMuX2J1ZiA9IG51bGxcbiAgdGhpcy5fc3RyID0gbnVsbFxuICB0aGlzLl9jYiA9IG51bGxcbiAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgdGhpcy5fd3JpdGVCdWZmZXIgPSBudWxsXG4gIHRoaXMuX3dyaXRlQ2IgPSBudWxsXG5cbiAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgdGhpcy5fa2ljaygpXG59XG5cbmluaGVyaXRzKERlY29kZXIsIHN0cmVhbS5Xcml0YWJsZSlcblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jLCBuZXh0KSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBkcmFpbmVkID0gIXRoaXMuX3N0ciB8fCAhdGhpcy5fc3RyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpblxuXG4gIHdoaWxlIChkYXRhLmxlbmd0aCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAoIXRoaXMuX21pc3NpbmcpIHtcbiAgICAgIHRoaXMuX3dyaXRlQnVmZmVyID0gZGF0YVxuICAgICAgdGhpcy5fd3JpdGVDYiA9IG5leHRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjb25zdW1lZCA9IGRhdGEubGVuZ3RoIDwgdGhpcy5fbWlzc2luZyA/IGRhdGEubGVuZ3RoIDogdGhpcy5fbWlzc2luZ1xuICAgIGlmICh0aGlzLl9idWYpIGRhdGEuY29weSh0aGlzLl9idWYsIHRoaXMuX2J1Zi5sZW5ndGggLSB0aGlzLl9taXNzaW5nKVxuICAgIGVsc2UgaWYgKHRoaXMuX3N0cikgZHJhaW5lZCA9IHRoaXMuX3N0ci53cml0ZShjb25zdW1lZCA9PT0gZGF0YS5sZW5ndGggPyBkYXRhIDogZGF0YS5zbGljZSgwLCBjb25zdW1lZCkpXG5cbiAgICB0aGlzLl9taXNzaW5nIC09IGNvbnN1bWVkXG5cbiAgICBpZiAoIXRoaXMuX21pc3NpbmcpIHtcbiAgICAgIHZhciBidWYgPSB0aGlzLl9idWZcbiAgICAgIHZhciBjYiA9IHRoaXMuX2NiXG4gICAgICB2YXIgc3RyZWFtID0gdGhpcy5fc3RyXG5cbiAgICAgIHRoaXMuX2J1ZiA9IHRoaXMuX2NiID0gdGhpcy5fc3RyID0gdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgICAgIGRyYWluZWQgPSB0cnVlXG5cbiAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS5lbmQoKVxuICAgICAgaWYgKGNiKSBjYihidWYpXG4gICAgfVxuXG4gICAgZGF0YSA9IGNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCA/IEVNUFRZIDogZGF0YS5zbGljZShjb25zdW1lZClcbiAgfVxuXG4gIGlmICh0aGlzLl9wZW5kaW5nICYmICF0aGlzLl9taXNzaW5nKSB7XG4gICAgdGhpcy5fd3JpdGVCdWZmZXIgPSBkYXRhXG4gICAgdGhpcy5fd3JpdGVDYiA9IG5leHRcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChkcmFpbmVkKSBuZXh0KClcbiAgZWxzZSB0aGlzLl9vbmRyYWluKG5leHQpXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9idWZmZXIgPSBmdW5jdGlvbiAoc2l6ZSwgY2IpIHtcbiAgdGhpcy5fbWlzc2luZyA9IHNpemVcbiAgdGhpcy5fYnVmID0gbmV3IEJ1ZmZlcihzaXplKVxuICB0aGlzLl9jYiA9IGNiXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9zdHJlYW0gPSBmdW5jdGlvbiAoc2l6ZSwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX21pc3NpbmcgPSBzaXplXG4gIHRoaXMuX3N0ciA9IG5ldyBNZWRpYURhdGEodGhpcylcbiAgdGhpcy5fb25kcmFpbiA9IG5leHRFdmVudCh0aGlzLl9zdHIsICdkcmFpbicpXG4gIHRoaXMuX3BlbmRpbmcrK1xuICB0aGlzLl9zdHIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9wZW5kaW5nLS1cbiAgICBzZWxmLl9raWNrKClcbiAgfSlcbiAgdGhpcy5fY2IgPSBjYlxuICByZXR1cm4gdGhpcy5fc3RyXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9yZWFkQm94ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgYnVmZmVySGVhZGVycyg4KVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckhlYWRlcnMgKGxlbiwgYnVmKSB7XG4gICAgc2VsZi5fYnVmZmVyKGxlbiwgZnVuY3Rpb24gKGFkZGl0aW9uYWxCdWYpIHtcbiAgICAgIGlmIChidWYpIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChidWYsIGFkZGl0aW9uYWxCdWYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBhZGRpdGlvbmFsQnVmXG4gICAgICB9XG4gICAgICB2YXIgaGVhZGVycyA9IEJveC5yZWFkSGVhZGVycyhidWYpXG4gICAgICBpZiAodHlwZW9mIGhlYWRlcnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ1ZmZlckhlYWRlcnMoaGVhZGVycyAtIGJ1Zi5sZW5ndGgsIGJ1ZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3BlbmRpbmcrK1xuICAgICAgICBzZWxmLl9oZWFkZXJzID0gaGVhZGVyc1xuICAgICAgICBzZWxmLmVtaXQoJ2JveCcsIGhlYWRlcnMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuX2hlYWRlcnMpIHRocm93IG5ldyBFcnJvcigndGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgb25jZSBhZnRlciBcXCdib3hcXCcgaXMgZW1pdHRlZCcpXG4gIHZhciBoZWFkZXJzID0gc2VsZi5faGVhZGVyc1xuICBzZWxmLl9oZWFkZXJzID0gbnVsbFxuXG4gIHJldHVybiBzZWxmLl9zdHJlYW0oaGVhZGVycy5jb250ZW50TGVuLCBudWxsKVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5faGVhZGVycykgdGhyb3cgbmV3IEVycm9yKCd0aGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlIGFmdGVyIFxcJ2JveFxcJyBpcyBlbWl0dGVkJylcbiAgdmFyIGhlYWRlcnMgPSBzZWxmLl9oZWFkZXJzXG4gIHNlbGYuX2hlYWRlcnMgPSBudWxsXG5cbiAgc2VsZi5fYnVmZmVyKGhlYWRlcnMuY29udGVudExlbiwgZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBib3ggPSBCb3guZGVjb2RlV2l0aG91dEhlYWRlcnMoaGVhZGVycywgYnVmKVxuICAgIGNiKGJveClcbiAgICBzZWxmLl9wZW5kaW5nLS1cbiAgICBzZWxmLl9raWNrKClcbiAgfSlcbn1cblxuRGVjb2Rlci5wcm90b3R5cGUuaWdub3JlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl9oZWFkZXJzKSB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UgYWZ0ZXIgXFwnYm94XFwnIGlzIGVtaXR0ZWQnKVxuICB2YXIgaGVhZGVycyA9IHNlbGYuX2hlYWRlcnNcbiAgc2VsZi5faGVhZGVycyA9IG51bGxcblxuICB0aGlzLl9taXNzaW5nID0gaGVhZGVycy5jb250ZW50TGVuXG4gIHRoaXMuX2NiID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3BlbmRpbmctLVxuICAgIHNlbGYuX2tpY2soKVxuICB9XG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9raWNrID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcGVuZGluZykgcmV0dXJuXG4gIGlmICghdGhpcy5fYnVmICYmICF0aGlzLl9zdHIpIHRoaXMuX3JlYWRCb3goKVxuICBpZiAodGhpcy5fd3JpdGVCdWZmZXIpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX3dyaXRlQ2JcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fd3JpdGVCdWZmZXJcbiAgICB0aGlzLl93cml0ZUJ1ZmZlciA9IG51bGxcbiAgICB0aGlzLl93cml0ZUNiID0gbnVsbFxuICAgIHRoaXMuX3dyaXRlKGJ1ZmZlciwgbnVsbCwgbmV4dClcbiAgfVxufVxuXG5mdW5jdGlvbiBNZWRpYURhdGEgKHBhcmVudCkge1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICBzdHJlYW0uUGFzc1Rocm91Z2guY2FsbCh0aGlzKVxufVxuXG5pbmhlcml0cyhNZWRpYURhdGEsIHN0cmVhbS5QYXNzVGhyb3VnaClcblxuTWVkaWFEYXRhLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgdGhpcy5fcGFyZW50LmRlc3Ryb3koZXJyKVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEJveCA9IHJlcXVpcmUoJ21wNC1ib3gtZW5jb2RpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuY29kZXJcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBFbmNvZGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVuY29kZXIpKSByZXR1cm4gbmV3IEVuY29kZXIoKVxuICBzdHJlYW0uUmVhZGFibGUuY2FsbCh0aGlzKVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICB0aGlzLl9yZWFkaW5nID0gZmFsc2VcbiAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICB0aGlzLl9kcmFpbiA9IG51bGxcbiAgdGhpcy5fd2FudCA9IGZhbHNlXG4gIHRoaXMuX29ucmVhZGFibGUgPSBvbnJlYWRhYmxlXG4gIHRoaXMuX29uZW5kID0gb25lbmRcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBvbnJlYWRhYmxlICgpIHtcbiAgICBpZiAoIXNlbGYuX3dhbnQpIHJldHVyblxuICAgIHNlbGYuX3dhbnQgPSBmYWxzZVxuICAgIHNlbGYuX3JlYWQoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQgKCkge1xuICAgIHNlbGYuX3N0cmVhbSA9IG51bGxcbiAgfVxufVxuXG5pbmhlcml0cyhFbmNvZGVyLCBzdHJlYW0uUmVhZGFibGUpXG5cbkVuY29kZXIucHJvdG90eXBlLm1lZGlhRGF0YSA9XG5FbmNvZGVyLnByb3RvdHlwZS5tZGF0ID0gZnVuY3Rpb24gKHNpemUsIGNiKSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgTWVkaWFEYXRhKHRoaXMpXG4gIHRoaXMuYm94KHt0eXBlOiAnbWRhdCcsIGNvbnRlbnRMZW5ndGg6IHNpemUsIGVuY29kZUJ1ZmZlckxlbjogOCwgc3RyZWFtOiBzdHJlYW19LCBjYilcbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5FbmNvZGVyLnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbiAoYm94LCBjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gY2IobmV3IEVycm9yKCdFbmNvZGVyIGlzIGRlc3Ryb3llZCcpKVxuXG4gIHZhciBidWZcbiAgaWYgKGJveC5lbmNvZGVCdWZmZXJMZW4pIHtcbiAgICBidWYgPSBuZXcgQnVmZmVyKGJveC5lbmNvZGVCdWZmZXJMZW4pXG4gIH1cbiAgaWYgKGJveC5zdHJlYW0pIHtcbiAgICBib3guYnVmZmVyID0gbnVsbFxuICAgIGJ1ZiA9IEJveC5lbmNvZGUoYm94LCBidWYpXG4gICAgdGhpcy5wdXNoKGJ1ZilcbiAgICB0aGlzLl9zdHJlYW0gPSBib3guc3RyZWFtXG4gICAgdGhpcy5fc3RyZWFtLm9uKCdyZWFkYWJsZScsIHRoaXMuX29ucmVhZGFibGUpXG4gICAgdGhpcy5fc3RyZWFtLm9uKCdlbmQnLCB0aGlzLl9vbmVuZClcbiAgICB0aGlzLl9zdHJlYW0ub24oJ2VuZCcsIGNiKVxuICAgIHRoaXMuX2ZvcndhcmQoKVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJveC5lbmNvZGUoYm94LCBidWYpXG4gICAgdmFyIGRyYWluZWQgPSB0aGlzLnB1c2goYnVmKVxuICAgIGlmIChkcmFpbmVkKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB0aGlzLl9kcmFpbiA9IGNiXG4gIH1cbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIGlmICh0aGlzLl9zdHJlYW0gJiYgdGhpcy5fc3RyZWFtLmRlc3Ryb3kpIHRoaXMuX3N0cmVhbS5kZXN0cm95KClcbiAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICBpZiAodGhpcy5fZHJhaW4pIHtcbiAgICB2YXIgY2IgPSB0aGlzLl9kcmFpblxuICAgIHRoaXMuX2RyYWluID0gbnVsbFxuICAgIGNiKGVycilcbiAgfVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucHVzaChudWxsKVxufVxuXG5FbmNvZGVyLnByb3RvdHlwZS5fZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9zdHJlYW0pIHJldHVyblxuXG4gIHdoaWxlICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICB2YXIgYnVmID0gdGhpcy5fc3RyZWFtLnJlYWQoKVxuXG4gICAgaWYgKCFidWYpIHtcbiAgICAgIHRoaXMuX3dhbnQgPSAhIXRoaXMuX3N0cmVhbVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnB1c2goYnVmKSkgcmV0dXJuXG4gIH1cbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9yZWFkaW5nIHx8IHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fcmVhZGluZyA9IHRydWVcblxuICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9mb3J3YXJkKClcbiAgaWYgKHRoaXMuX2RyYWluKSB7XG4gICAgdmFyIGRyYWluID0gdGhpcy5fZHJhaW5cbiAgICB0aGlzLl9kcmFpbiA9IG51bGxcbiAgICBkcmFpbigpXG4gIH1cblxuICB0aGlzLl9yZWFkaW5nID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gTWVkaWFEYXRhIChwYXJlbnQpIHtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgc3RyZWFtLlBhc3NUaHJvdWdoLmNhbGwodGhpcylcbn1cblxuaW5oZXJpdHMoTWVkaWFEYXRhLCBzdHJlYW0uUGFzc1Rocm91Z2gpXG5cbk1lZGlhRGF0YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX3BhcmVudC5kZXN0cm95KGVycilcbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG4iLCJleHBvcnRzLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJylcbmV4cG9ydHMuZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGUnKVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBNdWx0aVN0cmVhbVxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxuaW5oZXJpdHMoTXVsdGlTdHJlYW0sIHN0cmVhbS5SZWFkYWJsZSlcblxuZnVuY3Rpb24gTXVsdGlTdHJlYW0gKHN0cmVhbXMsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE11bHRpU3RyZWFtKSkgcmV0dXJuIG5ldyBNdWx0aVN0cmVhbShzdHJlYW1zLCBvcHRzKVxuICBzdHJlYW0uUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRzKVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICB0aGlzLl9kcmFpbmVkID0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG4gIHRoaXMuX2N1cnJlbnQgPSBudWxsXG4gIHRoaXMuX3F1ZXVlID0gKHR5cGVvZiBzdHJlYW1zID09PSAnZnVuY3Rpb24nID8gc3RyZWFtcyA6IHN0cmVhbXMubWFwKHRvU3RyZWFtczIpKVxuXG4gIHRoaXMuX25leHQoKVxufVxuXG5NdWx0aVN0cmVhbS5vYmogPSBmdW5jdGlvbiAoc3RyZWFtcykge1xuICByZXR1cm4gbmV3IE11bHRpU3RyZWFtKHN0cmVhbXMsIHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogMTYgfSlcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kcmFpbmVkID0gdHJ1ZVxuICB0aGlzLl9mb3J3YXJkKClcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9mb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZm9yd2FyZGluZyB8fCAhdGhpcy5fZHJhaW5lZCB8fCAhdGhpcy5fY3VycmVudCkgcmV0dXJuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSB0cnVlXG5cbiAgdmFyIGNodW5rXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jdXJyZW50LnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICB0aGlzLl9kcmFpbmVkID0gdGhpcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG59XG5cbk11bHRpU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcblxuICBpZiAodGhpcy5fY3VycmVudCAmJiB0aGlzLl9jdXJyZW50LmRlc3Ryb3kpIHRoaXMuX2N1cnJlbnQuZGVzdHJveSgpXG4gIGlmICh0eXBlb2YgdGhpcy5fcXVldWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9xdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIGlmIChzdHJlYW0uZGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koKVxuICAgIH0pXG4gIH1cblxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fY3VycmVudCA9IG51bGxcblxuICBpZiAodHlwZW9mIHNlbGYuX3F1ZXVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5fcXVldWUoZnVuY3Rpb24gKGVyciwgc3RyZWFtKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcbiAgICAgIHNlbGYuX2dvdE5leHRTdHJlYW0odG9TdHJlYW1zMihzdHJlYW0pKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmVhbSA9IHNlbGYuX3F1ZXVlLnNoaWZ0KClcbiAgICBpZiAodHlwZW9mIHN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykgc3RyZWFtID0gdG9TdHJlYW1zMihzdHJlYW0oKSlcbiAgICBzZWxmLl9nb3ROZXh0U3RyZWFtKHN0cmVhbSlcbiAgfVxufVxuXG5NdWx0aVN0cmVhbS5wcm90b3R5cGUuX2dvdE5leHRTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICghc3RyZWFtKSB7XG4gICAgc2VsZi5wdXNoKG51bGwpXG4gICAgc2VsZi5kZXN0cm95KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNlbGYuX2N1cnJlbnQgPSBzdHJlYW1cbiAgc2VsZi5fZm9yd2FyZCgpXG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUpXG4gIHN0cmVhbS5vbignZW5kJywgb25FbmQpXG4gIHN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25DbG9zZSlcblxuICBmdW5jdGlvbiBvblJlYWRhYmxlICgpIHtcbiAgICBzZWxmLl9mb3J3YXJkKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xvc2UgKCkge1xuICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICBzZWxmLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kICgpIHtcbiAgICBzZWxmLl9jdXJyZW50ID0gbnVsbFxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBvblJlYWRhYmxlKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG4gICAgc2VsZi5fbmV4dCgpXG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yIChlcnIpIHtcbiAgICBzZWxmLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3RyZWFtczIgKHMpIHtcbiAgaWYgKCFzIHx8IHR5cGVvZiBzID09PSAnZnVuY3Rpb24nIHx8IHMuX3JlYWRhYmxlU3RhdGUpIHJldHVybiBzXG5cbiAgdmFyIHdyYXAgPSBuZXcgc3RyZWFtLlJlYWRhYmxlKCkud3JhcChzKVxuICBpZiAocy5kZXN0cm95KSB7XG4gICAgd3JhcC5kZXN0cm95ID0gcy5kZXN0cm95LmJpbmQocylcbiAgfVxuICByZXR1cm4gd3JhcFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBuZXh0RXZlbnRcblxuZnVuY3Rpb24gbmV4dEV2ZW50IChlbWl0dGVyLCBuYW1lKSB7XG4gIHZhciBuZXh0ID0gbnVsbFxuICBlbWl0dGVyLm9uKG5hbWUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCFuZXh0KSByZXR1cm5cbiAgICB2YXIgZm4gPSBuZXh0XG4gICAgbmV4dCA9IG51bGxcbiAgICBmbihkYXRhKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAob25jZSkge1xuICAgIG5leHQgPSBvbmNlXG4gIH1cbn1cbiIsInZhciB3cmFwcHkgPSByZXF1aXJlKCd3cmFwcHknKVxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkob25jZSlcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZGVjb2RlVG9ycmVudEZpbGVcbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IGRlY29kZVRvcnJlbnRGaWxlXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVUb3JyZW50RmlsZVxuXG52YXIgYmVuY29kZSA9IHJlcXVpcmUoJ2JlbmNvZGUnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcblxuLyoqXG4gKiBQYXJzZSBhIHRvcnJlbnQuIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHRvcnJlbnQgaXMgbWlzc2luZyByZXF1aXJlZCBmaWVsZHMuXG4gKiBAcGFyYW0gIHtCdWZmZXJ8T2JqZWN0fSB0b3JyZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBwYXJzZWQgdG9ycmVudFxuICovXG5mdW5jdGlvbiBkZWNvZGVUb3JyZW50RmlsZSAodG9ycmVudCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcnJlbnQpKSB7XG4gICAgdG9ycmVudCA9IGJlbmNvZGUuZGVjb2RlKHRvcnJlbnQpXG4gIH1cblxuICAvLyBzYW5pdHkgY2hlY2tcbiAgZW5zdXJlKHRvcnJlbnQuaW5mbywgJ2luZm8nKVxuICBlbnN1cmUodG9ycmVudC5pbmZvWyduYW1lLnV0Zi04J10gfHwgdG9ycmVudC5pbmZvLm5hbWUsICdpbmZvLm5hbWUnKVxuICBlbnN1cmUodG9ycmVudC5pbmZvWydwaWVjZSBsZW5ndGgnXSwgJ2luZm9bXFwncGllY2UgbGVuZ3RoXFwnXScpXG4gIGVuc3VyZSh0b3JyZW50LmluZm8ucGllY2VzLCAnaW5mby5waWVjZXMnKVxuXG4gIGlmICh0b3JyZW50LmluZm8uZmlsZXMpIHtcbiAgICB0b3JyZW50LmluZm8uZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgZW5zdXJlKHR5cGVvZiBmaWxlLmxlbmd0aCA9PT0gJ251bWJlcicsICdpbmZvLmZpbGVzWzBdLmxlbmd0aCcpXG4gICAgICBlbnN1cmUoZmlsZVsncGF0aC51dGYtOCddIHx8IGZpbGUucGF0aCwgJ2luZm8uZmlsZXNbMF0ucGF0aCcpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBlbnN1cmUodHlwZW9mIHRvcnJlbnQuaW5mby5sZW5ndGggPT09ICdudW1iZXInLCAnaW5mby5sZW5ndGgnKVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG4gIHJlc3VsdC5pbmZvID0gdG9ycmVudC5pbmZvXG4gIHJlc3VsdC5pbmZvQnVmZmVyID0gYmVuY29kZS5lbmNvZGUodG9ycmVudC5pbmZvKVxuICByZXN1bHQuaW5mb0hhc2ggPSBzaGExLnN5bmMocmVzdWx0LmluZm9CdWZmZXIpXG4gIHJlc3VsdC5pbmZvSGFzaEJ1ZmZlciA9IG5ldyBCdWZmZXIocmVzdWx0LmluZm9IYXNoLCAnaGV4JylcblxuICByZXN1bHQubmFtZSA9ICh0b3JyZW50LmluZm9bJ25hbWUudXRmLTgnXSB8fCB0b3JyZW50LmluZm8ubmFtZSkudG9TdHJpbmcoKVxuXG4gIGlmICh0b3JyZW50LmluZm8ucHJpdmF0ZSAhPT0gdW5kZWZpbmVkKSByZXN1bHQucHJpdmF0ZSA9ICEhdG9ycmVudC5pbmZvLnByaXZhdGVcblxuICBpZiAodG9ycmVudFsnY3JlYXRpb24gZGF0ZSddKSByZXN1bHQuY3JlYXRlZCA9IG5ldyBEYXRlKHRvcnJlbnRbJ2NyZWF0aW9uIGRhdGUnXSAqIDEwMDApXG4gIGlmICh0b3JyZW50WydjcmVhdGVkIGJ5J10pIHJlc3VsdC5jcmVhdGVkQnkgPSB0b3JyZW50WydjcmVhdGVkIGJ5J10udG9TdHJpbmcoKVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodG9ycmVudC5jb21tZW50KSkgcmVzdWx0LmNvbW1lbnQgPSB0b3JyZW50LmNvbW1lbnQudG9TdHJpbmcoKVxuXG4gIC8vIGFubm91bmNlIGFuZCBhbm5vdW5jZS1saXN0IHdpbGwgYmUgbWlzc2luZyBpZiBtZXRhZGF0YSBmZXRjaGVkIHZpYSB1dF9tZXRhZGF0YVxuICByZXN1bHQuYW5ub3VuY2UgPSBbXVxuICBpZiAodG9ycmVudFsnYW5ub3VuY2UtbGlzdCddICYmIHRvcnJlbnRbJ2Fubm91bmNlLWxpc3QnXS5sZW5ndGgpIHtcbiAgICB0b3JyZW50Wydhbm5vdW5jZS1saXN0J10uZm9yRWFjaChmdW5jdGlvbiAodXJscykge1xuICAgICAgdXJscy5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmVzdWx0LmFubm91bmNlLnB1c2godXJsLnRvU3RyaW5nKCkpXG4gICAgICB9KVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodG9ycmVudC5hbm5vdW5jZSkge1xuICAgIHJlc3VsdC5hbm5vdW5jZS5wdXNoKHRvcnJlbnQuYW5ub3VuY2UudG9TdHJpbmcoKSlcbiAgfVxuXG4gIC8vIGhhbmRsZSB1cmwtbGlzdCAoQkVQMTkgLyB3ZWIgc2VlZGluZylcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3JyZW50Wyd1cmwtbGlzdCddKSkge1xuICAgIC8vIHNvbWUgY2xpZW50cyBzZXQgdXJsLWxpc3QgdG8gZW1wdHkgc3RyaW5nXG4gICAgdG9ycmVudFsndXJsLWxpc3QnXSA9IHRvcnJlbnRbJ3VybC1saXN0J10ubGVuZ3RoID4gMFxuICAgICAgPyBbIHRvcnJlbnRbJ3VybC1saXN0J10gXVxuICAgICAgOiBbXVxuICB9XG4gIHJlc3VsdC51cmxMaXN0ID0gKHRvcnJlbnRbJ3VybC1saXN0J10gfHwgW10pLm1hcChmdW5jdGlvbiAodXJsKSB7XG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpXG4gIH0pXG5cbiAgdW5pcShyZXN1bHQuYW5ub3VuY2UpXG4gIHVuaXEocmVzdWx0LnVybExpc3QpXG5cbiAgdmFyIGZpbGVzID0gdG9ycmVudC5pbmZvLmZpbGVzIHx8IFsgdG9ycmVudC5pbmZvIF1cbiAgcmVzdWx0LmZpbGVzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlLCBpKSB7XG4gICAgdmFyIHBhcnRzID0gW10uY29uY2F0KHJlc3VsdC5uYW1lLCBmaWxlWydwYXRoLnV0Zi04J10gfHwgZmlsZS5wYXRoIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwLnRvU3RyaW5nKClcbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLmpvaW4uYXBwbHkobnVsbCwgW3BhdGguc2VwXS5jb25jYXQocGFydHMpKS5zbGljZSgxKSxcbiAgICAgIG5hbWU6IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLFxuICAgICAgbGVuZ3RoOiBmaWxlLmxlbmd0aCxcbiAgICAgIG9mZnNldDogZmlsZXMuc2xpY2UoMCwgaSkucmVkdWNlKHN1bUxlbmd0aCwgMClcbiAgICB9XG4gIH0pXG5cbiAgcmVzdWx0Lmxlbmd0aCA9IGZpbGVzLnJlZHVjZShzdW1MZW5ndGgsIDApXG5cbiAgdmFyIGxhc3RGaWxlID0gcmVzdWx0LmZpbGVzW3Jlc3VsdC5maWxlcy5sZW5ndGggLSAxXVxuXG4gIHJlc3VsdC5waWVjZUxlbmd0aCA9IHRvcnJlbnQuaW5mb1sncGllY2UgbGVuZ3RoJ11cbiAgcmVzdWx0Lmxhc3RQaWVjZUxlbmd0aCA9ICgobGFzdEZpbGUub2Zmc2V0ICsgbGFzdEZpbGUubGVuZ3RoKSAlIHJlc3VsdC5waWVjZUxlbmd0aCkgfHwgcmVzdWx0LnBpZWNlTGVuZ3RoXG4gIHJlc3VsdC5waWVjZXMgPSBzcGxpdFBpZWNlcyh0b3JyZW50LmluZm8ucGllY2VzKVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcGFyc2VkIHRvcnJlbnQgb2JqZWN0IGJhY2sgaW50byBhIC50b3JyZW50IGZpbGUgYnVmZmVyLlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJzZWQgcGFyc2VkIHRvcnJlbnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVG9ycmVudEZpbGUgKHBhcnNlZCkge1xuICB2YXIgdG9ycmVudCA9IHtcbiAgICBpbmZvOiBwYXJzZWQuaW5mb1xuICB9XG5cbiAgdG9ycmVudFsnYW5ub3VuY2UtbGlzdCddID0gKHBhcnNlZC5hbm5vdW5jZSB8fCBbXSkubWFwKGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoIXRvcnJlbnQuYW5ub3VuY2UpIHRvcnJlbnQuYW5ub3VuY2UgPSB1cmxcbiAgICB1cmwgPSBuZXcgQnVmZmVyKHVybCwgJ3V0ZjgnKVxuICAgIHJldHVybiBbIHVybCBdXG4gIH0pXG5cbiAgdG9ycmVudFsndXJsLWxpc3QnXSA9IHBhcnNlZC51cmxMaXN0IHx8IFtdXG5cbiAgaWYgKHBhcnNlZC5jcmVhdGVkKSB7XG4gICAgdG9ycmVudFsnY3JlYXRpb24gZGF0ZSddID0gKHBhcnNlZC5jcmVhdGVkLmdldFRpbWUoKSAvIDEwMDApIHwgMFxuICB9XG5cbiAgaWYgKHBhcnNlZC5jcmVhdGVkQnkpIHtcbiAgICB0b3JyZW50WydjcmVhdGVkIGJ5J10gPSBwYXJzZWQuY3JlYXRlZEJ5XG4gIH1cblxuICBpZiAocGFyc2VkLmNvbW1lbnQpIHtcbiAgICB0b3JyZW50LmNvbW1lbnQgPSBwYXJzZWQuY29tbWVudFxuICB9XG5cbiAgcmV0dXJuIGJlbmNvZGUuZW5jb2RlKHRvcnJlbnQpXG59XG5cbmZ1bmN0aW9uIHN1bUxlbmd0aCAoc3VtLCBmaWxlKSB7XG4gIHJldHVybiBzdW0gKyBmaWxlLmxlbmd0aFxufVxuXG5mdW5jdGlvbiBzcGxpdFBpZWNlcyAoYnVmKSB7XG4gIHZhciBwaWVjZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMjApIHtcbiAgICBwaWVjZXMucHVzaChidWYuc2xpY2UoaSwgaSArIDIwKS50b1N0cmluZygnaGV4JykpXG4gIH1cbiAgcmV0dXJuIHBpZWNlc1xufVxuXG5mdW5jdGlvbiBlbnN1cmUgKGJvb2wsIGZpZWxkTmFtZSkge1xuICBpZiAoIWJvb2wpIHRocm93IG5ldyBFcnJvcignVG9ycmVudCBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiAnICsgZmllbGROYW1lKVxufVxuIiwidmFyIERpY3QgPSByZXF1aXJlKFwiLi9kaWN0XCIpXG5cbi8qKlxuICogRGVjb2RlcyBiZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcn0gZGF0YVxuICogQHBhcmFtICB7TnVtYmVyfSBzdGFydCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGVuY29kaW5nIChvcHRpb25hbClcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKCBkYXRhLCBzdGFydCwgZW5kLCBlbmNvZGluZyApIHtcbiAgXG4gIGlmKCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBzdGFydFxuICAgIHN0YXJ0ID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGlmKCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gZW5kXG4gICAgZW5kID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gISggQnVmZmVyLmlzQnVmZmVyKGRhdGEpIClcbiAgICA/IG5ldyBCdWZmZXIoIGRhdGEgKVxuICAgIDogZGF0YS5zbGljZSggc3RhcnQsIGVuZCApXG4gIFxuICBkZWNvZGUuYnl0ZXMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgXG4gIHJldHVybiBkZWNvZGUubmV4dCgpXG5cbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgICAgID0gbnVsbFxuZGVjb2RlLmVuY29kaW5nID0gbnVsbFxuXG5kZWNvZGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gIHN3aXRjaCggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSApIHtcbiAgICBjYXNlIDB4NjQ6IHJldHVybiBkZWNvZGUuZGljdGlvbmFyeSgpOyBicmVha1xuICAgIGNhc2UgMHg2QzogcmV0dXJuIGRlY29kZS5saXN0KCk7IGJyZWFrXG4gICAgY2FzZSAweDY5OiByZXR1cm4gZGVjb2RlLmludGVnZXIoKTsgYnJlYWtcbiAgICBkZWZhdWx0OiAgIHJldHVybiBkZWNvZGUuYnVmZmVyKCk7IGJyZWFrXG4gIH1cblxufVxuXG5kZWNvZGUuZmluZCA9IGZ1bmN0aW9uKCBjaHIgKSB7XG5cbiAgdmFyIGkgPSBkZWNvZGUucG9zaXRpb25cbiAgdmFyIGMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgdmFyIGQgPSBkZWNvZGUuZGF0YVxuXG4gIHdoaWxlKCBpIDwgYyApIHtcbiAgICBpZiggZFtpXSA9PT0gY2hyIClcbiAgICAgIHJldHVybiBpXG4gICAgaSsrXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ0ludmFsaWQgZGF0YTogTWlzc2luZyBkZWxpbWl0ZXIgXCInICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjaHIgKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoIDE2ICkgKyAnXSdcbiAgKVxuXG59XG5cbmRlY29kZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgZGljdCA9IG5ldyBEaWN0KClcblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBkaWN0LmJpbmFyeVNldChkZWNvZGUuYnVmZmVyKCksIGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBkaWN0XG5cbn1cblxuZGVjb2RlLmxpc3QgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBsc3QgPSBbXVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGxzdC5wdXNoKCBkZWNvZGUubmV4dCgpIClcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGxzdFxuXG59XG5cbmRlY29kZS5pbnRlZ2VyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGVuZCAgICA9IGRlY29kZS5maW5kKCAweDY1IClcbiAgdmFyIG51bWJlciA9IGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24gKyAxLCBlbmQgKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KCBudW1iZXIsIDEwIClcblxufVxuXG5kZWNvZGUuYnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNlcCAgICA9IGRlY29kZS5maW5kKCAweDNBIClcbiAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KCBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXAgKSwgMTAgKVxuICB2YXIgZW5kICAgID0gKytzZXAgKyBsZW5ndGhcblxuICBkZWNvZGUucG9zaXRpb24gPSBlbmRcblxuICByZXR1cm4gZGVjb2RlLmVuY29kaW5nXG4gICAgPyBkZWNvZGUuZGF0YS50b1N0cmluZyggZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZCApXG4gICAgOiBkZWNvZGUuZGF0YS5zbGljZSggc2VwLCBlbmQgKVxuXG59XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlXG4iLCIvKipcbiAqIEVuY29kZXMgZGF0YSBpbiBiZW5jb2RlLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcnxBcnJheXxTdHJpbmd8T2JqZWN0fE51bWJlcnxCb29sZWFufSBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZSggZGF0YSwgYnVmZmVyLCBvZmZzZXQgKSB7XG4gIFxuICB2YXIgYnVmZmVycyA9IFtdXG4gIHZhciByZXN1bHQgPSBudWxsXG4gIFxuICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YSApXG4gIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoIGJ1ZmZlcnMgKVxuICBlbmNvZGUuYnl0ZXMgPSByZXN1bHQubGVuZ3RoXG4gIFxuICBpZiggQnVmZmVyLmlzQnVmZmVyKCBidWZmZXIgKSApIHtcbiAgICByZXN1bHQuY29weSggYnVmZmVyLCBvZmZzZXQgKVxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdFxuICBcbn1cblxuZW5jb2RlLmJ5dGVzID0gLTFcbmVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSBmYWxzZVxuXG5lbmNvZGUuX2VuY29kZSA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGlmKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCggdHlwZW9mIGRhdGEgKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGVuY29kZS5idWZmZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KCBidWZmZXJzLCBkYXRhIClcbiAgICAgICAgOiBlbmNvZGUuZGljdCggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSA/IDEgOiAwIClcbiAgICAgIGJyZWFrXG4gIH1cblxufVxuXG52YXIgYnVmZl9lID0gbmV3IEJ1ZmZlcignZScpXG4gICwgYnVmZl9kID0gbmV3IEJ1ZmZlcignZCcpXG4gICwgYnVmZl9sID0gbmV3IEJ1ZmZlcignbCcpXG5cbmVuY29kZS5idWZmZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoIGRhdGEgKSArICc6JyArIGRhdGEpIClcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuICB2YXIgbWF4TG8gPSAweDgwMDAwMDAwXG4gIHZhciBoaSA9ICggZGF0YSAvIG1heExvICkgPDwgMFxuICB2YXIgbG8gPSAoIGRhdGEgJSBtYXhMbyAgKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoICdpJyArIHZhbCArICdlJyApKVxuXG4gIGlmKCB2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgKSB7XG4gICAgZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCA9IHRydWVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV0FSTklORzogUG9zc2libGUgZGF0YSBjb3JydXB0aW9uIGRldGVjdGVkIHdpdGggdmFsdWUgXCInK2RhdGErJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicrdmFsKydcIidcbiAgICApXG4gICAgY29uc29sZS50cmFjZSgpXG4gIH1cblxufVxuXG5lbmNvZGUuZGljdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9kIClcblxuICB2YXIgaiA9IDBcbiAgdmFyIGtcbiAgLy8gZml4IGZvciBpc3N1ZSAjMTMgLSBzb3J0ZWQgZGljdHNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZGF0YSApLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciggOyBqIDwga2wgOyBqKyspIHtcbiAgICBrPWtleXNbal1cbiAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBrIClcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtrXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgdmFyIGkgPSAwLCBqID0gMVxuICB2YXIgYyA9IGRhdGEubGVuZ3RoXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9sIClcblxuICBmb3IoIDsgaSA8IGM7IGkrKyApIHtcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtpXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG5cbn1cblxuLy8gRXhwb3NlXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuIiwiLyogZ2xvYmFsIEJsb2IgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVRvcnJlbnRcbm1vZHVsZS5leHBvcnRzLnJlbW90ZSA9IHBhcnNlVG9ycmVudFJlbW90ZVxuXG52YXIgYmxvYlRvQnVmZmVyID0gcmVxdWlyZSgnYmxvYi10by1idWZmZXInKVxudmFyIGZzID0gcmVxdWlyZSgnZnMnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBnZXQgPSByZXF1aXJlKCdzaW1wbGUtZ2V0JylcbnZhciBtYWduZXQgPSByZXF1aXJlKCdtYWduZXQtdXJpJylcbnZhciBwYXJzZVRvcnJlbnRGaWxlID0gcmVxdWlyZSgncGFyc2UtdG9ycmVudC1maWxlJylcblxubW9kdWxlLmV4cG9ydHMudG9NYWduZXRVUkkgPSBtYWduZXQuZW5jb2RlXG5tb2R1bGUuZXhwb3J0cy50b1RvcnJlbnRGaWxlID0gcGFyc2VUb3JyZW50RmlsZS5lbmNvZGVcblxuLyoqXG4gKiBQYXJzZSBhIHRvcnJlbnQgaWRlbnRpZmllciAobWFnbmV0IHVyaSwgLnRvcnJlbnQgZmlsZSwgaW5mbyBoYXNoKVxuICogQHBhcmFtICB7c3RyaW5nfEJ1ZmZlcnxPYmplY3R9IHRvcnJlbnRJZFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZVRvcnJlbnQgKHRvcnJlbnRJZCkge1xuICBpZiAodHlwZW9mIHRvcnJlbnRJZCA9PT0gJ3N0cmluZycgJiYgL14oc3RyZWFtLSk/bWFnbmV0Oi8udGVzdCh0b3JyZW50SWQpKSB7XG4gICAgLy8gbWFnbmV0IHVyaSAoc3RyaW5nKVxuICAgIHJldHVybiBtYWduZXQodG9ycmVudElkKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0b3JyZW50SWQgPT09ICdzdHJpbmcnICYmICgvXlthLWYwLTldezQwfSQvaS50ZXN0KHRvcnJlbnRJZCkgfHwgL15bYS16Mi03XXszMn0kL2kudGVzdCh0b3JyZW50SWQpKSkge1xuICAgIC8vIGluZm8gaGFzaCAoaGV4L2Jhc2UtMzIgc3RyaW5nKVxuICAgIHJldHVybiBtYWduZXQoJ21hZ25ldDo/eHQ9dXJuOmJ0aWg6JyArIHRvcnJlbnRJZClcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodG9ycmVudElkKSAmJiB0b3JyZW50SWQubGVuZ3RoID09PSAyMCkge1xuICAgIC8vIGluZm8gaGFzaCAoYnVmZmVyKVxuICAgIHJldHVybiBtYWduZXQoJ21hZ25ldDo/eHQ9dXJuOmJ0aWg6JyArIHRvcnJlbnRJZC50b1N0cmluZygnaGV4JykpXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcnJlbnRJZCkpIHtcbiAgICAvLyAudG9ycmVudCBmaWxlIChidWZmZXIpXG4gICAgcmV0dXJuIHBhcnNlVG9ycmVudEZpbGUodG9ycmVudElkKSAvLyBtaWdodCB0aHJvd1xuICB9IGVsc2UgaWYgKHRvcnJlbnRJZCAmJiB0b3JyZW50SWQuaW5mb0hhc2gpIHtcbiAgICAvLyBwYXJzZWQgdG9ycmVudCAoZnJvbSBgcGFyc2UtdG9ycmVudGAsIGBwYXJzZS10b3JyZW50LWZpbGVgLCBvciBgbWFnbmV0LXVyaWApXG4gICAgaWYgKCF0b3JyZW50SWQuYW5ub3VuY2UpIHRvcnJlbnRJZC5hbm5vdW5jZSA9IFtdXG4gICAgaWYgKHR5cGVvZiB0b3JyZW50SWQuYW5ub3VuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0b3JyZW50SWQuYW5ub3VuY2UgPSBbIHRvcnJlbnRJZC5hbm5vdW5jZSBdXG4gICAgfVxuICAgIGlmICghdG9ycmVudElkLnVybExpc3QpIHRvcnJlbnRJZC51cmxMaXN0ID0gW11cbiAgICByZXR1cm4gdG9ycmVudElkXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRvcnJlbnQgaWRlbnRpZmllcicpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUb3JyZW50UmVtb3RlICh0b3JyZW50SWQsIGNiKSB7XG4gIHZhciBwYXJzZWRUb3JyZW50XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBGdW5jdGlvbicpXG5cbiAgdHJ5IHtcbiAgICBwYXJzZWRUb3JyZW50ID0gcGFyc2VUb3JyZW50KHRvcnJlbnRJZClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWYgdG9ycmVudCBmYWlscyB0byBwYXJzZSwgaXQgY291bGQgYmUgYSBCbG9iLCBodHRwL2h0dHBzIFVSTCBvclxuICAgIC8vIGZpbGVzeXN0ZW0gcGF0aCwgc28gZG9uJ3QgY29uc2lkZXIgaXQgYW4gZXJyb3IgeWV0LlxuICB9XG5cbiAgaWYgKHBhcnNlZFRvcnJlbnQgJiYgcGFyc2VkVG9ycmVudC5pbmZvSGFzaCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2IobnVsbCwgcGFyc2VkVG9ycmVudClcbiAgICB9KVxuICB9IGVsc2UgaWYgKGlzQmxvYih0b3JyZW50SWQpKSB7XG4gICAgYmxvYlRvQnVmZmVyKHRvcnJlbnRJZCwgZnVuY3Rpb24gKGVyciwgdG9ycmVudEJ1Zikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKG5ldyBFcnJvcignRXJyb3IgY29udmVydGluZyBCbG9iOiAnICsgZXJyLm1lc3NhZ2UpKVxuICAgICAgcGFyc2VPclRocm93KHRvcnJlbnRCdWYpXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2V0ID09PSAnZnVuY3Rpb24nICYmIC9eaHR0cHM/Oi8udGVzdCh0b3JyZW50SWQpKSB7XG4gICAgLy8gaHR0cCwgb3IgaHR0cHMgdXJsIHRvIHRvcnJlbnQgZmlsZVxuICAgIGdldC5jb25jYXQoe1xuICAgICAgdXJsOiB0b3JyZW50SWQsXG4gICAgICBoZWFkZXJzOiB7ICd1c2VyLWFnZW50JzogJ1dlYlRvcnJlbnQgKGh0dHA6Ly93ZWJ0b3JyZW50LmlvKScgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlcywgdG9ycmVudEJ1Zikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKG5ldyBFcnJvcignRXJyb3IgZG93bmxvYWRpbmcgdG9ycmVudDogJyArIGVyci5tZXNzYWdlKSlcbiAgICAgIHBhcnNlT3JUaHJvdyh0b3JyZW50QnVmKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGZzLnJlYWRGaWxlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0b3JyZW50SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYXNzdW1lIGl0J3MgYSBmaWxlc3lzdGVtIHBhdGhcbiAgICBmcy5yZWFkRmlsZSh0b3JyZW50SWQsIGZ1bmN0aW9uIChlcnIsIHRvcnJlbnRCdWYpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihuZXcgRXJyb3IoJ0ludmFsaWQgdG9ycmVudCBpZGVudGlmaWVyJykpXG4gICAgICBwYXJzZU9yVGhyb3codG9ycmVudEJ1ZilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2IobmV3IEVycm9yKCdJbnZhbGlkIHRvcnJlbnQgaWRlbnRpZmllcicpKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9yVGhyb3cgKHRvcnJlbnRCdWYpIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVG9ycmVudCA9IHBhcnNlVG9ycmVudCh0b3JyZW50QnVmKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG4gICAgaWYgKHBhcnNlZFRvcnJlbnQgJiYgcGFyc2VkVG9ycmVudC5pbmZvSGFzaCkgY2IobnVsbCwgcGFyc2VkVG9ycmVudClcbiAgICBlbHNlIGNiKG5ldyBFcnJvcignSW52YWxpZCB0b3JyZW50IGlkZW50aWZpZXInKSlcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVzNDIGBCbG9iYCBvciBgRmlsZWAgb2JqZWN0XG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQmxvYiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgQmxvYlxufVxuXG4vLyBXb3JrYXJvdW5kIEJyb3dzZXJpZnkgdjEzIGJ1Z1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL25vZGUtYnJvd3NlcmlmeS9pc3N1ZXMvMTQ4M1xuOyhmdW5jdGlvbiAoKSB7IEJ1ZmZlcigwKSB9KSgpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsInZhciBjbG9zZXN0ID0gcmVxdWlyZSgnY2xvc2VzdC10bycpXG5cbi8vIENyZWF0ZSBhIHJhbmdlIGZyb20gMTZrYuKAkzRtYlxudmFyIHNpemVzID0gW11cbmZvciAodmFyIGkgPSAxNDsgaSA8PSAyMjsgaSsrKSB7XG4gIHNpemVzLnB1c2goTWF0aC5wb3coMiwgaSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2l6ZSkge1xuICByZXR1cm4gY2xvc2VzdChcbiAgICBzaXplIC8gTWF0aC5wb3coMiwgMTApLCBzaXplcyBcbiAgKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXG52YXIgZnMgPSByZXF1aXJlKCdmcycpIC8vIHdlIG9ubHkgbmVlZCBmcyB0byBnZXQgdGhlIFJlYWRTdHJlYW0gYW5kIFdyaXRlU3RyZWFtIHByb3RvdHlwZXNcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG52YXIgaXNGbiA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nXG59XG5cbnZhciBpc0ZTID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICByZXR1cm4gKHN0cmVhbSBpbnN0YW5jZW9mIChmcy5SZWFkU3RyZWFtIHx8IG5vb3ApIHx8IHN0cmVhbSBpbnN0YW5jZW9mIChmcy5Xcml0ZVN0cmVhbSB8fCBub29wKSkgJiYgaXNGbihzdHJlYW0uY2xvc2UpXG59XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIGlzRm4oc3RyZWFtLmFib3J0KVxufVxuXG52YXIgZGVzdHJveWVyID0gZnVuY3Rpb24gKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gIHZhciBjbG9zZWQgPSBmYWxzZVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWVcbiAgfSlcblxuICBlb3Moc3RyZWFtLCB7cmVhZGFibGU6IHJlYWRpbmcsIHdyaXRhYmxlOiB3cml0aW5nfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgY2xvc2VkID0gdHJ1ZVxuICAgIGNhbGxiYWNrKClcbiAgfSlcblxuICB2YXIgZGVzdHJveWVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm5cbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm5cbiAgICBkZXN0cm95ZWQgPSB0cnVlXG5cbiAgICBpZiAoaXNGUyhzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmNsb3NlKCkgLy8gdXNlIGNsb3NlIGZvciBmcyBzdHJlYW1zIHRvIGF2b2lkIGZkIGxlYWtzXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCkgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc0ZuKHN0cmVhbS5kZXN0cm95KSkgcmV0dXJuIHN0cmVhbS5kZXN0cm95KClcblxuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRXJyb3IoJ3N0cmVhbSB3YXMgZGVzdHJveWVkJykpXG4gIH1cbn1cblxudmFyIGNhbGwgPSBmdW5jdGlvbiAoZm4pIHtcbiAgZm4oKVxufVxuXG52YXIgcGlwZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKVxufVxuXG52YXIgcHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0cmVhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIHZhciBjYWxsYmFjayA9IGlzRm4oc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdIHx8IG5vb3ApICYmIHN0cmVhbXMucG9wKCkgfHwgbm9vcFxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXVxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ3B1bXAgcmVxdWlyZXMgdHdvIHN0cmVhbXMgcGVyIG1pbmltdW0nKVxuXG4gIHZhciBlcnJvclxuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxXG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMFxuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVyclxuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKVxuICAgICAgaWYgKHJlYWRpbmcpIHJldHVyblxuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKVxuICAgICAgY2FsbGJhY2soZXJyb3IpXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwdW1wXG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJ2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gIHZhciBvZmZzZXQgPSAwXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gbGlzdC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGggLSBvZmZzZXRcbiAgICB2YXIgaSA9IChNYXRoLnJhbmRvbSgpICogbGVuKSB8IDBcbiAgICB2YXIgZWwgPSBsaXN0W29mZnNldCArIGldXG5cbiAgICB2YXIgdG1wID0gbGlzdFtvZmZzZXRdXG4gICAgbGlzdFtvZmZzZXRdID0gZWxcbiAgICBsaXN0W29mZnNldCArIGldID0gdG1wXG4gICAgb2Zmc2V0KytcblxuICAgIHJldHVybiBlbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXRlcmF0ZVxuIiwiLypcbkluc3RhbmNlIG9mIHdyaXRhYmxlIHN0cmVhbS5cblxuY2FsbCAuZ2V0KGxlbmd0aCkgb3IgLmRpc2NhcmQobGVuZ3RoKSB0byBnZXQgYSBzdHJlYW0gKHJlbGF0aXZlIHRvIHRoZSBsYXN0IGVuZClcblxuZW1pdHMgJ3N0YWxsZWQnIG9uY2UgZXZlcnl0aGluZyBpcyB3cml0dGVuXG5cblxuKi9cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlU2xpY2VTdHJlYW1cblxuaW5oZXJpdHMoUmFuZ2VTbGljZVN0cmVhbSwgc3RyZWFtLldyaXRhYmxlKVxuXG5mdW5jdGlvbiBSYW5nZVNsaWNlU3RyZWFtIChvZmZzZXQpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICghKHNlbGYgaW5zdGFuY2VvZiBSYW5nZVNsaWNlU3RyZWFtKSkgcmV0dXJuIG5ldyBSYW5nZVNsaWNlU3RyZWFtKG9mZnNldClcblx0c3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG5cdHNlbGYuX3F1ZXVlID0gW11cblx0c2VsZi5fcG9zaXRpb24gPSBvZmZzZXQgfHwgMFxuXHRzZWxmLl9jYiA9IG51bGxcblx0c2VsZi5fYnVmZmVyID0gbnVsbFxuXHRzZWxmLl9vdXQgPSBudWxsXG59XG5cblJhbmdlU2xpY2VTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciBkcmFpbmVkID0gdHJ1ZVxuXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0aWYgKHNlbGYuZGVzdHJveWVkKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvLyBXYWl0IGZvciBtb3JlIHF1ZXVlIGVudHJpZXNcblx0XHRpZiAoc2VsZi5fcXVldWUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRzZWxmLl9idWZmZXIgPSBjaHVua1xuXHRcdFx0c2VsZi5fY2IgPSBjYlxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0c2VsZi5fYnVmZmVyID0gbnVsbFxuXHRcdHZhciBjdXJyUmFuZ2UgPSBzZWxmLl9xdWV1ZVswXVxuXHRcdC8vIFJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiBjaHVuaywgd2hhdCBkYXRhIGRvIHdlIG5lZWQ/XG5cdFx0dmFyIHdyaXRlU3RhcnQgPSBNYXRoLm1heChjdXJyUmFuZ2Uuc3RhcnQgLSBzZWxmLl9wb3NpdGlvbiwgMClcblx0XHR2YXIgd3JpdGVFbmQgPSBjdXJyUmFuZ2UuZW5kIC0gc2VsZi5fcG9zaXRpb25cblxuXHRcdC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdGhyb3cgaXQgYWxsIGF3YXlcblx0XHRpZiAod3JpdGVTdGFydCA+PSBjaHVuay5sZW5ndGgpIHtcblx0XHRcdHNlbGYuX3Bvc2l0aW9uICs9IGNodW5rLmxlbmd0aFxuXHRcdFx0cmV0dXJuIGNiKG51bGwpXG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgbmVlZCB0byB1c2UgaXQgYWxsXG5cdFx0dmFyIHRvV3JpdGVcblx0XHRpZiAod3JpdGVFbmQgPiBjaHVuay5sZW5ndGgpIHtcblx0XHRcdHNlbGYuX3Bvc2l0aW9uICs9IGNodW5rLmxlbmd0aFxuXHRcdFx0aWYgKHdyaXRlU3RhcnQgPT09IDApIHtcblx0XHRcdFx0dG9Xcml0ZSA9IGNodW5rXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b1dyaXRlID0gY2h1bmsuc2xpY2Uod3JpdGVTdGFydClcblx0XHRcdH1cblx0XHRcdGRyYWluZWQgPSBjdXJyUmFuZ2Uuc3RyZWFtLndyaXRlKHRvV3JpdGUpICYmIGRyYWluZWRcblx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0c2VsZi5fcG9zaXRpb24gKz0gd3JpdGVFbmRcblx0XHRpZiAod3JpdGVTdGFydCA9PT0gMCAmJiB3cml0ZUVuZCA9PT0gY2h1bmsubGVuZ3RoKSB7XG5cdFx0XHR0b1dyaXRlID0gY2h1bmtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9Xcml0ZSA9IGNodW5rLnNsaWNlKHdyaXRlU3RhcnQsIHdyaXRlRW5kKVxuXHRcdH1cblx0XHRkcmFpbmVkID0gY3VyclJhbmdlLnN0cmVhbS53cml0ZSh0b1dyaXRlKSAmJiBkcmFpbmVkXG5cdFx0aWYgKGN1cnJSYW5nZS5sYXN0KSB7XG5cdFx0XHRjdXJyUmFuZ2Uuc3RyZWFtLmVuZCgpXG5cdFx0fVxuXHRcdGNodW5rID0gY2h1bmsuc2xpY2Uod3JpdGVFbmQpXG5cdFx0c2VsZi5fcXVldWUuc2hpZnQoKVxuXHR9XG5cblx0aWYgKGRyYWluZWQpIHtcblx0XHRjYihudWxsKVxuXHR9IGVsc2Uge1xuXHRcdGN1cnJSYW5nZS5zdHJlYW0ub25jZSgnZHJhaW4nLCBjYi5iaW5kKG51bGwsIG51bGwpKVxuXHR9XG59XG5cblJhbmdlU2xpY2VTdHJlYW0ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHJhbmdlcykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBudWxsXG5cblx0aWYgKCEocmFuZ2VzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0cmFuZ2VzID0gW3Jhbmdlc11cblx0fVxuXG5cdHZhciBzdHIgPSBuZXcgc3RyZWFtLlBhc3NUaHJvdWdoKClcblxuXHRyYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UsIGkpIHtcblx0XHRzZWxmLl9xdWV1ZS5wdXNoKHtcblx0XHRcdHN0YXJ0OiByYW5nZS5zdGFydCxcblx0XHRcdGVuZDogcmFuZ2UuZW5kLFxuXHRcdFx0c3RyZWFtOiBzdHIsXG5cdFx0XHRsYXN0OiBpID09PSAocmFuZ2VzLmxlbmd0aCAtIDEpXG5cdFx0fSlcblx0fSlcblx0aWYgKHNlbGYuX2J1ZmZlcikge1xuXHRcdHNlbGYuX3dyaXRlKHNlbGYuX2J1ZmZlciwgbnVsbCwgc2VsZi5fY2IpXG5cdH1cblxuXHRyZXR1cm4gc3RyXG59XG5cblJhbmdlU2xpY2VTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXHRzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuXHRpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxufVxuIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn0iLCIvLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xuICB9IGNhdGNoIChfKSB7fSBmaW5hbGx5IHtcbiAgICBpZiAoIVN0cmVhbSkgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICB9XG59KSgpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGhhc1ByZXBlbmRMaXN0ZW5lciA9IHR5cGVvZiBFRS5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIGlmIChoYXNQcmVwZW5kTGlzdGVuZXIpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlXG4gIC8vIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHMgdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zXG4gIC8vIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZSB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbFxuICAvLyBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMCkgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcbiAgICAgIGRlc3RzW19pXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24gKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHJldCA9IG51bGw7ZWxzZSBpZiAob2JqZWN0TW9kZSkgcmV0ID0gbGlzdC5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSkgcmV0ID0gbGlzdC5qb2luKCcnKTtlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0ID0gbGlzdFswXTtlbHNlIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSkgcmV0ID0gJyc7ZWxzZSByZXQgPSBidWZmZXJTaGltLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBfYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBfYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpIHJldCArPSBfYnVmLnNsaWNlKDAsIGNweSk7ZWxzZSBfYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBfYnVmLmxlbmd0aCkgbGlzdFswXSA9IF9idWYuc2xpY2UoY3B5KTtlbHNlIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVHZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn0iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblxuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xufVxuIiwiZXhwb3J0cy5yZW5kZXIgPSByZW5kZXJcbmV4cG9ydHMuYXBwZW5kID0gYXBwZW5kXG52YXIgbWltZSA9IGV4cG9ydHMubWltZSA9IHJlcXVpcmUoJy4vbGliL21pbWUuanNvbicpXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3JlbmRlci1tZWRpYScpXG52YXIgaXNBc2NpaSA9IHJlcXVpcmUoJ2lzLWFzY2lpJylcbnZhciBNZWRpYUVsZW1lbnRXcmFwcGVyID0gcmVxdWlyZSgnbWVkaWFzb3VyY2UnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBzdHJlYW1Ub0Jsb2JVUkwgPSByZXF1aXJlKCdzdHJlYW0tdG8tYmxvYi11cmwnKVxudmFyIHZpZGVvc3RyZWFtID0gcmVxdWlyZSgndmlkZW9zdHJlYW0nKVxuXG52YXIgVklERU9TVFJFQU1fRVhUUyA9IFsgJy5tcDQnLCAnLm00dicsICcubTRhJyBdXG5cbnZhciBNRURJQVNPVVJDRV9WSURFT19FWFRTID0gWyAnLm1wNCcsICcubTR2JywgJy53ZWJtJywgJy5ta3YnIF1cbnZhciBNRURJQVNPVVJDRV9BVURJT19FWFRTID0gWyAnLm00YScsICcubXAzJyBdXG52YXIgTUVESUFTT1VSQ0VfRVhUUyA9IE1FRElBU09VUkNFX1ZJREVPX0VYVFMuY29uY2F0KE1FRElBU09VUkNFX0FVRElPX0VYVFMpXG5cbnZhciBBVURJT19FWFRTID0gWyAnLndhdicsICcuYWFjJywgJy5vZ2cnLCAnLm9nYScgXVxudmFyIElNQUdFX0VYVFMgPSBbICcuanBnJywgJy5qcGVnJywgJy5wbmcnLCAnLmdpZicsICcuYm1wJyBdXG52YXIgSUZSQU1FX0VYVFMgPSBbICcuY3NzJywgJy5odG1sJywgJy5qcycsICcubWQnLCAnLnBkZicsICcudHh0JyBdXG5cbnZhciBNZWRpYVNvdXJjZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NZWRpYVNvdXJjZVxuXG5mdW5jdGlvbiByZW5kZXIgKGZpbGUsIGVsZW0sIGNiKSB7XG4gIHZhbGlkYXRlRmlsZShmaWxlKVxuICBpZiAodHlwZW9mIGVsZW0gPT09ICdzdHJpbmcnKSBlbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtKVxuXG4gIHJlbmRlck1lZGlhKGZpbGUsIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgaWYgKGVsZW0ubm9kZU5hbWUgIT09IHRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUoZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCByZW5kZXIgXCInICsgZXh0bmFtZSArICdcIiBpbnNpZGUgYSBcIicgK1xuICAgICAgICBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKyAnXCIgZWxlbWVudCwgZXhwZWN0ZWQgXCInICsgdGFnTmFtZSArICdcIidcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbVxuICB9LCBjYilcbn1cblxuZnVuY3Rpb24gYXBwZW5kIChmaWxlLCByb290RWxlbSwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBmdW5jdGlvbiAoKSB7fVxuICB2YWxpZGF0ZUZpbGUoZmlsZSlcbiAgaWYgKHR5cGVvZiByb290RWxlbSA9PT0gJ3N0cmluZycpIHJvb3RFbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihyb290RWxlbSlcblxuICBpZiAocm9vdEVsZW0gJiYgKHJvb3RFbGVtLm5vZGVOYW1lID09PSAnVklERU8nIHx8IHJvb3RFbGVtLm5vZGVOYW1lID09PSAnQVVESU8nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHZpZGVvL2F1ZGlvIG5vZGUgYXJndW1lbnQuIEFyZ3VtZW50IG11c3QgYmUgcm9vdCBlbGVtZW50IHRoYXQgJyArXG4gICAgICAndmlkZW8vYXVkaW8gdGFnIHdpbGwgYmUgYXBwZW5kZWQgdG8uJ1xuICAgIClcbiAgfVxuXG4gIHJlbmRlck1lZGlhKGZpbGUsIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgaWYgKHRhZ05hbWUgPT09ICd2aWRlbycgfHwgdGFnTmFtZSA9PT0gJ2F1ZGlvJykgcmV0dXJuIGNyZWF0ZU1lZGlhKHRhZ05hbWUpXG4gICAgZWxzZSByZXR1cm4gY3JlYXRlRWxlbSh0YWdOYW1lKVxuICB9LCBmdW5jdGlvbiAoZXJyLCBlbGVtKSB7XG4gICAgaWYgKGVyciAmJiBlbGVtKSBlbGVtLnJlbW92ZSgpXG4gICAgY2IoZXJyLCBlbGVtKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1lZGlhICh0YWdOYW1lKSB7XG4gICAgdmFyIGVsZW0gPSBjcmVhdGVFbGVtKHRhZ05hbWUpXG4gICAgZWxlbS5jb250cm9scyA9IHRydWVcbiAgICBlbGVtLmF1dG9wbGF5ID0gdHJ1ZVxuICAgIHJvb3RFbGVtLmFwcGVuZENoaWxkKGVsZW0pXG4gICAgcmV0dXJuIGVsZW1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW0gKHRhZ05hbWUpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcbiAgICByb290RWxlbS5hcHBlbmRDaGlsZChlbGVtKVxuICAgIHJldHVybiBlbGVtXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVkaWEgKGZpbGUsIGdldEVsZW0sIGNiKSB7XG4gIGlmICghY2IpIGNiID0gZnVuY3Rpb24gKCkge31cbiAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUoZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpXG4gIHZhciBjdXJyZW50VGltZSA9IDBcbiAgdmFyIGVsZW1cblxuICBpZiAoTUVESUFTT1VSQ0VfRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDApIHtcbiAgICByZW5kZXJNZWRpYVNvdXJjZSgpXG4gIH0gZWxzZSBpZiAoQVVESU9fRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDApIHtcbiAgICByZW5kZXJBdWRpbygpXG4gIH0gZWxzZSBpZiAoSU1BR0VfRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDApIHtcbiAgICByZW5kZXJJbWFnZSgpXG4gIH0gZWxzZSBpZiAoSUZSQU1FX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgcmVuZGVySWZyYW1lKClcbiAgfSBlbHNlIHtcbiAgICB0cnlSZW5kZXJJZnJhbWUoKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTWVkaWFTb3VyY2UgKCkge1xuICAgIHZhciB0YWdOYW1lID0gTUVESUFTT1VSQ0VfVklERU9fRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDAgPyAndmlkZW8nIDogJ2F1ZGlvJ1xuXG4gICAgaWYgKE1lZGlhU291cmNlKSB7XG4gICAgICBpZiAoVklERU9TVFJFQU1fRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDApIHtcbiAgICAgICAgdXNlVmlkZW9zdHJlYW0oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXNlTWVkaWFTb3VyY2UoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1c2VCbG9iVVJMKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1c2VWaWRlb3N0cmVhbSAoKSB7XG4gICAgICBkZWJ1ZygnVXNlIGB2aWRlb3N0cmVhbWAgcGFja2FnZSBmb3IgJyArIGZpbGUubmFtZSlcbiAgICAgIHByZXBhcmVFbGVtKClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYWxsYmFja1RvTWVkaWFTb3VyY2UpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuICAgICAgdmlkZW9zdHJlYW0oZmlsZSwgZWxlbSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1c2VNZWRpYVNvdXJjZSAoKSB7XG4gICAgICBkZWJ1ZygnVXNlIE1lZGlhU291cmNlIEFQSSBmb3IgJyArIGZpbGUubmFtZSlcbiAgICAgIHByZXBhcmVFbGVtKClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYWxsYmFja1RvQmxvYlVSTClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0Jywgb25Mb2FkU3RhcnQpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXkpXG5cbiAgICAgIHZhciB3cmFwcGVyID0gbmV3IE1lZGlhRWxlbWVudFdyYXBwZXIoZWxlbSlcbiAgICAgIHZhciB3cml0YWJsZSA9IHdyYXBwZXIuY3JlYXRlV3JpdGVTdHJlYW0oZ2V0Q29kZWMoZmlsZS5uYW1lKSlcbiAgICAgIGZpbGUuY3JlYXRlUmVhZFN0cmVhbSgpLnBpcGUod3JpdGFibGUpXG5cbiAgICAgIGlmIChjdXJyZW50VGltZSkgZWxlbS5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXNlQmxvYlVSTCAoKSB7XG4gICAgICBkZWJ1ZygnVXNlIEJsb2IgVVJMIGZvciAnICsgZmlsZS5uYW1lKVxuICAgICAgcHJlcGFyZUVsZW0oKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZhdGFsRXJyb3IpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuICAgICAgZ2V0QmxvYlVSTChmaWxlLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGZhdGFsRXJyb3IoZXJyKVxuICAgICAgICBlbGVtLnNyYyA9IHVybFxuICAgICAgICBpZiAoY3VycmVudFRpbWUpIGVsZW0uY3VycmVudFRpbWUgPSBjdXJyZW50VGltZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWxsYmFja1RvTWVkaWFTb3VyY2UgKGVycikge1xuICAgICAgZGVidWcoJ3ZpZGVvc3RyZWFtIGVycm9yOiBmYWxsYmFjayB0byBNZWRpYVNvdXJjZSBBUEk6ICVvJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGZhbGxiYWNrVG9NZWRpYVNvdXJjZSlcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcblxuICAgICAgdXNlTWVkaWFTb3VyY2UoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhbGxiYWNrVG9CbG9iVVJMIChlcnIpIHtcbiAgICAgIGRlYnVnKCdNZWRpYVNvdXJjZSBBUEkgZXJyb3I6IGZhbGxiYWNrIHRvIEJsb2IgVVJMOiAlbycsIGVyci5tZXNzYWdlIHx8IGVycilcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYWxsYmFja1RvQmxvYlVSTClcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcblxuICAgICAgdXNlQmxvYlVSTCgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUVsZW0gKCkge1xuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIGVsZW0gPSBnZXRFbGVtKHRhZ05hbWUpXG5cbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjdXJyZW50VGltZSA9IGVsZW0uY3VycmVudFRpbWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJBdWRpbyAoKSB7XG4gICAgZWxlbSA9IGdldEVsZW0oJ2F1ZGlvJylcbiAgICBnZXRCbG9iVVJMKGZpbGUsIGZ1bmN0aW9uIChlcnIsIHVybCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGZhdGFsRXJyb3IoZXJyKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZhdGFsRXJyb3IpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuICAgICAgZWxlbS5zcmMgPSB1cmxcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gb25Mb2FkU3RhcnQgKCkge1xuICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0Jywgb25Mb2FkU3RhcnQpXG4gICAgZWxlbS5wbGF5KClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2FuUGxheSAoKSB7XG4gICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuICAgIGNiKG51bGwsIGVsZW0pXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJJbWFnZSAoKSB7XG4gICAgZWxlbSA9IGdldEVsZW0oJ2ltZycpXG4gICAgZ2V0QmxvYlVSTChmaWxlLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBmYXRhbEVycm9yKGVycilcbiAgICAgIGVsZW0uc3JjID0gdXJsXG4gICAgICBlbGVtLmFsdCA9IGZpbGUubmFtZVxuICAgICAgY2IobnVsbCwgZWxlbSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVySWZyYW1lICgpIHtcbiAgICBlbGVtID0gZ2V0RWxlbSgnaWZyYW1lJylcblxuICAgIGdldEJsb2JVUkwoZmlsZSwgZnVuY3Rpb24gKGVyciwgdXJsKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZmF0YWxFcnJvcihlcnIpXG4gICAgICBlbGVtLnNyYyA9IHVybFxuICAgICAgaWYgKGV4dG5hbWUgIT09ICcucGRmJykgZWxlbS5zYW5kYm94ID0gJ2FsbG93LWZvcm1zIGFsbG93LXNjcmlwdHMnXG4gICAgICBjYihudWxsLCBlbGVtKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiB0cnlSZW5kZXJJZnJhbWUgKCkge1xuICAgIGRlYnVnKCdVbmtub3duIGZpbGUgZXh0ZW5zaW9uIFwiJXNcIiAtIHdpbGwgYXR0ZW1wdCB0byByZW5kZXIgaW50byBpZnJhbWUnLCBleHRuYW1lKVxuXG4gICAgdmFyIHN0ciA9ICcnXG4gICAgZmlsZS5jcmVhdGVSZWFkU3RyZWFtKHsgc3RhcnQ6IDAsIGVuZDogMTAwMCB9KVxuICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBzdHIgKz0gY2h1bmtcbiAgICAgIH0pXG4gICAgICAub24oJ2VuZCcsIGRvbmUpXG4gICAgICAub24oJ2Vycm9yJywgY2IpXG5cbiAgICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICAgIGlmIChpc0FzY2lpKHN0cikpIHtcbiAgICAgICAgZGVidWcoJ0ZpbGUgZXh0ZW5zaW9uIFwiJXNcIiBhcHBlYXJzIGFzY2lpLCBzbyB3aWxsIHJlbmRlci4nLCBleHRuYW1lKVxuICAgICAgICByZW5kZXJJZnJhbWUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ0ZpbGUgZXh0ZW5zaW9uIFwiJXNcIiBhcHBlYXJzIG5vbi1hc2NpaSwgd2lsbCBub3QgcmVuZGVyLicsIGV4dG5hbWUpXG4gICAgICAgIGNiKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZmlsZSB0eXBlIFwiJyArIGV4dG5hbWUgKyAnXCI6IENhbm5vdCBhcHBlbmQgdG8gRE9NJykpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmF0YWxFcnJvciAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSAnRXJyb3IgcmVuZGVyaW5nIGZpbGUgXCInICsgZmlsZS5uYW1lICsgJ1wiOiAnICsgZXJyLm1lc3NhZ2VcbiAgICBkZWJ1ZyhlcnIubWVzc2FnZSlcbiAgICBjYihlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmxvYlVSTCAoZmlsZSwgY2IpIHtcbiAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUoZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpXG4gIHN0cmVhbVRvQmxvYlVSTChmaWxlLmNyZWF0ZVJlYWRTdHJlYW0oKSwgbWltZVtleHRuYW1lXSwgY2IpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRmlsZSAoZmlsZSkge1xuICBpZiAoZmlsZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpXG4gIH1cbiAgaWYgKHR5cGVvZiBmaWxlLm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9yIGludmFsaWQgZmlsZS5uYW1lIHByb3BlcnR5JylcbiAgfVxuICBpZiAodHlwZW9mIGZpbGUuY3JlYXRlUmVhZFN0cmVhbSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIGZpbGUuY3JlYXRlUmVhZFN0cmVhbSBwcm9wZXJ0eScpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29kZWMgKG5hbWUpIHtcbiAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUobmFtZSkudG9Mb3dlckNhc2UoKVxuICByZXR1cm4ge1xuICAgICcubTRhJzogJ2F1ZGlvL21wNDsgY29kZWNzPVwibXA0YS40MC41XCInLFxuICAgICcubTR2JzogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS42NDAwMjksIG1wNGEuNDAuNVwiJyxcbiAgICAnLm1rdic6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJhdmMxLjY0MDAyOSwgbXA0YS40MC41XCInLFxuICAgICcubXAzJzogJ2F1ZGlvL21wZWcnLFxuICAgICcubXA0JzogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS42NDAwMjksIG1wNGEuNDAuNVwiJyxcbiAgICAnLndlYm0nOiAndmlkZW8vd2VibTsgY29kZWNzPVwidm9yYmlzLCB2cDhcIidcbiAgfVtleHRuYW1lXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIi4zZ3BcIjogXCJ2aWRlby8zZ3BwXCIsXG4gIFwiLmFhY1wiOiBcImF1ZGlvL2FhY1wiLFxuICBcIi5haWZcIjogXCJhdWRpby94LWFpZmZcIixcbiAgXCIuYWlmZlwiOiBcImF1ZGlvL3gtYWlmZlwiLFxuICBcIi5hdG9tXCI6IFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIixcbiAgXCIuYXZpXCI6IFwidmlkZW8veC1tc3ZpZGVvXCIsXG4gIFwiLmJtcFwiOiBcImltYWdlL2JtcFwiLFxuICBcIi5iejJcIjogXCJhcHBsaWNhdGlvbi94LWJ6aXAyXCIsXG4gIFwiLmNvbmZcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiLmNzc1wiOiBcInRleHQvY3NzXCIsXG4gIFwiLmNzdlwiOiBcInRleHQvY3N2XCIsXG4gIFwiLmRpZmZcIjogXCJ0ZXh0L3gtZGlmZlwiLFxuICBcIi5kb2NcIjogXCJhcHBsaWNhdGlvbi9tc3dvcmRcIixcbiAgXCIuZmx2XCI6IFwidmlkZW8veC1mbHZcIixcbiAgXCIuZ2lmXCI6IFwiaW1hZ2UvZ2lmXCIsXG4gIFwiLmd6XCI6IFwiYXBwbGljYXRpb24veC1nemlwXCIsXG4gIFwiLmh0bVwiOiBcInRleHQvaHRtbFwiLFxuICBcIi5odG1sXCI6IFwidGV4dC9odG1sXCIsXG4gIFwiLmljb1wiOiBcImltYWdlL3ZuZC5taWNyb3NvZnQuaWNvblwiLFxuICBcIi5pY3NcIjogXCJ0ZXh0L2NhbGVuZGFyXCIsXG4gIFwiLmlzb1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIi5qYXJcIjogXCJhcHBsaWNhdGlvbi9qYXZhLWFyY2hpdmVcIixcbiAgXCIuanBlZ1wiOiBcImltYWdlL2pwZWdcIixcbiAgXCIuanBnXCI6IFwiaW1hZ2UvanBlZ1wiLFxuICBcIi5qc1wiOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIixcbiAgXCIuanNvblwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgXCIubGVzc1wiOiBcInRleHQvY3NzXCIsXG4gIFwiLmxvZ1wiOiBcInRleHQvcGxhaW5cIixcbiAgXCIubTN1XCI6IFwiYXVkaW8veC1tcGVndXJsXCIsXG4gIFwiLm00YVwiOiBcImF1ZGlvL21wNFwiLFxuICBcIi5tNHZcIjogXCJ2aWRlby9tcDRcIixcbiAgXCIubWFuaWZlc3RcIjogXCJ0ZXh0L2NhY2hlLW1hbmlmZXN0XCIsXG4gIFwiLm1hcmtkb3duXCI6IFwidGV4dC94LW1hcmtkb3duXCIsXG4gIFwiLm1hdGhtbFwiOiBcImFwcGxpY2F0aW9uL21hdGhtbCt4bWxcIixcbiAgXCIubWRcIjogXCJ0ZXh0L3gtbWFya2Rvd25cIixcbiAgXCIubWlkXCI6IFwiYXVkaW8vbWlkaVwiLFxuICBcIi5taWRpXCI6IFwiYXVkaW8vbWlkaVwiLFxuICBcIi5tb3ZcIjogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgXCIubXAzXCI6IFwiYXVkaW8vbXBlZ1wiLFxuICBcIi5tcDRcIjogXCJ2aWRlby9tcDRcIixcbiAgXCIubXA0dlwiOiBcInZpZGVvL21wNFwiLFxuICBcIi5tcGVnXCI6IFwidmlkZW8vbXBlZ1wiLFxuICBcIi5tcGdcIjogXCJ2aWRlby9tcGVnXCIsXG4gIFwiLm9kcFwiOiBcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uXCIsXG4gIFwiLm9kc1wiOiBcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXRcIixcbiAgXCIub2R0XCI6IFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0XCIsXG4gIFwiLm9nYVwiOiBcImF1ZGlvL29nZ1wiLFxuICBcIi5vZ2dcIjogXCJhcHBsaWNhdGlvbi9vZ2dcIixcbiAgXCIucGRmXCI6IFwiYXBwbGljYXRpb24vcGRmXCIsXG4gIFwiLnBuZ1wiOiBcImltYWdlL3BuZ1wiLFxuICBcIi5wcHNcIjogXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludFwiLFxuICBcIi5wcHRcIjogXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludFwiLFxuICBcIi5wc1wiOiBcImFwcGxpY2F0aW9uL3Bvc3RzY3JpcHRcIixcbiAgXCIucHNkXCI6IFwiaW1hZ2Uvdm5kLmFkb2JlLnBob3Rvc2hvcFwiLFxuICBcIi5xdFwiOiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBcIi5yYXJcIjogXCJhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkXCIsXG4gIFwiLnJkZlwiOiBcImFwcGxpY2F0aW9uL3JkZit4bWxcIixcbiAgXCIucnNzXCI6IFwiYXBwbGljYXRpb24vcnNzK3htbFwiLFxuICBcIi5ydGZcIjogXCJhcHBsaWNhdGlvbi9ydGZcIixcbiAgXCIuc3ZnXCI6IFwiaW1hZ2Uvc3ZnK3htbFwiLFxuICBcIi5zdmd6XCI6IFwiaW1hZ2Uvc3ZnK3htbFwiLFxuICBcIi5zd2ZcIjogXCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiLFxuICBcIi50YXJcIjogXCJhcHBsaWNhdGlvbi94LXRhclwiLFxuICBcIi50YnpcIjogXCJhcHBsaWNhdGlvbi94LWJ6aXAtY29tcHJlc3NlZC10YXJcIixcbiAgXCIudGV4dFwiOiBcInRleHQvcGxhaW5cIixcbiAgXCIudGlmXCI6IFwiaW1hZ2UvdGlmZlwiLFxuICBcIi50aWZmXCI6IFwiaW1hZ2UvdGlmZlwiLFxuICBcIi50b3JyZW50XCI6IFwiYXBwbGljYXRpb24veC1iaXR0b3JyZW50XCIsXG4gIFwiLnR0ZlwiOiBcImFwcGxpY2F0aW9uL3gtZm9udC10dGZcIixcbiAgXCIudHh0XCI6IFwidGV4dC9wbGFpblwiLFxuICBcIi53YXZcIjogXCJhdWRpby93YXZcIixcbiAgXCIud2VibVwiOiBcInZpZGVvL3dlYm1cIixcbiAgXCIud21hXCI6IFwiYXVkaW8veC1tcy13bWFcIixcbiAgXCIud212XCI6IFwidmlkZW8veC1tcy13bXZcIixcbiAgXCIueGxzXCI6IFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsXCIsXG4gIFwiLnhtbFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcIi55YW1sXCI6IFwidGV4dC95YW1sXCIsXG4gIFwiLnltbFwiOiBcInRleHQveWFtbFwiLFxuICBcIi56aXBcIjogXCJhcHBsaWNhdGlvbi96aXBcIlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFza3MsIGxpbWl0LCBjYikge1xuICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpXG4gIHZhciByZXN1bHRzLCBsZW4sIHBlbmRpbmcsIGtleXMsIGlzRXJyb3JlZFxuICB2YXIgaXNTeW5jID0gdHJ1ZVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRhc2tzKSkge1xuICAgIHJlc3VsdHMgPSBbXVxuICAgIHBlbmRpbmcgPSBsZW4gPSB0YXNrcy5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModGFza3MpXG4gICAgcmVzdWx0cyA9IHt9XG4gICAgcGVuZGluZyA9IGxlbiA9IGtleXMubGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgaWYgKGNiKSBjYihlcnIsIHJlc3VsdHMpXG4gICAgICBjYiA9IG51bGxcbiAgICB9XG4gICAgaWYgKGlzU3luYykgcHJvY2Vzcy5uZXh0VGljayhlbmQpXG4gICAgZWxzZSBlbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gZWFjaCAoaSwgZXJyLCByZXN1bHQpIHtcbiAgICByZXN1bHRzW2ldID0gcmVzdWx0XG4gICAgaWYgKGVycikgaXNFcnJvcmVkID0gdHJ1ZVxuICAgIGlmICgtLXBlbmRpbmcgPT09IDAgfHwgZXJyKSB7XG4gICAgICBkb25lKGVycilcbiAgICB9IGVsc2UgaWYgKCFpc0Vycm9yZWQgJiYgbmV4dCA8IGxlbikge1xuICAgICAgdmFyIGtleVxuICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAga2V5ID0ga2V5c1tuZXh0XVxuICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgdGFza3Nba2V5XShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChrZXksIGVyciwgcmVzdWx0KSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gbmV4dFxuICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgdGFza3Nba2V5XShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChrZXksIGVyciwgcmVzdWx0KSB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0ID0gbGltaXRcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgLy8gZW1wdHlcbiAgICBkb25lKG51bGwpXG4gIH0gZWxzZSBpZiAoa2V5cykge1xuICAgIC8vIG9iamVjdFxuICAgIGtleXMuc29tZShmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICB0YXNrc1trZXldKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgeyBlYWNoKGtleSwgZXJyLCByZXN1bHQpIH0pXG4gICAgICBpZiAoaSA9PT0gbGltaXQgLSAxKSByZXR1cm4gdHJ1ZSAvLyBlYXJseSByZXR1cm5cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGFycmF5XG4gICAgdGFza3Muc29tZShmdW5jdGlvbiAodGFzaywgaSkge1xuICAgICAgdGFzayhmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChpLCBlcnIsIHJlc3VsdCkgfSlcbiAgICAgIGlmIChpID09PSBsaW1pdCAtIDEpIHJldHVybiB0cnVlIC8vIGVhcmx5IHJldHVyblxuICAgIH0pXG4gIH1cblxuICBpc1N5bmMgPSBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFza3MsIGNiKSB7XG4gIHZhciByZXN1bHRzLCBwZW5kaW5nLCBrZXlzXG4gIHZhciBpc1N5bmMgPSB0cnVlXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFza3MpKSB7XG4gICAgcmVzdWx0cyA9IFtdXG4gICAgcGVuZGluZyA9IHRhc2tzLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh0YXNrcylcbiAgICByZXN1bHRzID0ge31cbiAgICBwZW5kaW5nID0ga2V5cy5sZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICBpZiAoY2IpIGNiKGVyciwgcmVzdWx0cylcbiAgICAgIGNiID0gbnVsbFxuICAgIH1cbiAgICBpZiAoaXNTeW5jKSBwcm9jZXNzLm5leHRUaWNrKGVuZClcbiAgICBlbHNlIGVuZCgpXG4gIH1cblxuICBmdW5jdGlvbiBlYWNoIChpLCBlcnIsIHJlc3VsdCkge1xuICAgIHJlc3VsdHNbaV0gPSByZXN1bHRcbiAgICBpZiAoLS1wZW5kaW5nID09PSAwIHx8IGVycikge1xuICAgICAgZG9uZShlcnIpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgLy8gZW1wdHlcbiAgICBkb25lKG51bGwpXG4gIH0gZWxzZSBpZiAoa2V5cykge1xuICAgIC8vIG9iamVjdFxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0YXNrc1trZXldKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgeyBlYWNoKGtleSwgZXJyLCByZXN1bHQpIH0pXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBhcnJheVxuICAgIHRhc2tzLmZvckVhY2goZnVuY3Rpb24gKHRhc2ssIGkpIHtcbiAgICAgIHRhc2soZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goaSwgZXJyLCByZXN1bHQpIH0pXG4gICAgfSlcbiAgfVxuXG4gIGlzU3luYyA9IGZhbHNlXG59XG4iLCIvKlxuICogUnVzaGEsIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSxcbiAqIGFzIGRlZmluZWQgaW4gRklQUyBQVUIgMTgwLTEsIHR1bmVkIGZvciBoaWdoIHBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgaW5wdXRzLlxuICogKGh0dHA6Ly9naXRodWIuY29tL3NyaWpzL3J1c2hhKVxuICpcbiAqIEluc3BpcmVkIGJ5IFBhdWwgSm9obnN0b25zIGltcGxlbWVudGF0aW9uIChodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1KS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgU2FtIFJpanMgKGh0dHA6Ly9hd2VzYW0uZGUpLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZSBhcyBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4gKiBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHV0aWwgPSB7XG4gICAgICAgICAgICBnZXREYXRhVHlwZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2J1ZmZlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndmlldyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Jsb2InO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAvLyBUaGUgUnVzaGEgb2JqZWN0IGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIGxvdy1sZXZlbCBSdXNoYUNvcmUuXG4gICAgLy8gSXQgcHJvdmlkZXMgbWVhbnMgb2YgY29udmVydGluZyBkaWZmZXJlbnQgaW5wdXRzIHRvIHRoZVxuICAgIC8vIGZvcm1hdCBhY2NlcHRlZCBieSBSdXNoYUNvcmUgYXMgd2VsbCBhcyBvdGhlciB1dGlsaXR5IG1ldGhvZHMuXG4gICAgZnVuY3Rpb24gUnVzaGEoY2h1bmtTaXplKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgLy8gUHJpdmF0ZSBvYmplY3Qgc3RydWN0dXJlLlxuICAgICAgICB2YXIgc2VsZiQyID0geyBmaWxsOiAwIH07XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIGJ1ZmZlciB0aGF0IHRoZSBzaGExIHJvdXRpbmUgdXNlc1xuICAgICAgICAvLyBpbmNsdWRpbmcgdGhlIHBhZGRpbmcuXG4gICAgICAgIHZhciBwYWRsZW4gPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgICAgICBmb3IgKGxlbiArPSA5OyBsZW4gJSA2NCA+IDA7IGxlbiArPSAxKTtcbiAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYWRaZXJvZXMgPSBmdW5jdGlvbiAoYmluLCBsZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZW4gPj4gMjsgaSA8IGJpbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBiaW5baV0gPSAwO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFkRGF0YSA9IGZ1bmN0aW9uIChiaW4sIGNodW5rTGVuLCBtc2dMZW4pIHtcbiAgICAgICAgICAgIGJpbltjaHVua0xlbiA+PiAyXSB8PSAxMjggPDwgMjQgLSAoY2h1bmtMZW4gJSA0IDw8IDMpO1xuICAgICAgICAgICAgYmluWygoY2h1bmtMZW4gPj4gMikgKyAyICYgfjE1KSArIDE0XSA9IG1zZ0xlbiA+PiAyOTtcbiAgICAgICAgICAgIGJpblsoKGNodW5rTGVuID4+IDIpICsgMiAmIH4xNSkgKyAxNV0gPSBtc2dMZW4gPDwgMztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29udmVydCBhIGJpbmFyeSBzdHJpbmcgYW5kIHdyaXRlIGl0IHRvIHRoZSBoZWFwLlxuICAgICAgICAvLyBBIGJpbmFyeSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gb25seSBjb250YWluIGNoYXIgY29kZXMgPCAyNTYuXG4gICAgICAgIHZhciBjb252U3RyID0gZnVuY3Rpb24gKEg4LCBIMzIsIHN0YXJ0LCBsZW4sIG9mZikge1xuICAgICAgICAgICAgdmFyIHN0ciA9IHRoaXMsIGksIG9tID0gb2ZmICUgNCwgbG0gPSBsZW4gJSA0LCBqID0gbGVuIC0gbG07XG4gICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9tKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAzIHwgMF0gPSBzdHIuY2hhckNvZGVBdChzdGFydCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAyIHwgMF0gPSBzdHIuY2hhckNvZGVBdChzdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMSB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyAyKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSBvbTsgaSA8IGo7IGkgPSBpICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICBIMzJbb2ZmICsgaSA+PiAyXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgaSkgPDwgMjQgfCBzdHIuY2hhckNvZGVBdChzdGFydCArIGkgKyAxKSA8PCAxNiB8IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgaSArIDIpIDw8IDggfCBzdHIuY2hhckNvZGVBdChzdGFydCArIGkgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAobG0pIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMSB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyBqICsgMik7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDIgfCAwXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgaiArIDEpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIEg4W29mZiArIGogKyAzIHwgMF0gPSBzdHIuY2hhckNvZGVBdChzdGFydCArIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDb252ZXJ0IGEgYnVmZmVyIG9yIGFycmF5IGFuZCB3cml0ZSBpdCB0byB0aGUgaGVhcC5cbiAgICAgICAgLy8gVGhlIGJ1ZmZlciBvciBhcnJheSBpcyBleHBlY3RlZCB0byBvbmx5IGNvbnRhaW4gZWxlbWVudHMgPCAyNTYuXG4gICAgICAgIHZhciBjb252QnVmID0gZnVuY3Rpb24gKEg4LCBIMzIsIHN0YXJ0LCBsZW4sIG9mZikge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IHRoaXMsIGksIG9tID0gb2ZmICUgNCwgbG0gPSBsZW4gJSA0LCBqID0gbGVuIC0gbG07XG4gICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9tKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAzIHwgMF0gPSBidWZbc3RhcnRdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMiB8IDBdID0gYnVmW3N0YXJ0ICsgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAxIHwgMF0gPSBidWZbc3RhcnQgKyAyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiB8IDBdID0gYnVmW3N0YXJ0ICsgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gNCAtIG9tOyBpIDwgajsgaSA9IGkgKz0gNCB8IDApIHtcbiAgICAgICAgICAgICAgICBIMzJbb2ZmICsgaSA+PiAyXSA9IGJ1ZltzdGFydCArIGldIDw8IDI0IHwgYnVmW3N0YXJ0ICsgaSArIDFdIDw8IDE2IHwgYnVmW3N0YXJ0ICsgaSArIDJdIDw8IDggfCBidWZbc3RhcnQgKyBpICsgM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGxtKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDEgfCAwXSA9IGJ1ZltzdGFydCArIGogKyAyXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMiB8IDBdID0gYnVmW3N0YXJ0ICsgaiArIDFdO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIEg4W29mZiArIGogKyAzIHwgMF0gPSBidWZbc3RhcnQgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnZCbG9iID0gZnVuY3Rpb24gKEg4LCBIMzIsIHN0YXJ0LCBsZW4sIG9mZikge1xuICAgICAgICAgICAgdmFyIGJsb2IgPSB0aGlzLCBpLCBvbSA9IG9mZiAlIDQsIGxtID0gbGVuICUgNCwgaiA9IGxlbiAtIGxtO1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iLnNsaWNlKHN0YXJ0LCBzdGFydCArIGxlbikpKTtcbiAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob20pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDMgfCAwXSA9IGJ1ZlswXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDIgfCAwXSA9IGJ1ZlsxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDEgfCAwXSA9IGJ1ZlsyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiB8IDBdID0gYnVmWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDQgLSBvbTsgaSA8IGo7IGkgPSBpICs9IDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgSDMyW29mZiArIGkgPj4gMl0gPSBidWZbaV0gPDwgMjQgfCBidWZbaSArIDFdIDw8IDE2IHwgYnVmW2kgKyAyXSA8PCA4IHwgYnVmW2kgKyAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAobG0pIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMSB8IDBdID0gYnVmW2ogKyAyXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMiB8IDBdID0gYnVmW2ogKyAxXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMyB8IDBdID0gYnVmW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udkZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodXRpbC5nZXREYXRhVHlwZShkYXRhKSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udlN0ci5iaW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb252QnVmLmJpbmQoZGF0YSk7XG4gICAgICAgICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb252QnVmLmJpbmQoZGF0YSk7XG4gICAgICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZCdWYuYmluZChuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgICAgICAgICBjYXNlICd2aWV3JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udkJ1Zi5iaW5kKG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZCbG9iLmJpbmQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzbGljZSA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodXRpbC5nZXREYXRhVHlwZShkYXRhKSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCk7XG4gICAgICAgICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCk7XG4gICAgICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgICAgIGNhc2UgJ3ZpZXcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmJ1ZmZlci5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDb252ZXJ0IGFuIEFycmF5QnVmZmVyIGludG8gaXRzIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgdmFyIGhleCA9IGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIGksIHgsIGhleF90YWIgPSAnMDEyMzQ1Njc4OWFiY2RlZicsIHJlcyA9IFtdLCBiaW5hcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSBiaW5hcnJheVtpXTtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBoZXhfdGFiLmNoYXJBdCh4ID4+IDQgJiAxNSkgKyBoZXhfdGFiLmNoYXJBdCh4ID4+IDAgJiAxNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLmpvaW4oJycpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2VpbEhlYXBTaXplID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIC8vIFRoZSBhc20uanMgc3BlYyBzYXlzOlxuICAgICAgICAgICAgLy8gVGhlIGhlYXAgb2JqZWN0J3MgYnl0ZUxlbmd0aCBtdXN0IGJlIGVpdGhlclxuICAgICAgICAgICAgLy8gMl5uIGZvciBuIGluIFsxMiwgMjQpIG9yIDJeMjQgKiBuIGZvciBuIOKJpSAxLlxuICAgICAgICAgICAgLy8gQWxzbywgYnl0ZUxlbmd0aHMgc21hbGxlciB0aGFuIDJeMTYgYXJlIGRlcHJlY2F0ZWQuXG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIC8vIElmIHYgaXMgc21hbGxlciB0aGFuIDJeMTYsIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBzb2x1dGlvblxuICAgICAgICAgICAgLy8gaXMgMl4xNi5cbiAgICAgICAgICAgIGlmICh2IDw9IDY1NTM2KVxuICAgICAgICAgICAgICAgIHJldHVybiA2NTUzNjtcbiAgICAgICAgICAgIC8vIElmIHYgPCAyXjI0LCB3ZSByb3VuZCB1cCB0byAyXm4sXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugcm91bmQgdXAgdG8gMl4yNCAqIG4uXG4gICAgICAgICAgICBpZiAodiA8IDE2Nzc3MjE2KSB7XG4gICAgICAgICAgICAgICAgZm9yIChwID0gMTsgcCA8IHY7IHAgPSBwIDw8IDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSAxNjc3NzIxNjsgcCA8IHY7IHAgKz0gMTY3NzcyMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcyB0byBhIG5ldyBjYXBhY2l0eS5cbiAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICAgICAgaWYgKHNpemUgJSA2NCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NodW5rIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDEyOCBiaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYkMi5tYXhDaHVua0xlbiA9IHNpemU7XG4gICAgICAgICAgICBzZWxmJDIucGFkTWF4Q2h1bmtMZW4gPSBwYWRsZW4oc2l6ZSk7XG4gICAgICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgaGVhcCBpcyB0aGUgc3VtIG9mOlxuICAgICAgICAgICAgLy8gMS4gVGhlIHBhZGRlZCBpbnB1dCBtZXNzYWdlIHNpemVcbiAgICAgICAgICAgIC8vIDIuIFRoZSBleHRlbmRlZCBzcGFjZSB0aGUgYWxnb3JpdGhtIG5lZWRzICgzMjAgYnl0ZSlcbiAgICAgICAgICAgIC8vIDMuIFRoZSAxNjAgYml0IHN0YXRlIHRoZSBhbGdvcml0bSB1c2VzXG4gICAgICAgICAgICBzZWxmJDIuaGVhcCA9IG5ldyBBcnJheUJ1ZmZlcihjZWlsSGVhcFNpemUoc2VsZiQyLnBhZE1heENodW5rTGVuICsgMzIwICsgMjApKTtcbiAgICAgICAgICAgIHNlbGYkMi5oMzIgPSBuZXcgSW50MzJBcnJheShzZWxmJDIuaGVhcCk7XG4gICAgICAgICAgICBzZWxmJDIuaDggPSBuZXcgSW50OEFycmF5KHNlbGYkMi5oZWFwKTtcbiAgICAgICAgICAgIHNlbGYkMi5jb3JlID0gbmV3IFJ1c2hhLl9jb3JlKHtcbiAgICAgICAgICAgICAgICBJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuICAgICAgICAgICAgICAgIERhdGFWaWV3OiBEYXRhVmlld1xuICAgICAgICAgICAgfSwge30sIHNlbGYkMi5oZWFwKTtcbiAgICAgICAgICAgIHNlbGYkMi5idWZmZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJaW5pdGlhbGl6ZXRoZSBkYXRhc3RydWN0dXJlcyBhY2NvcmRpbmdcbiAgICAgICAgLy8gdG8gYSBjaHVuayBzaXl6ZS5cbiAgICAgICAgaW5pdChjaHVua1NpemUgfHwgNjQgKiAxMDI0KTtcbiAgICAgICAgdmFyIGluaXRTdGF0ZSA9IGZ1bmN0aW9uIChoZWFwLCBwYWRNc2dMZW4pIHtcbiAgICAgICAgICAgIHZhciBpbyA9IG5ldyBJbnQzMkFycmF5KGhlYXAsIHBhZE1zZ0xlbiArIDMyMCwgNSk7XG4gICAgICAgICAgICBpb1swXSA9IDE3MzI1ODQxOTM7XG4gICAgICAgICAgICBpb1sxXSA9IC0yNzE3MzM4Nzk7XG4gICAgICAgICAgICBpb1syXSA9IC0xNzMyNTg0MTk0O1xuICAgICAgICAgICAgaW9bM10gPSAyNzE3MzM4Nzg7XG4gICAgICAgICAgICBpb1s0XSA9IC0xMDA5NTg5Nzc2O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFkQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmtMZW4sIG1zZ0xlbikge1xuICAgICAgICAgICAgdmFyIHBhZENodW5rTGVuID0gcGFkbGVuKGNodW5rTGVuKTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IEludDMyQXJyYXkoc2VsZiQyLmhlYXAsIDAsIHBhZENodW5rTGVuID4+IDIpO1xuICAgICAgICAgICAgcGFkWmVyb2VzKHZpZXcsIGNodW5rTGVuKTtcbiAgICAgICAgICAgIHBhZERhdGEodmlldywgY2h1bmtMZW4sIG1zZ0xlbik7XG4gICAgICAgICAgICByZXR1cm4gcGFkQ2h1bmtMZW47XG4gICAgICAgIH07XG4gICAgICAgIC8vIFdyaXRlIGRhdGEgdG8gdGhlIGhlYXAuXG4gICAgICAgIHZhciB3cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBjaHVua09mZnNldCwgY2h1bmtMZW4pIHtcbiAgICAgICAgICAgIGNvbnZGbihkYXRhKShzZWxmJDIuaDgsIHNlbGYkMi5oMzIsIGNodW5rT2Zmc2V0LCBjaHVua0xlbiwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluaXRpYWxpemUgYW5kIGNhbGwgdGhlIFJ1c2hhQ29yZSxcbiAgICAgICAgLy8gYXNzdW1pbmcgYW4gaW5wdXQgYnVmZmVyIG9mIGxlbmd0aCBsZW4gKiA0LlxuICAgICAgICB2YXIgY29yZUNhbGwgPSBmdW5jdGlvbiAoZGF0YSwgY2h1bmtPZmZzZXQsIGNodW5rTGVuLCBtc2dMZW4sIGZpbmFsaXplKSB7XG4gICAgICAgICAgICB2YXIgcGFkQ2h1bmtMZW4gPSBjaHVua0xlbjtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZSkge1xuICAgICAgICAgICAgICAgIHBhZENodW5rTGVuID0gcGFkQ2h1bmsoY2h1bmtMZW4sIG1zZ0xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZShkYXRhLCBjaHVua09mZnNldCwgY2h1bmtMZW4pO1xuICAgICAgICAgICAgc2VsZiQyLmNvcmUuaGFzaChwYWRDaHVua0xlbiwgc2VsZiQyLnBhZE1heENodW5rTGVuKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFJhd0RpZ2VzdCA9IGZ1bmN0aW9uIChoZWFwLCBwYWRNYXhDaHVua0xlbikge1xuICAgICAgICAgICAgdmFyIGlvID0gbmV3IEludDMyQXJyYXkoaGVhcCwgcGFkTWF4Q2h1bmtMZW4gKyAzMjAsIDUpO1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBJbnQzMkFycmF5KDUpO1xuICAgICAgICAgICAgdmFyIGFyciA9IG5ldyBEYXRhVmlldyhvdXQuYnVmZmVyKTtcbiAgICAgICAgICAgIGFyci5zZXRJbnQzMigwLCBpb1swXSwgZmFsc2UpO1xuICAgICAgICAgICAgYXJyLnNldEludDMyKDQsIGlvWzFdLCBmYWxzZSk7XG4gICAgICAgICAgICBhcnIuc2V0SW50MzIoOCwgaW9bMl0sIGZhbHNlKTtcbiAgICAgICAgICAgIGFyci5zZXRJbnQzMigxMiwgaW9bM10sIGZhbHNlKTtcbiAgICAgICAgICAgIGFyci5zZXRJbnQzMigxNiwgaW9bNF0sIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaGFzaCBkaWdlc3QgYXMgYW4gYXJyYXkgb2YgNSAzMmJpdCBpbnRlZ2Vycy5cbiAgICAgICAgdmFyIHJhd0RpZ2VzdCA9IHRoaXMucmF3RGlnZXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHZhciBtc2dMZW4gPSBzdHIuYnl0ZUxlbmd0aCB8fCBzdHIubGVuZ3RoIHx8IHN0ci5zaXplIHx8IDA7XG4gICAgICAgICAgICAgICAgaW5pdFN0YXRlKHNlbGYkMi5oZWFwLCBzZWxmJDIucGFkTWF4Q2h1bmtMZW4pO1xuICAgICAgICAgICAgICAgIHZhciBjaHVua09mZnNldCA9IDAsIGNodW5rTGVuID0gc2VsZiQyLm1heENodW5rTGVuLCBsYXN0O1xuICAgICAgICAgICAgICAgIGZvciAoY2h1bmtPZmZzZXQgPSAwOyBtc2dMZW4gPiBjaHVua09mZnNldCArIGNodW5rTGVuOyBjaHVua09mZnNldCArPSBjaHVua0xlbikge1xuICAgICAgICAgICAgICAgICAgICBjb3JlQ2FsbChzdHIsIGNodW5rT2Zmc2V0LCBjaHVua0xlbiwgbXNnTGVuLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvcmVDYWxsKHN0ciwgY2h1bmtPZmZzZXQsIG1zZ0xlbiAtIGNodW5rT2Zmc2V0LCBtc2dMZW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYXdEaWdlc3Qoc2VsZiQyLmhlYXAsIHNlbGYkMi5wYWRNYXhDaHVua0xlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgZGlnZXN0IGFuZCBkaWdlc3RGcm9tKiBpbnRlcmZhY2UgcmV0dXJucyB0aGUgaGFzaCBkaWdlc3RcbiAgICAgICAgLy8gYXMgYSBoZXggc3RyaW5nLlxuICAgICAgICB0aGlzLmRpZ2VzdCA9IHRoaXMuZGlnZXN0RnJvbVN0cmluZyA9IHRoaXMuZGlnZXN0RnJvbUJ1ZmZlciA9IHRoaXMuZGlnZXN0RnJvbUFycmF5QnVmZmVyID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIGhleChyYXdEaWdlc3Qoc3RyKS5idWZmZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICA7XG4gICAgLy8gVGhlIGxvdy1sZXZlbCBSdXNoQ29yZSBtb2R1bGUgcHJvdmlkZXMgdGhlIGhlYXJ0IG9mIFJ1c2hhLFxuICAgIC8vIGEgaGlnaC1zcGVlZCBzaGExIGltcGxlbWVudGF0aW9uIHdvcmtpbmcgb24gYW4gSW50MzJBcnJheSBoZWFwLlxuICAgIC8vIEF0IGZpcnN0IGdsYW5jZSwgdGhlIGltcGxlbWVudGF0aW9uIHNlZW1zIGNvbXBsaWNhdGVkLCBob3dldmVyXG4gICAgLy8gd2l0aCB0aGUgU0hBMSBzcGVjIGF0IGhhbmQsIGl0IGlzIG9idmlvdXMgdGhpcyBhbG1vc3QgYSB0ZXh0Ym9va1xuICAgIC8vIGltcGxlbWVudGF0aW9uIHRoYXQgaGFzIGEgZmV3IGZ1bmN0aW9ucyBoYW5kLWlubGluZWQgYW5kIGEgZmV3IGxvb3BzXG4gICAgLy8gaGFuZC11bnJvbGxlZC5cbiAgICBSdXNoYS5fY29yZSA9IGZ1bmN0aW9uIFJ1c2hhQ29yZShzdGRsaWIsIGZvcmVpZ24sIGhlYXApIHtcbiAgICAgICAgJ3VzZSBhc20nO1xuICAgICAgICB2YXIgSCA9IG5ldyBzdGRsaWIuSW50MzJBcnJheShoZWFwKTtcbiAgICAgICAgZnVuY3Rpb24gaGFzaChrLCB4KSB7XG4gICAgICAgICAgICAvLyBrIGluIGJ5dGVzXG4gICAgICAgICAgICBrID0gayB8IDA7XG4gICAgICAgICAgICB4ID0geCB8IDA7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGogPSAwLCB5MCA9IDAsIHowID0gMCwgeTEgPSAwLCB6MSA9IDAsIHkyID0gMCwgejIgPSAwLCB5MyA9IDAsIHozID0gMCwgeTQgPSAwLCB6NCA9IDAsIHQwID0gMCwgdDEgPSAwO1xuICAgICAgICAgICAgeTAgPSBIW3ggKyAzMjAgPj4gMl0gfCAwO1xuICAgICAgICAgICAgeTEgPSBIW3ggKyAzMjQgPj4gMl0gfCAwO1xuICAgICAgICAgICAgeTIgPSBIW3ggKyAzMjggPj4gMl0gfCAwO1xuICAgICAgICAgICAgeTMgPSBIW3ggKyAzMzIgPj4gMl0gfCAwO1xuICAgICAgICAgICAgeTQgPSBIW3ggKyAzMzYgPj4gMl0gfCAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgKGkgfCAwKSA8IChrIHwgMCk7IGkgPSBpICsgNjQgfCAwKSB7XG4gICAgICAgICAgICAgICAgejAgPSB5MDtcbiAgICAgICAgICAgICAgICB6MSA9IHkxO1xuICAgICAgICAgICAgICAgIHoyID0geTI7XG4gICAgICAgICAgICAgICAgejMgPSB5MztcbiAgICAgICAgICAgICAgICB6NCA9IHk0O1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IChqIHwgMCkgPCA2NDsgaiA9IGogKyA0IHwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IEhbaSArIGogPj4gMl0gfCAwO1xuICAgICAgICAgICAgICAgICAgICB0MCA9ICgoeTAgPDwgNSB8IHkwID4+PiAyNykgKyAoeTEgJiB5MiB8IH55MSAmIHkzKSB8IDApICsgKCh0MSArIHk0IHwgMCkgKyAxNTE4NTAwMjQ5IHwgMCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICB5NCA9IHkzO1xuICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IHkxIDw8IDMwIHwgeTEgPj4+IDI7XG4gICAgICAgICAgICAgICAgICAgIHkxID0geTA7XG4gICAgICAgICAgICAgICAgICAgIHkwID0gdDA7XG4gICAgICAgICAgICAgICAgICAgIEhbayArIGogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDY0IHwgMDsgKGogfCAwKSA8IChrICsgODAgfCAwKTsgaiA9IGogKyA0IHwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPDwgMSB8IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPj4+IDMxO1xuICAgICAgICAgICAgICAgICAgICB0MCA9ICgoeTAgPDwgNSB8IHkwID4+PiAyNykgKyAoeTEgJiB5MiB8IH55MSAmIHkzKSB8IDApICsgKCh0MSArIHk0IHwgMCkgKyAxNTE4NTAwMjQ5IHwgMCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICB5NCA9IHkzO1xuICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IHkxIDw8IDMwIHwgeTEgPj4+IDI7XG4gICAgICAgICAgICAgICAgICAgIHkxID0geTA7XG4gICAgICAgICAgICAgICAgICAgIHkwID0gdDA7XG4gICAgICAgICAgICAgICAgICAgIEhbaiA+PiAyXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBrICsgODAgfCAwOyAoaiB8IDApIDwgKGsgKyAxNjAgfCAwKTsgaiA9IGogKyA0IHwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPDwgMSB8IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPj4+IDMxO1xuICAgICAgICAgICAgICAgICAgICB0MCA9ICgoeTAgPDwgNSB8IHkwID4+PiAyNykgKyAoeTEgXiB5MiBeIHkzKSB8IDApICsgKCh0MSArIHk0IHwgMCkgKyAxODU5Nzc1MzkzIHwgMCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICB5NCA9IHkzO1xuICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IHkxIDw8IDMwIHwgeTEgPj4+IDI7XG4gICAgICAgICAgICAgICAgICAgIHkxID0geTA7XG4gICAgICAgICAgICAgICAgICAgIHkwID0gdDA7XG4gICAgICAgICAgICAgICAgICAgIEhbaiA+PiAyXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBrICsgMTYwIHwgMDsgKGogfCAwKSA8IChrICsgMjQwIHwgMCk7IGogPSBqICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pIDw8IDEgfCAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pID4+PiAzMTtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSAoKHkwIDw8IDUgfCB5MCA+Pj4gMjcpICsgKHkxICYgeTIgfCB5MSAmIHkzIHwgeTIgJiB5MykgfCAwKSArICgodDEgKyB5NCB8IDApIC0gMTg5NDAwNzU4OCB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2ogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDI0MCB8IDA7IChqIHwgMCkgPCAoayArIDMyMCB8IDApOyBqID0gaiArIDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gKEhbaiAtIDEyID4+IDJdIF4gSFtqIC0gMzIgPj4gMl0gXiBIW2ogLSA1NiA+PiAyXSBeIEhbaiAtIDY0ID4+IDJdKSA8PCAxIHwgKEhbaiAtIDEyID4+IDJdIF4gSFtqIC0gMzIgPj4gMl0gXiBIW2ogLSA1NiA+PiAyXSBeIEhbaiAtIDY0ID4+IDJdKSA+Pj4gMzE7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gKCh5MCA8PCA1IHwgeTAgPj4+IDI3KSArICh5MSBeIHkyIF4geTMpIHwgMCkgKyAoKHQxICsgeTQgfCAwKSAtIDg5OTQ5NzUxNCB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2ogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeTAgPSB5MCArIHowIHwgMDtcbiAgICAgICAgICAgICAgICB5MSA9IHkxICsgejEgfCAwO1xuICAgICAgICAgICAgICAgIHkyID0geTIgKyB6MiB8IDA7XG4gICAgICAgICAgICAgICAgeTMgPSB5MyArIHozIHwgMDtcbiAgICAgICAgICAgICAgICB5NCA9IHk0ICsgejQgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSFt4ICsgMzIwID4+IDJdID0geTA7XG4gICAgICAgICAgICBIW3ggKyAzMjQgPj4gMl0gPSB5MTtcbiAgICAgICAgICAgIEhbeCArIDMyOCA+PiAyXSA9IHkyO1xuICAgICAgICAgICAgSFt4ICsgMzMyID4+IDJdID0geTM7XG4gICAgICAgICAgICBIW3ggKyAzMzYgPj4gMl0gPSB5NDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoYXNoOiBoYXNoIH07XG4gICAgfTtcbiAgICAvLyBJZiB3ZSdlIHJ1bm5pbmcgaW4gTm9kZS5KUywgZXhwb3J0IGEgbW9kdWxlLlxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFJ1c2hhO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LlJ1c2hhID0gUnVzaGE7XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgaW4gYSB3ZWJ3b3JrZXIsIGFjY2VwdFxuICAgIC8vIG1lc3NhZ2VzIGNvbnRhaW5pbmcgYSBqb2JpZCBhbmQgYSBidWZmZXJcbiAgICAvLyBvciBibG9iIG9iamVjdCwgYW5kIHJldHVybiB0aGUgaGFzaCByZXN1bHQuXG4gICAgaWYgKHR5cGVvZiBGaWxlUmVhZGVyU3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyU3luYygpLCBoYXNoZXIgPSBuZXcgUnVzaGEoNCAqIDEwMjQgKiAxMDI0KTtcbiAgICAgICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYXNoLCBkYXRhID0gZXZlbnQuZGF0YS5kYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYXNoID0gaGFzaGVyLmRpZ2VzdChkYXRhKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGhhc2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnYnVmZmVyJylcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGNodW5rcyA9IFtdXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICB9KVxuICBzdHJlYW0ub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikgY2IobnVsbCwgQnVmZmVyLmNvbmNhdChjaHVua3MpKVxuICAgIGNiID0gbnVsbFxuICB9KVxuICBzdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNiKSBjYihlcnIpXG4gICAgY2IgPSBudWxsXG4gIH0pXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNpbXBsZUdldFxuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJylcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgdW56aXBSZXNwb25zZSA9IHJlcXVpcmUoJ3VuemlwLXJlc3BvbnNlJykgLy8gZXhjbHVkZWQgZnJvbSBicm93c2VyIGJ1aWxkXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxuZnVuY3Rpb24gc2ltcGxlR2V0IChvcHRzLCBjYikge1xuICBvcHRzID0gdHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnID8geyB1cmw6IG9wdHMgfSA6IGV4dGVuZChvcHRzKVxuICBjYiA9IG9uY2UoY2IpXG5cbiAgaWYgKG9wdHMudXJsKSBwYXJzZU9wdHNVcmwob3B0cylcbiAgaWYgKG9wdHMuaGVhZGVycyA9PSBudWxsKSBvcHRzLmhlYWRlcnMgPSB7fVxuICBpZiAob3B0cy5tYXhSZWRpcmVjdHMgPT0gbnVsbCkgb3B0cy5tYXhSZWRpcmVjdHMgPSAxMFxuXG4gIHZhciBib2R5ID0gb3B0cy5ib2R5XG4gIG9wdHMuYm9keSA9IHVuZGVmaW5lZFxuICBpZiAoYm9keSAmJiAhb3B0cy5tZXRob2QpIG9wdHMubWV0aG9kID0gJ1BPU1QnXG5cbiAgLy8gUmVxdWVzdCBnemlwL2RlZmxhdGVcbiAgdmFyIGN1c3RvbUFjY2VwdEVuY29kaW5nID0gT2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgcmV0dXJuIGgudG9Mb3dlckNhc2UoKSA9PT0gJ2FjY2VwdC1lbmNvZGluZydcbiAgfSlcbiAgaWYgKCFjdXN0b21BY2NlcHRFbmNvZGluZykgb3B0cy5oZWFkZXJzWydhY2NlcHQtZW5jb2RpbmcnXSA9ICdnemlwLCBkZWZsYXRlJ1xuXG4gIC8vIFN1cHBvcnQgaHR0cDogYW5kIGh0dHBzOiB1cmxzXG4gIHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgPT09ICdodHRwczonID8gaHR0cHMgOiBodHRwXG4gIHZhciByZXEgPSBwcm90b2NvbC5yZXF1ZXN0KG9wdHMsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAvLyBGb2xsb3cgM3h4IHJlZGlyZWN0c1xuICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAzMDAgJiYgcmVzLnN0YXR1c0NvZGUgPCA0MDAgJiYgJ2xvY2F0aW9uJyBpbiByZXMuaGVhZGVycykge1xuICAgICAgb3B0cy51cmwgPSByZXMuaGVhZGVycy5sb2NhdGlvblxuICAgICAgcGFyc2VPcHRzVXJsKG9wdHMpXG4gICAgICByZXMucmVzdW1lKCkgLy8gRGlzY2FyZCByZXNwb25zZVxuXG4gICAgICBvcHRzLm1heFJlZGlyZWN0cyAtPSAxXG4gICAgICBpZiAob3B0cy5tYXhSZWRpcmVjdHMgPiAwKSBzaW1wbGVHZXQob3B0cywgY2IpXG4gICAgICBlbHNlIGNiKG5ldyBFcnJvcigndG9vIG1hbnkgcmVkaXJlY3RzJykpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNiKG51bGwsIHR5cGVvZiB1bnppcFJlc3BvbnNlID09PSAnZnVuY3Rpb24nID8gdW56aXBSZXNwb25zZShyZXMpIDogcmVzKVxuICB9KVxuICByZXEub24oJ2Vycm9yJywgY2IpXG4gIHJlcS5lbmQoYm9keSlcbiAgcmV0dXJuIHJlcVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25jYXQgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgcmV0dXJuIHNpbXBsZUdldChvcHRzLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHZhciBjaHVua3MgPSBbXVxuICAgIHJlcy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgfSlcbiAgICByZXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIHJlcywgQnVmZmVyLmNvbmNhdChjaHVua3MpKVxuICAgIH0pXG4gIH0pXG59XG5cbjtbJ2dldCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdoZWFkJywgJ2RlbGV0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBtb2R1bGUuZXhwb3J0c1ttZXRob2RdID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykgb3B0cyA9IHsgdXJsOiBvcHRzIH1cbiAgICBvcHRzLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIHNpbXBsZUdldChvcHRzLCBjYilcbiAgfVxufSlcblxuZnVuY3Rpb24gcGFyc2VPcHRzVXJsIChvcHRzKSB7XG4gIHZhciBsb2MgPSB1cmwucGFyc2Uob3B0cy51cmwpXG4gIGlmIChsb2MuaG9zdG5hbWUpIG9wdHMuaG9zdG5hbWUgPSBsb2MuaG9zdG5hbWVcbiAgaWYgKGxvYy5wb3J0KSBvcHRzLnBvcnQgPSBsb2MucG9ydFxuICBpZiAobG9jLnByb3RvY29sKSBvcHRzLnByb3RvY29sID0gbG9jLnByb3RvY29sXG4gIGlmIChsb2MuYXV0aCkgb3B0cy5hdXRoID0gbG9jLmF1dGhcbiAgb3B0cy5wYXRoID0gbG9jLnBhdGhcbiAgZGVsZXRlIG9wdHMudXJsXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBlZXJcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc2ltcGxlLXBlZXInKVxudmFyIGdldEJyb3dzZXJSVEMgPSByZXF1aXJlKCdnZXQtYnJvd3Nlci1ydGMnKVxudmFyIGhhdCA9IHJlcXVpcmUoJ2hhdCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbmluaGVyaXRzKFBlZXIsIHN0cmVhbS5EdXBsZXgpXG5cbi8qKlxuICogV2ViUlRDIHBlZXIgY29ubmVjdGlvbi4gU2FtZSBBUEkgYXMgbm9kZSBjb3JlIGBuZXQuU29ja2V0YCwgcGx1cyBhIGZldyBleHRyYSBtZXRob2RzLlxuICogRHVwbGV4IHN0cmVhbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFBlZXIgKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBQZWVyKSkgcmV0dXJuIG5ldyBQZWVyKG9wdHMpXG4gIHNlbGYuX2RlYnVnKCduZXcgcGVlciAlbycsIG9wdHMpXG5cbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cy5hbGxvd0hhbGZPcGVuID0gZmFsc2VcbiAgaWYgKG9wdHMuaGlnaFdhdGVyTWFyayA9PSBudWxsKSBvcHRzLmhpZ2hXYXRlck1hcmsgPSAxMDI0ICogMTAyNFxuXG4gIHN0cmVhbS5EdXBsZXguY2FsbChzZWxmLCBvcHRzKVxuXG4gIHNlbGYuaW5pdGlhdG9yID0gb3B0cy5pbml0aWF0b3IgfHwgZmFsc2VcbiAgc2VsZi5jaGFubmVsQ29uZmlnID0gb3B0cy5jaGFubmVsQ29uZmlnIHx8IFBlZXIuY2hhbm5lbENvbmZpZ1xuICBzZWxmLmNoYW5uZWxOYW1lID0gb3B0cy5pbml0aWF0b3IgPyAob3B0cy5jaGFubmVsTmFtZSB8fCBoYXQoMTYwKSkgOiBudWxsXG4gIHNlbGYuY29uZmlnID0gb3B0cy5jb25maWcgfHwgUGVlci5jb25maWdcbiAgc2VsZi5jb25zdHJhaW50cyA9IG9wdHMuY29uc3RyYWludHMgfHwgUGVlci5jb25zdHJhaW50c1xuICBzZWxmLm9mZmVyQ29uc3RyYWludHMgPSBvcHRzLm9mZmVyQ29uc3RyYWludHNcbiAgc2VsZi5hbnN3ZXJDb25zdHJhaW50cyA9IG9wdHMuYW5zd2VyQ29uc3RyYWludHNcbiAgc2VsZi5yZWNvbm5lY3RUaW1lciA9IG9wdHMucmVjb25uZWN0VGltZXIgfHwgZmFsc2VcbiAgc2VsZi5zZHBUcmFuc2Zvcm0gPSBvcHRzLnNkcFRyYW5zZm9ybSB8fCBmdW5jdGlvbiAoc2RwKSB7IHJldHVybiBzZHAgfVxuICBzZWxmLnN0cmVhbSA9IG9wdHMuc3RyZWFtIHx8IGZhbHNlXG4gIHNlbGYudHJpY2tsZSA9IG9wdHMudHJpY2tsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy50cmlja2xlIDogdHJ1ZVxuXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuXG4gIC8vIHNvIFBlZXIgb2JqZWN0IGFsd2F5cyBoYXMgc2FtZSBzaGFwZSAoVjggb3B0aW1pemF0aW9uKVxuICBzZWxmLnJlbW90ZUFkZHJlc3MgPSB1bmRlZmluZWRcbiAgc2VsZi5yZW1vdGVGYW1pbHkgPSB1bmRlZmluZWRcbiAgc2VsZi5yZW1vdGVQb3J0ID0gdW5kZWZpbmVkXG4gIHNlbGYubG9jYWxBZGRyZXNzID0gdW5kZWZpbmVkXG4gIHNlbGYubG9jYWxQb3J0ID0gdW5kZWZpbmVkXG5cbiAgc2VsZi5faXNXcnRjID0gISFvcHRzLndydGMgLy8gSEFDSzogdG8gZml4IGB3cnRjYCBidWcuIFNlZSBpc3N1ZTogIzYwXG4gIHNlbGYuX3dydGMgPSAob3B0cy53cnRjICYmIHR5cGVvZiBvcHRzLndydGMgPT09ICdvYmplY3QnKVxuICAgID8gb3B0cy53cnRjXG4gICAgOiBnZXRCcm93c2VyUlRDKClcbiAgaWYgKCFzZWxmLl93cnRjKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBTcGVjaWZ5IGBvcHRzLndydGNgIG9wdGlvbiBpbiB0aGlzIGVudmlyb25tZW50JylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBXZWJSVEMgc3VwcG9ydDogTm90IGEgc3VwcG9ydGVkIGJyb3dzZXInKVxuICAgIH1cbiAgfVxuXG4gIHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50ID0gb3B0cy5oaWdoV2F0ZXJNYXJrXG4gIHNlbGYuX3BjUmVhZHkgPSBmYWxzZVxuICBzZWxmLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICBzZWxmLl9pY2VDb21wbGV0ZSA9IGZhbHNlIC8vIGljZSBjYW5kaWRhdGUgdHJpY2tsZSBkb25lIChnb3QgbnVsbCBjYW5kaWRhdGUpXG4gIHNlbGYuX2NoYW5uZWwgPSBudWxsXG4gIHNlbGYuX3BlbmRpbmdDYW5kaWRhdGVzID0gW11cblxuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG4gIHNlbGYuX2ludGVydmFsID0gbnVsbFxuICBzZWxmLl9yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbFxuXG4gIHNlbGYuX3BjID0gbmV3IChzZWxmLl93cnRjLlJUQ1BlZXJDb25uZWN0aW9uKShzZWxmLmNvbmZpZywgc2VsZi5jb25zdHJhaW50cylcbiAgc2VsZi5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UoKVxuICB9XG4gIHNlbGYuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25TaWduYWxpbmdTdGF0ZUNoYW5nZSgpXG4gIH1cbiAgc2VsZi5fcGMub25pY2VjYW5kaWRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBzZWxmLl9vbkljZUNhbmRpZGF0ZShldmVudClcbiAgfVxuXG4gIGlmIChzZWxmLnN0cmVhbSkgc2VsZi5fcGMuYWRkU3RyZWFtKHNlbGYuc3RyZWFtKVxuICBzZWxmLl9wYy5vbmFkZHN0cmVhbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHNlbGYuX29uQWRkU3RyZWFtKGV2ZW50KVxuICB9XG5cbiAgaWYgKHNlbGYuaW5pdGlhdG9yKSB7XG4gICAgc2VsZi5fc2V0dXBEYXRhKHtcbiAgICAgIGNoYW5uZWw6IHNlbGYuX3BjLmNyZWF0ZURhdGFDaGFubmVsKHNlbGYuY2hhbm5lbE5hbWUsIHNlbGYuY2hhbm5lbENvbmZpZylcbiAgICB9KVxuICAgIHNlbGYuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX2NyZWF0ZU9mZmVyKClcbiAgICB9KVxuICAgIC8vIE9ubHkgQ2hyb21lIHRyaWdnZXJzIFwibmVnb3RpYXRpb25uZWVkZWRcIjsgdGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIG90aGVyXG4gICAgLy8gaW1wbGVtZW50YXRpb25zXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHNlbGYuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQoKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9wYy5vbmRhdGFjaGFubmVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzZWxmLl9zZXR1cERhdGEoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgc2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgICAgLy8gV2hlbiBsb2NhbCBwZWVyIGlzIGZpbmlzaGVkIHdyaXRpbmcsIGNsb3NlIGNvbm5lY3Rpb24gdG8gcmVtb3RlIHBlZXIuXG4gICAgICAvLyBIYWxmIG9wZW4gY29ubmVjdGlvbnMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxuICAgICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgZGVzdHJveWluZyBzbyB0aGUgZGF0YWNoYW5uZWwgZmx1c2hlcy5cbiAgICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgbW9yZSByZWxpYWJsZSB3YXkgdG8gYWNjb21wbGlzaCB0aGlzP1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgfSwgMTAwKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBkYXRhIGNoYW5uZWwgaXMgbm90IGNvbm5lY3RlZCB3aGVuIGxvY2FsIHBlZXIgaXMgZmluaXNoZWQgd3JpdGluZywgd2FpdCB1bnRpbFxuICAgICAgLy8gZGF0YSBpcyBmbHVzaGVkIHRvIG5ldHdvcmsgYXQgXCJjb25uZWN0XCIgZXZlbnQuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNlbGYub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICAgIH0sIDEwMClcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5QZWVyLldFQlJUQ19TVVBQT1JUID0gISFnZXRCcm93c2VyUlRDKClcblxuLyoqXG4gKiBFeHBvc2UgY29uZmlnLCBjb25zdHJhaW50cywgYW5kIGRhdGEgY2hhbm5lbCBjb25maWcgZm9yIG92ZXJyaWRpbmcgYWxsIFBlZXJcbiAqIGluc3RhbmNlcy4gT3RoZXJ3aXNlLCBqdXN0IHNldCBvcHRzLmNvbmZpZywgb3B0cy5jb25zdHJhaW50cywgb3Igb3B0cy5jaGFubmVsQ29uZmlnXG4gKiB3aGVuIGNvbnN0cnVjdGluZyBhIFBlZXIuXG4gKi9cblBlZXIuY29uZmlnID0ge1xuICBpY2VTZXJ2ZXJzOiBbXG4gICAge1xuICAgICAgdXJsOiAnc3R1bjoyMy4yMS4xNTAuMTIxJywgLy8gZGVwcmVjYXRlZCwgcmVwbGFjZWQgYnkgYHVybHNgXG4gICAgICB1cmxzOiAnc3R1bjoyMy4yMS4xNTAuMTIxJ1xuICAgIH1cbiAgXVxufVxuUGVlci5jb25zdHJhaW50cyA9IHt9XG5QZWVyLmNoYW5uZWxDb25maWcgPSB7fVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlci5wcm90b3R5cGUsICdidWZmZXJTaXplJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICByZXR1cm4gKHNlbGYuX2NoYW5uZWwgJiYgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCkgfHwgMFxuICB9XG59KVxuXG5QZWVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHsgcG9ydDogc2VsZi5sb2NhbFBvcnQsIGZhbWlseTogJ0lQdjQnLCBhZGRyZXNzOiBzZWxmLmxvY2FsQWRkcmVzcyB9XG59XG5cblBlZXIucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNpZ25hbCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRhdGEgPSB7fVxuICAgIH1cbiAgfVxuICBzZWxmLl9kZWJ1Zygnc2lnbmFsKCknKVxuXG4gIGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX3BjLmFkZEljZUNhbmRpZGF0ZShcbiAgICAgICAgbmV3IHNlbGYuX3dydGMuUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSksXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH1cbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNlbGYuX2Rlc3Ryb3kobmV3IEVycm9yKCdlcnJvciBhZGRpbmcgY2FuZGlkYXRlOiAnICsgZXJyLm1lc3NhZ2UpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRhLnNkcCkge1xuICAgIHNlbGYuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyAoc2VsZi5fd3J0Yy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGRhdGEpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgaWYgKHNlbGYuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHNlbGYuX2NyZWF0ZUFuc3dlcigpXG5cbiAgICAgIHNlbGYuX3BlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goYWRkSWNlQ2FuZGlkYXRlKVxuICAgICAgc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH0pXG4gIH1cbiAgaWYgKGRhdGEuY2FuZGlkYXRlKSB7XG4gICAgaWYgKHNlbGYuX3BjLnJlbW90ZURlc2NyaXB0aW9uKSBhZGRJY2VDYW5kaWRhdGUoZGF0YS5jYW5kaWRhdGUpXG4gICAgZWxzZSBzZWxmLl9wZW5kaW5nQ2FuZGlkYXRlcy5wdXNoKGRhdGEuY2FuZGlkYXRlKVxuICB9XG4gIGlmICghZGF0YS5zZHAgJiYgIWRhdGEuY2FuZGlkYXRlKSB7XG4gICAgc2VsZi5fZGVzdHJveShuZXcgRXJyb3IoJ3NpZ25hbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgc2lnbmFsIGRhdGEnKSlcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGV4dC9iaW5hcnkgZGF0YSB0byB0aGUgcmVtb3RlIHBlZXIuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlWaWV3fEFycmF5QnVmZmVyfEJ1ZmZlcnxzdHJpbmd8QmxvYnxPYmplY3R9IGNodW5rXG4gKi9cblBlZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgLy8gSEFDSzogYHdydGNgIG1vZHVsZSBkb2Vzbid0IGFjY2VwdCBub2RlLmpzIGJ1ZmZlci4gU2VlIGlzc3VlOiAjNjBcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgc2VsZi5faXNXcnRjKSB7XG4gICAgY2h1bmsgPSBuZXcgVWludDhBcnJheShjaHVuaylcbiAgfVxuXG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGggfHwgY2h1bmsuYnl0ZUxlbmd0aCB8fCBjaHVuay5zaXplXG4gIHNlbGYuX2NoYW5uZWwuc2VuZChjaHVuaylcbiAgc2VsZi5fZGVidWcoJ3dyaXRlOiAlZCBieXRlcycsIGxlbilcbn1cblxuUGVlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvbmNsb3NlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZXN0cm95KG51bGwsIG9uY2xvc2UpXG59XG5cblBlZXIucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgb25jbG9zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgaWYgKG9uY2xvc2UpIHNlbGYub25jZSgnY2xvc2UnLCBvbmNsb3NlKVxuXG4gIHNlbGYuX2RlYnVnKCdkZXN0cm95IChlcnJvcjogJXMpJywgZXJyICYmIGVyci5tZXNzYWdlKVxuXG4gIHNlbGYucmVhZGFibGUgPSBzZWxmLndyaXRhYmxlID0gZmFsc2VcblxuICBpZiAoIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHNlbGYucHVzaChudWxsKVxuICBpZiAoIXNlbGYuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHNlbGYuZW5kKClcblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuICBzZWxmLl9wY1JlYWR5ID0gZmFsc2VcbiAgc2VsZi5fY2hhbm5lbFJlYWR5ID0gZmFsc2VcblxuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpXG4gIGNsZWFyVGltZW91dChzZWxmLl9yZWNvbm5lY3RUaW1lb3V0KVxuXG4gIGlmIChzZWxmLl9wYykge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLl9wYy5jbG9zZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgc2VsZi5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgc2VsZi5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbmFkZHN0cmVhbSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbFxuICAgIHNlbGYuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsXG4gIH1cblxuICBpZiAoc2VsZi5fY2hhbm5lbCkge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLl9jaGFubmVsLmNsb3NlKClcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICBzZWxmLl9jaGFubmVsLm9ubWVzc2FnZSA9IG51bGxcbiAgICBzZWxmLl9jaGFubmVsLm9ub3BlbiA9IG51bGxcbiAgICBzZWxmLl9jaGFubmVsLm9uY2xvc2UgPSBudWxsXG4gIH1cbiAgc2VsZi5fcGMgPSBudWxsXG4gIHNlbGYuX2NoYW5uZWwgPSBudWxsXG5cbiAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgc2VsZi5lbWl0KCdjbG9zZScpXG59XG5cblBlZXIucHJvdG90eXBlLl9zZXR1cERhdGEgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2NoYW5uZWwgPSBldmVudC5jaGFubmVsXG4gIHNlbGYuY2hhbm5lbE5hbWUgPSBzZWxmLl9jaGFubmVsLmxhYmVsXG5cbiAgc2VsZi5fY2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICBzZWxmLl9jaGFubmVsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHNlbGYuX29uQ2hhbm5lbE1lc3NhZ2UoZXZlbnQpXG4gIH1cbiAgc2VsZi5fY2hhbm5lbC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25DaGFubmVsT3BlbigpXG4gIH1cbiAgc2VsZi5fY2hhbm5lbC5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uQ2hhbm5lbENsb3NlKClcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cblBlZXIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYihuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpKVxuXG4gIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLnNlbmQoY2h1bmspXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5fb25FcnJvcihlcnIpXG4gICAgfVxuICAgIGlmIChzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50ID4gc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICAgIHNlbGYuX2NiID0gY2JcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fZGVidWcoJ3dyaXRlIGJlZm9yZSBjb25uZWN0JylcbiAgICBzZWxmLl9jaHVuayA9IGNodW5rXG4gICAgc2VsZi5fY2IgPSBjYlxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9jcmVhdGVPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fcGMuY3JlYXRlT2ZmZXIoZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBvZmZlci5zZHAgPSBzZWxmLnNkcFRyYW5zZm9ybShvZmZlci5zZHApXG4gICAgc2VsZi5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlciwgbm9vcCwgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfSlcbiAgICB2YXIgc2VuZE9mZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpZ25hbCA9IHNlbGYuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgb2ZmZXJcbiAgICAgIHNlbGYuX2RlYnVnKCdzaWduYWwnKVxuICAgICAgc2VsZi5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgIHR5cGU6IHNpZ25hbC50eXBlLFxuICAgICAgICBzZHA6IHNpZ25hbC5zZHBcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChzZWxmLnRyaWNrbGUgfHwgc2VsZi5faWNlQ29tcGxldGUpIHNlbmRPZmZlcigpXG4gICAgZWxzZSBzZWxmLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRPZmZlcikgLy8gd2FpdCBmb3IgY2FuZGlkYXRlc1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9LCBzZWxmLm9mZmVyQ29uc3RyYWludHMpXG59XG5cblBlZXIucHJvdG90eXBlLl9jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHNlbGYuX3BjLmNyZWF0ZUFuc3dlcihmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBhbnN3ZXIuc2RwID0gc2VsZi5zZHBUcmFuc2Zvcm0oYW5zd2VyLnNkcClcbiAgICBzZWxmLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlciwgbm9vcCwgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfSlcbiAgICB2YXIgc2VuZEFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaWduYWwgPSBzZWxmLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IGFuc3dlclxuICAgICAgc2VsZi5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICBzZWxmLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgdHlwZTogc2lnbmFsLnR5cGUsXG4gICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHNlbGYudHJpY2tsZSB8fCBzZWxmLl9pY2VDb21wbGV0ZSkgc2VuZEFuc3dlcigpXG4gICAgZWxzZSBzZWxmLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRBbnN3ZXIpXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH0sIHNlbGYuYW5zd2VyQ29uc3RyYWludHMpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBpY2VHYXRoZXJpbmdTdGF0ZSA9IHNlbGYuX3BjLmljZUdhdGhlcmluZ1N0YXRlXG4gIHZhciBpY2VDb25uZWN0aW9uU3RhdGUgPSBzZWxmLl9wYy5pY2VDb25uZWN0aW9uU3RhdGVcbiAgc2VsZi5fZGVidWcoJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSAlcyAlcycsIGljZUdhdGhlcmluZ1N0YXRlLCBpY2VDb25uZWN0aW9uU3RhdGUpXG4gIHNlbGYuZW1pdCgnaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlJywgaWNlR2F0aGVyaW5nU3RhdGUsIGljZUNvbm5lY3Rpb25TdGF0ZSlcbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJykge1xuICAgIGNsZWFyVGltZW91dChzZWxmLl9yZWNvbm5lY3RUaW1lb3V0KVxuICAgIHNlbGYuX3BjUmVhZHkgPSB0cnVlXG4gICAgc2VsZi5fbWF5YmVSZWFkeSgpXG4gIH1cbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICBpZiAoc2VsZi5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgLy8gSWYgdXNlciBoYXMgc2V0IGBvcHQucmVjb25uZWN0VGltZXJgLCBhbGxvdyB0aW1lIGZvciBJQ0UgdG8gYXR0ZW1wdCBhIHJlY29ubmVjdFxuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3JlY29ubmVjdFRpbWVvdXQpXG4gICAgICBzZWxmLl9yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgfSwgc2VsZi5yZWNvbm5lY3RUaW1lcilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgfVxuICB9XG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgc2VsZi5fZGVzdHJveSgpXG4gIH1cbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBzZWxmLl9kZXN0cm95KClcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl9wYy5nZXRTdGF0cykgeyAvLyBObyBhYmlsaXR5IHRvIGNhbGwgc3RhdHNcbiAgICBjYihbXSlcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikgeyAvLyBNb3ppbGxhXG4gICAgc2VsZi5fcGMuZ2V0U3RhdHMobnVsbCwgZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIGl0ZW1zID0gW11cbiAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSlcbiAgICAgIH0pXG4gICAgICBjYihpdGVtcylcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9KVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX3BjLmdldFN0YXRzKGZ1bmN0aW9uIChyZXMpIHsgLy8gQ2hyb21lXG4gICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgcmVzLnJlc3VsdCgpLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB2YXIgaXRlbSA9IHt9XG4gICAgICAgIHJlc3VsdC5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpdGVtW25hbWVdID0gcmVzdWx0LnN0YXQobmFtZSlcbiAgICAgICAgfSlcbiAgICAgICAgaXRlbS5pZCA9IHJlc3VsdC5pZFxuICAgICAgICBpdGVtLnR5cGUgPSByZXN1bHQudHlwZVxuICAgICAgICBpdGVtLnRpbWVzdGFtcCA9IHJlc3VsdC50aW1lc3RhbXBcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuICAgICAgfSlcbiAgICAgIGNiKGl0ZW1zKVxuICAgIH0pXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX21heWJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZWJ1ZygnbWF5YmVSZWFkeSBwYyAlcyBjaGFubmVsICVzJywgc2VsZi5fcGNSZWFkeSwgc2VsZi5fY2hhbm5lbFJlYWR5KVxuICBpZiAoc2VsZi5jb25uZWN0ZWQgfHwgc2VsZi5fY29ubmVjdGluZyB8fCAhc2VsZi5fcGNSZWFkeSB8fCAhc2VsZi5fY2hhbm5lbFJlYWR5KSByZXR1cm5cbiAgc2VsZi5fY29ubmVjdGluZyA9IHRydWVcblxuICBzZWxmLmdldFN0YXRzKGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHNlbGYuX2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHNlbGYuY29ubmVjdGVkID0gdHJ1ZVxuXG4gICAgdmFyIHJlbW90ZUNhbmRpZGF0ZXMgPSB7fVxuICAgIHZhciBsb2NhbENhbmRpZGF0ZXMgPSB7fVxuXG4gICAgZnVuY3Rpb24gc2V0QWN0aXZlQ2FuZGlkYXRlcyAoaXRlbSkge1xuICAgICAgdmFyIGxvY2FsID0gbG9jYWxDYW5kaWRhdGVzW2l0ZW0ubG9jYWxDYW5kaWRhdGVJZF1cbiAgICAgIHZhciByZW1vdGUgPSByZW1vdGVDYW5kaWRhdGVzW2l0ZW0ucmVtb3RlQ2FuZGlkYXRlSWRdXG5cbiAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICBzZWxmLmxvY2FsQWRkcmVzcyA9IGxvY2FsLmlwQWRkcmVzc1xuICAgICAgICBzZWxmLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbC5wb3J0TnVtYmVyKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbS5nb29nTG9jYWxBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBTb21ldGltZXMgYGl0ZW0uaWRgIGlzIHVuZGVmaW5lZCBpbiBgd3J0Y2AgYW5kIENocm9tZVxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3Mvc2ltcGxlLXBlZXIvaXNzdWVzLzY2XG4gICAgICAgIGxvY2FsID0gaXRlbS5nb29nTG9jYWxBZGRyZXNzLnNwbGl0KCc6JylcbiAgICAgICAgc2VsZi5sb2NhbEFkZHJlc3MgPSBsb2NhbFswXVxuICAgICAgICBzZWxmLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbFsxXSlcbiAgICAgIH1cbiAgICAgIHNlbGYuX2RlYnVnKCdjb25uZWN0IGxvY2FsOiAlczolcycsIHNlbGYubG9jYWxBZGRyZXNzLCBzZWxmLmxvY2FsUG9ydClcblxuICAgICAgaWYgKHJlbW90ZSkge1xuICAgICAgICBzZWxmLnJlbW90ZUFkZHJlc3MgPSByZW1vdGUuaXBBZGRyZXNzXG4gICAgICAgIHNlbGYucmVtb3RlUG9ydCA9IE51bWJlcihyZW1vdGUucG9ydE51bWJlcilcbiAgICAgICAgc2VsZi5yZW1vdGVGYW1pbHkgPSAnSVB2NCdcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0uZ29vZ1JlbW90ZUFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlbW90ZSA9IGl0ZW0uZ29vZ1JlbW90ZUFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICBzZWxmLnJlbW90ZUFkZHJlc3MgPSByZW1vdGVbMF1cbiAgICAgICAgc2VsZi5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZVsxXSlcbiAgICAgICAgc2VsZi5yZW1vdGVGYW1pbHkgPSAnSVB2NCdcbiAgICAgIH1cbiAgICAgIHNlbGYuX2RlYnVnKCdjb25uZWN0IHJlbW90ZTogJXM6JXMnLCBzZWxmLnJlbW90ZUFkZHJlc3MsIHNlbGYucmVtb3RlUG9ydClcbiAgICB9XG5cbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbS50eXBlID09PSAncmVtb3RlY2FuZGlkYXRlJykgcmVtb3RlQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdsb2NhbGNhbmRpZGF0ZScpIGxvY2FsQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICB9KVxuXG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGlzQ2FuZGlkYXRlUGFpciA9IChcbiAgICAgICAgKGl0ZW0udHlwZSA9PT0gJ2dvb2dDYW5kaWRhdGVQYWlyJyAmJiBpdGVtLmdvb2dBY3RpdmVDb25uZWN0aW9uID09PSAndHJ1ZScpIHx8XG4gICAgICAgIChpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGVwYWlyJyAmJiBpdGVtLnNlbGVjdGVkKVxuICAgICAgKVxuICAgICAgaWYgKGlzQ2FuZGlkYXRlUGFpcikgc2V0QWN0aXZlQ2FuZGlkYXRlcyhpdGVtKVxuICAgIH0pXG5cbiAgICBpZiAoc2VsZi5fY2h1bmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuc2VuZChzZWxmLl9jaHVuaylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZi5fb25FcnJvcihlcnIpXG4gICAgICB9XG4gICAgICBzZWxmLl9jaHVuayA9IG51bGxcbiAgICAgIHNlbGYuX2RlYnVnKCdzZW50IGNodW5rIGZyb20gXCJ3cml0ZSBiZWZvcmUgY29ubmVjdFwiJylcblxuICAgICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICAgIHNlbGYuX2NiID0gbnVsbFxuICAgICAgY2IobnVsbClcbiAgICB9XG5cbiAgICBzZWxmLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5fY2IgfHwgIXNlbGYuX2NoYW5uZWwgfHwgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50KSByZXR1cm5cbiAgICAgIHNlbGYuX2RlYnVnKCdlbmRpbmcgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpXG4gICAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSBudWxsXG4gICAgICBjYihudWxsKVxuICAgIH0sIDE1MClcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwudW5yZWYpIHNlbGYuX2ludGVydmFsLnVucmVmKClcblxuICAgIHNlbGYuX2RlYnVnKCdjb25uZWN0JylcbiAgICBzZWxmLmVtaXQoJ2Nvbm5lY3QnKVxuICB9KVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25TaWduYWxpbmdTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdzaWduYWxpbmdTdGF0ZUNoYW5nZSAlcycsIHNlbGYuX3BjLnNpZ25hbGluZ1N0YXRlKVxuICBzZWxmLmVtaXQoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlJywgc2VsZi5fcGMuc2lnbmFsaW5nU3RhdGUpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiBzZWxmLnRyaWNrbGUpIHtcbiAgICBzZWxmLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgIGNhbmRpZGF0ZToge1xuICAgICAgICBjYW5kaWRhdGU6IGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUsXG4gICAgICAgIHNkcE1MaW5lSW5kZXg6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxuICAgICAgICBzZHBNaWQ6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNaWRcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2UgaWYgKCFldmVudC5jYW5kaWRhdGUpIHtcbiAgICBzZWxmLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICBzZWxmLmVtaXQoJ19pY2VDb21wbGV0ZScpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBkYXRhID0gZXZlbnQuZGF0YVxuICBzZWxmLl9kZWJ1ZygncmVhZDogJWQgYnl0ZXMnLCBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGgpXG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcbiAgc2VsZi5wdXNoKGRhdGEpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkNoYW5uZWxPcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuY29ubmVjdGVkIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ29uIGNoYW5uZWwgb3BlbicpXG4gIHNlbGYuX2NoYW5uZWxSZWFkeSA9IHRydWVcbiAgc2VsZi5fbWF5YmVSZWFkeSgpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkNoYW5uZWxDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdvbiBjaGFubmVsIGNsb3NlJylcbiAgc2VsZi5fZGVzdHJveSgpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkFkZFN0cmVhbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ29uIGFkZCBzdHJlYW0nKVxuICBzZWxmLmVtaXQoJ3N0cmVhbScsIGV2ZW50LnN0cmVhbSlcbn1cblxuUGVlci5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1ZygnZXJyb3IgJXMnLCBlcnIubWVzc2FnZSB8fCBlcnIpXG4gIHNlbGYuX2Rlc3Ryb3koZXJyKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB2YXIgaWQgPSBzZWxmLmNoYW5uZWxOYW1lICYmIHNlbGYuY2hhbm5lbE5hbWUuc3Vic3RyaW5nKDAsIDcpXG4gIGFyZ3NbMF0gPSAnWycgKyBpZCArICddICcgKyBhcmdzWzBdXG4gIGRlYnVnLmFwcGx5KG51bGwsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbiIsInZhciBSdXNoYSA9IHJlcXVpcmUoJ3J1c2hhJylcblxudmFyIHJ1c2hhID0gbmV3IFJ1c2hhXG52YXIgY3J5cHRvID0gd2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG8gfHwge31cbnZhciBzdWJ0bGUgPSBjcnlwdG8uc3VidGxlIHx8IGNyeXB0by53ZWJraXRTdWJ0bGVcblxuZnVuY3Rpb24gc2hhMXN5bmMgKGJ1Zikge1xuICByZXR1cm4gcnVzaGEuZGlnZXN0KGJ1Zilcbn1cblxuLy8gQnJvd3NlcnMgdGhyb3cgaWYgdGhleSBsYWNrIHN1cHBvcnQgZm9yIGFuIGFsZ29yaXRobS5cbi8vIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCBvbiBub24tc2VjdXJlIG9yaWdpbnMuIChodHRwOi8vZ29vLmdsL2xxNGdDbylcbnRyeSB7XG4gIHN1YnRsZS5kaWdlc3QoeyBuYW1lOiAnc2hhLTEnIH0sIG5ldyBVaW50OEFycmF5KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgc3VidGxlID0gZmFsc2VcbiAgfSlcbn0gY2F0Y2ggKGVycikgeyBzdWJ0bGUgPSBmYWxzZSB9XG5cbmZ1bmN0aW9uIHNoYTEgKGJ1ZiwgY2IpIHtcbiAgaWYgKCFzdWJ0bGUpIHtcbiAgICAvLyBVc2UgUnVzaGFcbiAgICBzZXRUaW1lb3V0KGNiLCAwLCBzaGExc3luYyhidWYpKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gdWludDhhcnJheShidWYpXG4gIH1cblxuICBzdWJ0bGUuZGlnZXN0KHsgbmFtZTogJ3NoYS0xJyB9LCBidWYpXG4gICAgLnRoZW4oZnVuY3Rpb24gc3VjY2VlZCAocmVzdWx0KSB7XG4gICAgICBjYihoZXgobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSkpXG4gICAgfSxcbiAgICBmdW5jdGlvbiBmYWlsIChlcnJvcikge1xuICAgICAgY2Ioc2hhMXN5bmMoYnVmKSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiB1aW50OGFycmF5IChzKSB7XG4gIHZhciBsID0gcy5sZW5ndGhcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHMuY2hhckNvZGVBdChpKVxuICB9XG4gIHJldHVybiBhcnJheVxufVxuXG5mdW5jdGlvbiBoZXggKGJ1Zikge1xuICB2YXIgbCA9IGJ1Zi5sZW5ndGhcbiAgdmFyIGNoYXJzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgYml0ZSA9IGJ1ZltpXVxuICAgIGNoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSlcbiAgICBjaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYTFcbm1vZHVsZS5leHBvcnRzLnN5bmMgPSBzaGExc3luY1xuIiwiLyogZ2xvYmFsIFdlYlNvY2tldCAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldFxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzaW1wbGUtd2Vic29ja2V0JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIHdzID0gcmVxdWlyZSgnd3MnKSAvLyB3ZWJzb2NrZXRzIGluIG5vZGUgLSB3aWxsIGJlIGVtcHR5IG9iamVjdCBpbiBicm93c2VyXG5cbnZhciBfV2ViU29ja2V0ID0gdHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcgPyBXZWJTb2NrZXQgOiB3c1xuXG5pbmhlcml0cyhTb2NrZXQsIHN0cmVhbS5EdXBsZXgpXG5cbi8qKlxuICogV2ViU29ja2V0LiBTYW1lIEFQSSBhcyBub2RlIGNvcmUgYG5ldC5Tb2NrZXRgLiBEdXBsZXggc3RyZWFtLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB3ZWJzb2NrZXQgc2VydmVyIHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgb3B0aW9ucyB0byBzdHJlYW0uRHVwbGV4XG4gKi9cbmZ1bmN0aW9uIFNvY2tldCAodXJsLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJsLCBvcHRzKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBkZWJ1ZygnbmV3IHdlYnNvY2tldDogJXMgJW8nLCB1cmwsIG9wdHMpXG5cbiAgb3B0cy5hbGxvd0hhbGZPcGVuID0gZmFsc2VcbiAgaWYgKG9wdHMuaGlnaFdhdGVyTWFyayA9PSBudWxsKSBvcHRzLmhpZ2hXYXRlck1hcmsgPSAxMDI0ICogMTAyNFxuXG4gIHN0cmVhbS5EdXBsZXguY2FsbChzZWxmLCBvcHRzKVxuXG4gIHNlbGYudXJsID0gdXJsXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50ID0gb3B0cy5oaWdoV2F0ZXJNYXJrXG4gIHNlbGYuX2NodW5rID0gbnVsbFxuICBzZWxmLl9jYiA9IG51bGxcbiAgc2VsZi5faW50ZXJ2YWwgPSBudWxsXG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIFdlYlNvY2tldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGB3c2AgcGFja2FnZSBhY2NlcHRzIG9wdGlvbnNcbiAgICAgIHNlbGYuX3dzID0gbmV3IF9XZWJTb2NrZXQoc2VsZi51cmwsIG9wdHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX3dzID0gbmV3IF9XZWJTb2NrZXQoc2VsZi51cmwpXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX29uRXJyb3IoZXJyKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgc2VsZi5fd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgc2VsZi5fd3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uT3BlbigpXG4gIH1cbiAgc2VsZi5fd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgc2VsZi5fb25NZXNzYWdlKGV2ZW50KVxuICB9XG4gIHNlbGYuX3dzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25DbG9zZSgpXG4gIH1cbiAgc2VsZi5fd3Mub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbkVycm9yKG5ldyBFcnJvcignY29ubmVjdGlvbiBlcnJvciB0byAnICsgc2VsZi51cmwpKVxuICB9XG5cbiAgc2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgICAgLy8gV2hlbiBzdHJlYW0gaXMgZmluaXNoZWQgd3JpdGluZywgY2xvc2Ugc29ja2V0IGNvbm5lY3Rpb24uIEhhbGYgb3BlbiBjb25uZWN0aW9uc1xuICAgICAgLy8gYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxuICAgICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgZGVzdHJveWluZyBzbyB0aGUgc29ja2V0IGZsdXNoZXMuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kZXN0cm95KClcbiAgICAgIH0sIDEwMClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgc29ja2V0IGlzIG5vdCBjb25uZWN0ZWQgd2hlbiBzdHJlYW0gaXMgZmluaXNoZWQgd3JpdGluZywgd2FpdCB1bnRpbCBkYXRhIGlzXG4gICAgICAvLyBmbHVzaGVkIHRvIG5ldHdvcmsgYXQgXCJjb25uZWN0XCIgZXZlbnQuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNlbGYub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICAgIH0sIDEwMClcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5Tb2NrZXQuV0VCU09DS0VUX1NVUFBPUlQgPSAhIV9XZWJTb2NrZXRcblxuLyoqXG4gKiBTZW5kIHRleHQvYmluYXJ5IGRhdGEgdG8gdGhlIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlWaWV3fEFycmF5QnVmZmVyfEJ1ZmZlcnxzdHJpbmd8QmxvYnxPYmplY3R9IGNodW5rXG4gKi9cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoIHx8IGNodW5rLmJ5dGVMZW5ndGggfHwgY2h1bmsuc2l6ZVxuICBzZWxmLl93cy5zZW5kKGNodW5rKVxuICBkZWJ1Zygnd3JpdGU6ICVkIGJ5dGVzJywgbGVuKVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob25jbG9zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVzdHJveShudWxsLCBvbmNsb3NlKVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgb25jbG9zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgaWYgKG9uY2xvc2UpIHNlbGYub25jZSgnY2xvc2UnLCBvbmNsb3NlKVxuXG4gIGRlYnVnKCdkZXN0cm95IChlcnJvcjogJXMpJywgZXJyICYmIGVyci5tZXNzYWdlKVxuXG4gIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICBpZiAoIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHNlbGYucHVzaChudWxsKVxuICBpZiAoIXNlbGYuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHNlbGYuZW5kKClcblxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpXG4gIHNlbGYuX2ludGVydmFsID0gbnVsbFxuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG5cbiAgaWYgKHNlbGYuX3dzKSB7XG4gICAgdmFyIHdzID0gc2VsZi5fd3NcbiAgICB2YXIgb25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdzLm9uY2xvc2UgPSBudWxsXG4gICAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IF9XZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICBvbkNsb3NlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd3Mub25jbG9zZSA9IG9uQ2xvc2VcbiAgICAgICAgd3MuY2xvc2UoKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIG9uQ2xvc2UoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdzLm9ub3BlbiA9IG51bGxcbiAgICB3cy5vbm1lc3NhZ2UgPSBudWxsXG4gICAgd3Mub25lcnJvciA9IG51bGxcbiAgfVxuICBzZWxmLl93cyA9IG51bGxcblxuICBpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge31cblxuU29ja2V0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobmV3IEVycm9yKCdjYW5ub3Qgd3JpdGUgYWZ0ZXIgc29ja2V0IGlzIGRlc3Ryb3llZCcpKVxuXG4gIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLnNlbmQoY2h1bmspXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5fb25FcnJvcihlcnIpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd3MgIT09ICdmdW5jdGlvbicgJiYgc2VsZi5fd3MuYnVmZmVyZWRBbW91bnQgPiBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCkge1xuICAgICAgZGVidWcoJ3N0YXJ0IGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCBzZWxmLl93cy5idWZmZXJlZEFtb3VudClcbiAgICAgIHNlbGYuX2NiID0gY2JcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3dyaXRlIGJlZm9yZSBjb25uZWN0JylcbiAgICBzZWxmLl9jaHVuayA9IGNodW5rXG4gICAgc2VsZi5fY2IgPSBjYlxuICB9XG59XG5cblNvY2tldC5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgdmFyIGRhdGEgPSBldmVudC5kYXRhXG4gIGRlYnVnKCdyZWFkOiAlZCBieXRlcycsIGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aClcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhKVxuICBzZWxmLnB1c2goZGF0YSlcbn1cblxuU29ja2V0LnByb3RvdHlwZS5fb25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuY29ubmVjdGVkIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5jb25uZWN0ZWQgPSB0cnVlXG5cbiAgaWYgKHNlbGYuX2NodW5rKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuc2VuZChzZWxmLl9jaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBzZWxmLl9vbkVycm9yKGVycilcbiAgICB9XG4gICAgc2VsZi5fY2h1bmsgPSBudWxsXG4gICAgZGVidWcoJ3NlbnQgY2h1bmsgZnJvbSBcIndyaXRlIGJlZm9yZSBjb25uZWN0XCInKVxuXG4gICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICBzZWxmLl9jYiA9IG51bGxcbiAgICBjYihudWxsKVxuICB9XG5cbiAgLy8gTm8gYmFja3ByZXNzdXJlIGluIG5vZGUuIFRoZSBgd3NgIG1vZHVsZSBoYXMgYSBidWdneSBgYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5LlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy80OTJcbiAgaWYgKHR5cGVvZiB3cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmLl9jYiB8fCAhc2VsZi5fd3MgfHwgc2VsZi5fd3MuYnVmZmVyZWRBbW91bnQgPiBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGRlYnVnKCdlbmRpbmcgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHNlbGYuX3dzLmJ1ZmZlcmVkQW1vdW50KVxuICAgICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICAgIHNlbGYuX2NiID0gbnVsbFxuICAgICAgY2IobnVsbClcbiAgICB9LCAxNTApXG4gICAgaWYgKHNlbGYuX2ludGVydmFsLnVucmVmKSBzZWxmLl9pbnRlcnZhbC51bnJlZigpXG4gIH1cblxuICBkZWJ1ZygnY29ubmVjdCcpXG4gIHNlbGYuZW1pdCgnY29ubmVjdCcpXG59XG5cblNvY2tldC5wcm90b3R5cGUuX29uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBkZWJ1Zygnb24gY2xvc2UnKVxuICBzZWxmLl9kZXN0cm95KClcbn1cblxuU29ja2V0LnByb3RvdHlwZS5fb25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGRlYnVnKCdlcnJvcjogJXMnLCBlcnIubWVzc2FnZSB8fCBlcnIpXG4gIHNlbGYuX2Rlc3Ryb3koZXJyKVxufVxuIiwidmFyIHRpY2sgPSAxXG52YXIgbWF4VGljayA9IDY1NTM1XG52YXIgcmVzb2x1dGlvbiA9IDRcbnZhciBpbmMgPSBmdW5jdGlvbiAoKSB7XG4gIHRpY2sgPSAodGljayArIDEpICYgbWF4VGlja1xufVxuXG52YXIgdGltZXIgPSBzZXRJbnRlcnZhbChpbmMsICgxMDAwIC8gcmVzb2x1dGlvbikgfCAwKVxuaWYgKHRpbWVyLnVucmVmKSB0aW1lci51bnJlZigpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlY29uZHMpIHtcbiAgdmFyIHNpemUgPSByZXNvbHV0aW9uICogKHNlY29uZHMgfHwgNSlcbiAgdmFyIGJ1ZmZlciA9IFswXVxuICB2YXIgcG9pbnRlciA9IDFcbiAgdmFyIGxhc3QgPSAodGljayAtIDEpICYgbWF4VGlja1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICB2YXIgZGlzdCA9ICh0aWNrIC0gbGFzdCkgJiBtYXhUaWNrXG4gICAgaWYgKGRpc3QgPiBzaXplKSBkaXN0ID0gc2l6ZVxuICAgIGxhc3QgPSB0aWNrXG5cbiAgICB3aGlsZSAoZGlzdC0tKSB7XG4gICAgICBpZiAocG9pbnRlciA9PT0gc2l6ZSkgcG9pbnRlciA9IDBcbiAgICAgIGJ1ZmZlcltwb2ludGVyXSA9IGJ1ZmZlcltwb2ludGVyID09PSAwID8gc2l6ZSAtIDEgOiBwb2ludGVyIC0gMV1cbiAgICAgIHBvaW50ZXIrK1xuICAgIH1cblxuICAgIGlmIChkZWx0YSkgYnVmZmVyW3BvaW50ZXIgLSAxXSArPSBkZWx0YVxuXG4gICAgdmFyIHRvcCA9IGJ1ZmZlcltwb2ludGVyIC0gMV1cbiAgICB2YXIgYnRtID0gYnVmZmVyLmxlbmd0aCA8IHNpemUgPyAwIDogYnVmZmVyW3BvaW50ZXIgPT09IHNpemUgPyAwIDogcG9pbnRlcl1cblxuICAgIHJldHVybiBidWZmZXIubGVuZ3RoIDwgcmVzb2x1dGlvbiA/IHRvcCA6ICh0b3AgLSBidG0pICogcmVzb2x1dGlvbiAvIGJ1ZmZlci5sZW5ndGhcbiAgfVxufVxuIiwidmFyIENsaWVudFJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi9yZXF1ZXN0JylcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgc3RhdHVzQ29kZXMgPSByZXF1aXJlKCdidWlsdGluLXN0YXR1cy1jb2RlcycpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxudmFyIGh0dHAgPSBleHBvcnRzXG5cbmh0dHAucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKVxuXHRcdG9wdHMgPSB1cmwucGFyc2Uob3B0cylcblx0ZWxzZVxuXHRcdG9wdHMgPSBleHRlbmQob3B0cylcblxuXHQvLyBOb3JtYWxseSwgdGhlIHBhZ2UgaXMgbG9hZGVkIGZyb20gaHR0cCBvciBodHRwcywgc28gbm90IHNwZWNpZnlpbmcgYSBwcm90b2NvbFxuXHQvLyB3aWxsIHJlc3VsdCBpbiBhICh2YWxpZCkgcHJvdG9jb2wtcmVsYXRpdmUgdXJsLiBIb3dldmVyLCB0aGlzIHdvbid0IHdvcmsgaWZcblx0Ly8gdGhlIHByb3RvY29sIGlzIHNvbWV0aGluZyBlbHNlLCBsaWtlICdmaWxlOidcblx0dmFyIGRlZmF1bHRQcm90b2NvbCA9IGdsb2JhbC5sb2NhdGlvbi5wcm90b2NvbC5zZWFyY2goL15odHRwcz86JC8pID09PSAtMSA/ICdodHRwOicgOiAnJ1xuXG5cdHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgfHwgZGVmYXVsdFByb3RvY29sXG5cdHZhciBob3N0ID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3Rcblx0dmFyIHBvcnQgPSBvcHRzLnBvcnRcblx0dmFyIHBhdGggPSBvcHRzLnBhdGggfHwgJy8nXG5cblx0Ly8gTmVjZXNzYXJ5IGZvciBJUHY2IGFkZHJlc3Nlc1xuXHRpZiAoaG9zdCAmJiBob3N0LmluZGV4T2YoJzonKSAhPT0gLTEpXG5cdFx0aG9zdCA9ICdbJyArIGhvc3QgKyAnXSdcblxuXHQvLyBUaGlzIG1heSBiZSBhIHJlbGF0aXZlIHVybC4gVGhlIGJyb3dzZXIgc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGludGVycHJldCBpdCBjb3JyZWN0bHkuXG5cdG9wdHMudXJsID0gKGhvc3QgPyAocHJvdG9jb2wgKyAnLy8nICsgaG9zdCkgOiAnJykgKyAocG9ydCA/ICc6JyArIHBvcnQgOiAnJykgKyBwYXRoXG5cdG9wdHMubWV0aG9kID0gKG9wdHMubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpXG5cdG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fVxuXG5cdC8vIEFsc28gdmFsaWQgb3B0cy5hdXRoLCBvcHRzLm1vZGVcblxuXHR2YXIgcmVxID0gbmV3IENsaWVudFJlcXVlc3Qob3B0cylcblx0aWYgKGNiKVxuXHRcdHJlcS5vbigncmVzcG9uc2UnLCBjYilcblx0cmV0dXJuIHJlcVxufVxuXG5odHRwLmdldCA9IGZ1bmN0aW9uIGdldCAob3B0cywgY2IpIHtcblx0dmFyIHJlcSA9IGh0dHAucmVxdWVzdChvcHRzLCBjYilcblx0cmVxLmVuZCgpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5BZ2VudCA9IGZ1bmN0aW9uICgpIHt9XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNFxuXG5odHRwLlNUQVRVU19DT0RFUyA9IHN0YXR1c0NvZGVzXG5cbmh0dHAuTUVUSE9EUyA9IFtcblx0J0NIRUNLT1VUJyxcblx0J0NPTk5FQ1QnLFxuXHQnQ09QWScsXG5cdCdERUxFVEUnLFxuXHQnR0VUJyxcblx0J0hFQUQnLFxuXHQnTE9DSycsXG5cdCdNLVNFQVJDSCcsXG5cdCdNRVJHRScsXG5cdCdNS0FDVElWSVRZJyxcblx0J01LQ09MJyxcblx0J01PVkUnLFxuXHQnTk9USUZZJyxcblx0J09QVElPTlMnLFxuXHQnUEFUQ0gnLFxuXHQnUE9TVCcsXG5cdCdQUk9QRklORCcsXG5cdCdQUk9QUEFUQ0gnLFxuXHQnUFVSR0UnLFxuXHQnUFVUJyxcblx0J1JFUE9SVCcsXG5cdCdTRUFSQ0gnLFxuXHQnU1VCU0NSSUJFJyxcblx0J1RSQUNFJyxcblx0J1VOTE9DSycsXG5cdCdVTlNVQlNDUklCRSdcbl0iLCJleHBvcnRzLmZldGNoID0gaXNGdW5jdGlvbihnbG9iYWwuZmV0Y2gpICYmIGlzRnVuY3Rpb24oZ2xvYmFsLlJlYWRhYmxlQnl0ZVN0cmVhbSlcblxuZXhwb3J0cy5ibG9iQ29uc3RydWN0b3IgPSBmYWxzZVxudHJ5IHtcblx0bmV3IEJsb2IoW25ldyBBcnJheUJ1ZmZlcigxKV0pXG5cdGV4cG9ydHMuYmxvYkNvbnN0cnVjdG9yID0gdHJ1ZVxufSBjYXRjaCAoZSkge31cblxudmFyIHhociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuLy8gSWYgbG9jYXRpb24uaG9zdCBpcyBlbXB0eSwgZS5nLiBpZiB0aGlzIHBhZ2Uvd29ya2VyIHdhcyBsb2FkZWRcbi8vIGZyb20gYSBCbG9iLCB0aGVuIHVzZSBleGFtcGxlLmNvbSB0byBhdm9pZCBhbiBlcnJvclxueGhyLm9wZW4oJ0dFVCcsIGdsb2JhbC5sb2NhdGlvbi5ob3N0ID8gJy8nIDogJ2h0dHBzOi8vZXhhbXBsZS5jb20nKVxuXG5mdW5jdGlvbiBjaGVja1R5cGVTdXBwb3J0ICh0eXBlKSB7XG5cdHRyeSB7XG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHR5cGVcblx0XHRyZXR1cm4geGhyLnJlc3BvbnNlVHlwZSA9PT0gdHlwZVxuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2Vcbn1cblxuLy8gRm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIFNhZmFyaSA3LjAgcmVwb3J0cyB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnb2JqZWN0Jy5cbi8vIFNhZmFyaSA3LjEgYXBwZWFycyB0byBoYXZlIGZpeGVkIHRoaXMgYnVnLlxudmFyIGhhdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnXG52YXIgaGF2ZVNsaWNlID0gaGF2ZUFycmF5QnVmZmVyICYmIGlzRnVuY3Rpb24oZ2xvYmFsLkFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSlcblxuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IGhhdmVBcnJheUJ1ZmZlciAmJiBjaGVja1R5cGVTdXBwb3J0KCdhcnJheWJ1ZmZlcicpXG4vLyBUaGVzZSBuZXh0IHR3byB0ZXN0cyB1bmF2b2lkYWJseSBzaG93IHdhcm5pbmdzIGluIENocm9tZS4gU2luY2UgZmV0Y2ggd2lsbCBhbHdheXNcbi8vIGJlIHVzZWQgaWYgaXQncyBhdmFpbGFibGUsIGp1c3QgcmV0dXJuIGZhbHNlIGZvciB0aGVzZSB0byBhdm9pZCB0aGUgd2FybmluZ3MuXG5leHBvcnRzLm1zc3RyZWFtID0gIWV4cG9ydHMuZmV0Y2ggJiYgaGF2ZVNsaWNlICYmIGNoZWNrVHlwZVN1cHBvcnQoJ21zLXN0cmVhbScpXG5leHBvcnRzLm1vemNodW5rZWRhcnJheWJ1ZmZlciA9ICFleHBvcnRzLmZldGNoICYmIGhhdmVBcnJheUJ1ZmZlciAmJlxuXHRjaGVja1R5cGVTdXBwb3J0KCdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcicpXG5leHBvcnRzLm92ZXJyaWRlTWltZVR5cGUgPSBpc0Z1bmN0aW9uKHhoci5vdmVycmlkZU1pbWVUeXBlKVxuZXhwb3J0cy52YkFycmF5ID0gaXNGdW5jdGlvbihnbG9iYWwuVkJBcnJheSlcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG54aHIgPSBudWxsIC8vIEhlbHAgZ2NcbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgdG9BcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ3RvLWFycmF5YnVmZmVyJylcblxudmFyIEluY29taW5nTWVzc2FnZSA9IHJlc3BvbnNlLkluY29taW5nTWVzc2FnZVxudmFyIHJTdGF0ZXMgPSByZXNwb25zZS5yZWFkeVN0YXRlc1xuXG5mdW5jdGlvbiBkZWNpZGVNb2RlIChwcmVmZXJCaW5hcnkpIHtcblx0aWYgKGNhcGFiaWxpdHkuZmV0Y2gpIHtcblx0XHRyZXR1cm4gJ2ZldGNoJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubW96Y2h1bmtlZGFycmF5YnVmZmVyKSB7XG5cdFx0cmV0dXJuICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcidcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1zc3RyZWFtKSB7XG5cdFx0cmV0dXJuICdtcy1zdHJlYW0nXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5hcnJheWJ1ZmZlciAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ2FycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkudmJBcnJheSAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ3RleHQ6dmJhcnJheSdcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gJ3RleHQnXG5cdH1cbn1cblxudmFyIENsaWVudFJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzdHJlYW0uV3JpdGFibGUuY2FsbChzZWxmKVxuXG5cdHNlbGYuX29wdHMgPSBvcHRzXG5cdHNlbGYuX2JvZHkgPSBbXVxuXHRzZWxmLl9oZWFkZXJzID0ge31cblx0aWYgKG9wdHMuYXV0aClcblx0XHRzZWxmLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgbmV3IEJ1ZmZlcihvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKSlcblx0T2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0c2VsZi5zZXRIZWFkZXIobmFtZSwgb3B0cy5oZWFkZXJzW25hbWVdKVxuXHR9KVxuXG5cdHZhciBwcmVmZXJCaW5hcnlcblx0aWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSlcblxuXHRzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi5fb25GaW5pc2goKVxuXHR9KVxufVxuXG5pbmhlcml0cyhDbGllbnRSZXF1ZXN0LCBzdHJlYW0uV3JpdGFibGUpXG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0dmFyIGxvd2VyTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXHQvLyBUaGlzIGNoZWNrIGlzIG5vdCBuZWNlc3NhcnksIGJ1dCBpdCBwcmV2ZW50cyB3YXJuaW5ncyBmcm9tIGJyb3dzZXJzIGFib3V0IHNldHRpbmcgdW5zYWZlXG5cdC8vIGhlYWRlcnMuIFRvIGJlIGhvbmVzdCBJJ20gbm90IGVudGlyZWx5IHN1cmUgaGlkaW5nIHRoZXNlIHdhcm5pbmdzIGlzIGEgZ29vZCB0aGluZywgYnV0XG5cdC8vIGh0dHAtYnJvd3NlcmlmeSBkaWQgaXQsIHNvIEkgd2lsbCB0b28uXG5cdGlmICh1bnNhZmVIZWFkZXJzLmluZGV4T2YobG93ZXJOYW1lKSAhPT0gLTEpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5faGVhZGVyc1tsb3dlck5hbWVdID0ge1xuXHRcdG5hbWU6IG5hbWUsXG5cdFx0dmFsdWU6IHZhbHVlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHJldHVybiBzZWxmLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0udmFsdWVcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGRlbGV0ZSBzZWxmLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXHR2YXIgb3B0cyA9IHNlbGYuX29wdHNcblxuXHR2YXIgaGVhZGVyc09iaiA9IHNlbGYuX2hlYWRlcnNcblx0dmFyIGJvZHlcblx0aWYgKG9wdHMubWV0aG9kID09PSAnUE9TVCcgfHwgb3B0cy5tZXRob2QgPT09ICdQVVQnIHx8IG9wdHMubWV0aG9kID09PSAnUEFUQ0gnKSB7XG5cdFx0aWYgKGNhcGFiaWxpdHkuYmxvYkNvbnN0cnVjdG9yKSB7XG5cdFx0XHRib2R5ID0gbmV3IGdsb2JhbC5CbG9iKHNlbGYuX2JvZHkubWFwKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdFx0cmV0dXJuIHRvQXJyYXlCdWZmZXIoYnVmZmVyKVxuXHRcdFx0fSksIHtcblx0XHRcdFx0dHlwZTogKGhlYWRlcnNPYmpbJ2NvbnRlbnQtdHlwZSddIHx8IHt9KS52YWx1ZSB8fCAnJ1xuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZ2V0IHV0Zjggc3RyaW5nXG5cdFx0XHRib2R5ID0gQnVmZmVyLmNvbmNhdChzZWxmLl9ib2R5KS50b1N0cmluZygpXG5cdFx0fVxuXHR9XG5cblx0aWYgKHNlbGYuX21vZGUgPT09ICdmZXRjaCcpIHtcblx0XHR2YXIgaGVhZGVycyA9IE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLm1hcChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIFtoZWFkZXJzT2JqW25hbWVdLm5hbWUsIGhlYWRlcnNPYmpbbmFtZV0udmFsdWVdXG5cdFx0fSlcblxuXHRcdGdsb2JhbC5mZXRjaChzZWxmLl9vcHRzLnVybCwge1xuXHRcdFx0bWV0aG9kOiBzZWxmLl9vcHRzLm1ldGhvZCxcblx0XHRcdGhlYWRlcnM6IGhlYWRlcnMsXG5cdFx0XHRib2R5OiBib2R5LFxuXHRcdFx0bW9kZTogJ2NvcnMnLFxuXHRcdFx0Y3JlZGVudGlhbHM6IG9wdHMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJ1xuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2Vcblx0XHRcdHNlbGYuX2Nvbm5lY3QoKVxuXHRcdH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCByZWFzb24pXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHR2YXIgeGhyID0gc2VsZi5feGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKHNlbGYuX29wdHMubWV0aG9kLCBzZWxmLl9vcHRzLnVybCwgdHJ1ZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIENhbid0IHNldCByZXNwb25zZVR5cGUgb24gcmVhbGx5IG9sZCBicm93c2Vyc1xuXHRcdGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gc2VsZi5fbW9kZS5zcGxpdCgnOicpWzBdXG5cblx0XHRpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKVxuXHRcdFx0eGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0cy53aXRoQ3JlZGVudGlhbHNcblxuXHRcdGlmIChzZWxmLl9tb2RlID09PSAndGV4dCcgJiYgJ292ZXJyaWRlTWltZVR5cGUnIGluIHhocilcblx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJylcblxuXHRcdE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlcnNPYmpbbmFtZV0ubmFtZSwgaGVhZGVyc09ialtuYW1lXS52YWx1ZSlcblx0XHR9KVxuXG5cdFx0c2VsZi5fcmVzcG9uc2UgPSBudWxsXG5cdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHN3aXRjaCAoeGhyLnJlYWR5U3RhdGUpIHtcblx0XHRcdFx0Y2FzZSByU3RhdGVzLkxPQURJTkc6XG5cdFx0XHRcdGNhc2UgclN0YXRlcy5ET05FOlxuXHRcdFx0XHRcdHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE5lY2Vzc2FyeSBmb3Igc3RyZWFtaW5nIGluIEZpcmVmb3gsIHNpbmNlIHhoci5yZXNwb25zZSBpcyBPTkxZIGRlZmluZWRcblx0XHQvLyBpbiBvbnByb2dyZXNzLCBub3QgaW4gb25yZWFkeXN0YXRlY2hhbmdlIHdpdGggeGhyLnJlYWR5U3RhdGUgPSAzXG5cdFx0aWYgKHNlbGYuX21vZGUgPT09ICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcicpIHtcblx0XHRcdHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLl9vblhIUlByb2dyZXNzKClcblx0XHRcdH1cblx0XHR9XG5cblx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWEhSIGVycm9yJykpXG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5zZW5kKGJvZHkpXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgeGhyLnN0YXR1cyBpcyByZWFkYWJsZSBhbmQgbm9uLXplcm8sIGluZGljYXRpbmcgbm8gZXJyb3IuXG4gKiBFdmVuIHRob3VnaCB0aGUgc3BlYyBzYXlzIGl0IHNob3VsZCBiZSBhdmFpbGFibGUgaW4gcmVhZHlTdGF0ZSAzLFxuICogYWNjZXNzaW5nIGl0IHRocm93cyBhbiBleGNlcHRpb24gaW4gSUU4XG4gKi9cbmZ1bmN0aW9uIHN0YXR1c1ZhbGlkICh4aHIpIHtcblx0dHJ5IHtcblx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1c1xuXHRcdHJldHVybiAoc3RhdHVzICE9PSBudWxsICYmIHN0YXR1cyAhPT0gMClcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vblhIUlByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoIXN0YXR1c1ZhbGlkKHNlbGYuX3hocikgfHwgc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXG5cdGlmICghc2VsZi5fcmVzcG9uc2UpXG5cdFx0c2VsZi5fY29ubmVjdCgpXG5cblx0c2VsZi5fcmVzcG9uc2UuX29uWEhSUHJvZ3Jlc3MoKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRzZWxmLl9yZXNwb25zZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2Uoc2VsZi5feGhyLCBzZWxmLl9mZXRjaFJlc3BvbnNlLCBzZWxmLl9tb2RlKVxuXHRzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgc2VsZi5fcmVzcG9uc2UpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHNlbGYuX2JvZHkucHVzaChjaHVuaylcblx0Y2IoKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IENsaWVudFJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9kZXN0cm95ZWQgPSB0cnVlXG5cdGlmIChzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9yZXNwb25zZS5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5feGhyKVxuXHRcdHNlbGYuX3hoci5hYm9ydCgpXG5cdC8vIEN1cnJlbnRseSwgdGhlcmUgaXNuJ3QgYSB3YXkgdG8gdHJ1bHkgYWJvcnQgYSBmZXRjaC5cblx0Ly8gSWYgeW91IGxpa2UgYmlrZXNoZWRkaW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMjdcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2IgPSBkYXRhXG5cdFx0ZGF0YSA9IHVuZGVmaW5lZFxuXHR9XG5cblx0c3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbChzZWxmLCBkYXRhLCBlbmNvZGluZywgY2IpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmZsdXNoSGVhZGVycyA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldE5vRGVsYXkgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0U29ja2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge31cblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLXNldHJlcXVlc3RoZWFkZXIlMjglMjktbWV0aG9kXG52YXIgdW5zYWZlSGVhZGVycyA9IFtcblx0J2FjY2VwdC1jaGFyc2V0Jyxcblx0J2FjY2VwdC1lbmNvZGluZycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnLFxuXHQnY29ubmVjdGlvbicsXG5cdCdjb250ZW50LWxlbmd0aCcsXG5cdCdjb29raWUnLFxuXHQnY29va2llMicsXG5cdCdkYXRlJyxcblx0J2RudCcsXG5cdCdleHBlY3QnLFxuXHQnaG9zdCcsXG5cdCdrZWVwLWFsaXZlJyxcblx0J29yaWdpbicsXG5cdCdyZWZlcmVyJyxcblx0J3RlJyxcblx0J3RyYWlsZXInLFxuXHQndHJhbnNmZXItZW5jb2RpbmcnLFxuXHQndXBncmFkZScsXG5cdCd1c2VyLWFnZW50Jyxcblx0J3ZpYSdcbl1cbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgclN0YXRlcyA9IGV4cG9ydHMucmVhZHlTdGF0ZXMgPSB7XG5cdFVOU0VOVDogMCxcblx0T1BFTkVEOiAxLFxuXHRIRUFERVJTX1JFQ0VJVkVEOiAyLFxuXHRMT0FESU5HOiAzLFxuXHRET05FOiA0XG59XG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSBleHBvcnRzLkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uICh4aHIsIHJlc3BvbnNlLCBtb2RlKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzdHJlYW0uUmVhZGFibGUuY2FsbChzZWxmKVxuXG5cdHNlbGYuX21vZGUgPSBtb2RlXG5cdHNlbGYuaGVhZGVycyA9IHt9XG5cdHNlbGYucmF3SGVhZGVycyA9IFtdXG5cdHNlbGYudHJhaWxlcnMgPSB7fVxuXHRzZWxmLnJhd1RyYWlsZXJzID0gW11cblxuXHQvLyBGYWtlIHRoZSAnY2xvc2UnIGV2ZW50LCBidXQgb25seSBvbmNlICdlbmQnIGZpcmVzXG5cdHNlbGYub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUaGUgbmV4dFRpY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgdGhlICdyZXF1ZXN0JyBtb2R1bGUgZnJvbSBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3Bcblx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuZW1pdCgnY2xvc2UnKVxuXHRcdH0pXG5cdH0pXG5cblx0aWYgKG1vZGUgPT09ICdmZXRjaCcpIHtcblx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2VcblxuXHRcdHNlbGYudXJsID0gcmVzcG9uc2UudXJsXG5cdFx0c2VsZi5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dFxuXHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIHZlcnNpb24gb2YgZm9yICg8aXRlbT4gb2YgPGl0ZXJhYmxlPik6XG5cdFx0Ly8gZm9yICh2YXIgPGl0ZW0+LF9pLF9pdCA9IDxpdGVyYWJsZT5bU3ltYm9sLml0ZXJhdG9yXSgpOyA8aXRlbT4gPSAoX2kgPSBfaXQubmV4dCgpKS52YWx1ZSwhX2kuZG9uZTspXG5cdFx0Zm9yICh2YXIgaGVhZGVyLCBfaSwgX2l0ID0gcmVzcG9uc2UuaGVhZGVyc1tTeW1ib2wuaXRlcmF0b3JdKCk7IGhlYWRlciA9IChfaSA9IF9pdC5uZXh0KCkpLnZhbHVlLCAhX2kuZG9uZTspIHtcblx0XHRcdHNlbGYuaGVhZGVyc1toZWFkZXJbMF0udG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJbMV1cblx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuXHRcdH1cblxuXHRcdC8vIFRPRE86IHRoaXMgZG9lc24ndCByZXNwZWN0IGJhY2twcmVzc3VyZS4gT25jZSBXcml0YWJsZVN0cmVhbSBpcyBhdmFpbGFibGUsIHRoaXMgY2FuIGJlIGZpeGVkXG5cdFx0dmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcblx0XHRmdW5jdGlvbiByZWFkICgpIHtcblx0XHRcdHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGlmIChyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRcdHNlbGYucHVzaChudWxsKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucHVzaChuZXcgQnVmZmVyKHJlc3VsdC52YWx1ZSkpXG5cdFx0XHRcdHJlYWQoKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0cmVhZCgpXG5cblx0fSBlbHNlIHtcblx0XHRzZWxmLl94aHIgPSB4aHJcblx0XHRzZWxmLl9wb3MgPSAwXG5cblx0XHRzZWxmLnVybCA9IHhoci5yZXNwb25zZVVSTFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSB4aHIuc3RhdHVzVGV4dFxuXHRcdHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9cXHI/XFxuLylcblx0XHRoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBoZWFkZXIubWF0Y2goL14oW146XSspOlxccyooLiopLylcblx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuaGVhZGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gW11cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0ucHVzaChtYXRjaGVzWzJdKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSArPSAnLCAnICsgbWF0Y2hlc1syXVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gbWF0Y2hlc1syXVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0pXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHNlbGYuX2NoYXJzZXQgPSAneC11c2VyLWRlZmluZWQnXG5cdFx0aWYgKCFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGUpIHtcblx0XHRcdHZhciBtaW1lVHlwZSA9IHNlbGYucmF3SGVhZGVyc1snbWltZS10eXBlJ11cblx0XHRcdGlmIChtaW1lVHlwZSkge1xuXHRcdFx0XHR2YXIgY2hhcnNldE1hdGNoID0gbWltZVR5cGUubWF0Y2goLztcXHMqY2hhcnNldD0oW147XSkoO3wkKS8pXG5cdFx0XHRcdGlmIChjaGFyc2V0TWF0Y2gpIHtcblx0XHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gY2hhcnNldE1hdGNoWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gJ3V0Zi04JyAvLyBiZXN0IGd1ZXNzXG5cdFx0fVxuXHR9XG59XG5cbmluaGVyaXRzKEluY29taW5nTWVzc2FnZSwgc3RyZWFtLlJlYWRhYmxlKVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge31cblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHhociA9IHNlbGYuX3hoclxuXG5cdHZhciByZXNwb25zZSA9IG51bGxcblx0c3dpdGNoIChzZWxmLl9tb2RlKSB7XG5cdFx0Y2FzZSAndGV4dDp2YmFycmF5JzogLy8gRm9yIElFOVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBUaGlzIGZhaWxzIGluIElFOFxuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBnbG9iYWwuVkJBcnJheSh4aHIucmVzcG9uc2VCb2R5KS50b0FycmF5KClcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRpZiAocmVzcG9uc2UgIT09IG51bGwpIHtcblx0XHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIocmVzcG9uc2UpKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmFsbHMgdGhyb3VnaCBpbiBJRThcdFxuXHRcdGNhc2UgJ3RleHQnOlxuXHRcdFx0dHJ5IHsgLy8gVGhpcyB3aWxsIGZhaWwgd2hlbiByZWFkeVN0YXRlID0gMyBpbiBJRTkuIFN3aXRjaCBtb2RlIGFuZCB3YWl0IGZvciByZWFkeVN0YXRlID0gNFxuXHRcdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHRcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5fbW9kZSA9ICd0ZXh0OnZiYXJyYXknXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRpZiAocmVzcG9uc2UubGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdHZhciBuZXdEYXRhID0gcmVzcG9uc2Uuc3Vic3RyKHNlbGYuX3Bvcylcblx0XHRcdFx0aWYgKHNlbGYuX2NoYXJzZXQgPT09ICd4LXVzZXItZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihuZXdEYXRhLmxlbmd0aClcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0XHRidWZmZXJbaV0gPSBuZXdEYXRhLmNoYXJDb2RlQXQoaSkgJiAweGZmXG5cblx0XHRcdFx0XHRzZWxmLnB1c2goYnVmZmVyKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYucHVzaChuZXdEYXRhLCBzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX3BvcyA9IHJlc3BvbnNlLmxlbmd0aFxuXHRcdFx0fVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuRE9ORSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcic6IC8vIHRha2Ugd2hvbGVcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORyB8fCAhcmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtcy1zdHJlYW0nOlxuXHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2Vcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5MT0FESU5HKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBnbG9iYWwuTVNTdHJlYW1SZWFkZXIoKVxuXHRcdFx0cmVhZGVyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChyZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0LnNsaWNlKHNlbGYuX3BvcykpKSlcblx0XHRcdFx0XHRzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHR9XG5cdFx0XHQvLyByZWFkZXIub25lcnJvciA9ID8/PyAvLyBUT0RPOiB0aGlzXG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzcG9uc2UpXG5cdFx0XHRicmVha1xuXHR9XG5cblx0Ly8gVGhlIG1zLXN0cmVhbSBjYXNlIGhhbmRsZXMgZW5kIHNlcGFyYXRlbHkgaW4gcmVhZGVyLm9ubG9hZCgpXG5cdGlmIChzZWxmLl94aHIucmVhZHlTdGF0ZSA9PT0gclN0YXRlcy5ET05FICYmIHNlbGYuX21vZGUgIT09ICdtcy1zdHJlYW0nKSB7XG5cdFx0c2VsZi5wdXNoKG51bGwpXG5cdH1cbn1cbiIsIi8qIGdsb2JhbCBVUkwgKi9cblxudmFyIGdldEJsb2IgPSByZXF1aXJlKCdzdHJlYW0tdG8tYmxvYicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QmxvYlVSTCAoc3RyZWFtLCBtaW1lVHlwZSwgY2IpIHtcbiAgaWYgKHR5cGVvZiBtaW1lVHlwZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGdldEJsb2JVUkwoc3RyZWFtLCBudWxsLCBtaW1lVHlwZSlcbiAgZ2V0QmxvYihzdHJlYW0sIG1pbWVUeXBlLCBmdW5jdGlvbiAoZXJyLCBibG9iKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgIGNiKG51bGwsIHVybClcbiAgfSlcbn1cbiIsIi8qIGdsb2JhbCBCbG9iICovXG5cbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QmxvYiAoc3RyZWFtLCBtaW1lVHlwZSwgY2IpIHtcbiAgaWYgKHR5cGVvZiBtaW1lVHlwZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGdldEJsb2Ioc3RyZWFtLCBudWxsLCBtaW1lVHlwZSlcbiAgY2IgPSBvbmNlKGNiKVxuICB2YXIgY2h1bmtzID0gW11cbiAgc3RyZWFtXG4gICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBjaHVua3MucHVzaChjaHVuaylcbiAgICB9KVxuICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJsb2IgPSBtaW1lVHlwZVxuICAgICAgICA/IG5ldyBCbG9iKGNodW5rcywgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgICAgICA6IG5ldyBCbG9iKGNodW5rcylcbiAgICAgIGNiKG51bGwsIGJsb2IpXG4gICAgfSlcbiAgICAub24oJ2Vycm9yJywgY2IpXG59XG4iLCJ2YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJ1ZmZlciAoc3RyZWFtLCBsZW5ndGgsIGNiKSB7XG4gIGNiID0gb25jZShjYilcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgb2Zmc2V0ID0gMFxuICBzdHJlYW1cbiAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGNodW5rLmNvcHkoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoXG4gICAgfSlcbiAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHsgY2IobnVsbCwgYnVmKSB9KVxuICAgIC5vbignZXJyb3InLCBjYilcbn1cbiIsInZhciBhZGRyVG9JUFBvcnQgPSByZXF1aXJlKCdhZGRyLXRvLWlwLXBvcnQnKVxudmFyIGlwYWRkciA9IHJlcXVpcmUoJ2lwYWRkci5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFkZHJzKSB7XG4gIGlmICh0eXBlb2YgYWRkcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYWRkcnMgPSBbIGFkZHJzIF1cbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGFkZHJzLm1hcChmdW5jdGlvbiAoYWRkcikge1xuICAgIHZhciBzID0gYWRkclRvSVBQb3J0KGFkZHIpXG4gICAgaWYgKHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRkcmVzcyBmb3JtYXQsIGV4cGVjdGluZzogMTAuMTAuMTAuNToxMjgnKVxuICAgIH1cblxuICAgIHZhciBpcCA9IGlwYWRkci5wYXJzZShzWzBdKVxuICAgIHZhciBpcEJ1ZiA9IG5ldyBCdWZmZXIoaXAudG9CeXRlQXJyYXkoKSlcbiAgICB2YXIgcG9ydCA9IE51bWJlcihzWzFdKVxuICAgIHZhciBwb3J0QnVmID0gbmV3IEJ1ZmZlcigyKVxuICAgIHBvcnRCdWYud3JpdGVVSW50MTZCRShwb3J0LCAwKVxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtpcEJ1ZiwgcG9ydEJ1Zl0pXG4gIH0pKVxufVxuXG4vKipcbiAqIEFsc28gc3VwcG9ydCB0aGlzIHVzYWdlOlxuICogICBzdHJpbmcyY29tcGFjdC5tdWx0aShbICcxMC4xMC4xMC41OjEyOCcsICcxMDAuNTYuNTguOTk6Mjg1MjUnIF0pXG4gKlxuICogZm9yIHBhcmFsbGVsaXNtIHdpdGggdGhlIGBjb21wYWN0MnN0cmluZ2AgbW9kdWxlLlxuICovXG5tb2R1bGUuZXhwb3J0cy5tdWx0aSA9IG1vZHVsZS5leHBvcnRzXG5tb2R1bGUuZXhwb3J0cy5tdWx0aTYgPSBtb2R1bGUuZXhwb3J0c1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCIvKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbFxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluICAgICAgXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFxuVEhFIFNPRlRXQVJFLlxuKi9cblxudmFyIGJhc2UzMiA9IHJlcXVpcmUoJy4vdGhpcnR5LXR3bycpO1xuXG5leHBvcnRzLmVuY29kZSA9IGJhc2UzMi5lbmNvZGU7XG5leHBvcnRzLmRlY29kZSA9IGJhc2UzMi5kZWNvZGU7XG4iLCIvKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbFxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuKi9cblxudmFyIGNoYXJUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIjtcbnZhciBieXRlVGFibGUgPSBbXG4gICAgMHhmZiwgMHhmZiwgMHgxYSwgMHgxYiwgMHgxYywgMHgxZCwgMHgxZSwgMHgxZixcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAgIDB4ZmYsIDB4MDAsIDB4MDEsIDB4MDIsIDB4MDMsIDB4MDQsIDB4MDUsIDB4MDYsXG4gICAgMHgwNywgMHgwOCwgMHgwOSwgMHgwYSwgMHgwYiwgMHgwYywgMHgwZCwgMHgwZSxcbiAgICAweDBmLCAweDEwLCAweDExLCAweDEyLCAweDEzLCAweDE0LCAweDE1LCAweDE2LFxuICAgIDB4MTcsIDB4MTgsIDB4MTksIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gICAgMHhmZiwgMHgwMCwgMHgwMSwgMHgwMiwgMHgwMywgMHgwNCwgMHgwNSwgMHgwNixcbiAgICAweDA3LCAweDA4LCAweDA5LCAweDBhLCAweDBiLCAweDBjLCAweDBkLCAweDBlLFxuICAgIDB4MGYsIDB4MTAsIDB4MTEsIDB4MTIsIDB4MTMsIDB4MTQsIDB4MTUsIDB4MTYsXG4gICAgMHgxNywgMHgxOCwgMHgxOSwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZlxuXTtcblxuZnVuY3Rpb24gcXVpbnRldENvdW50KGJ1ZmYpIHtcbiAgICB2YXIgcXVpbnRldHMgPSBNYXRoLmZsb29yKGJ1ZmYubGVuZ3RoIC8gNSk7XG4gICAgcmV0dXJuIGJ1ZmYubGVuZ3RoICUgNSA9PSAwID8gcXVpbnRldHM6IHF1aW50ZXRzICsgMTtcbn1cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihwbGFpbikge1xuICAgIGlmKCFCdWZmZXIuaXNCdWZmZXIocGxhaW4pKXtcbiAgICBcdHBsYWluID0gbmV3IEJ1ZmZlcihwbGFpbik7XG4gICAgfVxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIHNoaWZ0SW5kZXggPSAwO1xuICAgIHZhciBkaWdpdCA9IDA7XG4gICAgdmFyIGVuY29kZWQgPSBuZXcgQnVmZmVyKHF1aW50ZXRDb3VudChwbGFpbikgKiA4KTtcblxuICAgIC8qIGJ5dGUgYnkgYnl0ZSBpc24ndCBhcyBwcmV0dHkgYXMgcXVpbnRldCBieSBxdWludGV0IGJ1dCB0ZXN0cyBhIGJpdFxuICAgICAgICBmYXN0ZXIuIHdpbGwgaGF2ZSB0byByZXZpc2l0LiAqL1xuICAgIHdoaWxlKGkgPCBwbGFpbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBwbGFpbltpXTtcbiAgICBcbiAgICAgICAgaWYoc2hpZnRJbmRleCA+IDMpIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gY3VycmVudCAmICgweGZmID4+IHNoaWZ0SW5kZXgpO1xuICAgICAgICAgICAgc2hpZnRJbmRleCA9IChzaGlmdEluZGV4ICsgNSkgJSA4O1xuICAgICAgICAgICAgZGlnaXQgPSAoZGlnaXQgPDwgc2hpZnRJbmRleCkgfCAoKGkgKyAxIDwgcGxhaW4ubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgcGxhaW5baSArIDFdIDogMCkgPj4gKDggLSBzaGlmdEluZGV4KTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gKGN1cnJlbnQgPj4gKDggLSAoc2hpZnRJbmRleCArIDUpKSkgJiAweDFmO1xuICAgICAgICAgICAgc2hpZnRJbmRleCA9IChzaGlmdEluZGV4ICsgNSkgJSA4OyAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoc2hpZnRJbmRleCA9PSAwKSBpKys7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGVuY29kZWRbal0gPSBjaGFyVGFibGUuY2hhckNvZGVBdChkaWdpdCk7XG4gICAgICAgIGorKztcbiAgICB9XG5cbiAgICBmb3IoaSA9IGo7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKVxuICAgICAgICBlbmNvZGVkW2ldID0gMHgzZDsgLy8nPScuY2hhckNvZGVBdCgwKVxuICAgICAgICBcbiAgICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgIHZhciBzaGlmdEluZGV4ID0gMDtcbiAgICB2YXIgcGxhaW5EaWdpdCA9IDA7XG4gICAgdmFyIHBsYWluQ2hhcjtcbiAgICB2YXIgcGxhaW5Qb3MgPSAwO1xuICAgIGlmKCFCdWZmZXIuaXNCdWZmZXIoZW5jb2RlZCkpe1xuICAgIFx0ZW5jb2RlZCA9IG5ldyBCdWZmZXIoZW5jb2RlZCk7XG4gICAgfVxuICAgIHZhciBkZWNvZGVkID0gbmV3IEJ1ZmZlcihNYXRoLmNlaWwoZW5jb2RlZC5sZW5ndGggKiA1IC8gOCkpO1xuICAgIFxuICAgIC8qIGJ5dGUgYnkgYnl0ZSBpc24ndCBhcyBwcmV0dHkgYXMgb2N0ZXQgYnkgb2N0ZXQgYnV0IHRlc3RzIGEgYml0XG4gICAgICAgIGZhc3Rlci4gd2lsbCBoYXZlIHRvIHJldmlzaXQuICovICAgIFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgXHRpZihlbmNvZGVkW2ldID09IDB4M2QpeyAvLyc9J1xuICAgIFx0XHRicmVhaztcbiAgICBcdH1cbiAgICBcdFx0XG4gICAgICAgIHZhciBlbmNvZGVkQnl0ZSA9IGVuY29kZWRbaV0gLSAweDMwO1xuICAgICAgICBcbiAgICAgICAgaWYoZW5jb2RlZEJ5dGUgPCBieXRlVGFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbGFpbkRpZ2l0ID0gYnl0ZVRhYmxlW2VuY29kZWRCeXRlXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoc2hpZnRJbmRleCA8PSAzKSB7XG4gICAgICAgICAgICAgICAgc2hpZnRJbmRleCA9IChzaGlmdEluZGV4ICsgNSkgJSA4O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHNoaWZ0SW5kZXggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwbGFpbkNoYXIgfD0gcGxhaW5EaWdpdDtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZFtwbGFpblBvc10gPSBwbGFpbkNoYXI7XG4gICAgICAgICAgICAgICAgICAgIHBsYWluUG9zKys7XG4gICAgICAgICAgICAgICAgICAgIHBsYWluQ2hhciA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhaW5DaGFyIHw9IDB4ZmYgJiAocGxhaW5EaWdpdCA8PCAoOCAtIHNoaWZ0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoaWZ0SW5kZXggPSAoc2hpZnRJbmRleCArIDUpICUgODtcbiAgICAgICAgICAgICAgICBwbGFpbkNoYXIgfD0gMHhmZiAmIChwbGFpbkRpZ2l0ID4+PiBzaGlmdEluZGV4KTtcbiAgICAgICAgICAgICAgICBkZWNvZGVkW3BsYWluUG9zXSA9IHBsYWluQ2hhcjtcbiAgICAgICAgICAgICAgICBwbGFpblBvcysrO1xuXG4gICAgICAgICAgICAgICAgcGxhaW5DaGFyID0gMHhmZiAmIChwbGFpbkRpZ2l0IDw8ICg4IC0gc2hpZnRJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICBcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCAtIGl0IGlzIG5vdCBiYXNlMzIgZW5jb2RlZCBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZC5zbGljZSgwLCBwbGFpblBvcyk7XG59O1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWYpIHtcblx0Ly8gSWYgdGhlIGJ1ZmZlciBpcyBiYWNrZWQgYnkgYSBVaW50OEFycmF5LCBhIGZhc3RlciB2ZXJzaW9uIHdpbGwgd29ya1xuXHRpZiAoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdC8vIElmIHRoZSBidWZmZXIgaXNuJ3QgYSBzdWJhcnJheSwgcmV0dXJuIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG5cdFx0aWYgKGJ1Zi5ieXRlT2Zmc2V0ID09PSAwICYmIGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdHJldHVybiBidWYuYnVmZmVyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYnVmLmJ1ZmZlci5zbGljZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gZ2V0IGEgcHJvcGVyIGNvcHlcblx0XHRcdHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKVxuXHRcdH1cblx0fVxuXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuXHRcdC8vIFRoaXMgaXMgdGhlIHNsb3cgdmVyc2lvbiB0aGF0IHdpbGwgd29yayB3aXRoIGFueSBCdWZmZXJcblx0XHQvLyBpbXBsZW1lbnRhdGlvbiAoZXZlbiBpbiBvbGQgYnJvd3NlcnMpXG5cdFx0dmFyIGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KGJ1Zi5sZW5ndGgpXG5cdFx0dmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnJheUNvcHlbaV0gPSBidWZbaV1cblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5Q29weS5idWZmZXJcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuXHR9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IERpc2NvdmVyeVxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd0b3JyZW50LWRpc2NvdmVyeScpXG52YXIgREhUID0gcmVxdWlyZSgnYml0dG9ycmVudC1kaHQvY2xpZW50JykgLy8gZW1wdHkgb2JqZWN0IGluIGJyb3dzZXJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcGFyYWxsZWwgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwnKVxudmFyIFRyYWNrZXIgPSByZXF1aXJlKCdiaXR0b3JyZW50LXRyYWNrZXIvY2xpZW50JylcblxuaW5oZXJpdHMoRGlzY292ZXJ5LCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIERpc2NvdmVyeSAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIERpc2NvdmVyeSkpIHJldHVybiBuZXcgRGlzY292ZXJ5KG9wdHMpXG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG5cbiAgaWYgKCFvcHRzLnBlZXJJZCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYHBlZXJJZGAgaXMgcmVxdWlyZWQnKVxuICBpZiAoIW9wdHMuaW5mb0hhc2gpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBpbmZvSGFzaGAgaXMgcmVxdWlyZWQnKVxuICBpZiAoIXByb2Nlc3MuYnJvd3NlciAmJiAhb3B0cy5wb3J0KSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgcG9ydGAgaXMgcmVxdWlyZWQnKVxuXG4gIHNlbGYucGVlcklkID0gdHlwZW9mIG9wdHMucGVlcklkID09PSAnc3RyaW5nJ1xuICAgID8gb3B0cy5wZWVySWRcbiAgICA6IG9wdHMucGVlcklkLnRvU3RyaW5nKCdoZXgnKVxuICBzZWxmLmluZm9IYXNoID0gdHlwZW9mIG9wdHMuaW5mb0hhc2ggPT09ICdzdHJpbmcnXG4gICAgPyBvcHRzLmluZm9IYXNoXG4gICAgOiBvcHRzLmluZm9IYXNoLnRvU3RyaW5nKCdoZXgnKVxuICBzZWxmLl9wb3J0ID0gb3B0cy5wb3J0IC8vIHRvcnJlbnQgcG9ydFxuXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcblxuICBzZWxmLl9hbm5vdW5jZSA9IG9wdHMuYW5ub3VuY2UgfHwgW11cbiAgc2VsZi5faW50ZXJ2YWxNcyA9IG9wdHMuaW50ZXJ2YWxNcyB8fCAoMTUgKiA2MCAqIDEwMDApXG4gIHNlbGYuX3RyYWNrZXJPcHRzID0gbnVsbFxuICBzZWxmLl9kaHRBbm5vdW5jaW5nID0gZmFsc2VcbiAgc2VsZi5fZGh0VGltZW91dCA9IGZhbHNlXG4gIHNlbGYuX2ludGVybmFsREhUID0gZmFsc2UgLy8gaXMgdGhlIERIVCBjcmVhdGVkIGludGVybmFsbHk/XG5cbiAgc2VsZi5fb25XYXJuaW5nID0gZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgfVxuICBzZWxmLl9vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbiAgc2VsZi5fb25ESFRQZWVyID0gZnVuY3Rpb24gKHBlZXIsIGluZm9IYXNoKSB7XG4gICAgaWYgKGluZm9IYXNoLnRvU3RyaW5nKCdoZXgnKSAhPT0gc2VsZi5pbmZvSGFzaCkgcmV0dXJuXG4gICAgc2VsZi5lbWl0KCdwZWVyJywgcGVlci5ob3N0ICsgJzonICsgcGVlci5wb3J0KVxuICB9XG4gIHNlbGYuX29uVHJhY2tlclBlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICAgIHNlbGYuZW1pdCgncGVlcicsIHBlZXIpXG4gIH1cbiAgc2VsZi5fb25UcmFja2VyQW5ub3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCd0cmFja2VyQW5ub3VuY2UnKVxuICB9XG5cbiAgaWYgKG9wdHMudHJhY2tlciA9PT0gZmFsc2UpIHtcbiAgICBzZWxmLnRyYWNrZXIgPSBudWxsXG4gIH0gZWxzZSBpZiAob3B0cy50cmFja2VyICYmIHR5cGVvZiBvcHRzLnRyYWNrZXIgPT09ICdvYmplY3QnKSB7XG4gICAgc2VsZi5fdHJhY2tlck9wdHMgPSBleHRlbmQob3B0cy50cmFja2VyKVxuICAgIHNlbGYudHJhY2tlciA9IHNlbGYuX2NyZWF0ZVRyYWNrZXIoKVxuICB9IGVsc2Uge1xuICAgIHNlbGYudHJhY2tlciA9IHNlbGYuX2NyZWF0ZVRyYWNrZXIoKVxuICB9XG5cbiAgaWYgKG9wdHMuZGh0ID09PSBmYWxzZSB8fCB0eXBlb2YgREhUICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5kaHQgPSBudWxsXG4gIH0gZWxzZSBpZiAob3B0cy5kaHQgJiYgdHlwZW9mIG9wdHMuZGh0LmFkZE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLmRodCA9IG9wdHMuZGh0XG4gIH0gZWxzZSBpZiAob3B0cy5kaHQgJiYgdHlwZW9mIG9wdHMuZGh0ID09PSAnb2JqZWN0Jykge1xuICAgIHNlbGYuZGh0ID0gY3JlYXRlREhUKG9wdHMuZGh0UG9ydCwgb3B0cy5kaHQpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5kaHQgPSBjcmVhdGVESFQob3B0cy5kaHRQb3J0KVxuICB9XG5cbiAgaWYgKHNlbGYuZGh0KSB7XG4gICAgc2VsZi5kaHQub24oJ3BlZXInLCBzZWxmLl9vbkRIVFBlZXIpXG4gICAgc2VsZi5fZGh0QW5ub3VuY2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlREhUIChwb3J0LCBvcHRzKSB7XG4gICAgdmFyIGRodCA9IG5ldyBESFQob3B0cylcbiAgICBkaHQub24oJ3dhcm5pbmcnLCBzZWxmLl9vbldhcm5pbmcpXG4gICAgZGh0Lm9uKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG4gICAgZGh0Lmxpc3Rlbihwb3J0KVxuICAgIHNlbGYuX2ludGVybmFsREhUID0gdHJ1ZVxuICAgIHJldHVybiBkaHRcbiAgfVxufVxuXG5EaXNjb3ZlcnkucHJvdG90eXBlLnVwZGF0ZVBvcnQgPSBmdW5jdGlvbiAocG9ydCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHBvcnQgPT09IHNlbGYuX3BvcnQpIHJldHVyblxuICBzZWxmLl9wb3J0ID0gcG9ydFxuXG4gIGlmIChzZWxmLmRodCkgc2VsZi5fZGh0QW5ub3VuY2UoKVxuXG4gIGlmIChzZWxmLnRyYWNrZXIpIHtcbiAgICBzZWxmLnRyYWNrZXIuc3RvcCgpXG4gICAgc2VsZi50cmFja2VyLmRlc3Ryb3koZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi50cmFja2VyID0gc2VsZi5fY3JlYXRlVHJhY2tlcigpXG4gICAgfSlcbiAgfVxufVxuXG5EaXNjb3ZlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGNsZWFyVGltZW91dChzZWxmLl9kaHRUaW1lb3V0KVxuXG4gIHZhciB0YXNrcyA9IFtdXG5cbiAgaWYgKHNlbGYudHJhY2tlcikge1xuICAgIHNlbGYudHJhY2tlci5zdG9wKClcbiAgICBzZWxmLnRyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ3dhcm5pbmcnLCBzZWxmLl9vbldhcm5pbmcpXG4gICAgc2VsZi50cmFja2VyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG4gICAgc2VsZi50cmFja2VyLnJlbW92ZUxpc3RlbmVyKCdwZWVyJywgc2VsZi5fb25UcmFja2VyUGVlcilcbiAgICBzZWxmLnRyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIHNlbGYuX29uVHJhY2tlckFubm91bmNlKVxuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLnRyYWNrZXIuZGVzdHJveShjYilcbiAgICB9KVxuICB9XG5cbiAgaWYgKHNlbGYuZGh0KSB7XG4gICAgc2VsZi5kaHQucmVtb3ZlTGlzdGVuZXIoJ3BlZXInLCBzZWxmLl9vbkRIVFBlZXIpXG4gIH1cblxuICBpZiAoc2VsZi5faW50ZXJuYWxESFQpIHtcbiAgICBzZWxmLmRodC5yZW1vdmVMaXN0ZW5lcignd2FybmluZycsIHNlbGYuX29uV2FybmluZylcbiAgICBzZWxmLmRodC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9vbkVycm9yKVxuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLmRodC5kZXN0cm95KGNiKVxuICAgIH0pXG4gIH1cblxuICBwYXJhbGxlbCh0YXNrcywgY2IpXG5cbiAgLy8gY2xlYW51cFxuICBzZWxmLmRodCA9IG51bGxcbiAgc2VsZi50cmFja2VyID0gbnVsbFxuICBzZWxmLl9hbm5vdW5jZSA9IG51bGxcbn1cblxuRGlzY292ZXJ5LnByb3RvdHlwZS5fY3JlYXRlVHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIG9wdHMgPSBleHRlbmQoc2VsZi5fdHJhY2tlck9wdHMsIHtcbiAgICBpbmZvSGFzaDogc2VsZi5pbmZvSGFzaCxcbiAgICBhbm5vdW5jZTogc2VsZi5fYW5ub3VuY2UsXG4gICAgcGVlcklkOiBzZWxmLnBlZXJJZCxcbiAgICBwb3J0OiBzZWxmLl9wb3J0XG4gIH0pXG5cbiAgdmFyIHRyYWNrZXIgPSBuZXcgVHJhY2tlcihvcHRzKVxuICB0cmFja2VyLm9uKCd3YXJuaW5nJywgc2VsZi5fb25XYXJuaW5nKVxuICB0cmFja2VyLm9uKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG4gIHRyYWNrZXIub24oJ3BlZXInLCBzZWxmLl9vblRyYWNrZXJQZWVyKVxuICB0cmFja2VyLm9uKCd1cGRhdGUnLCBzZWxmLl9vblRyYWNrZXJBbm5vdW5jZSlcbiAgdHJhY2tlci5zZXRJbnRlcnZhbChzZWxmLl9pbnRlcnZhbE1zKVxuICB0cmFja2VyLnN0YXJ0KClcbiAgcmV0dXJuIHRyYWNrZXJcbn1cblxuRGlzY292ZXJ5LnByb3RvdHlwZS5fZGh0QW5ub3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5fZGh0QW5ub3VuY2luZykgcmV0dXJuXG4gIGRlYnVnKCdkaHQgYW5ub3VuY2UnKVxuXG4gIHNlbGYuX2RodEFubm91bmNpbmcgPSB0cnVlXG4gIGNsZWFyVGltZW91dChzZWxmLl9kaHRUaW1lb3V0KVxuXG4gIHNlbGYuZGh0LmFubm91bmNlKHNlbGYuaW5mb0hhc2gsIHNlbGYuX3BvcnQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9kaHRBbm5vdW5jaW5nID0gZmFsc2VcbiAgICBkZWJ1ZygnZGh0IGFubm91bmNlIGNvbXBsZXRlJylcblxuICAgIGlmIChlcnIpIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgICBzZWxmLmVtaXQoJ2RodEFubm91bmNlJylcblxuICAgIGlmICghc2VsZi5kZXN0cm95ZWQpIHtcbiAgICAgIHNlbGYuX2RodFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZGh0QW5ub3VuY2UoKVxuICAgICAgfSwgZ2V0UmFuZG9tVGltZW91dCgpKVxuICAgICAgaWYgKHNlbGYuX2RodFRpbWVvdXQudW5yZWYpIHNlbGYuX2RodFRpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfSlcblxuICAvLyBSZXR1cm5zIHRpbWVvdXQgaW50ZXJ2YWwsIHdpdGggc29tZSByYW5kb20gaml0dGVyXG4gIGZ1bmN0aW9uIGdldFJhbmRvbVRpbWVvdXQgKCkge1xuICAgIHJldHVybiBzZWxmLl9pbnRlcnZhbE1zICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2VsZi5faW50ZXJ2YWxNcyAvIDUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gUGllY2VcblxudmFyIEJMT0NLX0xFTkdUSCA9IDEgPDwgMTRcblxuZnVuY3Rpb24gUGllY2UgKGxlbmd0aCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGllY2UpKSByZXR1cm4gbmV3IFBpZWNlKGxlbmd0aClcblxuICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICB0aGlzLm1pc3NpbmcgPSBsZW5ndGhcbiAgdGhpcy5zb3VyY2VzID0gbnVsbFxuXG4gIHRoaXMuX2NodW5rcyA9IE1hdGguY2VpbChsZW5ndGggLyBCTE9DS19MRU5HVEgpXG4gIHRoaXMuX3JlbWFpbmRlciA9IChsZW5ndGggJSBCTE9DS19MRU5HVEgpIHx8IEJMT0NLX0xFTkdUSFxuICB0aGlzLl9idWZmZXJlZCA9IDBcbiAgdGhpcy5fYnVmZmVyID0gbnVsbFxuICB0aGlzLl9jYW5jZWxsYXRpb25zID0gbnVsbFxuICB0aGlzLl9yZXNlcnZhdGlvbnMgPSAwXG4gIHRoaXMuX2ZsdXNoZWQgPSBmYWxzZVxufVxuXG5QaWVjZS5CTE9DS19MRU5HVEggPSBCTE9DS19MRU5HVEhcblxuUGllY2UucHJvdG90eXBlLmNodW5rTGVuZ3RoID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIGkgPT09IHRoaXMuX2NodW5rcyAtIDEgPyB0aGlzLl9yZW1haW5kZXIgOiBCTE9DS19MRU5HVEhcbn1cblxuUGllY2UucHJvdG90eXBlLmNodW5rTGVuZ3RoUmVtYWluaW5nID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gKGkgKiBCTE9DS19MRU5HVEgpXG59XG5cblBpZWNlLnByb3RvdHlwZS5jaHVua09mZnNldCA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiBpICogQkxPQ0tfTEVOR1RIXG59XG5cblBpZWNlLnByb3RvdHlwZS5yZXNlcnZlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm4gLTFcbiAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvbnMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY2FuY2VsbGF0aW9ucy5wb3AoKVxuICBpZiAodGhpcy5fcmVzZXJ2YXRpb25zIDwgdGhpcy5fY2h1bmtzKSByZXR1cm4gdGhpcy5fcmVzZXJ2YXRpb25zKytcbiAgcmV0dXJuIC0xXG59XG5cblBpZWNlLnByb3RvdHlwZS5yZXNlcnZlUmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm4gLTFcbiAgaWYgKHRoaXMuX3Jlc2VydmF0aW9ucyA8IHRoaXMuX2NodW5rcykge1xuICAgIHZhciBtaW4gPSB0aGlzLl9yZXNlcnZhdGlvbnNcbiAgICB0aGlzLl9yZXNlcnZhdGlvbnMgPSB0aGlzLl9jaHVua3NcbiAgICByZXR1cm4gbWluXG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cblBpZWNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoaSkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm5cbiAgdGhpcy5fY2FuY2VsbGF0aW9ucy5wdXNoKGkpXG59XG5cblBpZWNlLnByb3RvdHlwZS5jYW5jZWxSZW1haW5pbmcgPSBmdW5jdGlvbiAoaSkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm5cbiAgdGhpcy5fcmVzZXJ2YXRpb25zID0gaVxufVxuXG5QaWVjZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgaWYgKCF0aGlzLmluaXQoKSkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHRoaXMuX2J1ZmZlcltpXVxufVxuXG5QaWVjZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGksIGRhdGEsIHNvdXJjZSkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm4gZmFsc2VcbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoXG4gIHZhciBibG9ja3MgPSBNYXRoLmNlaWwobGVuIC8gQkxPQ0tfTEVOR1RIKVxuICBmb3IgKHZhciBqID0gMDsgaiA8IGJsb2NrczsgaisrKSB7XG4gICAgaWYgKCF0aGlzLl9idWZmZXJbaSArIGpdKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gaiAqIEJMT0NLX0xFTkdUSFxuICAgICAgdmFyIHNwbGl0RGF0YSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBCTE9DS19MRU5HVEgpXG4gICAgICB0aGlzLl9idWZmZXJlZCsrXG4gICAgICB0aGlzLl9idWZmZXJbaSArIGpdID0gc3BsaXREYXRhXG4gICAgICB0aGlzLm1pc3NpbmcgLT0gc3BsaXREYXRhLmxlbmd0aFxuICAgICAgaWYgKHRoaXMuc291cmNlcy5pbmRleE9mKHNvdXJjZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuc291cmNlcy5wdXNoKHNvdXJjZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkID09PSB0aGlzLl9jaHVua3Ncbn1cblxuUGllY2UucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX2J1ZmZlciB8fCB0aGlzLl9jaHVua3MgIT09IHRoaXMuX2J1ZmZlcmVkKSByZXR1cm4gbnVsbFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXIsIHRoaXMubGVuZ3RoKVxuICB0aGlzLl9idWZmZXIgPSBudWxsXG4gIHRoaXMuX2NhbmNlbGxhdGlvbnMgPSBudWxsXG4gIHRoaXMuc291cmNlcyA9IG51bGxcbiAgdGhpcy5fZmx1c2hlZCA9IHRydWVcbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5QaWVjZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2ZsdXNoZWQpIHJldHVybiBmYWxzZVxuICBpZiAodGhpcy5fYnVmZmVyKSByZXR1cm4gdHJ1ZVxuICB0aGlzLl9idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5fY2h1bmtzKVxuICB0aGlzLl9jYW5jZWxsYXRpb25zID0gW11cbiAgdGhpcy5zb3VyY2VzID0gW11cbiAgcmV0dXJuIHRydWVcbn1cbiIsIi8qKlxuICogQ29udmVydCBhIHR5cGVkIGFycmF5IHRvIGEgQnVmZmVyIHdpdGhvdXQgYSBjb3B5XG4gKlxuICogQXV0aG9yOiAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBMaWNlbnNlOiAgTUlUXG4gKlxuICogYG5wbSBpbnN0YWxsIHR5cGVkYXJyYXktdG8tYnVmZmVyYFxuICovXG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZGFycmF5Jykuc3RyaWN0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHlwZWRhcnJheVRvQnVmZmVyIChhcnIpIHtcbiAgaWYgKGlzVHlwZWRBcnJheShhcnIpKSB7XG4gICAgLy8gVG8gYXZvaWQgYSBjb3B5LCB1c2UgdGhlIHR5cGVkIGFycmF5J3MgdW5kZXJseWluZyBBcnJheUJ1ZmZlciB0byBiYWNrIG5ldyBCdWZmZXJcbiAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihhcnIuYnVmZmVyKVxuICAgIGlmIChhcnIuYnl0ZUxlbmd0aCAhPT0gYXJyLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAvLyBSZXNwZWN0IHRoZSBcInZpZXdcIiwgaS5lLiBieXRlT2Zmc2V0IGFuZCBieXRlTGVuZ3RoLCB3aXRob3V0IGRvaW5nIGEgY29weVxuICAgICAgYnVmID0gYnVmLnNsaWNlKGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZU9mZnNldCArIGFyci5ieXRlTGVuZ3RoKVxuICAgIH1cbiAgICByZXR1cm4gYnVmXG4gIH0gZWxzZSB7XG4gICAgLy8gUGFzcyB0aHJvdWdoIGFsbCBvdGhlciB0eXBlcyB0byB0aGUgYEJ1ZmZlcmAgY29uc3RydWN0b3JcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcnIpXG4gIH1cbn1cbiIsInZhciBVSU5UXzMyX01BWCA9IDB4ZmZmZmZmZmZcblxuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDhcbn1cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtLCBidWYsIG9mZnNldCkge1xuICBpZiAoIWJ1ZikgYnVmID0gbmV3IEJ1ZmZlcig4KVxuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIHZhciB0b3AgPSBNYXRoLmZsb29yKG51bSAvIFVJTlRfMzJfTUFYKVxuICB2YXIgcmVtID0gbnVtIC0gdG9wICogVUlOVF8zMl9NQVhcblxuICBidWYud3JpdGVVSW50MzJCRSh0b3AsIG9mZnNldClcbiAgYnVmLndyaXRlVUludDMyQkUocmVtLCBvZmZzZXQgKyA0KVxuICByZXR1cm4gYnVmXG59XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgaWYgKCFidWYpIGJ1ZiA9IG5ldyBCdWZmZXIoNClcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICB2YXIgdG9wID0gYnVmLnJlYWRVSW50MzJCRShvZmZzZXQpXG4gIHZhciByZW0gPSBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpXG5cbiAgcmV0dXJuIHRvcCAqIFVJTlRfMzJfTUFYICsgcmVtXG59XG5cbmV4cG9ydHMuZW5jb2RlLmJ5dGVzID0gOFxuZXhwb3J0cy5kZWNvZGUuYnl0ZXMgPSA4XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiPWxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoY29tcGFyZShhLCBiKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlX2VxKGxpc3QpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGIgPSBsaXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpLCBiPWEpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoYSAhPT0gYikge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QsIGNvbXBhcmUsIHNvcnRlZCkge1xuICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZVxuXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaSkge1xuICBpZiAoaSA+PSBhcnIubGVuZ3RoIHx8IGkgPCAwKSByZXR1cm5cbiAgdmFyIGxhc3QgPSBhcnIucG9wKClcbiAgaWYgKGkgPCBhcnIubGVuZ3RoKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXVxuICAgIGFycltpXSA9IGxhc3RcbiAgICByZXR1cm4gdG1wXG4gIH1cbiAgcmV0dXJuIGxhc3Rcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwidmFyIGJlbmNvZGUgPSByZXF1aXJlKCdiZW5jb2RlJylcbnZhciBCaXRGaWVsZCA9IHJlcXVpcmUoJ2JpdGZpZWxkJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgndXRfbWV0YWRhdGEnKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNoYTEgPSByZXF1aXJlKCdzaW1wbGUtc2hhMScpXG5cbnZhciBNQVhfTUVUQURBVEFfU0laRSA9IDEwMDAwMDAwIC8vIDEwTUJcbnZhciBCSVRGSUVMRF9HUk9XID0gMTAwMFxudmFyIFBJRUNFX0xFTkdUSCA9IDE2ICogMTAyNFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICBpbmhlcml0cyh1dE1ldGFkYXRhLCBFdmVudEVtaXR0ZXIpXG5cbiAgZnVuY3Rpb24gdXRNZXRhZGF0YSAod2lyZSkge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgICB0aGlzLl93aXJlID0gd2lyZVxuXG4gICAgdGhpcy5fbWV0YWRhdGFDb21wbGV0ZSA9IGZhbHNlXG4gICAgdGhpcy5fbWV0YWRhdGFTaXplID0gbnVsbFxuICAgIHRoaXMuX3JlbWFpbmluZ1JlamVjdHMgPSBudWxsIC8vIGhvdyBtYW55IHJlamVjdCBtZXNzYWdlcyB0byB0b2xlcmF0ZSBiZWZvcmUgcXVpdHRpbmdcbiAgICB0aGlzLl9mZXRjaGluZyA9IGZhbHNlXG5cbiAgICAvLyBUaGUgbGFyZ2VzdCAudG9ycmVudCBmaWxlIHRoYXQgSSBrbm93IG9mIGlzIH4xLTJNQiwgd2hpY2ggaXMgfjEwMCBwaWVjZXMuXG4gICAgLy8gVGhlcmVmb3JlLCBjYXAgdGhlIGJpdGZpZWxkIHRvIDEweCB0aGF0ICgxMDAwIHBpZWNlcykgc28gYSBtYWxpY2lvdXMgcGVlciBjYW4ndFxuICAgIC8vIG1ha2UgaXQgZ3JvdyB0byBmaWxsIGFsbCBtZW1vcnkuXG4gICAgdGhpcy5fYml0ZmllbGQgPSBuZXcgQml0RmllbGQoMCwgeyBncm93OiBCSVRGSUVMRF9HUk9XIH0pXG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG1ldGFkYXRhKSkge1xuICAgICAgdGhpcy5zZXRNZXRhZGF0YShtZXRhZGF0YSlcbiAgICB9XG4gIH1cblxuICAvLyBOYW1lIG9mIHRoZSBiaXR0b3JyZW50LXByb3RvY29sIGV4dGVuc2lvblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5uYW1lID0gJ3V0X21ldGFkYXRhJ1xuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGluZm9IYXNoLCBwZWVySWQsIGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLl9pbmZvSGFzaCA9IGluZm9IYXNoXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5vbkV4dGVuZGVkSGFuZHNoYWtlID0gZnVuY3Rpb24gKGhhbmRzaGFrZSkge1xuICAgIGlmICghaGFuZHNoYWtlLm0gfHwgIWhhbmRzaGFrZS5tLnV0X21ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQZWVyIGRvZXMgbm90IHN1cHBvcnQgdXRfbWV0YWRhdGEnKSlcbiAgICB9XG4gICAgaWYgKCFoYW5kc2hha2UubWV0YWRhdGFfc2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBkb2VzIG5vdCBoYXZlIG1ldGFkYXRhJykpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgaGFuZHNoYWtlLm1ldGFkYXRhX3NpemUgIT09ICdudW1iZXInIHx8XG4gICAgICAgIE1BWF9NRVRBREFUQV9TSVpFIDwgaGFuZHNoYWtlLm1ldGFkYXRhX3NpemUgfHxcbiAgICAgICAgaGFuZHNoYWtlLm1ldGFkYXRhX3NpemUgPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBnYXZlIGludmFsaWQgbWV0YWRhdGEgc2l6ZScpKVxuICAgIH1cblxuICAgIHRoaXMuX21ldGFkYXRhU2l6ZSA9IGhhbmRzaGFrZS5tZXRhZGF0YV9zaXplXG4gICAgdGhpcy5fbnVtUGllY2VzID0gTWF0aC5jZWlsKHRoaXMuX21ldGFkYXRhU2l6ZSAvIFBJRUNFX0xFTkdUSClcbiAgICB0aGlzLl9yZW1haW5pbmdSZWplY3RzID0gdGhpcy5fbnVtUGllY2VzICogMlxuXG4gICAgaWYgKHRoaXMuX2ZldGNoaW5nKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0UGllY2VzKClcbiAgICB9XG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIGRpY3QsIHRyYWlsZXJcbiAgICB0cnkge1xuICAgICAgdmFyIHN0ciA9IGJ1Zi50b1N0cmluZygpXG4gICAgICB2YXIgdHJhaWxlckluZGV4ID0gc3RyLmluZGV4T2YoJ2VlJykgKyAyXG4gICAgICBkaWN0ID0gYmVuY29kZS5kZWNvZGUoc3RyLnN1YnN0cmluZygwLCB0cmFpbGVySW5kZXgpKVxuICAgICAgdHJhaWxlciA9IGJ1Zi5zbGljZSh0cmFpbGVySW5kZXgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBkcm9wIGludmFsaWQgbWVzc2FnZXNcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN3aXRjaCAoZGljdC5tc2dfdHlwZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvLyB1dF9tZXRhZGF0YSByZXF1ZXN0IChmcm9tIHBlZXIpXG4gICAgICAgIC8vIGV4YW1wbGU6IHsgJ21zZ190eXBlJzogMCwgJ3BpZWNlJzogMCB9XG4gICAgICAgIHRoaXMuX29uUmVxdWVzdChkaWN0LnBpZWNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxOlxuICAgICAgICAvLyB1dF9tZXRhZGF0YSBkYXRhIChpbiByZXNwb25zZSB0byBvdXIgcmVxdWVzdClcbiAgICAgICAgLy8gZXhhbXBsZTogeyAnbXNnX3R5cGUnOiAxLCAncGllY2UnOiAwLCAndG90YWxfc2l6ZSc6IDM0MjUgfVxuICAgICAgICB0aGlzLl9vbkRhdGEoZGljdC5waWVjZSwgdHJhaWxlciwgZGljdC50b3RhbF9zaXplKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyB1dF9tZXRhZGF0YSByZWplY3QgKHBlZXIgZG9lc24ndCBoYXZlIHBpZWNlIHdlIHJlcXVlc3RlZClcbiAgICAgICAgLy8geyAnbXNnX3R5cGUnOiAyLCAncGllY2UnOiAwIH1cbiAgICAgICAgdGhpcy5fb25SZWplY3QoZGljdC5waWVjZSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNrIHRoZSBwZWVyIHRvIHNlbmQgbWV0YWRhdGEuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9tZXRhZGF0YUNvbXBsZXRlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fZmV0Y2hpbmcgPSB0cnVlXG4gICAgaWYgKHRoaXMuX21ldGFkYXRhU2l6ZSkge1xuICAgICAgdGhpcy5fcmVxdWVzdFBpZWNlcygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYXNraW5nIHRoZSBwZWVyIHRvIHNlbmQgbWV0YWRhdGEuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mZXRjaGluZyA9IGZhbHNlXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5zZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgIGlmICh0aGlzLl9tZXRhZGF0YUNvbXBsZXRlKSByZXR1cm4gdHJ1ZVxuICAgIGRlYnVnKCdzZXQgbWV0YWRhdGEnKVxuXG4gICAgLy8gaWYgZnVsbCB0b3JyZW50IGRpY3Rpb25hcnkgd2FzIHBhc3NlZCBpbiwgcHVsbCBvdXQganVzdCBgaW5mb2Aga2V5XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpbmZvID0gYmVuY29kZS5kZWNvZGUobWV0YWRhdGEpLmluZm9cbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIG1ldGFkYXRhID0gYmVuY29kZS5lbmNvZGUoaW5mbylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAvLyBjaGVjayBoYXNoXG4gICAgaWYgKHRoaXMuX2luZm9IYXNoICYmIHRoaXMuX2luZm9IYXNoICE9PSBzaGExLnN5bmMobWV0YWRhdGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLmNhbmNlbCgpXG5cbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGFcbiAgICB0aGlzLl9tZXRhZGF0YUNvbXBsZXRlID0gdHJ1ZVxuICAgIHRoaXMuX21ldGFkYXRhU2l6ZSA9IHRoaXMubWV0YWRhdGEubGVuZ3RoXG4gICAgdGhpcy5fd2lyZS5leHRlbmRlZEhhbmRzaGFrZS5tZXRhZGF0YV9zaXplID0gdGhpcy5fbWV0YWRhdGFTaXplXG5cbiAgICB0aGlzLmVtaXQoJ21ldGFkYXRhJywgYmVuY29kZS5lbmNvZGUoeyBpbmZvOiBiZW5jb2RlLmRlY29kZSh0aGlzLm1ldGFkYXRhKSB9KSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uIChkaWN0LCB0cmFpbGVyKSB7XG4gICAgdmFyIGJ1ZiA9IGJlbmNvZGUuZW5jb2RlKGRpY3QpXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0cmFpbGVyKSkge1xuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB0cmFpbGVyXSlcbiAgICB9XG4gICAgdGhpcy5fd2lyZS5leHRlbmRlZCgndXRfbWV0YWRhdGEnLCBidWYpXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uIChwaWVjZSkge1xuICAgIHRoaXMuX3NlbmQoeyBtc2dfdHlwZTogMCwgcGllY2U6IHBpZWNlIH0pXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fZGF0YSA9IGZ1bmN0aW9uIChwaWVjZSwgYnVmLCB0b3RhbFNpemUpIHtcbiAgICB2YXIgbXNnID0geyBtc2dfdHlwZTogMSwgcGllY2U6IHBpZWNlIH1cbiAgICBpZiAodHlwZW9mIHRvdGFsU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIG1zZy50b3RhbF9zaXplID0gdG90YWxTaXplXG4gICAgfVxuICAgIHRoaXMuX3NlbmQobXNnLCBidWYpXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgdGhpcy5fc2VuZCh7IG1zZ190eXBlOiAyLCBwaWVjZTogcGllY2UgfSlcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9vblJlcXVlc3QgPSBmdW5jdGlvbiAocGllY2UpIHtcbiAgICBpZiAoIXRoaXMuX21ldGFkYXRhQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuX3JlamVjdChwaWVjZSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBwaWVjZSAqIFBJRUNFX0xFTkdUSFxuICAgIHZhciBlbmQgPSBzdGFydCArIFBJRUNFX0xFTkdUSFxuICAgIGlmIChlbmQgPiB0aGlzLl9tZXRhZGF0YVNpemUpIHtcbiAgICAgIGVuZCA9IHRoaXMuX21ldGFkYXRhU2l6ZVxuICAgIH1cbiAgICB2YXIgYnVmID0gdGhpcy5tZXRhZGF0YS5zbGljZShzdGFydCwgZW5kKVxuICAgIHRoaXMuX2RhdGEocGllY2UsIGJ1ZiwgdGhpcy5fbWV0YWRhdGFTaXplKVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX29uRGF0YSA9IGZ1bmN0aW9uIChwaWVjZSwgYnVmLCB0b3RhbFNpemUpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCA+IFBJRUNFX0xFTkdUSCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGJ1Zi5jb3B5KHRoaXMubWV0YWRhdGEsIHBpZWNlICogUElFQ0VfTEVOR1RIKVxuICAgIHRoaXMuX2JpdGZpZWxkLnNldChwaWVjZSlcbiAgICB0aGlzLl9jaGVja0RvbmUoKVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX29uUmVqZWN0ID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZ1JlamVjdHMgPiAwICYmIHRoaXMuX2ZldGNoaW5nKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlbid0IGJlZW4gcmVqZWN0ZWQgdG9vIG11Y2gsIHRoZW4gdHJ5IHRvIHJlcXVlc3QgdGhlIHBpZWNlIGFnYWluXG4gICAgICB0aGlzLl9yZXF1ZXN0KHBpZWNlKVxuICAgICAgdGhpcy5fcmVtYWluaW5nUmVqZWN0cyAtPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBzZW50IFwicmVqZWN0XCIgdG9vIG11Y2gnKSlcbiAgICB9XG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fcmVxdWVzdFBpZWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1ldGFkYXRhID0gQnVmZmVyLmFsbG9jKHRoaXMuX21ldGFkYXRhU2l6ZSlcbiAgICBmb3IgKHZhciBwaWVjZSA9IDA7IHBpZWNlIDwgdGhpcy5fbnVtUGllY2VzOyBwaWVjZSsrKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0KHBpZWNlKVxuICAgIH1cbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9jaGVja0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbmUgPSB0cnVlXG4gICAgZm9yICh2YXIgcGllY2UgPSAwOyBwaWVjZSA8IHRoaXMuX251bVBpZWNlczsgcGllY2UrKykge1xuICAgICAgaWYgKCF0aGlzLl9iaXRmaWVsZC5nZXQocGllY2UpKSB7XG4gICAgICAgIGRvbmUgPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRvbmUpIHJldHVyblxuXG4gICAgLy8gYXR0ZW1wdCB0byBzZXQgbWV0YWRhdGEgLS0gbWF5IGZhaWwgc2hhMSBjaGVja1xuICAgIHZhciBzdWNjZXNzID0gdGhpcy5zZXRNZXRhZGF0YSh0aGlzLm1ldGFkYXRhKVxuXG4gICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9mYWlsZWRNZXRhZGF0YSgpXG4gICAgfVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX2ZhaWxlZE1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlc2V0IGJpdGZpZWxkICYgdHJ5IGFnYWluXG4gICAgdGhpcy5fYml0ZmllbGQgPSBuZXcgQml0RmllbGQoMCwgeyBncm93OiBCSVRGSUVMRF9HUk9XIH0pXG4gICAgdGhpcy5fcmVtYWluaW5nUmVqZWN0cyAtPSB0aGlzLl9udW1QaWVjZXNcbiAgICBpZiAodGhpcy5fcmVtYWluaW5nUmVqZWN0cyA+IDApIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RQaWVjZXMoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ1BlZXIgc2VudCBpbnZhbGlkIG1ldGFkYXRhJykpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHV0TWV0YWRhdGFcbn1cbiIsIi8qIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlICovXG5cbi8vIFRPRE86IGlwdjYgc3VwcG9ydFxuLy8gVE9ETzogcGFyc2UgYW5kIHNlbmQgcGVlciBmbGFncyAoY3VycmVudGx5IHVudXNlZClcbi8vIE5PVEU6IGFkZFBlZXIgc2hvdWxkIHRha2UgaW4gYW4gb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50LCBmbGFnc1xuLy8gVE9ETzogZGVzdHJveSB3aXJlIGlmIHBlZXIgc2VuZHMgUEVYIG1lc3NhZ2VzIHRvbyBmcmVxdWVudGx5XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBjb21wYWN0MnN0cmluZyA9IHJlcXVpcmUoJ2NvbXBhY3Qyc3RyaW5nJylcbnZhciBzdHJpbmcyY29tcGFjdCA9IHJlcXVpcmUoJ3N0cmluZzJjb21wYWN0JylcbnZhciBiZW5jb2RlID0gcmVxdWlyZSgnYmVuY29kZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbnZhciBQRVhfSU5URVJWQUwgPSA2NTAwMCAvLyBqdXN0IG92ZXIgb25lIG1pbnV0ZVxudmFyIFBFWF9NQVhfUEVFUlMgPSA1MCAgICAvLyBtYXggbnVtYmVyIG9mIHBlZXJzIHRvIGFkdmVydGlzZSBwZXIgUEVYIG1lc3NhZ2VcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGluaGVyaXRzKHV0X3BleCwgRXZlbnRFbWl0dGVyKVxuXG4gIGZ1bmN0aW9uIHV0X3BleCAod2lyZSkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG5cbiAgICBzZWxmLl93aXJlID0gd2lyZVxuICAgIHNlbGYuX2ludGVydmFsSWQgPSBudWxsXG5cbiAgICBzZWxmLnJlc2V0KClcbiAgfVxuXG4gIHV0X3BleC5wcm90b3R5cGUubmFtZSA9ICd1dF9wZXgnXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHNlbmRpbmcgcmVndWxhciBQRVggdXBkYXRlcyB0byByZW1vdGUgcGVlci5cbiAgICovXG4gIHV0X3BleC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbElkKVxuICAgIHNlbGYuX2ludGVydmFsSWQgPSBzZXRJbnRlcnZhbChzZWxmLl9zZW5kTWVzc2FnZS5iaW5kKHNlbGYpLCBQRVhfSU5URVJWQUwpXG4gICAgaWYgKHNlbGYuX2ludGVydmFsSWQudW5yZWYpIHNlbGYuX2ludGVydmFsSWQudW5yZWYoKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3Agc2VuZGluZyBQRVggdXBkYXRlcyB0byB0aGUgcmVtb3RlIHBlZXIuXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbElkKVxuICAgIHNlbGYuX2ludGVydmFsSWQgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgc2VuZGluZyB1cGRhdGVzIHRvIHRoZSByZW1vdGUgcGVlciBhbmQgcmVzZXRzIGludGVybmFsIHN0YXRlIG9mIHBlZXJzIHNlZW4uXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHNlbGYuX3JlbW90ZUFkZGVkUGVlcnMgPSB7fVxuICAgIHNlbGYuX3JlbW90ZURyb3BwZWRQZWVycyA9IHt9XG4gICAgc2VsZi5fbG9jYWxBZGRlZFBlZXJzID0ge31cbiAgICBzZWxmLl9sb2NhbERyb3BwZWRQZWVycyA9IHt9XG4gICAgc2VsZi5zdG9wKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGVlciB0byB0aGUgbG9jYWxseSBkaXNjb3ZlcmVkIHBlZXIgbGlzdCBmb3IgdGhlIG5leHQgUEVYIG1lc3NhZ2UuXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLmFkZFBlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGlmIChwZWVyLmluZGV4T2YoJzonKSA8IDApIHJldHVybiAvLyBkaXNyZWdhcmQgaW52YWxpZCBwZWVyc1xuICAgIGlmIChwZWVyIGluIHNlbGYuX3JlbW90ZUFkZGVkUGVlcnMpIHJldHVybiAvLyBuZXZlciBhZHZlcnRpc2UgcGVlciB0aGUgcmVtb3RlIHdpcmUgYWxyZWFkeSBzZW50IHVzXG4gICAgaWYgKHBlZXIgaW4gc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnMpIGRlbGV0ZSBzZWxmLl9sb2NhbERyb3BwZWRQZWVyc1twZWVyXVxuICAgIHNlbGYuX2xvY2FsQWRkZWRQZWVyc1twZWVyXSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGVlciB0byB0aGUgbG9jYWxseSBkcm9wcGVkIHBlZXIgbGlzdCBmb3IgdGhlIG5leHQgUEVYIG1lc3NhZ2UuXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLmRyb3BQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAocGVlci5pbmRleE9mKCc6JykgPCAwKSByZXR1cm4gLy8gZGlzcmVnYXJkIGludmFsaWQgcGVlcnNcbiAgICBpZiAocGVlciBpbiBzZWxmLl9yZW1vdGVEcm9wcGVkUGVlcnMpIHJldHVybiAvLyBuZXZlciBhZHZlcnRpc2UgcGVlciB0aGUgcmVtb3RlIHdpcmUgYWxyZWFkeSBzZW50IHVzXG4gICAgaWYgKHBlZXIgaW4gc2VsZi5fbG9jYWxBZGRlZFBlZXJzKSBkZWxldGUgc2VsZi5fbG9jYWxBZGRlZFBlZXJzW3BlZXJdXG4gICAgc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnNbcGVlcl0gPSB0cnVlXG4gIH1cblxuICB1dF9wZXgucHJvdG90eXBlLm9uRXh0ZW5kZWRIYW5kc2hha2UgPSBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgaWYgKCFoYW5kc2hha2UubSB8fCAhaGFuZHNoYWtlLm0udXRfcGV4KSB7XG4gICAgICByZXR1cm4gc2VsZi5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQZWVyIGRvZXMgbm90IHN1cHBvcnQgdXRfcGV4JykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBFWCBtZXNzYWdlcyBhcmUgYmVuY29kZWQgZGljdGlvbmFyaWVzIHdpdGggdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgKiAnYWRkZWQnICAgICA6IGFycmF5IG9mIHBlZXJzIG1ldCBzaW5jZSBsYXN0IFBFWCBtZXNzYWdlXG4gICAqICdhZGRlZC5mJyAgIDogYXJyYXkgb2YgZmxhZ3MgcGVyIHBlZXJcbiAgICogICcweDAxJyAgICAgOiBwZWVyIHByZWZlcnMgZW5jcnlwdGlvblxuICAgKiAgJzB4MDInICAgICA6IHBlZXIgaXMgc2VlZGVyXG4gICAqICdkcm9wcGVkJyAgIDogYXJyYXkgb2YgcGVlcnMgbG9jYWxseSBkcm9wcGVkIGZyb20gc3dhcm0gc2luY2UgbGFzdCBQRVggbWVzc2FnZVxuICAgKiAnYWRkZWQ2JyAgICA6IGlwdjYgdmVyc2lvbiBvZiAnYWRkZWQnXG4gICAqICdhZGRlZDYuZicgIDogaXB2NiB2ZXJzaW9uIG9mICdhZGRlZC5mJ1xuICAgKiAnZHJvcHBlZC5mJyA6IGlwdjYgdmVyc2lvbiBvZiAnZHJvcHBlZCdcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBiZW5jb2RlZCBQRVggZGljdGlvbmFyeVxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdmFyIG1lc3NhZ2VcblxuICAgIHRyeSB7XG4gICAgICBtZXNzYWdlID0gYmVuY29kZS5kZWNvZGUoYnVmKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZHJvcCBpbnZhbGlkIG1lc3NhZ2VzXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS5hZGRlZCkge1xuICAgICAgY29tcGFjdDJzdHJpbmcubXVsdGkobWVzc2FnZS5hZGRlZCkuZm9yRWFjaChmdW5jdGlvbiAocGVlcikge1xuICAgICAgICBkZWxldGUgc2VsZi5fcmVtb3RlRHJvcHBlZFBlZXJzW3BlZXJdXG4gICAgICAgIGlmICghKHBlZXIgaW4gc2VsZi5fcmVtb3RlQWRkZWRQZWVycykpIHtcbiAgICAgICAgICBzZWxmLl9yZW1vdGVBZGRlZFBlZXJzW3BlZXJdID0gdHJ1ZVxuICAgICAgICAgIHNlbGYuZW1pdCgncGVlcicsIHBlZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UuZHJvcHBlZCkge1xuICAgICAgY29tcGFjdDJzdHJpbmcubXVsdGkobWVzc2FnZS5kcm9wcGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl9yZW1vdGVBZGRlZFBlZXJzW3BlZXJdXG4gICAgICAgIGlmICghKHBlZXIgaW4gc2VsZi5fcmVtb3RlRHJvcHBlZFBlZXJzKSkge1xuICAgICAgICAgIHNlbGYuX3JlbW90ZURyb3BwZWRQZWVyc1twZWVyXSA9IHRydWVcbiAgICAgICAgICBzZWxmLmVtaXQoJ2Ryb3BwZWQnLCBwZWVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIFBFWCBtZXNzYWdlIHRvIHRoZSByZW1vdGUgcGVlciBpbmNsdWRpbmcgaW5mb3JtYXRpb24gYWJvdXQgYW55IGxvY2FsbHlcbiAgICogYWRkZWQgLyBkcm9wcGVkIHBlZXJzLlxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5fc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICB2YXIgbG9jYWxBZGRlZCA9IE9iamVjdC5rZXlzKHNlbGYuX2xvY2FsQWRkZWRQZWVycykuc2xpY2UoMCwgUEVYX01BWF9QRUVSUylcbiAgICB2YXIgbG9jYWxEcm9wcGVkID0gT2JqZWN0LmtleXMoc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnMpLnNsaWNlKDAsIFBFWF9NQVhfUEVFUlMpXG5cbiAgICB2YXIgYWRkZWQgPSBCdWZmZXIuY29uY2F0KGxvY2FsQWRkZWQubWFwKHN0cmluZzJjb21wYWN0KSlcbiAgICB2YXIgZHJvcHBlZCA9IEJ1ZmZlci5jb25jYXQobG9jYWxEcm9wcGVkLm1hcChzdHJpbmcyY29tcGFjdCkpXG5cbiAgICB2YXIgYWRkZWRGbGFncyA9IEJ1ZmZlci5jb25jYXQobG9jYWxBZGRlZC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBmbGFnc1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoWzBdKVxuICAgIH0pKVxuXG4gICAgLy8gdXBkYXRlIGxvY2FsIGRlbHRhc1xuICAgIGxvY2FsQWRkZWQuZm9yRWFjaChmdW5jdGlvbiAocGVlcikgeyBkZWxldGUgc2VsZi5fbG9jYWxBZGRlZFBlZXJzW3BlZXJdIH0pXG4gICAgbG9jYWxEcm9wcGVkLmZvckVhY2goZnVuY3Rpb24gKHBlZXIpIHsgZGVsZXRlIHNlbGYuX2xvY2FsRHJvcHBlZFBlZXJzW3BlZXJdIH0pXG5cbiAgICAvLyBzZW5kIFBFWCBtZXNzYWdlXG4gICAgc2VsZi5fd2lyZS5leHRlbmRlZCgndXRfcGV4Jywge1xuICAgICAgJ2FkZGVkJzogYWRkZWQsXG4gICAgICAnYWRkZWQuZic6IGFkZGVkRmxhZ3MsXG4gICAgICAnZHJvcHBlZCc6IGRyb3BwZWQsXG4gICAgICAnYWRkZWQ2JzogbmV3IEJ1ZmZlcigwKSxcbiAgICAgICdhZGRlZDYuZic6IG5ldyBCdWZmZXIoMCksXG4gICAgICAnZHJvcHBlZDYnOiBuZXcgQnVmZmVyKDApXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB1dF9wZXhcbn1cbiIsInZhciBEaWN0ID0gcmVxdWlyZShcIi4vZGljdFwiKVxuXG4vKipcbiAqIERlY29kZXMgYmVuY29kZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGRhdGFcbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnQgKG9wdGlvbmFsKVxuICogQHBhcmFtICB7TnVtYmVyfSBlbmQgKG9wdGlvbmFsKVxuICogQHBhcmFtICB7U3RyaW5nfSBlbmNvZGluZyAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtPYmplY3R8QXJyYXl8QnVmZmVyfFN0cmluZ3xOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZSggZGF0YSwgc3RhcnQsIGVuZCwgZW5jb2RpbmcgKSB7XG4gIFxuICBpZiggdHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICBzdGFydCA9IHVuZGVmaW5lZFxuICB9XG4gIFxuICBpZiggdHlwZW9mIGVuZCAhPT0gJ251bWJlcicgJiYgZW5jb2RpbmcgPT0gbnVsbCApIHtcbiAgICBlbmNvZGluZyA9IGVuZFxuICAgIGVuZCA9IHVuZGVmaW5lZFxuICB9XG4gIFxuICBkZWNvZGUucG9zaXRpb24gPSAwXG4gIGRlY29kZS5lbmNvZGluZyA9IGVuY29kaW5nIHx8IG51bGxcblxuICBkZWNvZGUuZGF0YSA9ICEoIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSApXG4gICAgPyBuZXcgQnVmZmVyKCBkYXRhIClcbiAgICA6IGRhdGEuc2xpY2UoIHN0YXJ0LCBlbmQgKVxuICBcbiAgZGVjb2RlLmJ5dGVzID0gZGVjb2RlLmRhdGEubGVuZ3RoXG4gIFxuICByZXR1cm4gZGVjb2RlLm5leHQoKVxuXG59XG5cbmRlY29kZS5ieXRlcyA9IDBcbmRlY29kZS5wb3NpdGlvbiA9IDBcbmRlY29kZS5kYXRhICAgICA9IG51bGxcbmRlY29kZS5lbmNvZGluZyA9IG51bGxcblxuZGVjb2RlLm5leHQgPSBmdW5jdGlvbigpIHtcblxuICBzd2l0Y2goIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gKSB7XG4gICAgY2FzZSAweDY0OiByZXR1cm4gZGVjb2RlLmRpY3Rpb25hcnkoKTsgYnJlYWtcbiAgICBjYXNlIDB4NkM6IHJldHVybiBkZWNvZGUubGlzdCgpOyBicmVha1xuICAgIGNhc2UgMHg2OTogcmV0dXJuIGRlY29kZS5pbnRlZ2VyKCk7IGJyZWFrXG4gICAgZGVmYXVsdDogICByZXR1cm4gZGVjb2RlLmJ1ZmZlcigpOyBicmVha1xuICB9XG5cbn1cblxuZGVjb2RlLmZpbmQgPSBmdW5jdGlvbiggY2hyICkge1xuXG4gIHZhciBpID0gZGVjb2RlLnBvc2l0aW9uXG4gIHZhciBjID0gZGVjb2RlLmRhdGEubGVuZ3RoXG4gIHZhciBkID0gZGVjb2RlLmRhdGFcblxuICB3aGlsZSggaSA8IGMgKSB7XG4gICAgaWYoIGRbaV0gPT09IGNociApXG4gICAgICByZXR1cm4gaVxuICAgIGkrK1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdJbnZhbGlkIGRhdGE6IE1pc3NpbmcgZGVsaW1pdGVyIFwiJyArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZSggY2hyICkgKyAnXCIgWzB4JyArXG4gICAgY2hyLnRvU3RyaW5nKCAxNiApICsgJ10nXG4gIClcblxufVxuXG5kZWNvZGUuZGljdGlvbmFyeSA9IGZ1bmN0aW9uKCkge1xuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGRpY3QgPSBuZXcgRGljdCgpXG5cbiAgd2hpbGUoIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gIT09IDB4NjUgKSB7XG4gICAgZGljdC5iaW5hcnlTZXQoZGVjb2RlLmJ1ZmZlcigpLCBkZWNvZGUubmV4dCgpKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gZGljdFxuXG59XG5cbmRlY29kZS5saXN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgbHN0ID0gW11cblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBsc3QucHVzaCggZGVjb2RlLm5leHQoKSApXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBsc3RcblxufVxuXG5kZWNvZGUuaW50ZWdlciA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBlbmQgICAgPSBkZWNvZGUuZmluZCggMHg2NSApXG4gIHZhciBudW1iZXIgPSBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uICsgMSwgZW5kIClcblxuICBkZWNvZGUucG9zaXRpb24gKz0gZW5kICsgMSAtIGRlY29kZS5wb3NpdGlvblxuXG4gIHJldHVybiBwYXJzZUludCggbnVtYmVyLCAxMCApXG5cbn1cblxuZGVjb2RlLmJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzZXAgICAgPSBkZWNvZGUuZmluZCggMHgzQSApXG4gIHZhciBsZW5ndGggPSBwYXJzZUludCggZGVjb2RlLmRhdGEudG9TdHJpbmcoICdhc2NpaScsIGRlY29kZS5wb3NpdGlvbiwgc2VwICksIDEwIClcbiAgdmFyIGVuZCAgICA9ICsrc2VwICsgbGVuZ3RoXG5cbiAgZGVjb2RlLnBvc2l0aW9uID0gZW5kXG5cbiAgcmV0dXJuIGRlY29kZS5lbmNvZGluZ1xuICAgID8gZGVjb2RlLmRhdGEudG9TdHJpbmcoIGRlY29kZS5lbmNvZGluZywgc2VwLCBlbmQgKVxuICAgIDogZGVjb2RlLmRhdGEuc2xpY2UoIHNlcCwgZW5kIClcblxufVxuXG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZVxuIiwiLyoqXG4gKiBFbmNvZGVzIGRhdGEgaW4gYmVuY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE9iamVjdHxOdW1iZXJ8Qm9vbGVhbn0gZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBlbmNvZGUoIGRhdGEsIGJ1ZmZlciwgb2Zmc2V0ICkge1xuICBcbiAgdmFyIGJ1ZmZlcnMgPSBbXVxuICB2YXIgcmVzdWx0ID0gbnVsbFxuICBcbiAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGEgKVxuICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KCBidWZmZXJzIClcbiAgZW5jb2RlLmJ5dGVzID0gcmVzdWx0Lmxlbmd0aFxuICBcbiAgaWYoIEJ1ZmZlci5pc0J1ZmZlciggYnVmZmVyICkgKSB7XG4gICAgcmVzdWx0LmNvcHkoIGJ1ZmZlciwgb2Zmc2V0IClcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRcbiAgXG59XG5cbmVuY29kZS5ieXRlcyA9IC0xXG5lbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gZmFsc2VcblxuZW5jb2RlLl9lbmNvZGUgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBpZiggQnVmZmVyLmlzQnVmZmVyKGRhdGEpICkge1xuICAgIGJ1ZmZlcnMucHVzaChuZXcgQnVmZmVyKGRhdGEubGVuZ3RoICsgJzonKSlcbiAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2goIHR5cGVvZiBkYXRhICkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBkYXRhIClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlcbiAgICAgICAgPyBlbmNvZGUubGlzdCggYnVmZmVycywgZGF0YSApXG4gICAgICAgIDogZW5jb2RlLmRpY3QoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgPyAxIDogMCApXG4gICAgICBicmVha1xuICB9XG5cbn1cblxudmFyIGJ1ZmZfZSA9IG5ldyBCdWZmZXIoJ2UnKVxuICAsIGJ1ZmZfZCA9IG5ldyBCdWZmZXIoJ2QnKVxuICAsIGJ1ZmZfbCA9IG5ldyBCdWZmZXIoJ2wnKVxuXG5lbmNvZGUuYnVmZmVyID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKEJ1ZmZlci5ieXRlTGVuZ3RoKCBkYXRhICkgKyAnOicgKyBkYXRhKSApXG59XG5cbmVuY29kZS5udW1iZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcbiAgdmFyIG1heExvID0gMHg4MDAwMDAwMFxuICB2YXIgaGkgPSAoIGRhdGEgLyBtYXhMbyApIDw8IDBcbiAgdmFyIGxvID0gKCBkYXRhICUgbWF4TG8gICkgPDwgMFxuICB2YXIgdmFsID0gaGkgKiBtYXhMbyArIGxvXG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKCAnaScgKyB2YWwgKyAnZScgKSlcblxuICBpZiggdmFsICE9PSBkYXRhICYmICFlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkICkge1xuICAgIGVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSB0cnVlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dBUk5JTkc6IFBvc3NpYmxlIGRhdGEgY29ycnVwdGlvbiBkZXRlY3RlZCB3aXRoIHZhbHVlIFwiJytkYXRhKydcIjonLFxuICAgICAgJ0JlbmNvZGluZyBvbmx5IGRlZmluZXMgc3VwcG9ydCBmb3IgaW50ZWdlcnMsIHZhbHVlIHdhcyBjb252ZXJ0ZWQgdG8gXCInK3ZhbCsnXCInXG4gICAgKVxuICAgIGNvbnNvbGUudHJhY2UoKVxuICB9XG5cbn1cblxuZW5jb2RlLmRpY3QgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZCApXG5cbiAgdmFyIGogPSAwXG4gIHZhciBrXG4gIC8vIGZpeCBmb3IgaXNzdWUgIzEzIC0gc29ydGVkIGRpY3RzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGRhdGEgKS5zb3J0KClcbiAgdmFyIGtsID0ga2V5cy5sZW5ndGhcblxuICBmb3IoIDsgaiA8IGtsIDsgaisrKSB7XG4gICAgaz1rZXlzW2pdXG4gICAgZW5jb2RlLmJ1ZmZlciggYnVmZmVycywgayApXG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFba10gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxufVxuXG5lbmNvZGUubGlzdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIHZhciBpID0gMCwgaiA9IDFcbiAgdmFyIGMgPSBkYXRhLmxlbmd0aFxuICBidWZmZXJzLnB1c2goIGJ1ZmZfbCApXG5cbiAgZm9yKCA7IGkgPCBjOyBpKysgKSB7XG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFbaV0gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxuXG59XG5cbi8vIEV4cG9zZVxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJ2YXIgYnMgPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoJylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtcDQgPSByZXF1aXJlKCdtcDQtc3RyZWFtJylcbnZhciBCb3ggPSByZXF1aXJlKCdtcDQtYm94LWVuY29kaW5nJylcbnZhciBSYW5nZVNsaWNlU3RyZWFtID0gcmVxdWlyZSgncmFuZ2Utc2xpY2Utc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBNUDRSZW11eGVyXG5cbmZ1bmN0aW9uIE1QNFJlbXV4ZXIgKGZpbGUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG5cdHNlbGYuX3RyYWNrcyA9IFtdXG5cdHNlbGYuX2ZyYWdtZW50U2VxdWVuY2UgPSAxXG5cdHNlbGYuX2ZpbGUgPSBmaWxlXG5cdHNlbGYuX2RlY29kZXIgPSBudWxsXG5cdHNlbGYuX2ZpbmRNb292KDApXG59XG5cbmluaGVyaXRzKE1QNFJlbXV4ZXIsIEV2ZW50RW1pdHRlcilcblxuTVA0UmVtdXhlci5wcm90b3R5cGUuX2ZpbmRNb292ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVjb2Rlcikge1xuXHRcdHNlbGYuX2RlY29kZXIuZGVzdHJveSgpXG5cdH1cblxuXHRzZWxmLl9kZWNvZGVyID0gbXA0LmRlY29kZSgpXG5cdHZhciBmaWxlU3RyZWFtID0gc2VsZi5fZmlsZS5jcmVhdGVSZWFkU3RyZWFtKHtcblx0XHRzdGFydDogb2Zmc2V0XG5cdH0pXG5cdGZpbGVTdHJlYW0ucGlwZShzZWxmLl9kZWNvZGVyKVxuXG5cdHNlbGYuX2RlY29kZXIub25jZSgnYm94JywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcblx0XHRpZiAoaGVhZGVycy50eXBlID09PSAnbW9vdicpIHtcblx0XHRcdHNlbGYuX2RlY29kZXIuZGVjb2RlKGZ1bmN0aW9uIChtb292KSB7XG5cdFx0XHRcdGZpbGVTdHJlYW0uZGVzdHJveSgpXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0c2VsZi5fcHJvY2Vzc01vb3YobW9vdilcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0ZXJyLm1lc3NhZ2UgPSAnQ2Fubm90IHBhcnNlIG1wNCBmaWxlOiAnICsgZXJyLm1lc3NhZ2Vcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmaWxlU3RyZWFtLmRlc3Ryb3koKVxuXHRcdFx0c2VsZi5fZmluZE1vb3Yob2Zmc2V0ICsgaGVhZGVycy5sZW5ndGgpXG5cdFx0fVxuXHR9KVxufVxuXG5mdW5jdGlvbiBSdW5MZW5ndGhJbmRleCAoZW50cmllcywgY291bnROYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9lbnRyaWVzID0gZW50cmllc1xuXHRzZWxmLl9jb3VudE5hbWUgPSBjb3VudE5hbWUgfHwgJ2NvdW50J1xuXHRzZWxmLl9pbmRleCA9IDBcblx0c2VsZi5fb2Zmc2V0ID0gMFxuXG5cdHNlbGYudmFsdWUgPSBzZWxmLl9lbnRyaWVzWzBdXG59XG5cblJ1bkxlbmd0aEluZGV4LnByb3RvdHlwZS5pbmMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9vZmZzZXQrK1xuXHRpZiAoc2VsZi5fb2Zmc2V0ID49IHNlbGYuX2VudHJpZXNbc2VsZi5faW5kZXhdW3NlbGYuX2NvdW50TmFtZV0pIHtcblx0XHRzZWxmLl9pbmRleCsrXG5cdFx0c2VsZi5fb2Zmc2V0ID0gMFxuXHR9XG5cblx0c2VsZi52YWx1ZSA9IHNlbGYuX2VudHJpZXNbc2VsZi5faW5kZXhdXG59XG5cbk1QNFJlbXV4ZXIucHJvdG90eXBlLl9wcm9jZXNzTW9vdiA9IGZ1bmN0aW9uIChtb292KSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciB0cmFrcyA9IG1vb3YudHJha3Ncblx0c2VsZi5fdHJhY2tzID0gW11cblx0c2VsZi5faGFzVmlkZW8gPSBmYWxzZVxuXHRzZWxmLl9oYXNBdWRpbyA9IGZhbHNlXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdHJha3MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdHJhayA9IHRyYWtzW2ldXG5cdFx0dmFyIHN0YmwgPSB0cmFrLm1kaWEubWluZi5zdGJsXG5cdFx0dmFyIHN0c2RFbnRyeSA9IHN0Ymwuc3RzZC5lbnRyaWVzWzBdXG5cdFx0dmFyIGhhbmRsZXJUeXBlID0gdHJhay5tZGlhLmhkbHIuaGFuZGxlclR5cGVcblx0XHR2YXIgY29kZWNcblx0XHR2YXIgbWltZVxuXHRcdGlmIChoYW5kbGVyVHlwZSA9PT0gJ3ZpZGUnICYmIHN0c2RFbnRyeS50eXBlID09PSAnYXZjMScpIHtcblx0XHRcdGlmIChzZWxmLl9oYXNWaWRlbykge1xuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0c2VsZi5faGFzVmlkZW8gPSB0cnVlXG5cdFx0XHRjb2RlYyA9ICdhdmMxJ1xuXHRcdFx0aWYgKHN0c2RFbnRyeS5hdmNDKSB7XG5cdFx0XHRcdGNvZGVjICs9ICcuJyArIHN0c2RFbnRyeS5hdmNDLm1pbWVDb2RlY1xuXHRcdFx0fVxuXHRcdFx0bWltZSA9ICd2aWRlby9tcDQ7IGNvZGVjcz1cIicgKyBjb2RlYyArICdcIidcblx0XHR9IGVsc2UgaWYgKGhhbmRsZXJUeXBlID09PSAnc291bicgJiYgc3RzZEVudHJ5LnR5cGUgPT09ICdtcDRhJykge1xuXHRcdFx0aWYgKHNlbGYuX2hhc0F1ZGlvKSB7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRzZWxmLl9oYXNBdWRpbyA9IHRydWVcblx0XHRcdGNvZGVjID0gJ21wNGEnXG5cdFx0XHRpZiAoc3RzZEVudHJ5LmVzZHMgJiYgc3RzZEVudHJ5LmVzZHMubWltZUNvZGVjKSB7XG5cdFx0XHRcdGNvZGVjICs9ICcuJyArIHN0c2RFbnRyeS5lc2RzLm1pbWVDb2RlY1xuXHRcdFx0fVxuXHRcdFx0bWltZSA9ICdhdWRpby9tcDQ7IGNvZGVjcz1cIicgKyBjb2RlYyArICdcIidcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGludWVcblx0XHR9XG5cblx0XHR2YXIgc2FtcGxlcyA9IFtdXG5cdFx0dmFyIHNhbXBsZSA9IDBcblxuXHRcdC8vIENodW5rL3Bvc2l0aW9uIGRhdGFcblx0XHR2YXIgc2FtcGxlSW5DaHVuayA9IDBcblx0XHR2YXIgY2h1bmsgPSAwXG5cdFx0dmFyIG9mZnNldEluQ2h1bmsgPSAwXG5cdFx0dmFyIHNhbXBsZVRvQ2h1bmtJbmRleCA9IDBcblxuXHRcdC8vIFRpbWUgZGF0YVxuXHRcdHZhciBkdHMgPSAwXG5cdFx0dmFyIGRlY29kaW5nVGltZUVudHJ5ID0gbmV3IFJ1bkxlbmd0aEluZGV4KHN0Ymwuc3R0cy5lbnRyaWVzKVxuXHRcdHZhciBwcmVzZW50YXRpb25PZmZzZXRFbnRyeSA9IG51bGxcblx0XHRpZiAoc3RibC5jdHRzKSB7XG5cdFx0XHRwcmVzZW50YXRpb25PZmZzZXRFbnRyeSA9IG5ldyBSdW5MZW5ndGhJbmRleChzdGJsLmN0dHMuZW50cmllcylcblx0XHR9XG5cblx0XHQvLyBTeW5jIHRhYmxlIGluZGV4XG5cdFx0dmFyIHN5bmNTYW1wbGVJbmRleCA9IDBcblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHR2YXIgY3VyckNodW5rRW50cnkgPSBzdGJsLnN0c2MuZW50cmllc1tzYW1wbGVUb0NodW5rSW5kZXhdXG5cblx0XHRcdC8vIENvbXB1dGUgc2l6ZVxuXHRcdFx0dmFyIHNpemUgPSBzdGJsLnN0c3ouZW50cmllc1tzYW1wbGVdXG5cblx0XHRcdC8vIENvbXB1dGUgdGltZSBkYXRhXG5cdFx0XHR2YXIgZHVyYXRpb24gPSBkZWNvZGluZ1RpbWVFbnRyeS52YWx1ZS5kdXJhdGlvblxuXHRcdFx0dmFyIHByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvbk9mZnNldEVudHJ5ID8gcHJlc2VudGF0aW9uT2Zmc2V0RW50cnkudmFsdWUuY29tcG9zaXRpb25PZmZzZXQgOiAwXG5cblx0XHRcdC8vIENvbXB1dGUgc3luY1xuXHRcdFx0dmFyIHN5bmMgPSB0cnVlXG5cdFx0XHRpZiAoc3RibC5zdHNzKSB7XG5cdFx0XHRcdHN5bmMgPSBzdGJsLnN0c3MuZW50cmllc1tzeW5jU2FtcGxlSW5kZXhdID09PSBzYW1wbGUgKyAxXG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBuZXcgc2FtcGxlIGVudHJ5XG5cdFx0XHRzYW1wbGVzLnB1c2goe1xuXHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRcdGR0czogZHRzLFxuXHRcdFx0XHRwcmVzZW50YXRpb25PZmZzZXQ6IHByZXNlbnRhdGlvbk9mZnNldCxcblx0XHRcdFx0c3luYzogc3luYyxcblx0XHRcdFx0b2Zmc2V0OiBvZmZzZXRJbkNodW5rICsgc3RibC5zdGNvLmVudHJpZXNbY2h1bmtdXG5cdFx0XHR9KVxuXG5cdFx0XHQvLyBHbyB0byBuZXh0IHNhbXBsZVxuXHRcdFx0c2FtcGxlKytcblx0XHRcdGlmIChzYW1wbGUgPj0gc3RibC5zdHN6LmVudHJpZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cblx0XHRcdC8vIE1vdmUgcG9zaXRpb24vY2h1bmtcblx0XHRcdHNhbXBsZUluQ2h1bmsrK1xuXHRcdFx0b2Zmc2V0SW5DaHVuayArPSBzaXplXG5cdFx0XHRpZiAoc2FtcGxlSW5DaHVuayA+PSBjdXJyQ2h1bmtFbnRyeS5zYW1wbGVzUGVyQ2h1bmspIHtcblx0XHRcdFx0Ly8gTW92ZSB0byBuZXcgY2h1bmtcblx0XHRcdFx0c2FtcGxlSW5DaHVuayA9IDBcblx0XHRcdFx0b2Zmc2V0SW5DaHVuayA9IDBcblx0XHRcdFx0Y2h1bmsrK1xuXHRcdFx0XHQvLyBNb3ZlIHNhbXBsZSB0byBjaHVuayBib3ggaW5kZXhcblx0XHRcdFx0dmFyIG5leHRDaHVua0VudHJ5ID0gc3RibC5zdHNjLmVudHJpZXNbc2FtcGxlVG9DaHVua0luZGV4ICsgMV1cblx0XHRcdFx0aWYgKG5leHRDaHVua0VudHJ5ICYmIGNodW5rICsgMSA+PSBuZXh0Q2h1bmtFbnRyeS5maXJzdENodW5rKSB7XG5cdFx0XHRcdFx0c2FtcGxlVG9DaHVua0luZGV4Kytcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBNb3ZlIHRpbWUgZm9yd2FyZFxuXHRcdFx0ZHRzICs9IGR1cmF0aW9uXG5cdFx0XHRkZWNvZGluZ1RpbWVFbnRyeS5pbmMoKVxuXHRcdFx0cHJlc2VudGF0aW9uT2Zmc2V0RW50cnkgJiYgcHJlc2VudGF0aW9uT2Zmc2V0RW50cnkuaW5jKClcblxuXHRcdFx0Ly8gTW92ZSBzeW5jIHRhYmxlIGluZGV4XG5cdFx0XHRpZiAoc3luYykge1xuXHRcdFx0XHRzeW5jU2FtcGxlSW5kZXgrK1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRyYWsubWRpYS5tZGhkLmR1cmF0aW9uID0gMFxuXHRcdHRyYWsudGtoZC5kdXJhdGlvbiA9IDBcblxuXHRcdHZhciBkZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleCA9IGN1cnJDaHVua0VudHJ5LnNhbXBsZURlc2NyaXB0aW9uSWRcblxuXHRcdHZhciB0cmFja01vb3YgPSB7XG5cdFx0XHR0eXBlOiAnbW9vdicsXG5cdFx0XHRtdmhkOiBtb292Lm12aGQsXG5cdFx0XHR0cmFrczogW3tcblx0XHRcdFx0dGtoZDogdHJhay50a2hkLFxuXHRcdFx0XHRtZGlhOiB7XG5cdFx0XHRcdFx0bWRoZDogdHJhay5tZGlhLm1kaGQsXG5cdFx0XHRcdFx0aGRscjogdHJhay5tZGlhLmhkbHIsXG5cdFx0XHRcdFx0ZWxuZzogdHJhay5tZGlhLmVsbmcsXG5cdFx0XHRcdFx0bWluZjoge1xuXHRcdFx0XHRcdFx0dm1oZDogdHJhay5tZGlhLm1pbmYudm1oZCxcblx0XHRcdFx0XHRcdHNtaGQ6IHRyYWsubWRpYS5taW5mLnNtaGQsXG5cdFx0XHRcdFx0XHRkaW5mOiB0cmFrLm1kaWEubWluZi5kaW5mLFxuXHRcdFx0XHRcdFx0c3RibDoge1xuXHRcdFx0XHRcdFx0XHRzdHNkOiBzdGJsLnN0c2QsXG5cdFx0XHRcdFx0XHRcdHN0dHM6IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdGN0dHM6IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdHN0c2M6IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdHN0c3o6IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdHN0Y286IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdHN0c3M6IGVtcHR5KClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1dLFxuXHRcdFx0bXZleDoge1xuXHRcdFx0XHRtZWhkOiB7XG5cdFx0XHRcdFx0ZnJhZ21lbnREdXJhdGlvbjogbW9vdi5tdmhkLmR1cmF0aW9uXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRyZXhzOiBbe1xuXHRcdFx0XHRcdHRyYWNrSWQ6IHRyYWsudGtoZC50cmFja0lkLFxuXHRcdFx0XHRcdGRlZmF1bHRTYW1wbGVEZXNjcmlwdGlvbkluZGV4OiBkZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleCxcblx0XHRcdFx0XHRkZWZhdWx0U2FtcGxlRHVyYXRpb246IDAsXG5cdFx0XHRcdFx0ZGVmYXVsdFNhbXBsZVNpemU6IDAsXG5cdFx0XHRcdFx0ZGVmYXVsdFNhbXBsZUZsYWdzOiAwXG5cdFx0XHRcdH1dXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5fdHJhY2tzLnB1c2goe1xuXHRcdFx0dHJhY2tJZDogdHJhay50a2hkLnRyYWNrSWQsXG5cdFx0XHR0aW1lU2NhbGU6IHRyYWsubWRpYS5tZGhkLnRpbWVTY2FsZSxcblx0XHRcdHNhbXBsZXM6IHNhbXBsZXMsXG5cdFx0XHRjdXJyU2FtcGxlOiBudWxsLFxuXHRcdFx0Y3VyclRpbWU6IG51bGwsXG5cdFx0XHRtb292OiB0cmFja01vb3YsXG5cdFx0XHRtaW1lOiBtaW1lXG5cdFx0fSlcblx0fVxuXG5cdGlmIChzZWxmLl90cmFja3MubGVuZ3RoID09PSAwKSB7XG5cdFx0c2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gcGxheWFibGUgdHJhY2tzJykpXG5cdFx0cmV0dXJuXG5cdH1cblxuXHQvLyBNdXN0IGJlIHNldCBsYXN0IHNpbmNlIHRoaXMgaXMgdXNlZCBhYm92ZVxuXHRtb292Lm12aGQuZHVyYXRpb24gPSAwXG5cblx0c2VsZi5fZnR5cCA9IHtcblx0XHR0eXBlOiAnZnR5cCcsXG5cdFx0YnJhbmQ6ICdpc281Jyxcblx0XHRicmFuZFZlcnNpb246IDAsXG5cdFx0Y29tcGF0aWJsZUJyYW5kczogW1xuXHRcdFx0J2lzbzUnXG5cdFx0XVxuXHR9XG5cblx0dmFyIGZ0eXBCdWYgPSBCb3guZW5jb2RlKHNlbGYuX2Z0eXApXG5cdHZhciBkYXRhID0gc2VsZi5fdHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHtcblx0XHR2YXIgbW9vdkJ1ZiA9IEJveC5lbmNvZGUodHJhY2subW9vdilcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWltZTogdHJhY2subWltZSxcblx0XHRcdGluaXQ6IEJ1ZmZlci5jb25jYXQoW2Z0eXBCdWYsIG1vb3ZCdWZdKVxuXHRcdH1cblx0fSlcblxuXHRzZWxmLmVtaXQoJ3JlYWR5JywgZGF0YSlcbn1cblxuZnVuY3Rpb24gZW1wdHkgKCkge1xuXHRyZXR1cm4ge1xuXHRcdHZlcnNpb246IDAsXG5cdFx0ZmxhZ3M6IDAsXG5cdFx0ZW50cmllczogW11cblx0fVxufVxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICghc2VsZi5fdHJhY2tzKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgcmVhZHkgeWV0OyB3YWl0IGZvciBcXCdyZWFkeVxcJyBldmVudCcpXG5cdH1cblxuXHRpZiAoc2VsZi5fZmlsZVN0cmVhbSkge1xuXHRcdHNlbGYuX2ZpbGVTdHJlYW0uZGVzdHJveSgpXG5cdFx0c2VsZi5fZmlsZVN0cmVhbSA9IG51bGxcblx0fVxuXG5cdHZhciBzdGFydE9mZnNldCA9IC0xXG5cdHNlbGYuX3RyYWNrcy5tYXAoZnVuY3Rpb24gKHRyYWNrLCBpKSB7XG5cdFx0Ly8gZmluZCB0aGUga2V5ZnJhbWUgYmVmb3JlIHRoZSB0aW1lXG5cdFx0Ly8gc3RyZWFtIGZyb20gdGhlcmVcblx0XHRpZiAodHJhY2sub3V0U3RyZWFtKSB7XG5cdFx0XHR0cmFjay5vdXRTdHJlYW0uZGVzdHJveSgpXG5cdFx0fVxuXHRcdGlmICh0cmFjay5pblN0cmVhbSkge1xuXHRcdFx0dHJhY2suaW5TdHJlYW0uZGVzdHJveSgpXG5cdFx0XHR0cmFjay5pblN0cmVhbSA9IG51bGxcblx0XHR9XG5cdFx0dmFyIG91dFN0cmVhbSA9IHRyYWNrLm91dFN0cmVhbSA9IG1wNC5lbmNvZGUoKVxuXHRcdHZhciBmcmFnbWVudCA9IHNlbGYuX2dlbmVyYXRlRnJhZ21lbnQoaSwgdGltZSlcblx0XHRpZiAoIWZyYWdtZW50KSB7XG5cdFx0XHRyZXR1cm4gb3V0U3RyZWFtLmZpbmFsaXplKClcblx0XHR9XG5cblx0XHRpZiAoc3RhcnRPZmZzZXQgPT09IC0xIHx8IGZyYWdtZW50LnJhbmdlc1swXS5zdGFydCA8IHN0YXJ0T2Zmc2V0KSB7XG5cdFx0XHRzdGFydE9mZnNldCA9IGZyYWdtZW50LnJhbmdlc1swXS5zdGFydFxuXHRcdH1cblxuXHRcdHdyaXRlRnJhZ21lbnQoZnJhZ21lbnQpXG5cblx0XHRmdW5jdGlvbiB3cml0ZUZyYWdtZW50IChmcmFnKSB7XG5cdFx0XHRpZiAob3V0U3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuXG5cdFx0XHRvdXRTdHJlYW0uYm94KGZyYWcubW9vZiwgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRpZiAoZXJyKSByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0aWYgKG91dFN0cmVhbS5kZXN0cm95ZWQpIHJldHVyblxuXHRcdFx0XHR2YXIgc2xpY2VkU3RyZWFtID0gdHJhY2suaW5TdHJlYW0uc2xpY2UoZnJhZy5yYW5nZXMpXG5cdFx0XHRcdHNsaWNlZFN0cmVhbS5waXBlKG91dFN0cmVhbS5tZWRpYURhdGEoZnJhZy5sZW5ndGgsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRpZiAoZXJyKSByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0XHRpZiAob3V0U3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuXG5cdFx0XHRcdFx0dmFyIG5leHRGcmFnID0gc2VsZi5fZ2VuZXJhdGVGcmFnbWVudChpKVxuXHRcdFx0XHRcdGlmICghbmV4dEZyYWcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvdXRTdHJlYW0uZmluYWxpemUoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3cml0ZUZyYWdtZW50KG5leHRGcmFnKVxuXHRcdFx0XHR9KSlcblx0XHRcdH0pXG5cdFx0fVxuXHR9KVxuXG5cdGlmIChzdGFydE9mZnNldCA+PSAwKSB7XG5cdFx0dmFyIGZpbGVTdHJlYW0gPSBzZWxmLl9maWxlU3RyZWFtID0gc2VsZi5fZmlsZS5jcmVhdGVSZWFkU3RyZWFtKHtcblx0XHRcdHN0YXJ0OiBzdGFydE9mZnNldFxuXHRcdH0pXG5cblx0XHRzZWxmLl90cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdHRyYWNrLmluU3RyZWFtID0gbmV3IFJhbmdlU2xpY2VTdHJlYW0oc3RhcnRPZmZzZXQpXG5cdFx0XHRmaWxlU3RyZWFtLnBpcGUodHJhY2suaW5TdHJlYW0pXG5cdFx0fSlcblx0fVxuXG5cdHJldHVybiBzZWxmLl90cmFja3MubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuXHRcdHJldHVybiB0cmFjay5vdXRTdHJlYW1cblx0fSlcbn1cblxuTVA0UmVtdXhlci5wcm90b3R5cGUuX2ZpbmRTYW1wbGVCZWZvcmUgPSBmdW5jdGlvbiAodHJhY2tJbmQsIHRpbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHRyYWNrID0gc2VsZi5fdHJhY2tzW3RyYWNrSW5kXVxuXHR2YXIgc2NhbGVkVGltZSA9IE1hdGguZmxvb3IodHJhY2sudGltZVNjYWxlICogdGltZSlcblx0dmFyIHNhbXBsZSA9IGJzKHRyYWNrLnNhbXBsZXMsIHNjYWxlZFRpbWUsIGZ1bmN0aW9uIChzYW1wbGUsIHQpIHtcblx0XHR2YXIgcHRzID0gc2FtcGxlLmR0cyArIHNhbXBsZS5wcmVzZW50YXRpb25PZmZzZXQvLyAtIHRyYWNrLmVkaXRTaGlmdFxuXHRcdHJldHVybiBwdHMgLSB0XG5cdH0pXG5cdGlmIChzYW1wbGUgPT09IC0xKSB7XG5cdFx0c2FtcGxlID0gMFxuXHR9IGVsc2UgaWYgKHNhbXBsZSA8IDApIHtcblx0XHRzYW1wbGUgPSAtc2FtcGxlIC0gMlxuXHR9XG5cdC8vIHNhbXBsZSBpcyBub3cgdGhlIGxhc3Qgc2FtcGxlIHdpdGggZHRzIDw9IHRpbWVcblx0Ly8gRmluZCB0aGUgcHJlY2VlZGluZyBzeW5jIHNhbXBsZVxuXHR3aGlsZSAoIXRyYWNrLnNhbXBsZXNbc2FtcGxlXS5zeW5jKSB7XG5cdFx0c2FtcGxlLS1cblx0fVxuXHRyZXR1cm4gc2FtcGxlXG59XG5cbnZhciBNSU5fRlJBR01FTlRfRFVSQVRJT04gPSAxIC8vIHNlY29uZFxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5fZ2VuZXJhdGVGcmFnbWVudCA9IGZ1bmN0aW9uICh0cmFjaywgdGltZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0Lypcblx0MS4gRmluZCBjb3JyZWN0IHNhbXBsZVxuXHQyLiBQcm9jZXNzIGJhY2t3YXJkIHVudGlsIHN5bmMgc2FtcGxlIGZvdW5kXG5cdDMuIFByb2Nlc3MgZm9yd2FyZCB1bnRpbCBuZXh0IHN5bmMgc2FtcGxlIGFmdGVyIE1JTl9GUkFHTUVOVF9EVVJBVElPTiBmb3VuZFxuXHQqL1xuXHR2YXIgY3VyclRyYWNrID0gc2VsZi5fdHJhY2tzW3RyYWNrXVxuXHR2YXIgZmlyc3RTYW1wbGVcblx0aWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZpcnN0U2FtcGxlID0gc2VsZi5fZmluZFNhbXBsZUJlZm9yZSh0cmFjaywgdGltZSlcblx0fSBlbHNlIHtcblx0XHRmaXJzdFNhbXBsZSA9IGN1cnJUcmFjay5jdXJyU2FtcGxlXG5cdH1cblxuXHRpZiAoZmlyc3RTYW1wbGUgPj0gY3VyclRyYWNrLnNhbXBsZXMubGVuZ3RoKVxuXHRcdHJldHVybiBudWxsXG5cblx0dmFyIHN0YXJ0RHRzID0gY3VyclRyYWNrLnNhbXBsZXNbZmlyc3RTYW1wbGVdLmR0c1xuXG5cdHZhciB0b3RhbExlbiA9IDBcblx0dmFyIHJhbmdlcyA9IFtdXG5cdGZvciAodmFyIGN1cnJTYW1wbGUgPSBmaXJzdFNhbXBsZTsgY3VyclNhbXBsZSA8IGN1cnJUcmFjay5zYW1wbGVzLmxlbmd0aDsgY3VyclNhbXBsZSsrKSB7XG5cdFx0dmFyIHNhbXBsZSA9IGN1cnJUcmFjay5zYW1wbGVzW2N1cnJTYW1wbGVdXG5cdFx0aWYgKHNhbXBsZS5zeW5jICYmIHNhbXBsZS5kdHMgLSBzdGFydER0cyA+PSBjdXJyVHJhY2sudGltZVNjYWxlICogTUlOX0ZSQUdNRU5UX0RVUkFUSU9OKSB7XG5cdFx0XHRicmVhayAvLyBUaGlzIGlzIGEgcmVhc29uYWJsZSBwbGFjZSB0byBlbmQgdGhlIGZyYWdtZW50XG5cdFx0fVxuXG5cdFx0dG90YWxMZW4gKz0gc2FtcGxlLnNpemVcblx0XHR2YXIgY3VyclJhbmdlID0gcmFuZ2VzLmxlbmd0aCAtIDFcblx0XHRpZiAoY3VyclJhbmdlIDwgMCB8fCByYW5nZXNbY3VyclJhbmdlXS5lbmQgIT09IHNhbXBsZS5vZmZzZXQpIHtcblx0XHRcdC8vIFB1c2ggYSBuZXcgcmFuZ2Vcblx0XHRcdHJhbmdlcy5wdXNoKHtcblx0XHRcdFx0c3RhcnQ6IHNhbXBsZS5vZmZzZXQsXG5cdFx0XHRcdGVuZDogc2FtcGxlLm9mZnNldCArIHNhbXBsZS5zaXplXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYW5nZXNbY3VyclJhbmdlXS5lbmQgKz0gc2FtcGxlLnNpemVcblx0XHR9XG5cdH1cblxuXHRjdXJyVHJhY2suY3VyclNhbXBsZSA9IGN1cnJTYW1wbGVcblxuXHRyZXR1cm4ge1xuXHRcdG1vb2Y6IHNlbGYuX2dlbmVyYXRlTW9vZih0cmFjaywgZmlyc3RTYW1wbGUsIGN1cnJTYW1wbGUpLFxuXHRcdHJhbmdlczogcmFuZ2VzLFxuXHRcdGxlbmd0aDogdG90YWxMZW5cblx0fVxufVxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5fZ2VuZXJhdGVNb29mID0gZnVuY3Rpb24gKHRyYWNrLCBmaXJzdFNhbXBsZSwgbGFzdFNhbXBsZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgY3VyclRyYWNrID0gc2VsZi5fdHJhY2tzW3RyYWNrXVxuXG5cdHZhciBlbnRyaWVzID0gW11cblx0Zm9yICh2YXIgaiA9IGZpcnN0U2FtcGxlOyBqIDwgbGFzdFNhbXBsZTsgaisrKSB7XG5cdFx0dmFyIGN1cnJTYW1wbGUgPSBjdXJyVHJhY2suc2FtcGxlc1tqXVxuXHRcdGVudHJpZXMucHVzaCh7XG5cdFx0XHRzYW1wbGVEdXJhdGlvbjogY3VyclNhbXBsZS5kdXJhdGlvbixcblx0XHRcdHNhbXBsZVNpemU6IGN1cnJTYW1wbGUuc2l6ZSxcblx0XHRcdHNhbXBsZUZsYWdzOiBjdXJyU2FtcGxlLnN5bmMgPyAweDIwMDAwMDAgOiAweDEwMTAwMDAsXG5cdFx0XHRzYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQ6IGN1cnJTYW1wbGUucHJlc2VudGF0aW9uT2Zmc2V0XG5cdFx0fSlcblx0fVxuXG5cdHZhciBtb29mID0ge1xuXHRcdHR5cGU6ICdtb29mJyxcblx0XHRtZmhkOiB7XG5cdFx0XHRzZXF1ZW5jZU51bWJlcjogc2VsZi5fZnJhZ21lbnRTZXF1ZW5jZSsrXG5cdFx0fSxcblx0XHR0cmFmczogW3tcblx0XHRcdHRmaGQ6IHtcblx0XHRcdFx0ZmxhZ3M6IDB4MjAwMDAsIC8vIGRlZmF1bHQtYmFzZS1pcy1tb29mXG5cdFx0XHRcdHRyYWNrSWQ6IGN1cnJUcmFjay50cmFja0lkXG5cdFx0XHR9LFxuXHRcdFx0dGZkdDoge1xuXHRcdFx0XHRiYXNlTWVkaWFEZWNvZGVUaW1lOiBjdXJyVHJhY2suc2FtcGxlc1tmaXJzdFNhbXBsZV0uZHRzXG5cdFx0XHR9LFxuXHRcdFx0dHJ1bjoge1xuXHRcdFx0XHRmbGFnczogMHhmMDEsXG5cdFx0XHRcdGRhdGFPZmZzZXQ6IDgsIC8vIFRoZSBtb29mIHNpemUgaGFzIHRvIGJlIGFkZGVkIHRvIHRoaXMgbGF0ZXIgYXMgd2VsbFxuXHRcdFx0XHRlbnRyaWVzOiBlbnRyaWVzXG5cdFx0XHR9XG5cdFx0fV1cblx0fVxuXG5cdC8vIFVwZGF0ZSB0aGUgb2Zmc2V0XG5cdG1vb2YudHJhZnNbMF0udHJ1bi5kYXRhT2Zmc2V0ICs9IEJveC5lbmNvZGluZ0xlbmd0aChtb29mKVxuXG5cdHJldHVybiBtb29mXG59XG4iLCJ2YXIgTWVkaWFFbGVtZW50V3JhcHBlciA9IHJlcXVpcmUoJ21lZGlhc291cmNlJylcbnZhciBwdW1wID0gcmVxdWlyZSgncHVtcCcpXG5cbnZhciBNUDRSZW11eGVyID0gcmVxdWlyZSgnLi9tcDQtcmVtdXhlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gVmlkZW9TdHJlYW1cblxuZnVuY3Rpb24gVmlkZW9TdHJlYW0gKGZpbGUsIG1lZGlhRWxlbSwgb3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFZpZGVvU3RyZWFtKSkgcmV0dXJuIG5ldyBWaWRlb1N0cmVhbShmaWxlLCBtZWRpYUVsZW0sIG9wdHMpXG5cdG9wdHMgPSBvcHRzIHx8IHt9XG5cblx0c2VsZi5fZWxlbSA9IG1lZGlhRWxlbVxuXHRzZWxmLl9lbGVtV3JhcHBlciA9IG5ldyBNZWRpYUVsZW1lbnRXcmFwcGVyKG1lZGlhRWxlbSlcblx0c2VsZi5fd2FpdGluZ0ZpcmVkID0gZmFsc2Vcblx0c2VsZi5fdHJhY2tNZXRhID0gbnVsbFxuXHRzZWxmLl9maWxlID0gZmlsZVxuXHRzZWxmLl90cmFja3MgPSBudWxsXG5cdGlmIChzZWxmLl9lbGVtLnByZWxvYWQgIT09ICdub25lJykge1xuXHRcdHNlbGYuX2NyZWF0ZU11eGVyKClcblx0fVxuXG5cdHNlbGYuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0c2VsZi5kZXN0cm95KCkgLy8gZG9uJ3QgcGFzcyBlcnIgdGhvdWdoIHNvIHRoZSB1c2VyIGRvZXNuJ3QgbmVlZCB0byBsaXN0ZW4gZm9yIGVycm9yc1xuXHR9XG5cdHNlbGYuX29uV2FpdGluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRzZWxmLl93YWl0aW5nRmlyZWQgPSB0cnVlXG5cdFx0aWYgKCFzZWxmLl9tdXhlcikge1xuXHRcdFx0c2VsZi5fY3JlYXRlTXV4ZXIoKVxuXHRcdH0gZWxzZSBpZiAoc2VsZi5fdHJhY2tzKSB7XG5cdFx0XHRzZWxmLl9wdW1wKClcblx0XHR9XG5cdH1cblx0c2VsZi5fZWxlbS5hZGRFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgc2VsZi5fb25XYWl0aW5nKVxuXHRzZWxmLl9lbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fb25FcnJvcilcbn1cblxuVmlkZW9TdHJlYW0ucHJvdG90eXBlLl9jcmVhdGVNdXhlciA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHNlbGYuX211eGVyID0gbmV3IE1QNFJlbXV4ZXIoc2VsZi5fZmlsZSlcblx0c2VsZi5fbXV4ZXIub24oJ3JlYWR5JywgZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRzZWxmLl90cmFja3MgPSBkYXRhLm1hcChmdW5jdGlvbiAodHJhY2tEYXRhKSB7XG5cdFx0XHR2YXIgbWVkaWFTb3VyY2UgPSBzZWxmLl9lbGVtV3JhcHBlci5jcmVhdGVXcml0ZVN0cmVhbSh0cmFja0RhdGEubWltZSlcblx0XHRcdG1lZGlhU291cmNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0c2VsZi5fZWxlbVdyYXBwZXIuZXJyb3IoZXJyKVxuXHRcdFx0fSlcblx0XHRcdG1lZGlhU291cmNlLndyaXRlKHRyYWNrRGF0YS5pbml0KVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bXV4ZWQ6IG51bGwsXG5cdFx0XHRcdG1lZGlhU291cmNlOiBtZWRpYVNvdXJjZVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRpZiAoc2VsZi5fd2FpdGluZ0ZpcmVkIHx8IHNlbGYuX2VsZW0ucHJlbG9hZCA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRzZWxmLl9wdW1wKClcblx0XHR9XG5cdH0pXG5cblx0c2VsZi5fbXV4ZXIub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHRcdHNlbGYuX2VsZW1XcmFwcGVyLmVycm9yKGVycilcblx0fSlcbn1cblxuVmlkZW9TdHJlYW0ucHJvdG90eXBlLl9wdW1wID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgbXV4ZWQgPSBzZWxmLl9tdXhlci5zZWVrKHNlbGYuX2VsZW0uY3VycmVudFRpbWUsICFzZWxmLl90cmFja3MpXG5cblx0c2VsZi5fdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrLCBpKSB7XG5cdFx0aWYgKHRyYWNrLm11eGVkKSB7XG5cdFx0XHR0cmFjay5tdXhlZC5kZXN0cm95KClcblx0XHRcdHRyYWNrLm1lZGlhU291cmNlID0gc2VsZi5fZWxlbVdyYXBwZXIuY3JlYXRlV3JpdGVTdHJlYW0odHJhY2subWVkaWFTb3VyY2UpXG5cdFx0XHR0cmFjay5tZWRpYVNvdXJjZS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdHNlbGYuX2VsZW1XcmFwcGVyLmVycm9yKGVycilcblx0XHRcdH0pXG5cdFx0fVxuXHRcdHRyYWNrLm11eGVkID0gbXV4ZWRbaV1cblx0XHRwdW1wKHRyYWNrLm11eGVkLCB0cmFjay5tZWRpYVNvdXJjZSlcblx0fSlcbn1cblxuVmlkZW9TdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAoc2VsZi5kZXN0cm95ZWQpIHtcblx0XHRyZXR1cm5cblx0fVxuXHRzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuXHRzZWxmLl9lbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCBzZWxmLl9vbldhaXRpbmcpXG5cdHNlbGYuX2VsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9vbkVycm9yKVxuXG5cdGlmIChzZWxmLl90cmFja3MpIHtcblx0XHRzZWxmLl90cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdHRyYWNrLm11eGVkLmRlc3Ryb3koKVxuXHRcdH0pXG5cdH1cblxuXHRzZWxmLl9lbGVtLnNyYyA9ICcnXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFdlYlRvcnJlbnRcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY29uY2F0ID0gcmVxdWlyZSgnc2ltcGxlLWNvbmNhdCcpXG52YXIgY3JlYXRlVG9ycmVudCA9IHJlcXVpcmUoJ2NyZWF0ZS10b3JyZW50JylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3dlYnRvcnJlbnQnKVxudmFyIERIVCA9IHJlcXVpcmUoJ2JpdHRvcnJlbnQtZGh0L2NsaWVudCcpIC8vIGJyb3dzZXIgZXhjbHVkZVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBoYXQgPSByZXF1aXJlKCdoYXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIGxvYWRJUFNldCA9IHJlcXVpcmUoJ2xvYWQtaXAtc2V0JykgLy8gYnJvd3NlciBleGNsdWRlXG52YXIgcGFyYWxsZWwgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwnKVxudmFyIHBhcnNlVG9ycmVudCA9IHJlcXVpcmUoJ3BhcnNlLXRvcnJlbnQnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBQZWVyID0gcmVxdWlyZSgnc2ltcGxlLXBlZXInKVxudmFyIHNwZWVkb21ldGVyID0gcmVxdWlyZSgnc3BlZWRvbWV0ZXInKVxudmFyIHplcm9GaWxsID0gcmVxdWlyZSgnemVyby1maWxsJylcblxudmFyIFRDUFBvb2wgPSByZXF1aXJlKCcuL2xpYi90Y3AtcG9vbCcpIC8vIGJyb3dzZXIgZXhjbHVkZVxudmFyIFRvcnJlbnQgPSByZXF1aXJlKCcuL2xpYi90b3JyZW50JylcblxuLyoqXG4gKiBXZWJUb3JyZW50IHZlcnNpb24uXG4gKi9cbnZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbi8qKlxuICogVmVyc2lvbiBudW1iZXIgaW4gQXp1cmV1cy1zdHlsZS4gR2VuZXJhdGVkIGZyb20gbWFqb3IgYW5kIG1pbm9yIHNlbXZlciB2ZXJzaW9uLlxuICogRm9yIGV4YW1wbGU6XG4gKiAgICcwLjE2LjEnIC0+ICcwMDE2J1xuICogICAnMS4yLjUnIC0+ICcwMTAyJ1xuICovXG52YXIgVkVSU0lPTl9TVFIgPSBWRVJTSU9OLm1hdGNoKC8oWzAtOV0rKS9nKS5zbGljZSgwLCAyKS5tYXAoemVyb0ZpbGwoMikpLmpvaW4oJycpXG5cbi8qKlxuICogVmVyc2lvbiBwcmVmaXggc3RyaW5nICh1c2VkIGluIHBlZXIgSUQpLiBXZWJUb3JyZW50IHVzZXMgdGhlIEF6dXJldXMtc3R5bGVcbiAqIGVuY29kaW5nOiAnLScsIHR3byBjaGFyYWN0ZXJzIGZvciBjbGllbnQgaWQgKCdXVycpLCBmb3VyIGFzY2lpIGRpZ2l0cyBmb3IgdmVyc2lvblxuICogbnVtYmVyLCAnLScsIGZvbGxvd2VkIGJ5IHJhbmRvbSBudW1iZXJzLlxuICogRm9yIGV4YW1wbGU6XG4gKiAgICctV1cwMTAyLScuLi5cbiAqL1xudmFyIFZFUlNJT05fUFJFRklYID0gJy1XVycgKyBWRVJTSU9OX1NUUiArICctJ1xuXG5pbmhlcml0cyhXZWJUb3JyZW50LCBFdmVudEVtaXR0ZXIpXG5cbi8qKlxuICogV2ViVG9ycmVudCBDbGllbnRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0c1xuICovXG5mdW5jdGlvbiBXZWJUb3JyZW50IChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgV2ViVG9ycmVudCkpIHJldHVybiBuZXcgV2ViVG9ycmVudChvcHRzKVxuICBFdmVudEVtaXR0ZXIuY2FsbChzZWxmKVxuXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgaWYgKHR5cGVvZiBvcHRzLnBlZXJJZCA9PT0gJ3N0cmluZycpIHtcbiAgICBzZWxmLnBlZXJJZCA9IG9wdHMucGVlcklkXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG9wdHMucGVlcklkKSkge1xuICAgIHNlbGYucGVlcklkID0gb3B0cy5wZWVySWQudG9TdHJpbmcoJ2hleCcpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5wZWVySWQgPSBCdWZmZXIuZnJvbShWRVJTSU9OX1BSRUZJWCArIGhhdCg0OCkpXG4gIH1cbiAgc2VsZi5wZWVySWRCdWZmZXIgPSBCdWZmZXIuZnJvbShzZWxmLnBlZXJJZCwgJ2hleCcpXG5cbiAgaWYgKHR5cGVvZiBvcHRzLm5vZGVJZCA9PT0gJ3N0cmluZycpIHtcbiAgICBzZWxmLm5vZGVJZCA9IG9wdHMubm9kZUlkXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG9wdHMubm9kZUlkKSkge1xuICAgIHNlbGYubm9kZUlkID0gb3B0cy5ub2RlSWQudG9TdHJpbmcoJ2hleCcpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5ub2RlSWQgPSBoYXQoMTYwKVxuICB9XG4gIHNlbGYubm9kZUlkQnVmZmVyID0gQnVmZmVyLmZyb20oc2VsZi5ub2RlSWQsICdoZXgnKVxuXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcbiAgc2VsZi5saXN0ZW5pbmcgPSBmYWxzZVxuICBzZWxmLnRvcnJlbnRQb3J0ID0gb3B0cy50b3JyZW50UG9ydCB8fCAwXG4gIHNlbGYuZGh0UG9ydCA9IG9wdHMuZGh0UG9ydCB8fCAwXG4gIHNlbGYudHJhY2tlciA9IG9wdHMudHJhY2tlciAhPT0gdW5kZWZpbmVkID8gb3B0cy50cmFja2VyIDoge31cbiAgc2VsZi50b3JyZW50cyA9IFtdXG4gIHNlbGYubWF4Q29ubnMgPSBOdW1iZXIob3B0cy5tYXhDb25ucykgfHwgNTVcblxuICBpZiAoc2VsZi50cmFja2VyKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmLnRyYWNrZXIgIT09ICdvYmplY3QnKSBzZWxmLnRyYWNrZXIgPSB7fVxuICAgIGlmIChvcHRzLnJ0Y0NvbmZpZykge1xuICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHYxXG4gICAgICBjb25zb2xlLndhcm4oJ1dlYlRvcnJlbnQ6IG9wdHMucnRjQ29uZmlnIGlzIGRlcHJlY2F0ZWQuIFVzZSBvcHRzLnRyYWNrZXIucnRjQ29uZmlnIGluc3RlYWQnKVxuICAgICAgc2VsZi50cmFja2VyLnJ0Y0NvbmZpZyA9IG9wdHMucnRjQ29uZmlnXG4gICAgfVxuICAgIGlmIChvcHRzLndydGMpIHtcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB2MVxuICAgICAgY29uc29sZS53YXJuKCdXZWJUb3JyZW50OiBvcHRzLndydGMgaXMgZGVwcmVjYXRlZC4gVXNlIG9wdHMudHJhY2tlci53cnRjIGluc3RlYWQnKVxuICAgICAgc2VsZi50cmFja2VyLndydGMgPSBvcHRzLndydGMgLy8gdG8gc3VwcG9ydCBgd2VidG9ycmVudC1oeWJyaWRgIHBhY2thZ2VcbiAgICB9XG4gICAgaWYgKGdsb2JhbC5XUlRDICYmICFzZWxmLnRyYWNrZXIud3J0Yykgc2VsZi50cmFja2VyLndydGMgPSBnbG9iYWwuV1JUQ1xuICB9XG5cbiAgaWYgKHR5cGVvZiBUQ1BQb29sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5fdGNwUG9vbCA9IG5ldyBUQ1BQb29sKHNlbGYpXG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9vbkxpc3RlbmluZygpXG4gICAgfSlcbiAgfVxuXG4gIC8vIHN0YXRzXG4gIHNlbGYuX2Rvd25sb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG4gIHNlbGYuX3VwbG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuXG4gIGlmIChvcHRzLmRodCAhPT0gZmFsc2UgJiYgdHlwZW9mIERIVCA9PT0gJ2Z1bmN0aW9uJyAvKiBicm93c2VyIGV4Y2x1ZGUgKi8pIHtcbiAgICAvLyB1c2UgYSBzaW5nbGUgREhUIGluc3RhbmNlIGZvciBhbGwgdG9ycmVudHMsIHNvIHRoZSByb3V0aW5nIHRhYmxlIGNhbiBiZSByZXVzZWRcbiAgICBzZWxmLmRodCA9IG5ldyBESFQoZXh0ZW5kKHsgbm9kZUlkOiBzZWxmLm5vZGVJZCB9LCBvcHRzLmRodCkpXG5cbiAgICBzZWxmLmRodC5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICAgIH0pXG5cbiAgICBzZWxmLmRodC5vbmNlKCdsaXN0ZW5pbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWRkcmVzcyA9IHNlbGYuZGh0LmFkZHJlc3MoKVxuICAgICAgaWYgKGFkZHJlc3MpIHNlbGYuZGh0UG9ydCA9IGFkZHJlc3MucG9ydFxuICAgIH0pXG5cbiAgICAvLyBJZ25vcmUgd2FybmluZyB3aGVuIHRoZXJlIGFyZSA+IDEwIHRvcnJlbnRzIGluIHRoZSBjbGllbnRcbiAgICBzZWxmLmRodC5zZXRNYXhMaXN0ZW5lcnMoMClcblxuICAgIHNlbGYuZGh0Lmxpc3RlbihzZWxmLmRodFBvcnQpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5kaHQgPSBmYWxzZVxuICB9XG5cbiAgZGVidWcoJ25ldyB3ZWJ0b3JyZW50IChwZWVySWQgJXMsIG5vZGVJZCAlcyknLCBzZWxmLnBlZXJJZCwgc2VsZi5ub2RlSWQpXG5cbiAgaWYgKHR5cGVvZiBsb2FkSVBTZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBsb2FkSVBTZXQob3B0cy5ibG9ja2xpc3QsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ3VzZXItYWdlbnQnOiAnV2ViVG9ycmVudC8nICsgVkVSU0lPTiArICcgKGh0dHBzOi8vd2VidG9ycmVudC5pbyknXG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVyciwgaXBTZXQpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBibG9ja2xpc3Q6ICcgKyBlcnIubWVzc2FnZSlcbiAgICAgIHNlbGYuYmxvY2tlZCA9IGlwU2V0XG4gICAgICByZWFkeSgpXG4gICAgfSlcbiAgfSBlbHNlIHByb2Nlc3MubmV4dFRpY2socmVhZHkpXG5cbiAgZnVuY3Rpb24gcmVhZHkgKCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgc2VsZi5yZWFkeSA9IHRydWVcbiAgICBzZWxmLmVtaXQoJ3JlYWR5JylcbiAgfVxufVxuXG5XZWJUb3JyZW50LldFQlJUQ19TVVBQT1JUID0gUGVlci5XRUJSVENfU1VQUE9SVFxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViVG9ycmVudC5wcm90b3R5cGUsICdkb3dubG9hZFNwZWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rvd25sb2FkU3BlZWQoKSB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViVG9ycmVudC5wcm90b3R5cGUsICd1cGxvYWRTcGVlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl91cGxvYWRTcGVlZCgpIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJUb3JyZW50LnByb3RvdHlwZSwgJ3Byb2dyZXNzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9ycmVudHMgPSB0aGlzLnRvcnJlbnRzLmZpbHRlcihmdW5jdGlvbiAodG9ycmVudCkge1xuICAgICAgcmV0dXJuIHRvcnJlbnQucHJvZ3Jlc3MgIT09IDFcbiAgICB9KVxuICAgIHZhciBkb3dubG9hZGVkID0gdG9ycmVudHMucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgdG9ycmVudCkge1xuICAgICAgcmV0dXJuIHRvdGFsICsgdG9ycmVudC5kb3dubG9hZGVkXG4gICAgfSwgMClcbiAgICB2YXIgbGVuZ3RoID0gdG9ycmVudHMucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgdG9ycmVudCkge1xuICAgICAgcmV0dXJuIHRvdGFsICsgKHRvcnJlbnQubGVuZ3RoIHx8IDApXG4gICAgfSwgMCkgfHwgMVxuICAgIHJldHVybiBkb3dubG9hZGVkIC8gbGVuZ3RoXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJUb3JyZW50LnByb3RvdHlwZSwgJ3JhdGlvJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXBsb2FkZWQgPSB0aGlzLnRvcnJlbnRzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIHRvcnJlbnQpIHtcbiAgICAgIHJldHVybiB0b3RhbCArIHRvcnJlbnQudXBsb2FkZWRcbiAgICB9LCAwKVxuICAgIHZhciByZWNlaXZlZCA9IHRoaXMudG9ycmVudHMucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgdG9ycmVudCkge1xuICAgICAgcmV0dXJuIHRvdGFsICsgdG9ycmVudC5yZWNlaXZlZFxuICAgIH0sIDApIHx8IDFcbiAgICByZXR1cm4gdXBsb2FkZWQgLyByZWNlaXZlZFxuICB9XG59KVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRvcnJlbnQgd2l0aCB0aGUgZ2l2ZW4gYHRvcnJlbnRJZGAuIENvbnZlbmllbmNlIG1ldGhvZC4gRWFzaWVyIHRoYW5cbiAqIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBgY2xpZW50LnRvcnJlbnRzYCBhcnJheS4gUmV0dXJucyBgbnVsbGAgaWYgbm8gbWF0Y2hpbmcgdG9ycmVudFxuICogZm91bmQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfEJ1ZmZlcnxPYmplY3R8VG9ycmVudH0gdG9ycmVudElkXG4gKiBAcmV0dXJuIHtUb3JyZW50fG51bGx9XG4gKi9cbldlYlRvcnJlbnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b3JyZW50SWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpLCB0b3JyZW50XG4gIHZhciBsZW4gPSBzZWxmLnRvcnJlbnRzLmxlbmd0aFxuXG4gIGlmICh0b3JyZW50SWQgaW5zdGFuY2VvZiBUb3JyZW50KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0b3JyZW50ID0gc2VsZi50b3JyZW50c1tpXVxuICAgICAgaWYgKHRvcnJlbnQgPT09IHRvcnJlbnRJZCkgcmV0dXJuIHRvcnJlbnRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnNlZFxuICAgIHRyeSB7IHBhcnNlZCA9IHBhcnNlVG9ycmVudCh0b3JyZW50SWQpIH0gY2F0Y2ggKGVycikge31cblxuICAgIGlmICghcGFyc2VkKSByZXR1cm4gbnVsbFxuICAgIGlmICghcGFyc2VkLmluZm9IYXNoKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9ycmVudCBpZGVudGlmaWVyJylcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdG9ycmVudCA9IHNlbGYudG9ycmVudHNbaV1cbiAgICAgIGlmICh0b3JyZW50LmluZm9IYXNoID09PSBwYXJzZWQuaW5mb0hhc2gpIHJldHVybiB0b3JyZW50XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8vIFRPRE86IHJlbW92ZSBpbiB2MVxuV2ViVG9ycmVudC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbiAodG9ycmVudElkLCBvcHRzLCBvbnRvcnJlbnQpIHtcbiAgY29uc29sZS53YXJuKCdXZWJUb3JyZW50OiBjbGllbnQuZG93bmxvYWQoKSBpcyBkZXByZWNhdGVkLiBVc2UgY2xpZW50LmFkZCgpIGluc3RlYWQnKVxuICByZXR1cm4gdGhpcy5hZGQodG9ycmVudElkLCBvcHRzLCBvbnRvcnJlbnQpXG59XG5cbi8qKlxuICogU3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgdG9ycmVudC4gQWxpYXNlZCBhcyBgY2xpZW50LmRvd25sb2FkYC5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxPYmplY3R9IHRvcnJlbnRJZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgdG9ycmVudC1zcGVjaWZpYyBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb250b3JyZW50IGNhbGxlZCB3aGVuIHRoZSB0b3JyZW50IGlzIHJlYWR5IChoYXMgbWV0YWRhdGEpXG4gKi9cbldlYlRvcnJlbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0b3JyZW50SWQsIG9wdHMsIG9udG9ycmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudCBpcyBkZXN0cm95ZWQnKVxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmLmFkZCh0b3JyZW50SWQsIG51bGwsIG9wdHMpXG5cbiAgZGVidWcoJ2FkZCcpXG4gIG9wdHMgPSBvcHRzID8gZXh0ZW5kKG9wdHMpIDoge31cblxuICB2YXIgdG9ycmVudCA9IG5ldyBUb3JyZW50KHRvcnJlbnRJZCwgc2VsZiwgb3B0cylcbiAgc2VsZi50b3JyZW50cy5wdXNoKHRvcnJlbnQpXG5cbiAgdG9ycmVudC5vbmNlKCdfaW5mb0hhc2gnLCBvbkluZm9IYXNoKVxuICB0b3JyZW50Lm9uY2UoJ3JlYWR5Jywgb25SZWFkeSlcbiAgdG9ycmVudC5vbmNlKCdjbG9zZScsIG9uQ2xvc2UpXG5cbiAgZnVuY3Rpb24gb25JbmZvSGFzaCAoKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi50b3JyZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHQgPSBzZWxmLnRvcnJlbnRzW2ldXG4gICAgICBpZiAodC5pbmZvSGFzaCA9PT0gdG9ycmVudC5pbmZvSGFzaCAmJiB0ICE9PSB0b3JyZW50KSB7XG4gICAgICAgIHRvcnJlbnQuX2Rlc3Ryb3kobmV3IEVycm9yKCdDYW5ub3QgYWRkIGR1cGxpY2F0ZSB0b3JyZW50ICcgKyB0b3JyZW50LmluZm9IYXNoKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZWFkeSAoKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAodHlwZW9mIG9udG9ycmVudCA9PT0gJ2Z1bmN0aW9uJykgb250b3JyZW50KHRvcnJlbnQpXG4gICAgc2VsZi5lbWl0KCd0b3JyZW50JywgdG9ycmVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xvc2UgKCkge1xuICAgIHRvcnJlbnQucmVtb3ZlTGlzdGVuZXIoJ19pbmZvSGFzaCcsIG9uSW5mb0hhc2gpXG4gICAgdG9ycmVudC5yZW1vdmVMaXN0ZW5lcigncmVhZHknLCBvblJlYWR5KVxuICAgIHRvcnJlbnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSlcbiAgfVxuXG4gIHJldHVybiB0b3JyZW50XG59XG5cbi8qKlxuICogU3RhcnQgc2VlZGluZyBhIG5ldyBmaWxlL2ZvbGRlci5cbiAqIEBwYXJhbSAge3N0cmluZ3xGaWxlfEZpbGVMaXN0fEJ1ZmZlcnxBcnJheS48c3RyaW5nfEZpbGV8QnVmZmVyPn0gaW5wdXRcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdHNcbiAqIEBwYXJhbSAge2Z1bmN0aW9uPX0gb25zZWVkIGNhbGxlZCB3aGVuIHRvcnJlbnQgaXMgc2VlZGluZ1xuICovXG5XZWJUb3JyZW50LnByb3RvdHlwZS5zZWVkID0gZnVuY3Rpb24gKGlucHV0LCBvcHRzLCBvbnNlZWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdjbGllbnQgaXMgZGVzdHJveWVkJylcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZi5zZWVkKGlucHV0LCBudWxsLCBvcHRzKVxuXG4gIGRlYnVnKCdzZWVkJylcbiAgb3B0cyA9IG9wdHMgPyBleHRlbmQob3B0cykgOiB7fVxuXG4gIC8vIFdoZW4gc2VlZGluZyBmcm9tIGZzIHBhdGgsIGluaXRpYWxpemUgc3RvcmUgZnJvbSB0aGF0IHBhdGggdG8gYXZvaWQgYSBjb3B5XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSBvcHRzLnBhdGggPSBwYXRoLmRpcm5hbWUoaW5wdXQpXG4gIGlmICghb3B0cy5jcmVhdGVkQnkpIG9wdHMuY3JlYXRlZEJ5ID0gJ1dlYlRvcnJlbnQvJyArIFZFUlNJT05fU1RSXG4gIGlmICghc2VsZi50cmFja2VyKSBvcHRzLmFubm91bmNlID0gW11cblxuICB2YXIgdG9ycmVudCA9IHNlbGYuYWRkKG51bGwsIG9wdHMsIG9uVG9ycmVudClcbiAgdmFyIHN0cmVhbXNcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSBpbnB1dCA9IFsgaW5wdXQgXVxuICBwYXJhbGxlbChpbnB1dC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBpZiAoaXNSZWFkYWJsZShpdGVtKSkgY29uY2F0KGl0ZW0sIGNiKVxuICAgICAgZWxzZSBjYihudWxsLCBpdGVtKVxuICAgIH1cbiAgfSksIGZ1bmN0aW9uIChlcnIsIGlucHV0KSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAoZXJyKSByZXR1cm4gdG9ycmVudC5fZGVzdHJveShlcnIpXG5cbiAgICBjcmVhdGVUb3JyZW50LnBhcnNlSW5wdXQoaW5wdXQsIG9wdHMsIGZ1bmN0aW9uIChlcnIsIGZpbGVzKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgaWYgKGVycikgcmV0dXJuIHRvcnJlbnQuX2Rlc3Ryb3koZXJyKVxuXG4gICAgICBzdHJlYW1zID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHJldHVybiBmaWxlLmdldFN0cmVhbVxuICAgICAgfSlcblxuICAgICAgY3JlYXRlVG9ycmVudChpbnB1dCwgb3B0cywgZnVuY3Rpb24gKGVyciwgdG9ycmVudEJ1Zikge1xuICAgICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICBpZiAoZXJyKSByZXR1cm4gdG9ycmVudC5fZGVzdHJveShlcnIpXG5cbiAgICAgICAgdmFyIGV4aXN0aW5nVG9ycmVudCA9IHNlbGYuZ2V0KHRvcnJlbnRCdWYpXG4gICAgICAgIGlmIChleGlzdGluZ1RvcnJlbnQpIHtcbiAgICAgICAgICB0b3JyZW50Ll9kZXN0cm95KG5ldyBFcnJvcignQ2Fubm90IGFkZCBkdXBsaWNhdGUgdG9ycmVudCAnICsgZXhpc3RpbmdUb3JyZW50LmluZm9IYXNoKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3JyZW50Ll9vblRvcnJlbnRJZCh0b3JyZW50QnVmKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gb25Ub3JyZW50ICh0b3JyZW50KSB7XG4gICAgdmFyIHRhc2tzID0gW1xuICAgICAgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHRvcnJlbnQubG9hZChzdHJlYW1zLCBjYilcbiAgICAgIH1cbiAgICBdXG4gICAgaWYgKHNlbGYuZGh0KSB7XG4gICAgICB0YXNrcy5wdXNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICB0b3JyZW50Lm9uY2UoJ2RodEFubm91bmNlJywgY2IpXG4gICAgICB9KVxuICAgIH1cbiAgICBwYXJhbGxlbCh0YXNrcywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIGlmIChlcnIpIHJldHVybiB0b3JyZW50Ll9kZXN0cm95KGVycilcbiAgICAgIF9vbnNlZWQodG9ycmVudClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gX29uc2VlZCAodG9ycmVudCkge1xuICAgIGRlYnVnKCdvbiBzZWVkJylcbiAgICBpZiAodHlwZW9mIG9uc2VlZCA9PT0gJ2Z1bmN0aW9uJykgb25zZWVkKHRvcnJlbnQpXG4gICAgc2VsZi5lbWl0KCdzZWVkJywgdG9ycmVudClcbiAgfVxuXG4gIHJldHVybiB0b3JyZW50XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgdG9ycmVudCBmcm9tIHRoZSBjbGllbnQuXG4gKiBAcGFyYW0gIHtzdHJpbmd8QnVmZmVyfFRvcnJlbnR9ICAgdG9ycmVudElkXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2JcbiAqL1xuV2ViVG9ycmVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRvcnJlbnRJZCwgY2IpIHtcbiAgZGVidWcoJ3JlbW92ZScpXG4gIHZhciB0b3JyZW50ID0gdGhpcy5nZXQodG9ycmVudElkKVxuICBpZiAoIXRvcnJlbnQpIHRocm93IG5ldyBFcnJvcignTm8gdG9ycmVudCB3aXRoIGlkICcgKyB0b3JyZW50SWQpXG4gIHRoaXMuX3JlbW92ZSh0b3JyZW50SWQsIGNiKVxufVxuXG5XZWJUb3JyZW50LnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKHRvcnJlbnRJZCwgY2IpIHtcbiAgdmFyIHRvcnJlbnQgPSB0aGlzLmdldCh0b3JyZW50SWQpXG4gIGlmICghdG9ycmVudCkgcmV0dXJuXG4gIHRoaXMudG9ycmVudHMuc3BsaWNlKHRoaXMudG9ycmVudHMuaW5kZXhPZih0b3JyZW50KSwgMSlcbiAgdG9ycmVudC5kZXN0cm95KGNiKVxufVxuXG5XZWJUb3JyZW50LnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMubGlzdGVuaW5nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gdGhpcy5fdGNwUG9vbFxuICAgID8gdGhpcy5fdGNwUG9vbC5zZXJ2ZXIuYWRkcmVzcygpXG4gICAgOiB7IGFkZHJlc3M6ICcwLjAuMC4wJywgZmFtaWx5OiAnSVB2NCcsIHBvcnQ6IDAgfVxufVxuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGNsaWVudCwgaW5jbHVkaW5nIGFsbCB0b3JyZW50cyBhbmQgY29ubmVjdGlvbnMgdG8gcGVlcnMuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2JcbiAqL1xuV2ViVG9ycmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignY2xpZW50IGFscmVhZHkgZGVzdHJveWVkJylcbiAgdGhpcy5fZGVzdHJveShudWxsLCBjYilcbn1cblxuV2ViVG9ycmVudC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ2NsaWVudCBkZXN0cm95JylcbiAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgdmFyIHRhc2tzID0gc2VsZi50b3JyZW50cy5tYXAoZnVuY3Rpb24gKHRvcnJlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICB0b3JyZW50LmRlc3Ryb3koY2IpXG4gICAgfVxuICB9KVxuXG4gIGlmIChzZWxmLl90Y3BQb29sKSB7XG4gICAgdGFza3MucHVzaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHNlbGYuX3RjcFBvb2wuZGVzdHJveShjYilcbiAgICB9KVxuICB9XG5cbiAgaWYgKHNlbGYuZGh0KSB7XG4gICAgdGFza3MucHVzaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHNlbGYuZGh0LmRlc3Ryb3koY2IpXG4gICAgfSlcbiAgfVxuXG4gIHBhcmFsbGVsKHRhc2tzLCBjYilcblxuICBpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXG4gIHNlbGYudG9ycmVudHMgPSBbXVxuICBzZWxmLl90Y3BQb29sID0gbnVsbFxuICBzZWxmLmRodCA9IG51bGxcbn1cblxuV2ViVG9ycmVudC5wcm90b3R5cGUuX29uTGlzdGVuaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxpc3RlbmluZyA9IHRydWVcblxuICBpZiAodGhpcy5fdGNwUG9vbCkge1xuICAgIC8vIFNvbWV0aW1lcyBzZXJ2ZXIuYWRkcmVzcygpIHJldHVybnMgYG51bGxgIGluIERvY2tlci5cbiAgICAvLyBXZWJUb3JyZW50IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2JpdHRvcnJlbnQtc3dhcm0vcHVsbC8xOFxuICAgIHZhciBhZGRyZXNzID0gdGhpcy5fdGNwUG9vbC5zZXJ2ZXIuYWRkcmVzcygpXG4gICAgaWYgKGFkZHJlc3MpIHRoaXMudG9ycmVudFBvcnQgPSBhZGRyZXNzLnBvcnRcbiAgfVxuXG4gIHRoaXMuZW1pdCgnbGlzdGVuaW5nJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIG5vZGUgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUmVhZGFibGUgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEZpbGVTdHJlYW1cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2VidG9ycmVudDpmaWxlLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxuaW5oZXJpdHMoRmlsZVN0cmVhbSwgc3RyZWFtLlJlYWRhYmxlKVxuXG4vKipcbiAqIFJlYWRhYmxlIHN0cmVhbSBvZiBhIHRvcnJlbnQgZmlsZVxuICpcbiAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnN0YXJ0IHN0cmVhbSBzbGljZSBvZiBmaWxlLCBzdGFydGluZyBmcm9tIHRoaXMgYnl0ZSAoaW5jbHVzaXZlKVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZW5kIHN0cmVhbSBzbGljZSBvZiBmaWxlLCBlbmRpbmcgd2l0aCB0aGlzIGJ5dGUgKGluY2x1c2l2ZSlcbiAqL1xuZnVuY3Rpb24gRmlsZVN0cmVhbSAoZmlsZSwgb3B0cykge1xuICBzdHJlYW0uUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRzKVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgdGhpcy5fdG9ycmVudCA9IGZpbGUuX3RvcnJlbnRcblxuICB2YXIgc3RhcnQgPSAob3B0cyAmJiBvcHRzLnN0YXJ0KSB8fCAwXG4gIHZhciBlbmQgPSAob3B0cyAmJiBvcHRzLmVuZCAmJiBvcHRzLmVuZCA8IGZpbGUubGVuZ3RoKVxuICAgID8gb3B0cy5lbmRcbiAgICA6IGZpbGUubGVuZ3RoIC0gMVxuXG4gIHZhciBwaWVjZUxlbmd0aCA9IGZpbGUuX3RvcnJlbnQucGllY2VMZW5ndGhcblxuICB0aGlzLl9zdGFydFBpZWNlID0gKHN0YXJ0ICsgZmlsZS5vZmZzZXQpIC8gcGllY2VMZW5ndGggfCAwXG4gIHRoaXMuX2VuZFBpZWNlID0gKGVuZCArIGZpbGUub2Zmc2V0KSAvIHBpZWNlTGVuZ3RoIHwgMFxuXG4gIHRoaXMuX3BpZWNlID0gdGhpcy5fc3RhcnRQaWVjZVxuICB0aGlzLl9vZmZzZXQgPSAoc3RhcnQgKyBmaWxlLm9mZnNldCkgLSAodGhpcy5fc3RhcnRQaWVjZSAqIHBpZWNlTGVuZ3RoKVxuXG4gIHRoaXMuX21pc3NpbmcgPSBlbmQgLSBzdGFydCArIDFcbiAgdGhpcy5fcmVhZGluZyA9IGZhbHNlXG4gIHRoaXMuX25vdGlmeWluZyA9IGZhbHNlXG4gIHRoaXMuX2NyaXRpY2FsTGVuZ3RoID0gTWF0aC5taW4oKDEwMjQgKiAxMDI0IC8gcGllY2VMZW5ndGgpIHwgMCwgMilcbn1cblxuRmlsZVN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9yZWFkaW5nKSByZXR1cm5cbiAgdGhpcy5fcmVhZGluZyA9IHRydWVcbiAgdGhpcy5fbm90aWZ5KClcbn1cblxuRmlsZVN0cmVhbS5wcm90b3R5cGUuX25vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKCFzZWxmLl9yZWFkaW5nIHx8IHNlbGYuX21pc3NpbmcgPT09IDApIHJldHVyblxuICBpZiAoIXNlbGYuX3RvcnJlbnQuYml0ZmllbGQuZ2V0KHNlbGYuX3BpZWNlKSkge1xuICAgIHJldHVybiBzZWxmLl90b3JyZW50LmNyaXRpY2FsKHNlbGYuX3BpZWNlLCBzZWxmLl9waWVjZSArIHNlbGYuX2NyaXRpY2FsTGVuZ3RoKVxuICB9XG5cbiAgaWYgKHNlbGYuX25vdGlmeWluZykgcmV0dXJuXG4gIHNlbGYuX25vdGlmeWluZyA9IHRydWVcblxuICB2YXIgcCA9IHNlbGYuX3BpZWNlXG4gIHNlbGYuX3RvcnJlbnQuc3RvcmUuZ2V0KHAsIGZ1bmN0aW9uIChlcnIsIGJ1ZmZlcikge1xuICAgIHNlbGYuX25vdGlmeWluZyA9IGZhbHNlXG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5fZGVzdHJveShlcnIpXG4gICAgZGVidWcoJ3JlYWQgJXMgKGxlbmd0aCAlcykgKGVyciAlcyknLCBwLCBidWZmZXIubGVuZ3RoLCBlcnIgJiYgZXJyLm1lc3NhZ2UpXG5cbiAgICBpZiAoc2VsZi5fb2Zmc2V0KSB7XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2Uoc2VsZi5fb2Zmc2V0KVxuICAgICAgc2VsZi5fb2Zmc2V0ID0gMFxuICAgIH1cblxuICAgIGlmIChzZWxmLl9taXNzaW5nIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIHNlbGYuX21pc3NpbmcpXG4gICAgfVxuICAgIHNlbGYuX21pc3NpbmcgLT0gYnVmZmVyLmxlbmd0aFxuXG4gICAgZGVidWcoJ3B1c2hpbmcgYnVmZmVyIG9mIGxlbmd0aCAlcycsIGJ1ZmZlci5sZW5ndGgpXG4gICAgc2VsZi5fcmVhZGluZyA9IGZhbHNlXG4gICAgc2VsZi5wdXNoKGJ1ZmZlcilcblxuICAgIGlmIChzZWxmLl9taXNzaW5nID09PSAwKSBzZWxmLnB1c2gobnVsbClcbiAgfSlcbiAgc2VsZi5fcGllY2UgKz0gMVxufVxuXG5GaWxlU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9uY2xvc2UpIHtcbiAgdGhpcy5fZGVzdHJveShudWxsLCBvbmNsb3NlKVxufVxuXG5GaWxlU3RyZWFtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIG9uY2xvc2UpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgaWYgKCF0aGlzLl90b3JyZW50LmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX3RvcnJlbnQuZGVzZWxlY3QodGhpcy5fc3RhcnRQaWVjZSwgdGhpcy5fZW5kUGllY2UsIHRydWUpXG4gIH1cblxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgaWYgKG9uY2xvc2UpIG9uY2xvc2UoKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBGaWxlXG5cbnZhciBlb3MgPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBGaWxlU3RyZWFtID0gcmVxdWlyZSgnLi9maWxlLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIHJlbmRlciA9IHJlcXVpcmUoJ3JlbmRlci1tZWRpYScpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciBzdHJlYW1Ub0Jsb2JVUkwgPSByZXF1aXJlKCdzdHJlYW0tdG8tYmxvYi11cmwnKVxudmFyIHN0cmVhbVRvQnVmZmVyID0gcmVxdWlyZSgnc3RyZWFtLXdpdGgta25vd24tbGVuZ3RoLXRvLWJ1ZmZlcicpXG5cbmluaGVyaXRzKEZpbGUsIEV2ZW50RW1pdHRlcilcblxuZnVuY3Rpb24gRmlsZSAodG9ycmVudCwgZmlsZSkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIHRoaXMuX3RvcnJlbnQgPSB0b3JyZW50XG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG5cbiAgdGhpcy5uYW1lID0gZmlsZS5uYW1lXG4gIHRoaXMucGF0aCA9IGZpbGUucGF0aFxuICB0aGlzLmxlbmd0aCA9IGZpbGUubGVuZ3RoXG4gIHRoaXMub2Zmc2V0ID0gZmlsZS5vZmZzZXRcblxuICB0aGlzLmRvbmUgPSBmYWxzZVxuXG4gIHZhciBzdGFydCA9IGZpbGUub2Zmc2V0XG4gIHZhciBlbmQgPSBzdGFydCArIGZpbGUubGVuZ3RoIC0gMVxuXG4gIHRoaXMuX3N0YXJ0UGllY2UgPSBzdGFydCAvIHRoaXMuX3RvcnJlbnQucGllY2VMZW5ndGggfCAwXG4gIHRoaXMuX2VuZFBpZWNlID0gZW5kIC8gdGhpcy5fdG9ycmVudC5waWVjZUxlbmd0aCB8IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmRvbmUgPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdkb25lJylcbiAgfVxufVxuXG5GaWxlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgdGhpcy5fdG9ycmVudC5zZWxlY3QodGhpcy5fc3RhcnRQaWVjZSwgdGhpcy5fZW5kUGllY2UsIHByaW9yaXR5KVxufVxuXG5GaWxlLnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgdGhpcy5fdG9ycmVudC5kZXNlbGVjdCh0aGlzLl9zdGFydFBpZWNlLCB0aGlzLl9lbmRQaWVjZSwgZmFsc2UpXG59XG5cbkZpbGUucHJvdG90eXBlLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIGVtcHR5ID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBlbXB0eS5lbmQoKVxuICAgIH0pXG4gICAgcmV0dXJuIGVtcHR5XG4gIH1cblxuICB2YXIgZmlsZVN0cmVhbSA9IG5ldyBGaWxlU3RyZWFtKHNlbGYsIG9wdHMpXG4gIHNlbGYuX3RvcnJlbnQuc2VsZWN0KGZpbGVTdHJlYW0uX3N0YXJ0UGllY2UsIGZpbGVTdHJlYW0uX2VuZFBpZWNlLCB0cnVlLCBmdW5jdGlvbiAoKSB7XG4gICAgZmlsZVN0cmVhbS5fbm90aWZ5KClcbiAgfSlcbiAgZW9zKGZpbGVTdHJlYW0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5fZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAoIXNlbGYuX3RvcnJlbnQuZGVzdHJveWVkKSB7XG4gICAgICBzZWxmLl90b3JyZW50LmRlc2VsZWN0KGZpbGVTdHJlYW0uX3N0YXJ0UGllY2UsIGZpbGVTdHJlYW0uX2VuZFBpZWNlLCB0cnVlKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGZpbGVTdHJlYW1cbn1cblxuRmlsZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gKGNiKSB7XG4gIHN0cmVhbVRvQnVmZmVyKHRoaXMuY3JlYXRlUmVhZFN0cmVhbSgpLCB0aGlzLmxlbmd0aCwgY2IpXG59XG5cbkZpbGUucHJvdG90eXBlLmdldEJsb2JVUkwgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2Jyb3dzZXItb25seSBtZXRob2QnKVxuICB2YXIgbWltZSA9IHJlbmRlci5taW1lW3BhdGguZXh0bmFtZSh0aGlzLm5hbWUpLnRvTG93ZXJDYXNlKCldXG4gIHN0cmVhbVRvQmxvYlVSTCh0aGlzLmNyZWF0ZVJlYWRTdHJlYW0oKSwgbWltZSwgY2IpXG59XG5cbkZpbGUucHJvdG90eXBlLmFwcGVuZFRvID0gZnVuY3Rpb24gKGVsZW0sIGNiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdicm93c2VyLW9ubHkgbWV0aG9kJylcbiAgcmVuZGVyLmFwcGVuZCh0aGlzLCBlbGVtLCBjYilcbn1cblxuRmlsZS5wcm90b3R5cGUucmVuZGVyVG8gPSBmdW5jdGlvbiAoZWxlbSwgY2IpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2Jyb3dzZXItb25seSBtZXRob2QnKVxuICByZW5kZXIucmVuZGVyKHRoaXMsIGVsZW0sIGNiKVxufVxuXG5GaWxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICB0aGlzLl90b3JyZW50ID0gbnVsbFxufVxuIiwidmFyIGFycmF5UmVtb3ZlID0gcmVxdWlyZSgndW5vcmRlcmVkLWFycmF5LXJlbW92ZScpXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd3ZWJ0b3JyZW50OnBlZXInKVxudmFyIFdpcmUgPSByZXF1aXJlKCdiaXR0b3JyZW50LXByb3RvY29sJylcblxudmFyIFdlYkNvbm4gPSByZXF1aXJlKCcuL3dlYmNvbm4nKVxuXG52YXIgQ09OTkVDVF9USU1FT1VUX1RDUCA9IDUwMDBcbnZhciBDT05ORUNUX1RJTUVPVVRfV0VCUlRDID0gMjUwMDBcbnZhciBIQU5EU0hBS0VfVElNRU9VVCA9IDI1MDAwXG5cbi8qKlxuICogV2ViUlRDIHBlZXIgY29ubmVjdGlvbnMgc3RhcnQgb3V0IGNvbm5lY3RlZCwgYmVjYXVzZSBXZWJSVEMgcGVlcnMgcmVxdWlyZSBhblxuICogXCJpbnRyb2R1Y3Rpb25cIiAoaS5lLiBXZWJSVEMgc2lnbmFsaW5nKSwgYW5kIHRoZXJlJ3Mgbm8gZXF1aXZhbGVudCB0byBhbiBJUCBhZGRyZXNzXG4gKiB0aGF0IGxldHMgeW91IHJlZmVyIHRvIGEgV2ViUlRDIGVuZHBvaW50LlxuICovXG5leHBvcnRzLmNyZWF0ZVdlYlJUQ1BlZXIgPSBmdW5jdGlvbiAoY29ubiwgc3dhcm0pIHtcbiAgdmFyIHBlZXIgPSBuZXcgUGVlcihjb25uLmlkLCAnd2VicnRjJylcbiAgcGVlci5jb25uID0gY29ublxuICBwZWVyLnN3YXJtID0gc3dhcm1cblxuICBpZiAocGVlci5jb25uLmNvbm5lY3RlZCkge1xuICAgIHBlZXIub25Db25uZWN0KClcbiAgfSBlbHNlIHtcbiAgICBwZWVyLmNvbm4ub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHsgcGVlci5vbkNvbm5lY3QoKSB9KVxuICAgIHBlZXIuY29ubi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgcGVlci5kZXN0cm95KGVycikgfSlcbiAgICBwZWVyLnN0YXJ0Q29ubmVjdFRpbWVvdXQoKVxuICB9XG5cbiAgcmV0dXJuIHBlZXJcbn1cblxuLyoqXG4gKiBJbmNvbWluZyBUQ1AgcGVlcnMgc3RhcnQgb3V0IGNvbm5lY3RlZCwgYmVjYXVzZSB0aGUgcmVtb3RlIHBlZXIgY29ubmVjdGVkIHRvIHRoZVxuICogbGlzdGVuaW5nIHBvcnQgb2YgdGhlIFRDUCBzZXJ2ZXIuIFVudGlsIHRoZSByZW1vdGUgcGVlciBzZW5kcyBhIGhhbmRzaGFrZSwgd2UgZG9uJ3RcbiAqIGtub3cgd2hhdCBzd2FybSB0aGUgY29ubmVjdGlvbiBpcyBpbnRlbmRlZCBmb3IuXG4gKi9cbmV4cG9ydHMuY3JlYXRlVENQSW5jb21pbmdQZWVyID0gZnVuY3Rpb24gKGNvbm4pIHtcbiAgdmFyIGFkZHIgPSBjb25uLnJlbW90ZUFkZHJlc3MgKyAnOicgKyBjb25uLnJlbW90ZVBvcnRcbiAgdmFyIHBlZXIgPSBuZXcgUGVlcihhZGRyLCAndGNwSW5jb21pbmcnKVxuICBwZWVyLmNvbm4gPSBjb25uXG4gIHBlZXIuYWRkciA9IGFkZHJcblxuICBwZWVyLm9uQ29ubmVjdCgpXG5cbiAgcmV0dXJuIHBlZXJcbn1cblxuLyoqXG4gKiBPdXRnb2luZyBUQ1AgcGVlcnMgc3RhcnQgb3V0IHdpdGgganVzdCBhbiBJUCBhZGRyZXNzLiBBdCBzb21lIHBvaW50ICh3aGVuIHRoZXJlIGlzIGFuXG4gKiBhdmFpbGFibGUgY29ubmVjdGlvbiksIHRoZSBjbGllbnQgY2FuIGF0dGVtcHQgdG8gY29ubmVjdCB0byB0aGUgYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5jcmVhdGVUQ1BPdXRnb2luZ1BlZXIgPSBmdW5jdGlvbiAoYWRkciwgc3dhcm0pIHtcbiAgdmFyIHBlZXIgPSBuZXcgUGVlcihhZGRyLCAndGNwT3V0Z29pbmcnKVxuICBwZWVyLmFkZHIgPSBhZGRyXG4gIHBlZXIuc3dhcm0gPSBzd2FybVxuXG4gIHJldHVybiBwZWVyXG59XG5cbi8qKlxuICogUGVlciB0aGF0IHJlcHJlc2VudHMgYSBXZWIgU2VlZCAoQkVQMTcgLyBCRVAxOSkuXG4gKi9cbmV4cG9ydHMuY3JlYXRlV2ViU2VlZFBlZXIgPSBmdW5jdGlvbiAodXJsLCBzd2FybSkge1xuICB2YXIgcGVlciA9IG5ldyBQZWVyKHVybCwgJ3dlYlNlZWQnKVxuICBwZWVyLnN3YXJtID0gc3dhcm1cbiAgcGVlci5jb25uID0gbmV3IFdlYkNvbm4odXJsLCBzd2FybSlcblxuICBwZWVyLm9uQ29ubmVjdCgpXG5cbiAgcmV0dXJuIHBlZXJcbn1cblxuLyoqXG4gKiBQZWVyLiBSZXByZXNlbnRzIGEgcGVlciBpbiB0aGUgdG9ycmVudCBzd2FybS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgXCJpcDpwb3J0XCIgc3RyaW5nLCBwZWVyIGlkIChmb3IgV2ViUlRDIHBlZXJzKSwgb3IgdXJsIChmb3IgV2ViIFNlZWRzKVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIHBlZXJcbiAqL1xuZnVuY3Rpb24gUGVlciAoaWQsIHR5cGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuaWQgPSBpZFxuICBzZWxmLnR5cGUgPSB0eXBlXG5cbiAgZGVidWcoJ25ldyBQZWVyICVzJywgaWQpXG5cbiAgc2VsZi5hZGRyID0gbnVsbFxuICBzZWxmLmNvbm4gPSBudWxsXG4gIHNlbGYuc3dhcm0gPSBudWxsXG4gIHNlbGYud2lyZSA9IG51bGxcblxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcbiAgc2VsZi50aW1lb3V0ID0gbnVsbCAvLyBoYW5kc2hha2UgdGltZW91dFxuICBzZWxmLnJldHJpZXMgPSAwIC8vIG91dGdvaW5nIFRDUCBjb25uZWN0aW9uIHJldHJ5IGNvdW50XG5cbiAgc2VsZi5zZW50SGFuZHNoYWtlID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDYWxsZWQgb25jZSB0aGUgcGVlciBpcyBjb25uZWN0ZWQgKGkuZS4gZmlyZWQgJ2Nvbm5lY3QnIGV2ZW50KVxuICogQHBhcmFtIHtTb2NrZXR9IGNvbm5cbiAqL1xuUGVlci5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5jb25uZWN0ZWQgPSB0cnVlXG5cbiAgZGVidWcoJ1BlZXIgJXMgY29ubmVjdGVkJywgc2VsZi5pZClcblxuICBjbGVhclRpbWVvdXQoc2VsZi5jb25uZWN0VGltZW91dClcblxuICB2YXIgY29ubiA9IHNlbGYuY29ublxuICBjb25uLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3koKVxuICB9KVxuICBjb25uLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveSgpXG4gIH0pXG4gIGNvbm4ub25jZSgnZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveSgpXG4gIH0pXG4gIGNvbm4ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5kZXN0cm95KGVycilcbiAgfSlcblxuICB2YXIgd2lyZSA9IHNlbGYud2lyZSA9IG5ldyBXaXJlKClcbiAgd2lyZS50eXBlID0gc2VsZi50eXBlXG4gIHdpcmUub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveSgpXG4gIH0pXG4gIHdpcmUub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgd2lyZS5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgd2lyZS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLmRlc3Ryb3koZXJyKVxuICB9KVxuXG4gIHdpcmUub25jZSgnaGFuZHNoYWtlJywgZnVuY3Rpb24gKGluZm9IYXNoLCBwZWVySWQpIHtcbiAgICBzZWxmLm9uSGFuZHNoYWtlKGluZm9IYXNoLCBwZWVySWQpXG4gIH0pXG4gIHNlbGYuc3RhcnRIYW5kc2hha2VUaW1lb3V0KClcblxuICBjb25uLnBpcGUod2lyZSkucGlwZShjb25uKVxuICBpZiAoc2VsZi5zd2FybSAmJiAhc2VsZi5zZW50SGFuZHNoYWtlKSBzZWxmLmhhbmRzaGFrZSgpXG59XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gaGFuZHNoYWtlIGlzIHJlY2VpdmVkIGZyb20gcmVtb3RlIHBlZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5mb0hhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBwZWVySWRcbiAqL1xuUGVlci5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoaW5mb0hhc2gsIHBlZXJJZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLnN3YXJtKSByZXR1cm4gLy8gYHNlbGYuc3dhcm1gIG5vdCBzZXQgeWV0LCBzbyBkbyBub3RoaW5nXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgaWYgKHNlbGYuc3dhcm0uZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ3N3YXJtIGFscmVhZHkgZGVzdHJveWVkJykpXG4gIH1cbiAgaWYgKGluZm9IYXNoICE9PSBzZWxmLnN3YXJtLmluZm9IYXNoKSB7XG4gICAgcmV0dXJuIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgaGFuZHNoYWtlIGluZm8gaGFzaCBmb3IgdGhpcyBzd2FybScpKVxuICB9XG4gIGlmIChwZWVySWQgPT09IHNlbGYuc3dhcm0ucGVlcklkKSB7XG4gICAgcmV0dXJuIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ3JlZnVzaW5nIHRvIGNvbm5lY3QgdG8gb3Vyc2VsdmVzJykpXG4gIH1cblxuICBkZWJ1ZygnUGVlciAlcyBnb3QgaGFuZHNoYWtlICVzJywgc2VsZi5pZCwgaW5mb0hhc2gpXG5cbiAgY2xlYXJUaW1lb3V0KHNlbGYuaGFuZHNoYWtlVGltZW91dClcblxuICBzZWxmLnJldHJpZXMgPSAwXG5cbiAgdmFyIGFkZHIgPSBzZWxmLmFkZHJcbiAgaWYgKCFhZGRyICYmIHNlbGYuY29ubi5yZW1vdGVBZGRyZXNzKSB7XG4gICAgYWRkciA9IHNlbGYuY29ubi5yZW1vdGVBZGRyZXNzICsgJzonICsgc2VsZi5jb25uLnJlbW90ZVBvcnRcbiAgfVxuICBzZWxmLnN3YXJtLl9vbldpcmUoc2VsZi53aXJlLCBhZGRyKVxuXG4gIC8vIHN3YXJtIGNvdWxkIGJlIGRlc3Ryb3llZCBpbiB1c2VyJ3MgJ3dpcmUnIGV2ZW50IGhhbmRsZXJcbiAgaWYgKCFzZWxmLnN3YXJtIHx8IHNlbGYuc3dhcm0uZGVzdHJveWVkKSByZXR1cm5cblxuICBpZiAoIXNlbGYuc2VudEhhbmRzaGFrZSkgc2VsZi5oYW5kc2hha2UoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5oYW5kc2hha2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgb3B0cyA9IHtcbiAgICBkaHQ6IHNlbGYuc3dhcm0ucHJpdmF0ZSA/IGZhbHNlIDogISFzZWxmLnN3YXJtLmNsaWVudC5kaHRcbiAgfVxuICBzZWxmLndpcmUuaGFuZHNoYWtlKHNlbGYuc3dhcm0uaW5mb0hhc2gsIHNlbGYuc3dhcm0uY2xpZW50LnBlZXJJZCwgb3B0cylcbiAgc2VsZi5zZW50SGFuZHNoYWtlID0gdHJ1ZVxufVxuXG5QZWVyLnByb3RvdHlwZS5zdGFydENvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgY2xlYXJUaW1lb3V0KHNlbGYuY29ubmVjdFRpbWVvdXQpXG4gIHNlbGYuY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3kobmV3IEVycm9yKCdjb25uZWN0IHRpbWVvdXQnKSlcbiAgfSwgc2VsZi50eXBlID09PSAnd2VicnRjJyA/IENPTk5FQ1RfVElNRU9VVF9XRUJSVEMgOiBDT05ORUNUX1RJTUVPVVRfVENQKVxuICBpZiAoc2VsZi5jb25uZWN0VGltZW91dC51bnJlZikgc2VsZi5jb25uZWN0VGltZW91dC51bnJlZigpXG59XG5cblBlZXIucHJvdG90eXBlLnN0YXJ0SGFuZHNoYWtlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGNsZWFyVGltZW91dChzZWxmLmhhbmRzaGFrZVRpbWVvdXQpXG4gIHNlbGYuaGFuZHNoYWtlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ2hhbmRzaGFrZSB0aW1lb3V0JykpXG4gIH0sIEhBTkRTSEFLRV9USU1FT1VUKVxuICBpZiAoc2VsZi5oYW5kc2hha2VUaW1lb3V0LnVucmVmKSBzZWxmLmhhbmRzaGFrZVRpbWVvdXQudW5yZWYoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcblxuICBkZWJ1ZygnZGVzdHJveSAlcyAoZXJyb3I6ICVzKScsIHNlbGYuaWQsIGVyciAmJiAoZXJyLm1lc3NhZ2UgfHwgZXJyKSlcblxuICBjbGVhclRpbWVvdXQoc2VsZi5jb25uZWN0VGltZW91dClcbiAgY2xlYXJUaW1lb3V0KHNlbGYuaGFuZHNoYWtlVGltZW91dClcblxuICB2YXIgc3dhcm0gPSBzZWxmLnN3YXJtXG4gIHZhciBjb25uID0gc2VsZi5jb25uXG4gIHZhciB3aXJlID0gc2VsZi53aXJlXG5cbiAgc2VsZi5zd2FybSA9IG51bGxcbiAgc2VsZi5jb25uID0gbnVsbFxuICBzZWxmLndpcmUgPSBudWxsXG5cbiAgaWYgKHN3YXJtICYmIHdpcmUpIHtcbiAgICBhcnJheVJlbW92ZShzd2FybS53aXJlcywgc3dhcm0ud2lyZXMuaW5kZXhPZih3aXJlKSlcbiAgfVxuICBpZiAoY29ubikge1xuICAgIGNvbm4ub24oJ2Vycm9yJywgbm9vcClcbiAgICBjb25uLmRlc3Ryb3koKVxuICB9XG4gIGlmICh3aXJlKSB3aXJlLmRlc3Ryb3koKVxuICBpZiAoc3dhcm0pIHN3YXJtLnJlbW92ZVBlZXIoc2VsZi5pZClcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBSYXJpdHlNYXBcblxuLyoqXG4gKiBNYXBwaW5nIG9mIHRvcnJlbnQgcGllY2VzIHRvIHRoZWlyIHJlc3BlY3RpdmUgYXZhaWxhYmlsaXR5IGluIHRoZSB0b3JyZW50IHN3YXJtLiBVc2VkXG4gKiBieSB0aGUgdG9ycmVudCBtYW5hZ2VyIGZvciBpbXBsZW1lbnRpbmcgdGhlIHJhcmVzdCBwaWVjZSBmaXJzdCBzZWxlY3Rpb24gc3RyYXRlZ3kuXG4gKi9cbmZ1bmN0aW9uIFJhcml0eU1hcCAodG9ycmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl90b3JyZW50ID0gdG9ycmVudFxuICBzZWxmLl9udW1QaWVjZXMgPSB0b3JyZW50LnBpZWNlcy5sZW5ndGhcbiAgc2VsZi5fcGllY2VzID0gW11cblxuICBzZWxmLl9vbldpcmUgPSBmdW5jdGlvbiAod2lyZSkge1xuICAgIHNlbGYucmVjYWxjdWxhdGUoKVxuICAgIHNlbGYuX2luaXRXaXJlKHdpcmUpXG4gIH1cbiAgc2VsZi5fb25XaXJlSGF2ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHNlbGYuX3BpZWNlc1tpbmRleF0gKz0gMVxuICB9XG4gIHNlbGYuX29uV2lyZUJpdGZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYucmVjYWxjdWxhdGUoKVxuICB9XG5cbiAgc2VsZi5fdG9ycmVudC53aXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgc2VsZi5faW5pdFdpcmUod2lyZSlcbiAgfSlcbiAgc2VsZi5fdG9ycmVudC5vbignd2lyZScsIHNlbGYuX29uV2lyZSlcbiAgc2VsZi5yZWNhbGN1bGF0ZSgpXG59XG5cbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiB0aGUgcmFyZXN0IHBpZWNlLiBPcHRpb25hbGx5LCBwYXNzIGEgZmlsdGVyIGZ1bmN0aW9uIHRvIGV4Y2x1ZGVcbiAqIGNlcnRhaW4gcGllY2VzIChmb3IgaW5zdGFuY2UsIHRob3NlIHRoYXQgd2UgYWxyZWFkeSBoYXZlKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwaWVjZUZpbHRlckZ1bmNcbiAqIEByZXR1cm4ge251bWJlcn0gaW5kZXggb2YgcmFyZXN0IHBpZWNlLCBvciAtMVxuICovXG5SYXJpdHlNYXAucHJvdG90eXBlLmdldFJhcmVzdFBpZWNlID0gZnVuY3Rpb24gKHBpZWNlRmlsdGVyRnVuYykge1xuICBpZiAoIXBpZWNlRmlsdGVyRnVuYykgcGllY2VGaWx0ZXJGdW5jID0gdHJ1ZUZuXG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXVxuICB2YXIgbWluID0gSW5maW5pdHlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX251bVBpZWNlczsgKytpKSB7XG4gICAgaWYgKCFwaWVjZUZpbHRlckZ1bmMoaSkpIGNvbnRpbnVlXG5cbiAgICB2YXIgYXZhaWxhYmlsaXR5ID0gdGhpcy5fcGllY2VzW2ldXG4gICAgaWYgKGF2YWlsYWJpbGl0eSA9PT0gbWluKSB7XG4gICAgICBjYW5kaWRhdGVzLnB1c2goaSlcbiAgICB9IGVsc2UgaWYgKGF2YWlsYWJpbGl0eSA8IG1pbikge1xuICAgICAgY2FuZGlkYXRlcyA9IFsgaSBdXG4gICAgICBtaW4gPSBhdmFpbGFiaWxpdHlcbiAgICB9XG4gIH1cblxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIHBpZWNlcyB3aXRoIHRoZSBzYW1lIGF2YWlsYWJpbGl0eSwgY2hvb3NlIG9uZSByYW5kb21seVxuICAgIHJldHVybiBjYW5kaWRhdGVzW01hdGgucmFuZG9tKCkgKiBjYW5kaWRhdGVzLmxlbmd0aCB8IDBdXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbn1cblxuUmFyaXR5TWFwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fdG9ycmVudC5yZW1vdmVMaXN0ZW5lcignd2lyZScsIHNlbGYuX29uV2lyZSlcbiAgc2VsZi5fdG9ycmVudC53aXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgc2VsZi5fY2xlYW51cFdpcmVFdmVudHMod2lyZSlcbiAgfSlcbiAgc2VsZi5fdG9ycmVudCA9IG51bGxcbiAgc2VsZi5fcGllY2VzID0gbnVsbFxuXG4gIHNlbGYuX29uV2lyZSA9IG51bGxcbiAgc2VsZi5fb25XaXJlSGF2ZSA9IG51bGxcbiAgc2VsZi5fb25XaXJlQml0ZmllbGQgPSBudWxsXG59XG5cblJhcml0eU1hcC5wcm90b3R5cGUuX2luaXRXaXJlID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgd2lyZS5fb25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9jbGVhbnVwV2lyZUV2ZW50cyh3aXJlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbnVtUGllY2VzOyArK2kpIHtcbiAgICAgIHNlbGYuX3BpZWNlc1tpXSAtPSB3aXJlLnBlZXJQaWVjZXMuZ2V0KGkpXG4gICAgfVxuICB9XG5cbiAgd2lyZS5vbignaGF2ZScsIHNlbGYuX29uV2lyZUhhdmUpXG4gIHdpcmUub24oJ2JpdGZpZWxkJywgc2VsZi5fb25XaXJlQml0ZmllbGQpXG4gIHdpcmUub25jZSgnY2xvc2UnLCB3aXJlLl9vbkNsb3NlKVxufVxuXG4vKipcbiAqIFJlY2FsY3VsYXRlcyBwaWVjZSBhdmFpbGFiaWxpdHkgYWNyb3NzIGFsbCBwZWVycyBpbiB0aGUgdG9ycmVudC5cbiAqL1xuUmFyaXR5TWFwLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX251bVBpZWNlczsgKytpKSB7XG4gICAgdGhpcy5fcGllY2VzW2ldID0gMFxuICB9XG5cbiAgdmFyIG51bVdpcmVzID0gdGhpcy5fdG9ycmVudC53aXJlcy5sZW5ndGhcbiAgZm9yIChpID0gMDsgaSA8IG51bVdpcmVzOyArK2kpIHtcbiAgICB2YXIgd2lyZSA9IHRoaXMuX3RvcnJlbnQud2lyZXNbaV1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX251bVBpZWNlczsgKytqKSB7XG4gICAgICB0aGlzLl9waWVjZXNbal0gKz0gd2lyZS5wZWVyUGllY2VzLmdldChqKVxuICAgIH1cbiAgfVxufVxuXG5SYXJpdHlNYXAucHJvdG90eXBlLl9jbGVhbnVwV2lyZUV2ZW50cyA9IGZ1bmN0aW9uICh3aXJlKSB7XG4gIHdpcmUucmVtb3ZlTGlzdGVuZXIoJ2hhdmUnLCB0aGlzLl9vbldpcmVIYXZlKVxuICB3aXJlLnJlbW92ZUxpc3RlbmVyKCdiaXRmaWVsZCcsIHRoaXMuX29uV2lyZUJpdGZpZWxkKVxuICBpZiAod2lyZS5fb25DbG9zZSkgd2lyZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCB3aXJlLl9vbkNsb3NlKVxuICB3aXJlLl9vbkNsb3NlID0gbnVsbFxufVxuXG5mdW5jdGlvbiB0cnVlRm4gKCkge1xuICByZXR1cm4gdHJ1ZVxufVxuIiwiLyogZ2xvYmFsIFVSTCwgQmxvYiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvcnJlbnRcblxudmFyIGFkZHJUb0lQUG9ydCA9IHJlcXVpcmUoJ2FkZHItdG8taXAtcG9ydCcpXG52YXIgQml0RmllbGQgPSByZXF1aXJlKCdiaXRmaWVsZCcpXG52YXIgQ2h1bmtTdG9yZVdyaXRlU3RyZWFtID0gcmVxdWlyZSgnY2h1bmstc3RvcmUtc3RyZWFtL3dyaXRlJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3dlYnRvcnJlbnQ6dG9ycmVudCcpXG52YXIgRGlzY292ZXJ5ID0gcmVxdWlyZSgndG9ycmVudC1kaXNjb3ZlcnknKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBleHRlbmRNdXRhYmxlID0gcmVxdWlyZSgneHRlbmQvbXV0YWJsZScpXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgRlNDaHVua1N0b3JlID0gcmVxdWlyZSgnZnMtY2h1bmstc3RvcmUnKSAvLyBicm93c2VyOiBgbWVtb3J5LWNodW5rLXN0b3JlYFxudmFyIGdldCA9IHJlcXVpcmUoJ3NpbXBsZS1nZXQnKVxudmFyIEltbWVkaWF0ZUNodW5rU3RvcmUgPSByZXF1aXJlKCdpbW1lZGlhdGUtY2h1bmstc3RvcmUnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIE11bHRpU3RyZWFtID0gcmVxdWlyZSgnbXVsdGlzdHJlYW0nKVxudmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpIC8vIGJyb3dzZXIgZXhjbHVkZVxudmFyIG9zID0gcmVxdWlyZSgnb3MnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBwYXJhbGxlbCA9IHJlcXVpcmUoJ3J1bi1wYXJhbGxlbCcpXG52YXIgcGFyYWxsZWxMaW1pdCA9IHJlcXVpcmUoJ3J1bi1wYXJhbGxlbC1saW1pdCcpXG52YXIgcGFyc2VUb3JyZW50ID0gcmVxdWlyZSgncGFyc2UtdG9ycmVudCcpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIFBpZWNlID0gcmVxdWlyZSgndG9ycmVudC1waWVjZScpXG52YXIgcHVtcCA9IHJlcXVpcmUoJ3B1bXAnKVxudmFyIHJhbmRvbUl0ZXJhdGUgPSByZXF1aXJlKCdyYW5kb20taXRlcmF0ZScpXG52YXIgc2hhMSA9IHJlcXVpcmUoJ3NpbXBsZS1zaGExJylcbnZhciBzcGVlZG9tZXRlciA9IHJlcXVpcmUoJ3NwZWVkb21ldGVyJylcbnZhciB1bmlxID0gcmVxdWlyZSgndW5pcScpXG52YXIgdXRNZXRhZGF0YSA9IHJlcXVpcmUoJ3V0X21ldGFkYXRhJylcbnZhciB1dFBleCA9IHJlcXVpcmUoJ3V0X3BleCcpIC8vIGJyb3dzZXIgZXhjbHVkZVxuXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4vZmlsZScpXG52YXIgUGVlciA9IHJlcXVpcmUoJy4vcGVlcicpXG52YXIgUmFyaXR5TWFwID0gcmVxdWlyZSgnLi9yYXJpdHktbWFwJylcbnZhciBTZXJ2ZXIgPSByZXF1aXJlKCcuL3NlcnZlcicpIC8vIGJyb3dzZXIgZXhjbHVkZVxuXG52YXIgTUFYX0JMT0NLX0xFTkdUSCA9IDEyOCAqIDEwMjRcbnZhciBQSUVDRV9USU1FT1VUID0gMzAwMDBcbnZhciBDSE9LRV9USU1FT1VUID0gNTAwMFxudmFyIFNQRUVEX1RIUkVTSE9MRCA9IDMgKiBQaWVjZS5CTE9DS19MRU5HVEhcblxudmFyIFBJUEVMSU5FX01JTl9EVVJBVElPTiA9IDAuNVxudmFyIFBJUEVMSU5FX01BWF9EVVJBVElPTiA9IDFcblxudmFyIFJFQ0hPS0VfSU5URVJWQUwgPSAxMDAwMCAvLyAxMCBzZWNvbmRzXG52YXIgUkVDSE9LRV9PUFRJTUlTVElDX0RVUkFUSU9OID0gMiAvLyAzMCBzZWNvbmRzXG5cbnZhciBGSUxFU1lTVEVNX0NPTkNVUlJFTkNZID0gMlxuXG52YXIgUkVDT05ORUNUX1dBSVQgPSBbIDEwMDAsIDUwMDAsIDE1MDAwIF1cblxudmFyIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbnZhciBUTVBcbnRyeSB7XG4gIFRNUCA9IHBhdGguam9pbihmcy5zdGF0U3luYygnL3RtcCcpICYmICcvdG1wJywgJ3dlYnRvcnJlbnQnKVxufSBjYXRjaCAoZXJyKSB7XG4gIFRNUCA9IHBhdGguam9pbih0eXBlb2Ygb3MudG1wRGlyID09PSAnZnVuY3Rpb24nID8gb3MudG1wRGlyKCkgOiAnLycsICd3ZWJ0b3JyZW50Jylcbn1cblxuaW5oZXJpdHMoVG9ycmVudCwgRXZlbnRFbWl0dGVyKVxuXG5mdW5jdGlvbiBUb3JyZW50ICh0b3JyZW50SWQsIGNsaWVudCwgb3B0cykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gIHRoaXMuX2RlYnVnSWQgPSB0aGlzLmNsaWVudC5wZWVySWQuc2xpY2UoMzIpXG5cbiAgdGhpcy5fZGVidWcoJ25ldyB0b3JyZW50JylcblxuICB0aGlzLmFubm91bmNlID0gb3B0cy5hbm5vdW5jZVxuICB0aGlzLnVybExpc3QgPSBvcHRzLnVybExpc3RcblxuICB0aGlzLnBhdGggPSBvcHRzLnBhdGhcbiAgdGhpcy5fc3RvcmUgPSBvcHRzLnN0b3JlIHx8IEZTQ2h1bmtTdG9yZVxuICB0aGlzLl9nZXRBbm5vdW5jZU9wdHMgPSBvcHRzLmdldEFubm91bmNlT3B0c1xuXG4gIHRoaXMuc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5IHx8ICdzZXF1ZW50aWFsJ1xuXG4gIHRoaXMubWF4V2ViQ29ubnMgPSBvcHRzLm1heFdlYkNvbm5zIHx8IDRcblxuICB0aGlzLl9yZWNob2tlTnVtU2xvdHMgPSAob3B0cy51cGxvYWRzID09PSBmYWxzZSB8fCBvcHRzLnVwbG9hZHMgPT09IDApXG4gICAgPyAwXG4gICAgOiAoK29wdHMudXBsb2FkcyB8fCAxMClcbiAgdGhpcy5fcmVjaG9rZU9wdGltaXN0aWNXaXJlID0gbnVsbFxuICB0aGlzLl9yZWNob2tlT3B0aW1pc3RpY1RpbWUgPSAwXG4gIHRoaXMuX3JlY2hva2VJbnRlcnZhbElkID0gbnVsbFxuXG4gIHRoaXMucmVhZHkgPSBmYWxzZVxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgdGhpcy5kb25lID0gZmFsc2VcblxuICB0aGlzLm1ldGFkYXRhID0gbnVsbFxuICB0aGlzLnN0b3JlID0gbnVsbFxuICB0aGlzLmZpbGVzID0gW11cbiAgdGhpcy5waWVjZXMgPSBbXVxuXG4gIHRoaXMuX2FtSW50ZXJlc3RlZCA9IGZhbHNlXG4gIHRoaXMuX3NlbGVjdGlvbnMgPSBbXVxuICB0aGlzLl9jcml0aWNhbCA9IFtdXG5cbiAgdGhpcy53aXJlcyA9IFtdIC8vIG9wZW4gd2lyZXMgKGFkZGVkICphZnRlciogaGFuZHNoYWtlKVxuXG4gIHRoaXMuX3F1ZXVlID0gW10gLy8gcXVldWUgb2Ygb3V0Z29pbmcgdGNwIHBlZXJzIHRvIGNvbm5lY3QgdG9cbiAgdGhpcy5fcGVlcnMgPSB7fSAvLyBjb25uZWN0ZWQgcGVlcnMgKGFkZHIvcGVlcklkIC0+IFBlZXIpXG4gIHRoaXMuX3BlZXJzTGVuZ3RoID0gMCAvLyBudW1iZXIgb2YgZWxlbWVudHMgaW4gYHRoaXMuX3BlZXJzYCAoY2FjaGUsIGZvciBwZXJmKVxuXG4gIC8vIHN0YXRzXG4gIHRoaXMucmVjZWl2ZWQgPSAwXG4gIHRoaXMudXBsb2FkZWQgPSAwXG4gIHRoaXMuX2Rvd25sb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG4gIHRoaXMuX3VwbG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuXG4gIC8vIGZvciBjbGVhbnVwXG4gIHRoaXMuX3NlcnZlcnMgPSBbXVxuICB0aGlzLl94c1JlcXVlc3RzID0gW11cblxuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBhbmQgZXhwb3NlIGEgaG9vayBpbnN0ZWFkXG4gIC8vIG9wdGltaXphdGlvbjogZG9uJ3QgcmVjaGVjayBldmVyeSBmaWxlIGlmIGl0IGhhc24ndCBjaGFuZ2VkXG4gIHRoaXMuX2ZpbGVNb2R0aW1lcyA9IG9wdHMuZmlsZU1vZHRpbWVzXG5cbiAgaWYgKHRvcnJlbnRJZCAhPT0gbnVsbCkgdGhpcy5fb25Ub3JyZW50SWQodG9ycmVudElkKVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICd0aW1lUmVtYWluaW5nJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kb25lKSByZXR1cm4gMFxuICAgIGlmICh0aGlzLmRvd25sb2FkU3BlZWQgPT09IDApIHJldHVybiBJbmZpbml0eVxuICAgIHJldHVybiAoKHRoaXMubGVuZ3RoIC0gdGhpcy5kb3dubG9hZGVkKSAvIHRoaXMuZG93bmxvYWRTcGVlZCkgKiAxMDAwXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ2Rvd25sb2FkZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5iaXRmaWVsZCkgcmV0dXJuIDBcbiAgICB2YXIgZG93bmxvYWRlZCA9IDBcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbiA9IHRoaXMucGllY2VzLmxlbmd0aDsgaW5kZXggPCBsZW47ICsraW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLmJpdGZpZWxkLmdldChpbmRleCkpIHsgLy8gdmVyaWZpZWQgZGF0YVxuICAgICAgICBkb3dubG9hZGVkICs9IChpbmRleCA9PT0gbGVuIC0gMSkgPyB0aGlzLmxhc3RQaWVjZUxlbmd0aCA6IHRoaXMucGllY2VMZW5ndGhcbiAgICAgIH0gZWxzZSB7IC8vIFwiaW4gcHJvZ3Jlc3NcIiBkYXRhXG4gICAgICAgIHZhciBwaWVjZSA9IHRoaXMucGllY2VzW2luZGV4XVxuICAgICAgICBkb3dubG9hZGVkICs9IChwaWVjZS5sZW5ndGggLSBwaWVjZS5taXNzaW5nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG93bmxvYWRlZFxuICB9XG59KVxuXG4vLyBUT0RPOiByZS1lbmFibGUgdGhpcy4gVGhlIG51bWJlciBvZiBtaXNzaW5nIHBpZWNlcy4gVXNlZCB0byBpbXBsZW1lbnQgJ2VuZCBnYW1lJyBtb2RlLlxuLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0b3JhZ2UucHJvdG90eXBlLCAnbnVtTWlzc2luZycsIHtcbi8vICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4vLyAgICAgdmFyIHNlbGYgPSB0aGlzXG4vLyAgICAgdmFyIG51bU1pc3NpbmcgPSBzZWxmLnBpZWNlcy5sZW5ndGhcbi8vICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbiA9IHNlbGYucGllY2VzLmxlbmd0aDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbi8vICAgICAgIG51bU1pc3NpbmcgLT0gc2VsZi5iaXRmaWVsZC5nZXQoaW5kZXgpXG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBudW1NaXNzaW5nXG4vLyAgIH1cbi8vIH0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ2Rvd25sb2FkU3BlZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG93bmxvYWRTcGVlZCgpIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ3VwbG9hZFNwZWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3VwbG9hZFNwZWVkKCkgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAncHJvZ3Jlc3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5sZW5ndGggPyB0aGlzLmRvd25sb2FkZWQgLyB0aGlzLmxlbmd0aCA6IDAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAncmF0aW8nLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy51cGxvYWRlZCAvICh0aGlzLnJlY2VpdmVkIHx8IDEpIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ251bVBlZXJzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMud2lyZXMubGVuZ3RoIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ3RvcnJlbnRGaWxlQmxvYlVSTCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2Jyb3dzZXItb25seSBwcm9wZXJ0eScpXG4gICAgaWYgKCF0aGlzLnRvcnJlbnRGaWxlKSByZXR1cm4gbnVsbFxuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgbmV3IEJsb2IoWyB0aGlzLnRvcnJlbnRGaWxlIF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL3gtYml0dG9ycmVudCcgfSlcbiAgICApXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ19udW1RdWV1ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGggKyAodGhpcy5fcGVlcnNMZW5ndGggLSB0aGlzLl9udW1Db25ucylcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnX251bUNvbm5zJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB2YXIgbnVtQ29ubnMgPSAwXG4gICAgZm9yICh2YXIgaWQgaW4gc2VsZi5fcGVlcnMpIHtcbiAgICAgIGlmIChzZWxmLl9wZWVyc1tpZF0uY29ubmVjdGVkKSBudW1Db25ucyArPSAxXG4gICAgfVxuICAgIHJldHVybiBudW1Db25uc1xuICB9XG59KVxuXG4vLyBUT0RPOiByZW1vdmUgaW4gdjFcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ3N3YXJtJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dlYlRvcnJlbnQ6IGB0b3JyZW50LnN3YXJtYCBpcyBkZXByZWNhdGVkLiBVc2UgYHRvcnJlbnRgIGRpcmVjdGx5IGluc3RlYWQuJylcbiAgICByZXR1cm4gdGhpc1xuICB9XG59KVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fb25Ub3JyZW50SWQgPSBmdW5jdGlvbiAodG9ycmVudElkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHZhciBwYXJzZWRUb3JyZW50XG4gIHRyeSB7IHBhcnNlZFRvcnJlbnQgPSBwYXJzZVRvcnJlbnQodG9ycmVudElkKSB9IGNhdGNoIChlcnIpIHt9XG4gIGlmIChwYXJzZWRUb3JyZW50KSB7XG4gICAgLy8gQXR0ZW1wdCB0byBzZXQgaW5mb0hhc2ggcHJvcGVydHkgc3luY2hyb25vdXNseVxuICAgIHNlbGYuaW5mb0hhc2ggPSBwYXJzZWRUb3JyZW50LmluZm9IYXNoXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgc2VsZi5fb25QYXJzZWRUb3JyZW50KHBhcnNlZFRvcnJlbnQpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0b3JyZW50SWQgZmFpbGVkIHRvIHBhcnNlLCBpdCBjb3VsZCBiZSBpbiBhIGZvcm0gdGhhdCByZXF1aXJlcyBhbiBhc3luY1xuICAgIC8vIG9wZXJhdGlvbiwgaS5lLiBodHRwL2h0dHBzIGxpbmssIGZpbGVzeXN0ZW0gcGF0aCwgb3IgQmxvYi5cbiAgICBwYXJzZVRvcnJlbnQucmVtb3RlKHRvcnJlbnRJZCwgZnVuY3Rpb24gKGVyciwgcGFyc2VkVG9ycmVudCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIGlmIChlcnIpIHJldHVybiBzZWxmLl9kZXN0cm95KGVycilcbiAgICAgIHNlbGYuX29uUGFyc2VkVG9ycmVudChwYXJzZWRUb3JyZW50KVxuICAgIH0pXG4gIH1cbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX29uUGFyc2VkVG9ycmVudCA9IGZ1bmN0aW9uIChwYXJzZWRUb3JyZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHNlbGYuX3Byb2Nlc3NQYXJzZWRUb3JyZW50KHBhcnNlZFRvcnJlbnQpXG5cbiAgaWYgKCFzZWxmLmluZm9IYXNoKSB7XG4gICAgcmV0dXJuIHNlbGYuX2Rlc3Ryb3kobmV3IEVycm9yKCdNYWxmb3JtZWQgdG9ycmVudCBkYXRhOiBObyBpbmZvIGhhc2gnKSlcbiAgfVxuXG4gIGlmICghc2VsZi5wYXRoKSBzZWxmLnBhdGggPSBwYXRoLmpvaW4oVE1QLCBzZWxmLmluZm9IYXNoKVxuXG4gIHNlbGYuX3JlY2hva2VJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3JlY2hva2UoKVxuICB9LCBSRUNIT0tFX0lOVEVSVkFMKVxuICBpZiAoc2VsZi5fcmVjaG9rZUludGVydmFsSWQudW5yZWYpIHNlbGYuX3JlY2hva2VJbnRlcnZhbElkLnVucmVmKClcblxuICAvLyBQcml2YXRlICdpbmZvSGFzaCcgZXZlbnQgYWxsb3dzIGNsaWVudC5hZGQgdG8gY2hlY2sgZm9yIGR1cGxpY2F0ZSB0b3JyZW50cyBhbmRcbiAgLy8gZGVzdHJveSB0aGVtIGJlZm9yZSB0aGUgbm9ybWFsICdpbmZvSGFzaCcgZXZlbnQgaXMgZW1pdHRlZC4gUHJldmVudHMgdXNlclxuICAvLyBhcHBsaWNhdGlvbnMgZnJvbSBuZWVkaW5nIHRvIGRlYWwgd2l0aCBkdXBsaWNhdGUgJ2luZm9IYXNoJyBldmVudHMuXG4gIHNlbGYuZW1pdCgnX2luZm9IYXNoJywgc2VsZi5pbmZvSGFzaClcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBzZWxmLmVtaXQoJ2luZm9IYXNoJywgc2VsZi5pbmZvSGFzaClcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gLy8gdXNlciBtaWdodCBkZXN0cm95IHRvcnJlbnQgaW4gZXZlbnQgaGFuZGxlclxuXG4gIGlmIChzZWxmLmNsaWVudC5saXN0ZW5pbmcpIHtcbiAgICBzZWxmLl9vbkxpc3RlbmluZygpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5jbGllbnQub25jZSgnbGlzdGVuaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fb25MaXN0ZW5pbmcoKVxuICAgIH0pXG4gIH1cbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX3Byb2Nlc3NQYXJzZWRUb3JyZW50ID0gZnVuY3Rpb24gKHBhcnNlZFRvcnJlbnQpIHtcbiAgaWYgKHRoaXMuYW5ub3VuY2UpIHtcbiAgICAvLyBBbGxvdyBzcGVjaWZ5aW5nIHRyYWNrZXJzIHZpYSBgb3B0c2AgcGFyYW1ldGVyXG4gICAgcGFyc2VkVG9ycmVudC5hbm5vdW5jZSA9IHBhcnNlZFRvcnJlbnQuYW5ub3VuY2UuY29uY2F0KHRoaXMuYW5ub3VuY2UpXG4gIH1cblxuICBpZiAodGhpcy5jbGllbnQudHJhY2tlciAmJiBnbG9iYWwuV0VCVE9SUkVOVF9BTk5PVU5DRSAmJiAhdGhpcy5wcml2YXRlKSB7XG4gICAgLy8gU28gYHdlYnRvcnJlbnQtaHlicmlkYCBjYW4gZm9yY2Ugc3BlY2lmaWMgdHJhY2tlcnMgdG8gYmUgdXNlZFxuICAgIHBhcnNlZFRvcnJlbnQuYW5ub3VuY2UgPSBwYXJzZWRUb3JyZW50LmFubm91bmNlLmNvbmNhdChnbG9iYWwuV0VCVE9SUkVOVF9BTk5PVU5DRSlcbiAgfVxuXG4gIGlmICh0aGlzLnVybExpc3QpIHtcbiAgICAvLyBBbGxvdyBzcGVjaWZ5aW5nIHdlYiBzZWVkcyB2aWEgYG9wdHNgIHBhcmFtZXRlclxuICAgIHBhcnNlZFRvcnJlbnQudXJsTGlzdCA9IHBhcnNlZFRvcnJlbnQudXJsTGlzdC5jb25jYXQodGhpcy51cmxMaXN0KVxuICB9XG5cbiAgdW5pcShwYXJzZWRUb3JyZW50LmFubm91bmNlKVxuICB1bmlxKHBhcnNlZFRvcnJlbnQudXJsTGlzdClcblxuICBleHRlbmRNdXRhYmxlKHRoaXMsIHBhcnNlZFRvcnJlbnQpXG5cbiAgdGhpcy5tYWduZXRVUkkgPSBwYXJzZVRvcnJlbnQudG9NYWduZXRVUkkocGFyc2VkVG9ycmVudClcbiAgdGhpcy50b3JyZW50RmlsZSA9IHBhcnNlVG9ycmVudC50b1RvcnJlbnRGaWxlKHBhcnNlZFRvcnJlbnQpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9vbkxpc3RlbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRpc2NvdmVyeSB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgdmFyIHRyYWNrZXJPcHRzID0gc2VsZi5jbGllbnQudHJhY2tlclxuICBpZiAodHJhY2tlck9wdHMpIHtcbiAgICB0cmFja2VyT3B0cyA9IGV4dGVuZChzZWxmLmNsaWVudC50cmFja2VyLCB7XG4gICAgICBnZXRBbm5vdW5jZU9wdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgdXBsb2FkZWQ6IHNlbGYudXBsb2FkZWQsXG4gICAgICAgICAgZG93bmxvYWRlZDogc2VsZi5kb3dubG9hZGVkLFxuICAgICAgICAgIGxlZnQ6IE1hdGgubWF4KHNlbGYubGVuZ3RoIC0gc2VsZi5kb3dubG9hZGVkLCAwKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmNsaWVudC50cmFja2VyLmdldEFubm91bmNlT3B0cykge1xuICAgICAgICAgIGV4dGVuZE11dGFibGUob3B0cywgc2VsZi5jbGllbnQudHJhY2tlci5nZXRBbm5vdW5jZU9wdHMoKSlcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5fZ2V0QW5ub3VuY2VPcHRzKSB7XG4gICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgZGVwcmVjYXRpbmcgdGhpcywgYXMgaXQncyByZWR1bmRhbnQgd2l0aCB0aGUgZm9ybWVyIGNhc2VcbiAgICAgICAgICBleHRlbmRNdXRhYmxlKG9wdHMsIHNlbGYuX2dldEFubm91bmNlT3B0cygpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIGJlZ2luIGRpc2NvdmVyaW5nIHBlZXJzIHZpYSBESFQgYW5kIHRyYWNrZXJzXG4gIHNlbGYuZGlzY292ZXJ5ID0gbmV3IERpc2NvdmVyeSh7XG4gICAgaW5mb0hhc2g6IHNlbGYuaW5mb0hhc2gsXG4gICAgYW5ub3VuY2U6IHNlbGYuYW5ub3VuY2UsXG4gICAgcGVlcklkOiBzZWxmLmNsaWVudC5wZWVySWQsXG4gICAgZGh0OiAhc2VsZi5wcml2YXRlICYmIHNlbGYuY2xpZW50LmRodCxcbiAgICB0cmFja2VyOiB0cmFja2VyT3B0cyxcbiAgICBwb3J0OiBzZWxmLmNsaWVudC50b3JyZW50UG9ydFxuICB9KVxuXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCdlcnJvcicsIG9uRXJyb3IpXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCdwZWVyJywgb25QZWVyKVxuICBzZWxmLmRpc2NvdmVyeS5vbigndHJhY2tlckFubm91bmNlJywgb25UcmFja2VyQW5ub3VuY2UpXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCdkaHRBbm5vdW5jZScsIG9uREhUQW5ub3VuY2UpXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCd3YXJuaW5nJywgb25XYXJuaW5nKVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IgKGVycikge1xuICAgIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25QZWVyIChwZWVyKSB7XG4gICAgLy8gRG9uJ3QgY3JlYXRlIG5ldyBvdXRnb2luZyBUQ1AgY29ubmVjdGlvbnMgd2hlbiB0b3JyZW50IGlzIGRvbmVcbiAgICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnICYmIHNlbGYuZG9uZSkgcmV0dXJuXG4gICAgc2VsZi5hZGRQZWVyKHBlZXIpXG4gIH1cblxuICBmdW5jdGlvbiBvblRyYWNrZXJBbm5vdW5jZSAoKSB7XG4gICAgc2VsZi5lbWl0KCd0cmFja2VyQW5ub3VuY2UnKVxuICAgIGlmIChzZWxmLm51bVBlZXJzID09PSAwKSBzZWxmLmVtaXQoJ25vUGVlcnMnLCAndHJhY2tlcicpXG4gIH1cblxuICBmdW5jdGlvbiBvbkRIVEFubm91bmNlICgpIHtcbiAgICBzZWxmLmVtaXQoJ2RodEFubm91bmNlJylcbiAgICBpZiAoc2VsZi5udW1QZWVycyA9PT0gMCkgc2VsZi5lbWl0KCdub1BlZXJzJywgJ2RodCcpXG4gIH1cblxuICBmdW5jdGlvbiBvbldhcm5pbmcgKGVycikge1xuICAgIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgfVxuXG4gIGlmIChzZWxmLmluZm8pIHtcbiAgICAvLyBpZiBmdWxsIG1ldGFkYXRhIHdhcyBpbmNsdWRlZCBpbiBpbml0aWFsIHRvcnJlbnQgaWQsIHVzZSBpdCBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlLFxuICAgIC8vIHdhaXQgZm9yIHRvcnJlbnQtZGlzY292ZXJ5IHRvIGZpbmQgcGVlcnMgYW5kIHV0X21ldGFkYXRhIHRvIGdldCB0aGUgbWV0YWRhdGEuXG4gICAgc2VsZi5fb25NZXRhZGF0YShzZWxmKVxuICB9IGVsc2UgaWYgKHNlbGYueHMpIHtcbiAgICBzZWxmLl9nZXRNZXRhZGF0YUZyb21TZXJ2ZXIoKVxuICB9XG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9nZXRNZXRhZGF0YUZyb21TZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdXJscyA9IEFycmF5LmlzQXJyYXkoc2VsZi54cykgPyBzZWxmLnhzIDogWyBzZWxmLnhzIF1cblxuICB2YXIgdGFza3MgPSB1cmxzLm1hcChmdW5jdGlvbiAodXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgZ2V0TWV0YWRhdGFGcm9tVVJMKHVybCwgY2IpXG4gICAgfVxuICB9KVxuICBwYXJhbGxlbCh0YXNrcylcblxuICBmdW5jdGlvbiBnZXRNZXRhZGF0YUZyb21VUkwgKHVybCwgY2IpIHtcbiAgICBpZiAodXJsLmluZGV4T2YoJ2h0dHA6Ly8nKSAhPT0gMCAmJiB1cmwuaW5kZXhPZignaHR0cHM6Ly8nKSAhPT0gMCkge1xuICAgICAgc2VsZi5fZGVidWcoJ3NraXBwaW5nIG5vbi1odHRwIHhzIHBhcmFtOiAlcycsIHVybClcbiAgICAgIHJldHVybiBjYihudWxsKVxuICAgIH1cblxuICAgIHZhciBvcHRzID0ge1xuICAgICAgdXJsOiB1cmwsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAndXNlci1hZ2VudCc6ICdXZWJUb3JyZW50LycgKyBWRVJTSU9OICsgJyAoaHR0cHM6Ly93ZWJ0b3JyZW50LmlvKSdcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlcVxuICAgIHRyeSB7XG4gICAgICByZXEgPSBnZXQuY29uY2F0KG9wdHMsIG9uUmVzcG9uc2UpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZWxmLl9kZWJ1Zygnc2tpcHBpbmcgaW52YWxpZCB1cmwgeHMgcGFyYW06ICVzJywgdXJsKVxuICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgfVxuXG4gICAgc2VsZi5feHNSZXF1ZXN0cy5wdXNoKHJlcSlcblxuICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2UgKGVyciwgcmVzLCB0b3JyZW50KSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYihudWxsKVxuICAgICAgaWYgKHNlbGYubWV0YWRhdGEpIHJldHVybiBjYihudWxsKVxuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuX2RlYnVnKCdodHRwIGVycm9yIGZyb20geHMgcGFyYW06ICVzJywgdXJsKVxuICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgIHNlbGYuX2RlYnVnKCdub24tMjAwIHN0YXR1cyBjb2RlICVzIGZyb20geHMgcGFyYW06ICVzJywgcmVzLnN0YXR1c0NvZGUsIHVybClcbiAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJzZWRUb3JyZW50XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRUb3JyZW50ID0gcGFyc2VUb3JyZW50KHRvcnJlbnQpXG4gICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgIGlmICghcGFyc2VkVG9ycmVudCkge1xuICAgICAgICBzZWxmLl9kZWJ1ZygnZ290IGludmFsaWQgdG9ycmVudCBmaWxlIGZyb20geHMgcGFyYW06ICVzJywgdXJsKVxuICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnNlZFRvcnJlbnQuaW5mb0hhc2ggIT09IHNlbGYuaW5mb0hhc2gpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ2dvdCB0b3JyZW50IGZpbGUgd2l0aCBpbmNvcnJlY3QgaW5mbyBoYXNoIGZyb20geHMgcGFyYW06ICVzJywgdXJsKVxuICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgIH1cblxuICAgICAgc2VsZi5fb25NZXRhZGF0YShwYXJzZWRUb3JyZW50KVxuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgZnVsbCB0b3JyZW50IG1ldGFkYXRhIGlzIHJlY2VpdmVkLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fb25NZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYubWV0YWRhdGEgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1ZygnZ290IG1ldGFkYXRhJylcblxuICBzZWxmLl94c1JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcSkge1xuICAgIHJlcS5hYm9ydCgpXG4gIH0pXG4gIHNlbGYuX3hzUmVxdWVzdHMgPSBbXVxuXG4gIHZhciBwYXJzZWRUb3JyZW50XG4gIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5pbmZvSGFzaCkge1xuICAgIC8vIGBtZXRhZGF0YWAgaXMgYSBwYXJzZWQgdG9ycmVudCAoZnJvbSBwYXJzZS10b3JyZW50IG1vZHVsZSlcbiAgICBwYXJzZWRUb3JyZW50ID0gbWV0YWRhdGFcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVG9ycmVudCA9IHBhcnNlVG9ycmVudChtZXRhZGF0YSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBzZWxmLl9kZXN0cm95KGVycilcbiAgICB9XG4gIH1cblxuICBzZWxmLl9wcm9jZXNzUGFyc2VkVG9ycmVudChwYXJzZWRUb3JyZW50KVxuICBzZWxmLm1ldGFkYXRhID0gc2VsZi50b3JyZW50RmlsZVxuXG4gIC8vIGFkZCB3ZWIgc2VlZCB1cmxzIChCRVAxOSlcbiAgc2VsZi51cmxMaXN0LmZvckVhY2goZnVuY3Rpb24gKHVybCkge1xuICAgIHNlbGYuYWRkV2ViU2VlZCh1cmwpXG4gIH0pXG5cbiAgc2VsZi5fcmFyaXR5TWFwID0gbmV3IFJhcml0eU1hcChzZWxmKVxuXG4gIHNlbGYuc3RvcmUgPSBuZXcgSW1tZWRpYXRlQ2h1bmtTdG9yZShcbiAgICBuZXcgc2VsZi5fc3RvcmUoc2VsZi5waWVjZUxlbmd0aCwge1xuICAgICAgdG9ycmVudDoge1xuICAgICAgICBpbmZvSGFzaDogc2VsZi5pbmZvSGFzaFxuICAgICAgfSxcbiAgICAgIGZpbGVzOiBzZWxmLmZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGg6IHBhdGguam9pbihzZWxmLnBhdGgsIGZpbGUucGF0aCksXG4gICAgICAgICAgbGVuZ3RoOiBmaWxlLmxlbmd0aCxcbiAgICAgICAgICBvZmZzZXQ6IGZpbGUub2Zmc2V0XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgbGVuZ3RoOiBzZWxmLmxlbmd0aFxuICAgIH0pXG4gIClcblxuICBzZWxmLmZpbGVzID0gc2VsZi5maWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICByZXR1cm4gbmV3IEZpbGUoc2VsZiwgZmlsZSlcbiAgfSlcblxuICBzZWxmLl9oYXNoZXMgPSBzZWxmLnBpZWNlc1xuXG4gIHNlbGYucGllY2VzID0gc2VsZi5waWVjZXMubWFwKGZ1bmN0aW9uIChoYXNoLCBpKSB7XG4gICAgdmFyIHBpZWNlTGVuZ3RoID0gKGkgPT09IHNlbGYucGllY2VzLmxlbmd0aCAtIDEpXG4gICAgICA/IHNlbGYubGFzdFBpZWNlTGVuZ3RoXG4gICAgICA6IHNlbGYucGllY2VMZW5ndGhcbiAgICByZXR1cm4gbmV3IFBpZWNlKHBpZWNlTGVuZ3RoKVxuICB9KVxuXG4gIHNlbGYuX3Jlc2VydmF0aW9ucyA9IHNlbGYucGllY2VzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH0pXG5cbiAgc2VsZi5iaXRmaWVsZCA9IG5ldyBCaXRGaWVsZChzZWxmLnBpZWNlcy5sZW5ndGgpXG5cbiAgc2VsZi53aXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgLy8gSWYgd2UgZGlkbid0IGhhdmUgdGhlIG1ldGFkYXRhIGF0IHRoZSB0aW1lIHV0X21ldGFkYXRhIHdhcyBpbml0aWFsaXplZCBmb3IgdGhpc1xuICAgIC8vIHdpcmUsIHdlIHN0aWxsIHdhbnQgdG8gbWFrZSBpdCBhdmFpbGFibGUgdG8gdGhlIHBlZXIgaW4gY2FzZSB0aGV5IHJlcXVlc3QgaXQuXG4gICAgaWYgKHdpcmUudXRfbWV0YWRhdGEpIHdpcmUudXRfbWV0YWRhdGEuc2V0TWV0YWRhdGEoc2VsZi5tZXRhZGF0YSlcblxuICAgIHNlbGYuX29uV2lyZVdpdGhNZXRhZGF0YSh3aXJlKVxuICB9KVxuXG4gIHNlbGYuX2RlYnVnKCd2ZXJpZnlpbmcgZXhpc3RpbmcgdG9ycmVudCBkYXRhJylcbiAgaWYgKHNlbGYuX2ZpbGVNb2R0aW1lcyAmJiBzZWxmLl9zdG9yZSA9PT0gRlNDaHVua1N0b3JlKSB7XG4gICAgLy8gZG9uJ3QgdmVyaWZ5IGlmIHRoZSBmaWxlcyBoYXZlbid0IGJlZW4gbW9kaWZpZWQgc2luY2Ugd2UgbGFzdCBjaGVja2VkXG4gICAgc2VsZi5nZXRGaWxlTW9kdGltZXMoZnVuY3Rpb24gKGVyciwgZmlsZU1vZHRpbWVzKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5fZGVzdHJveShlcnIpXG5cbiAgICAgIHZhciB1bmNoYW5nZWQgPSBzZWxmLmZpbGVzLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVNb2R0aW1lc1tpbmRleF0gPT09IHNlbGYuX2ZpbGVNb2R0aW1lc1tpbmRleF1cbiAgICAgIH0pLmV2ZXJ5KGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4XG4gICAgICB9KVxuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzZWxmLnBpZWNlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBzZWxmLl9tYXJrVmVyaWZpZWQoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fb25TdG9yZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl92ZXJpZnlQaWVjZXMoKVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fdmVyaWZ5UGllY2VzKClcbiAgfVxuXG4gIHNlbGYuZW1pdCgnbWV0YWRhdGEnKVxufVxuXG4vKlxuICogVE9ETzogcmVtb3ZlIHRoaXNcbiAqIEdldHMgdGhlIGxhc3QgbW9kaWZpZWQgdGltZSBvZiBldmVyeSBmaWxlIG9uIGRpc2sgZm9yIHRoaXMgdG9ycmVudC5cbiAqIE9ubHkgdmFsaWQgaW4gTm9kZSwgbm90IGluIHRoZSBicm93c2VyLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5nZXRGaWxlTW9kdGltZXMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXQgPSBbXVxuICBwYXJhbGxlbExpbWl0KHNlbGYuZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlLCBpbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGZzLnN0YXQocGF0aC5qb2luKHNlbGYucGF0aCwgZmlsZS5wYXRoKSwgZnVuY3Rpb24gKGVyciwgc3RhdCkge1xuICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRU5PRU5UJykgcmV0dXJuIGNiKGVycilcbiAgICAgICAgcmV0W2luZGV4XSA9IHN0YXQgJiYgc3RhdC5tdGltZS5nZXRUaW1lKClcbiAgICAgICAgY2IobnVsbClcbiAgICAgIH0pXG4gICAgfVxuICB9KSwgRklMRVNZU1RFTV9DT05DVVJSRU5DWSwgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX2RlYnVnKCdkb25lIGdldHRpbmcgZmlsZSBtb2R0aW1lcycpXG4gICAgY2IoZXJyLCByZXQpXG4gIH0pXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl92ZXJpZnlQaWVjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBwYXJhbGxlbExpbWl0KHNlbGYucGllY2VzLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYihuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJykpXG4gICAgICBzZWxmLnN0b3JlLmdldChpbmRleCwgZnVuY3Rpb24gKGVyciwgYnVmKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihudWxsKSAvLyBpZ25vcmUgZXJyb3JcbiAgICAgICAgc2hhMShidWYsIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgICAgaWYgKGhhc2ggPT09IHNlbGYuX2hhc2hlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5waWVjZXNbaW5kZXhdKSByZXR1cm5cbiAgICAgICAgICAgIHNlbGYuX2RlYnVnKCdwaWVjZSB2ZXJpZmllZCAlcycsIGluZGV4KVxuICAgICAgICAgICAgc2VsZi5fbWFya1ZlcmlmaWVkKGluZGV4KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLl9kZWJ1ZygncGllY2UgaW52YWxpZCAlcycsIGluZGV4KVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYihudWxsKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0pLCBGSUxFU1lTVEVNX0NPTkNVUlJFTkNZLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICAgIHNlbGYuX2RlYnVnKCdkb25lIHZlcmlmeWluZycpXG4gICAgc2VsZi5fb25TdG9yZSgpXG4gIH0pXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9tYXJrVmVyaWZpZWQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdGhpcy5waWVjZXNbaW5kZXhdID0gbnVsbFxuICB0aGlzLl9yZXNlcnZhdGlvbnNbaW5kZXhdID0gbnVsbFxuICB0aGlzLmJpdGZpZWxkLnNldChpbmRleCwgdHJ1ZSlcbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgbWV0YWRhdGEsIGxpc3RlbmluZyBzZXJ2ZXIsIGFuZCB1bmRlcmx5aW5nIGNodW5rIHN0b3JlIGlzIGluaXRpYWxpemVkLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fb25TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdvbiBzdG9yZScpXG5cbiAgLy8gc3RhcnQgb2ZmIHNlbGVjdGluZyB0aGUgZW50aXJlIHRvcnJlbnQgd2l0aCBsb3cgcHJpb3JpdHlcbiAgaWYgKHNlbGYucGllY2VzLmxlbmd0aCAhPT0gMCkge1xuICAgIHNlbGYuc2VsZWN0KDAsIHNlbGYucGllY2VzLmxlbmd0aCAtIDEsIGZhbHNlKVxuICB9XG5cbiAgc2VsZi5yZWFkeSA9IHRydWVcbiAgc2VsZi5lbWl0KCdyZWFkeScpXG5cbiAgLy8gRmlsZXMgbWF5IHN0YXJ0IG91dCBkb25lIGlmIHRoZSBmaWxlIHdhcyBhbHJlYWR5IGluIHRoZSBzdG9yZVxuICBzZWxmLl9jaGVja0RvbmUoKVxuXG4gIC8vIEluIGNhc2UgYW55IHNlbGVjdGlvbnMgd2VyZSBtYWRlIGJlZm9yZSB0b3JyZW50IHdhcyByZWFkeVxuICBzZWxmLl91cGRhdGVTZWxlY3Rpb25zKClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVzdHJveShudWxsLCBjYilcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlXG4gIHNlbGYuX2RlYnVnKCdkZXN0cm95JylcblxuICBzZWxmLmNsaWVudC5fcmVtb3ZlKHNlbGYpXG5cbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9yZWNob2tlSW50ZXJ2YWxJZClcblxuICBzZWxmLl94c1JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcSkge1xuICAgIHJlcS5hYm9ydCgpXG4gIH0pXG5cbiAgaWYgKHNlbGYuX3Jhcml0eU1hcCkge1xuICAgIHNlbGYuX3Jhcml0eU1hcC5kZXN0cm95KClcbiAgfVxuXG4gIGZvciAodmFyIGlkIGluIHNlbGYuX3BlZXJzKSB7XG4gICAgc2VsZi5yZW1vdmVQZWVyKGlkKVxuICB9XG5cbiAgc2VsZi5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSBmaWxlLl9kZXN0cm95KClcbiAgfSlcblxuICB2YXIgdGFza3MgPSBzZWxmLl9zZXJ2ZXJzLm1hcChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgc2VydmVyLmRlc3Ryb3koY2IpXG4gICAgfVxuICB9KVxuXG4gIGlmIChzZWxmLmRpc2NvdmVyeSkge1xuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLmRpc2NvdmVyeS5kZXN0cm95KGNiKVxuICAgIH0pXG4gIH1cblxuICBpZiAoc2VsZi5zdG9yZSkge1xuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLnN0b3JlLmNsb3NlKGNiKVxuICAgIH0pXG4gIH1cblxuICBwYXJhbGxlbCh0YXNrcywgY2IpXG5cbiAgaWYgKGVycikge1xuICAgIC8vIFRvcnJlbnQgZXJyb3JzIGFyZSBlbWl0dGVkIGF0IGB0b3JyZW50Lm9uKCdlcnJvcicpYC4gSWYgdGhlcmUgYXJlIG5vICdlcnJvcicgZXZlbnRcbiAgICAvLyBoYW5kbGVycyBvbiB0aGUgdG9ycmVudCBpbnN0YW5jZSwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCBhdFxuICAgIC8vIGBjbGllbnQub24oJ2Vycm9yJylgLiBUaGlzIHByZXZlbnRzIGNyYXNoaW5nIHRoZSB1c2VyJ3MgcHJvZ3JhbSwgYnV0IGl0IG1ha2VzIGl0XG4gICAgLy8gaW1wb3NzaWJsZSB0byBkZXRlcm1pbmUgYSBjbGllbnQgZXJyb3IgdmVyc3VzIGEgdG9ycmVudCBlcnJvciAod2hlcmUgdGhlIGNsaWVudFxuICAgIC8vIGlzIHN0aWxsIHVzYWJsZSBhZnRlcndhcmRzKS4gVXNlcnMgYXJlIHJlY29tbWVuZGVkIGZvciBlcnJvcnMgaW4gYm90aCBwbGFjZXNcbiAgICAvLyB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBlcnJvciB0eXBlcy5cbiAgICBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICBzZWxmLmNsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9XG4gIH1cblxuICBzZWxmLmVtaXQoJ2Nsb3NlJylcblxuICBzZWxmLmNsaWVudCA9IG51bGxcbiAgc2VsZi5maWxlcyA9IFtdXG4gIHNlbGYuZGlzY292ZXJ5ID0gbnVsbFxuICBzZWxmLnN0b3JlID0gbnVsbFxuICBzZWxmLl9yYXJpdHlNYXAgPSBudWxsXG4gIHNlbGYuX3BlZXJzID0gbnVsbFxuICBzZWxmLl9zZXJ2ZXJzID0gbnVsbFxuICBzZWxmLl94c1JlcXVlc3RzID0gbnVsbFxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5hZGRQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG4gIGlmICghc2VsZi5pbmZvSGFzaCkgdGhyb3cgbmV3IEVycm9yKCdhZGRQZWVyKCkgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgYGluZm9IYXNoYCBldmVudCcpXG5cbiAgaWYgKHNlbGYuY2xpZW50LmJsb2NrZWQpIHtcbiAgICB2YXIgaG9zdFxuICAgIGlmICh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwYXJ0c1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFydHMgPSBhZGRyVG9JUFBvcnQocGVlcilcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IGludmFsaWQgJXMnLCBwZWVyKVxuICAgICAgICBzZWxmLmVtaXQoJ2ludmFsaWRQZWVyJywgcGVlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBob3N0ID0gcGFydHNbMF1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwZWVyLnJlbW90ZUFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBob3N0ID0gcGVlci5yZW1vdGVBZGRyZXNzXG4gICAgfVxuXG4gICAgaWYgKGhvc3QgJiYgc2VsZi5jbGllbnQuYmxvY2tlZC5jb250YWlucyhob3N0KSkge1xuICAgICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IGJsb2NrZWQgJXMnLCBwZWVyKVxuICAgICAgaWYgKHR5cGVvZiBwZWVyICE9PSAnc3RyaW5nJykgcGVlci5kZXN0cm95KClcbiAgICAgIHNlbGYuZW1pdCgnYmxvY2tlZFBlZXInLCBwZWVyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgdmFyIHdhc0FkZGVkID0gISFzZWxmLl9hZGRQZWVyKHBlZXIpXG4gIGlmICh3YXNBZGRlZCkge1xuICAgIHNlbGYuZW1pdCgncGVlcicsIHBlZXIpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5lbWl0KCdpbnZhbGlkUGVlcicsIHBlZXIpXG4gIH1cbiAgcmV0dXJuIHdhc0FkZGVkXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9hZGRQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkge1xuICAgIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBwZWVyOiB0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG4gICAgaWYgKHR5cGVvZiBwZWVyICE9PSAnc3RyaW5nJykgcGVlci5kZXN0cm95KClcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmICh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycgJiYgIXNlbGYuX3ZhbGlkQWRkcihwZWVyKSkge1xuICAgIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBwZWVyOiBpbnZhbGlkICVzJywgcGVlcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIGlkID0gKHBlZXIgJiYgcGVlci5pZCkgfHwgcGVlclxuICBpZiAoc2VsZi5fcGVlcnNbaWRdKSB7XG4gICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IGR1cGxpY2F0ZSAoJXMpJywgaWQpXG4gICAgaWYgKHR5cGVvZiBwZWVyICE9PSAnc3RyaW5nJykgcGVlci5kZXN0cm95KClcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHNlbGYucGF1c2VkKSB7XG4gICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IHRvcnJlbnQgaXMgcGF1c2VkJylcbiAgICBpZiAodHlwZW9mIHBlZXIgIT09ICdzdHJpbmcnKSBwZWVyLmRlc3Ryb3koKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBzZWxmLl9kZWJ1ZygnYWRkIHBlZXIgJXMnLCBpZClcblxuICB2YXIgbmV3UGVlclxuICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYHBlZXJgIGlzIGFuIGFkZHIgKFwiaXA6cG9ydFwiIHN0cmluZylcbiAgICBuZXdQZWVyID0gUGVlci5jcmVhdGVUQ1BPdXRnb2luZ1BlZXIocGVlciwgc2VsZilcbiAgfSBlbHNlIHtcbiAgICAvLyBgcGVlcmAgaXMgYSBXZWJSVEMgY29ubmVjdGlvbiAoc2ltcGxlLXBlZXIpXG4gICAgbmV3UGVlciA9IFBlZXIuY3JlYXRlV2ViUlRDUGVlcihwZWVyLCBzZWxmKVxuICB9XG5cbiAgc2VsZi5fcGVlcnNbbmV3UGVlci5pZF0gPSBuZXdQZWVyXG4gIHNlbGYuX3BlZXJzTGVuZ3RoICs9IDFcblxuICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYHBlZXJgIGlzIGFuIGFkZHIgKFwiaXA6cG9ydFwiIHN0cmluZylcbiAgICBzZWxmLl9xdWV1ZS5wdXNoKG5ld1BlZXIpXG4gICAgc2VsZi5fZHJhaW4oKVxuICB9XG5cbiAgcmV0dXJuIG5ld1BlZXJcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuYWRkV2ViU2VlZCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcblxuICBpZiAoIS9eaHR0cHM/OlxcL1xcLy4rLy50ZXN0KHVybCkpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaWdub3JpbmcgaW52YWxpZCB3ZWIgc2VlZCAlcycsIHVybClcbiAgICB0aGlzLmVtaXQoJ2ludmFsaWRQZWVyJywgdXJsKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHRoaXMuX3BlZXJzW3VybF0pIHtcbiAgICB0aGlzLl9kZWJ1ZygnaWdub3JpbmcgZHVwbGljYXRlIHdlYiBzZWVkICVzJywgdXJsKVxuICAgIHRoaXMuZW1pdCgnaW52YWxpZFBlZXInLCB1cmwpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLl9kZWJ1ZygnYWRkIHdlYiBzZWVkICVzJywgdXJsKVxuXG4gIHZhciBuZXdQZWVyID0gUGVlci5jcmVhdGVXZWJTZWVkUGVlcih1cmwsIHRoaXMpXG4gIHRoaXMuX3BlZXJzW25ld1BlZXIuaWRdID0gbmV3UGVlclxuICB0aGlzLl9wZWVyc0xlbmd0aCArPSAxXG5cbiAgdGhpcy5lbWl0KCdwZWVyJywgdXJsKVxufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmNvbWluZyBUQ1AgcGVlciBjb25uZWN0cyB0byB0aGlzIHRvcnJlbnQgc3dhcm0uIENhbGxlZCB3aXRoIGFcbiAqIHBlZXIgdGhhdCBoYXMgYWxyZWFkeSBzZW50IGEgaGFuZHNoYWtlLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fYWRkSW5jb21pbmdQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIHBlZXIuZGVzdHJveShuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJykpXG4gIGlmIChzZWxmLnBhdXNlZCkgcmV0dXJuIHBlZXIuZGVzdHJveShuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgcGF1c2VkJykpXG5cbiAgdGhpcy5fZGVidWcoJ2FkZCBpbmNvbWluZyBwZWVyICVzJywgcGVlci5pZClcblxuICBzZWxmLl9wZWVyc1twZWVyLmlkXSA9IHBlZXJcbiAgc2VsZi5fcGVlcnNMZW5ndGggKz0gMVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5yZW1vdmVQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpZCA9IChwZWVyICYmIHBlZXIuaWQpIHx8IHBlZXJcbiAgcGVlciA9IHNlbGYuX3BlZXJzW2lkXVxuXG4gIGlmICghcGVlcikgcmV0dXJuXG5cbiAgdGhpcy5fZGVidWcoJ3JlbW92ZVBlZXIgJXMnLCBpZClcblxuICBkZWxldGUgc2VsZi5fcGVlcnNbaWRdXG4gIHNlbGYuX3BlZXJzTGVuZ3RoIC09IDFcblxuICBwZWVyLmRlc3Ryb3koKVxuXG4gIC8vIElmIHRvcnJlbnQgc3dhcm0gd2FzIGF0IGNhcGFjaXR5IGJlZm9yZSwgdHJ5IHRvIG9wZW4gYSBuZXcgY29ubmVjdGlvbiBub3dcbiAgc2VsZi5fZHJhaW4oKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcHJpb3JpdHksIG5vdGlmeSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA8IHN0YXJ0IHx8IHNlbGYucGllY2VzLmxlbmd0aCA8PSBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2VsZWN0aW9uICcsIHN0YXJ0LCAnOicsIGVuZClcbiAgfVxuICBwcmlvcml0eSA9IE51bWJlcihwcmlvcml0eSkgfHwgMFxuXG4gIHNlbGYuX2RlYnVnKCdzZWxlY3QgJXMtJXMgKHByaW9yaXR5ICVzKScsIHN0YXJ0LCBlbmQsIHByaW9yaXR5KVxuXG4gIHNlbGYuX3NlbGVjdGlvbnMucHVzaCh7XG4gICAgZnJvbTogc3RhcnQsXG4gICAgdG86IGVuZCxcbiAgICBvZmZzZXQ6IDAsXG4gICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgIG5vdGlmeTogbm90aWZ5IHx8IG5vb3BcbiAgfSlcblxuICBzZWxmLl9zZWxlY3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHlcbiAgfSlcblxuICBzZWxmLl91cGRhdGVTZWxlY3Rpb25zKClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcHJpb3JpdHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG5cbiAgcHJpb3JpdHkgPSBOdW1iZXIocHJpb3JpdHkpIHx8IDBcbiAgc2VsZi5fZGVidWcoJ2Rlc2VsZWN0ICVzLSVzIChwcmlvcml0eSAlcyknLCBzdGFydCwgZW5kLCBwcmlvcml0eSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcyA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cbiAgICBpZiAocy5mcm9tID09PSBzdGFydCAmJiBzLnRvID09PSBlbmQgJiYgcy5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIHNlbGYuX3NlbGVjdGlvbnMuc3BsaWNlKGktLSwgMSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgc2VsZi5fdXBkYXRlU2VsZWN0aW9ucygpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmNyaXRpY2FsID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG5cbiAgc2VsZi5fZGVidWcoJ2NyaXRpY2FsICVzLSVzJywgc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBzZWxmLl9jcml0aWNhbFtpXSA9IHRydWVcbiAgfVxuXG4gIHNlbGYuX3VwZGF0ZVNlbGVjdGlvbnMoKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fb25XaXJlID0gZnVuY3Rpb24gKHdpcmUsIGFkZHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2RlYnVnKCdnb3Qgd2lyZSAlcyAoJXMpJywgd2lyZS5fZGVidWdJZCwgYWRkciB8fCAnVW5rbm93bicpXG5cbiAgd2lyZS5vbignZG93bmxvYWQnLCBmdW5jdGlvbiAoZG93bmxvYWRlZCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgc2VsZi5yZWNlaXZlZCArPSBkb3dubG9hZGVkXG4gICAgc2VsZi5fZG93bmxvYWRTcGVlZChkb3dubG9hZGVkKVxuICAgIHNlbGYuY2xpZW50Ll9kb3dubG9hZFNwZWVkKGRvd25sb2FkZWQpXG4gICAgc2VsZi5lbWl0KCdkb3dubG9hZCcsIGRvd25sb2FkZWQpXG4gICAgc2VsZi5jbGllbnQuZW1pdCgnZG93bmxvYWQnLCBkb3dubG9hZGVkKVxuICB9KVxuXG4gIHdpcmUub24oJ3VwbG9hZCcsIGZ1bmN0aW9uICh1cGxvYWRlZCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgc2VsZi51cGxvYWRlZCArPSB1cGxvYWRlZFxuICAgIHNlbGYuX3VwbG9hZFNwZWVkKHVwbG9hZGVkKVxuICAgIHNlbGYuY2xpZW50Ll91cGxvYWRTcGVlZCh1cGxvYWRlZClcbiAgICBzZWxmLmVtaXQoJ3VwbG9hZCcsIHVwbG9hZGVkKVxuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3VwbG9hZCcsIHVwbG9hZGVkKVxuICB9KVxuXG4gIHNlbGYud2lyZXMucHVzaCh3aXJlKVxuXG4gIGlmIChhZGRyKSB7XG4gICAgLy8gU29tZXRpbWVzIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKCkgZG9lc24ndCByZXR1cm4gYW4gaXA6cG9ydCBmb3IgcGVlcnNcbiAgICB2YXIgcGFydHMgPSBhZGRyVG9JUFBvcnQoYWRkcilcbiAgICB3aXJlLnJlbW90ZUFkZHJlc3MgPSBwYXJ0c1swXVxuICAgIHdpcmUucmVtb3RlUG9ydCA9IHBhcnRzWzFdXG4gIH1cblxuICAvLyBXaGVuIHBlZXIgc2VuZHMgUE9SVCBtZXNzYWdlLCBhZGQgdGhhdCBESFQgbm9kZSB0byByb3V0aW5nIHRhYmxlXG4gIGlmIChzZWxmLmNsaWVudC5kaHQgJiYgc2VsZi5jbGllbnQuZGh0Lmxpc3RlbmluZykge1xuICAgIHdpcmUub24oJ3BvcnQnLCBmdW5jdGlvbiAocG9ydCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkIHx8IHNlbGYuY2xpZW50LmRodC5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoIXdpcmUucmVtb3RlQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gc2VsZi5fZGVidWcoJ2lnbm9yaW5nIFBPUlQgZnJvbSBwZWVyIHdpdGggbm8gYWRkcmVzcycpXG4gICAgICB9XG4gICAgICBpZiAocG9ydCA9PT0gMCB8fCBwb3J0ID4gNjU1MzYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBpbnZhbGlkIFBPUlQgZnJvbSBwZWVyJylcbiAgICAgIH1cblxuICAgICAgc2VsZi5fZGVidWcoJ3BvcnQ6ICVzIChmcm9tICVzKScsIHBvcnQsIGFkZHIpXG4gICAgICBzZWxmLmNsaWVudC5kaHQuYWRkTm9kZSh7IGhvc3Q6IHdpcmUucmVtb3RlQWRkcmVzcywgcG9ydDogcG9ydCB9KVxuICAgIH0pXG4gIH1cblxuICB3aXJlLm9uKCd0aW1lb3V0JywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2RlYnVnKCd3aXJlIHRpbWVvdXQgKCVzKScsIGFkZHIpXG4gICAgLy8gVE9ETzogdGhpcyBtaWdodCBiZSBkZXN0cm95aW5nIHdpcmVzIHRvbyBlYWdlcmx5XG4gICAgd2lyZS5kZXN0cm95KClcbiAgfSlcblxuICAvLyBUaW1lb3V0IGZvciBwaWVjZSByZXF1ZXN0cyB0byB0aGlzIHBlZXJcbiAgd2lyZS5zZXRUaW1lb3V0KFBJRUNFX1RJTUVPVVQsIHRydWUpXG5cbiAgLy8gU2VuZCBLRUVQLUFMSVZFIChldmVyeSA2MHMpIHNvIHBlZXJzIHdpbGwgbm90IGRpc2Nvbm5lY3QgdGhlIHdpcmVcbiAgd2lyZS5zZXRLZWVwQWxpdmUodHJ1ZSlcblxuICAvLyB1c2UgdXRfbWV0YWRhdGEgZXh0ZW5zaW9uXG4gIHdpcmUudXNlKHV0TWV0YWRhdGEoc2VsZi5tZXRhZGF0YSkpXG5cbiAgd2lyZS51dF9tZXRhZGF0YS5vbignd2FybmluZycsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9kZWJ1ZygndXRfbWV0YWRhdGEgd2FybmluZzogJXMnLCBlcnIubWVzc2FnZSlcbiAgfSlcblxuICBpZiAoIXNlbGYubWV0YWRhdGEpIHtcbiAgICB3aXJlLnV0X21ldGFkYXRhLm9uKCdtZXRhZGF0YScsIGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgc2VsZi5fZGVidWcoJ2dvdCBtZXRhZGF0YSB2aWEgdXRfbWV0YWRhdGEnKVxuICAgICAgc2VsZi5fb25NZXRhZGF0YShtZXRhZGF0YSlcbiAgICB9KVxuICAgIHdpcmUudXRfbWV0YWRhdGEuZmV0Y2goKVxuICB9XG5cbiAgLy8gdXNlIHV0X3BleCBleHRlbnNpb24gaWYgdGhlIHRvcnJlbnQgaXMgbm90IGZsYWdnZWQgYXMgcHJpdmF0ZVxuICBpZiAodHlwZW9mIHV0UGV4ID09PSAnZnVuY3Rpb24nICYmICFzZWxmLnByaXZhdGUpIHtcbiAgICB3aXJlLnVzZSh1dFBleCgpKVxuXG4gICAgd2lyZS51dF9wZXgub24oJ3BlZXInLCBmdW5jdGlvbiAocGVlcikge1xuICAgICAgLy8gT25seSBhZGQgcG90ZW50aWFsIG5ldyBwZWVycyB3aGVuIHdlJ3JlIG5vdCBzZWVkaW5nXG4gICAgICBpZiAoc2VsZi5kb25lKSByZXR1cm5cbiAgICAgIHNlbGYuX2RlYnVnKCd1dF9wZXg6IGdvdCBwZWVyOiAlcyAoZnJvbSAlcyknLCBwZWVyLCBhZGRyKVxuICAgICAgc2VsZi5hZGRQZWVyKHBlZXIpXG4gICAgfSlcblxuICAgIHdpcmUudXRfcGV4Lm9uKCdkcm9wcGVkJywgZnVuY3Rpb24gKHBlZXIpIHtcbiAgICAgIC8vIHRoZSByZW1vdGUgcGVlciBiZWxpZXZlcyBhIGdpdmVuIHBlZXIgaGFzIGJlZW4gZHJvcHBlZCBmcm9tIHRoZSB0b3JyZW50IHN3YXJtLlxuICAgICAgLy8gaWYgd2UncmUgbm90IGN1cnJlbnRseSBjb25uZWN0ZWQgdG8gaXQsIHRoZW4gcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXVlLlxuICAgICAgdmFyIHBlZXJPYmogPSBzZWxmLl9wZWVyc1twZWVyXVxuICAgICAgaWYgKHBlZXJPYmogJiYgIXBlZXJPYmouY29ubmVjdGVkKSB7XG4gICAgICAgIHNlbGYuX2RlYnVnKCd1dF9wZXg6IGRyb3BwZWQgcGVlcjogJXMgKGZyb20gJXMpJywgcGVlciwgYWRkcilcbiAgICAgICAgc2VsZi5yZW1vdmVQZWVyKHBlZXIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHdpcmUub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTdG9wIHNlbmRpbmcgdXBkYXRlcyB0byByZW1vdGUgcGVlclxuICAgICAgd2lyZS51dF9wZXgucmVzZXQoKVxuICAgIH0pXG4gIH1cblxuICAvLyBIb29rIHRvIGFsbG93IHVzZXItZGVmaW5lZCBgYml0dG9ycmVudC1wcm90b2NvbGAgZXh0ZW5zaW9uc1xuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYml0dG9ycmVudC1wcm90b2NvbCNleHRlbnNpb24tYXBpXG4gIHNlbGYuZW1pdCgnd2lyZScsIHdpcmUsIGFkZHIpXG5cbiAgaWYgKHNlbGYubWV0YWRhdGEpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRoaXMgYWxsb3dzIHdpcmUuaGFuZHNoYWtlKCkgdG8gYmUgY2FsbGVkIChieSBQZWVyLm9uSGFuZHNoYWtlKSBiZWZvcmUgYW55XG4gICAgICAvLyBtZXNzYWdlcyBnZXQgc2VudCBvbiB0aGUgd2lyZVxuICAgICAgc2VsZi5fb25XaXJlV2l0aE1ldGFkYXRhKHdpcmUpXG4gICAgfSlcbiAgfVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fb25XaXJlV2l0aE1ldGFkYXRhID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB0aW1lb3V0SWQgPSBudWxsXG5cbiAgZnVuY3Rpb24gb25DaG9rZVRpbWVvdXQgKCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCB8fCB3aXJlLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBpZiAoc2VsZi5fbnVtUXVldWVkID4gMiAqIChzZWxmLl9udW1Db25ucyAtIHNlbGYubnVtUGVlcnMpICYmXG4gICAgICB3aXJlLmFtSW50ZXJlc3RlZCkge1xuICAgICAgd2lyZS5kZXN0cm95KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChvbkNob2tlVGltZW91dCwgQ0hPS0VfVElNRU9VVClcbiAgICAgIGlmICh0aW1lb3V0SWQudW5yZWYpIHRpbWVvdXRJZC51bnJlZigpXG4gICAgfVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlZWRTdGF0dXMgKCkge1xuICAgIGlmICh3aXJlLnBlZXJQaWVjZXMubGVuZ3RoICE9PSBzZWxmLnBpZWNlcy5sZW5ndGgpIHJldHVyblxuICAgIGZvciAoOyBpIDwgc2VsZi5waWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghd2lyZS5wZWVyUGllY2VzLmdldChpKSkgcmV0dXJuXG4gICAgfVxuICAgIHdpcmUuaXNTZWVkZXIgPSB0cnVlXG4gICAgd2lyZS5jaG9rZSgpIC8vIGFsd2F5cyBjaG9rZSBzZWVkZXJzXG4gIH1cblxuICB3aXJlLm9uKCdiaXRmaWVsZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVTZWVkU3RhdHVzKClcbiAgICBzZWxmLl91cGRhdGUoKVxuICB9KVxuXG4gIHdpcmUub24oJ2hhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlU2VlZFN0YXR1cygpXG4gICAgc2VsZi5fdXBkYXRlKClcbiAgfSlcblxuICB3aXJlLm9uY2UoJ2ludGVyZXN0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgd2lyZS51bmNob2tlKClcbiAgfSlcblxuICB3aXJlLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gIH0pXG5cbiAgd2lyZS5vbignY2hva2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KG9uQ2hva2VUaW1lb3V0LCBDSE9LRV9USU1FT1VUKVxuICAgIGlmICh0aW1lb3V0SWQudW5yZWYpIHRpbWVvdXRJZC51bnJlZigpXG4gIH0pXG5cbiAgd2lyZS5vbigndW5jaG9rZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgIHNlbGYuX3VwZGF0ZSgpXG4gIH0pXG5cbiAgd2lyZS5vbigncmVxdWVzdCcsIGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGNiKSB7XG4gICAgaWYgKGxlbmd0aCA+IE1BWF9CTE9DS19MRU5HVEgpIHtcbiAgICAgIC8vIFBlciBzcGVjLCBkaXNjb25uZWN0IGZyb20gcGVlcnMgdGhhdCByZXF1ZXN0ID4xMjhLQlxuICAgICAgcmV0dXJuIHdpcmUuZGVzdHJveSgpXG4gICAgfVxuICAgIGlmIChzZWxmLnBpZWNlc1tpbmRleF0pIHJldHVyblxuICAgIHNlbGYuc3RvcmUuZ2V0KGluZGV4LCB7IG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCB9LCBjYilcbiAgfSlcblxuICB3aXJlLmJpdGZpZWxkKHNlbGYuYml0ZmllbGQpIC8vIGFsd2F5cyBzZW5kIGJpdGZpZWxkIChyZXF1aXJlZClcbiAgd2lyZS5pbnRlcmVzdGVkKCkgLy8gYWx3YXlzIHN0YXJ0IG91dCBpbnRlcmVzdGVkXG5cbiAgLy8gU2VuZCBQT1JUIG1lc3NhZ2UgdG8gcGVlcnMgdGhhdCBzdXBwb3J0IERIVFxuICBpZiAod2lyZS5wZWVyRXh0ZW5zaW9ucy5kaHQgJiYgc2VsZi5jbGllbnQuZGh0ICYmIHNlbGYuY2xpZW50LmRodC5saXN0ZW5pbmcpIHtcbiAgICB3aXJlLnBvcnQoc2VsZi5jbGllbnQuZGh0LmFkZHJlc3MoKS5wb3J0KVxuICB9XG5cbiAgdGltZW91dElkID0gc2V0VGltZW91dChvbkNob2tlVGltZW91dCwgQ0hPS0VfVElNRU9VVClcbiAgaWYgKHRpbWVvdXRJZC51bnJlZikgdGltZW91dElkLnVucmVmKClcblxuICB3aXJlLmlzU2VlZGVyID0gZmFsc2VcbiAgdXBkYXRlU2VlZFN0YXR1cygpXG59XG5cbi8qKlxuICogQ2FsbGVkIG9uIHNlbGVjdGlvbiBjaGFuZ2VzLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fdXBkYXRlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5yZWFkeSB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fZ2NTZWxlY3Rpb25zKClcbiAgfSlcbiAgc2VsZi5fdXBkYXRlSW50ZXJlc3QoKVxuICBzZWxmLl91cGRhdGUoKVxufVxuXG4vKipcbiAqIEdhcmJhZ2UgY29sbGVjdCBzZWxlY3Rpb25zIHdpdGggcmVzcGVjdCB0byB0aGUgc3RvcmUncyBjdXJyZW50IHN0YXRlLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fZ2NTZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcyA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cbiAgICB2YXIgb2xkT2Zmc2V0ID0gcy5vZmZzZXRcblxuICAgIC8vIGNoZWNrIGZvciBuZXdseSBkb3dubG9hZGVkIHBpZWNlcyBpbiBzZWxlY3Rpb25cbiAgICB3aGlsZSAoc2VsZi5iaXRmaWVsZC5nZXQocy5mcm9tICsgcy5vZmZzZXQpICYmIHMuZnJvbSArIHMub2Zmc2V0IDwgcy50bykge1xuICAgICAgcy5vZmZzZXQrK1xuICAgIH1cblxuICAgIGlmIChvbGRPZmZzZXQgIT09IHMub2Zmc2V0KSBzLm5vdGlmeSgpXG4gICAgaWYgKHMudG8gIT09IHMuZnJvbSArIHMub2Zmc2V0KSBjb250aW51ZVxuICAgIGlmICghc2VsZi5iaXRmaWVsZC5nZXQocy5mcm9tICsgcy5vZmZzZXQpKSBjb250aW51ZVxuXG4gICAgLy8gcmVtb3ZlIGZ1bGx5IGRvd25sb2FkZWQgc2VsZWN0aW9uXG4gICAgc2VsZi5fc2VsZWN0aW9ucy5zcGxpY2UoaS0tLCAxKSAvLyBkZWNyZW1lbnQgaSB0byBvZmZzZXQgc3BsaWNlXG4gICAgcy5ub3RpZnkoKSAvLyBUT0RPOiB0aGlzIG1heSBub3RpZnkgdHdpY2UgaW4gYSByb3cuIGlzIHRoaXMgYSBwcm9ibGVtP1xuICAgIHNlbGYuX3VwZGF0ZUludGVyZXN0KClcbiAgfVxuXG4gIGlmICghc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGgpIHNlbGYuZW1pdCgnaWRsZScpXG59XG5cbi8qKlxuICogVXBkYXRlIGludGVyZXN0ZWQgc3RhdHVzIGZvciBhbGwgcGVlcnMuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl91cGRhdGVJbnRlcmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIHByZXYgPSBzZWxmLl9hbUludGVyZXN0ZWRcbiAgc2VsZi5fYW1JbnRlcmVzdGVkID0gISFzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aFxuXG4gIHNlbGYud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgIC8vIFRPRE86IG9ubHkgY2FsbCB3aXJlLmludGVyZXN0ZWQgaWYgdGhlIHdpcmUgaGFzIGF0IGxlYXN0IG9uZSBwaWVjZSB3ZSBuZWVkXG4gICAgaWYgKHNlbGYuX2FtSW50ZXJlc3RlZCkgd2lyZS5pbnRlcmVzdGVkKClcbiAgICBlbHNlIHdpcmUudW5pbnRlcmVzdGVkKClcbiAgfSlcblxuICBpZiAocHJldiA9PT0gc2VsZi5fYW1JbnRlcmVzdGVkKSByZXR1cm5cbiAgaWYgKHNlbGYuX2FtSW50ZXJlc3RlZCkgc2VsZi5lbWl0KCdpbnRlcmVzdGVkJylcbiAgZWxzZSBzZWxmLmVtaXQoJ3VuaW50ZXJlc3RlZCcpXG59XG5cbi8qKlxuICogSGVhcnRiZWF0IHRvIHVwZGF0ZSBhbGwgcGVlcnMgYW5kIHRoZWlyIHJlcXVlc3RzLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICAvLyB1cGRhdGUgd2lyZXMgaW4gcmFuZG9tIG9yZGVyIGZvciBiZXR0ZXIgcmVxdWVzdCBkaXN0cmlidXRpb25cbiAgdmFyIGl0ZSA9IHJhbmRvbUl0ZXJhdGUoc2VsZi53aXJlcylcbiAgdmFyIHdpcmVcbiAgd2hpbGUgKCh3aXJlID0gaXRlKCkpKSB7XG4gICAgc2VsZi5fdXBkYXRlV2lyZSh3aXJlKVxuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gdXBkYXRlIGEgcGVlcidzIHJlcXVlc3RzXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl91cGRhdGVXaXJlID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHdpcmUucGVlckNob2tpbmcpIHJldHVyblxuICBpZiAoIXdpcmUuZG93bmxvYWRlZCkgcmV0dXJuIHZhbGlkYXRlV2lyZSgpXG5cbiAgdmFyIG1pbk91dHN0YW5kaW5nUmVxdWVzdHMgPSBnZXRCbG9ja1BpcGVsaW5lTGVuZ3RoKHdpcmUsIFBJUEVMSU5FX01JTl9EVVJBVElPTilcbiAgaWYgKHdpcmUucmVxdWVzdHMubGVuZ3RoID49IG1pbk91dHN0YW5kaW5nUmVxdWVzdHMpIHJldHVyblxuICB2YXIgbWF4T3V0c3RhbmRpbmdSZXF1ZXN0cyA9IGdldEJsb2NrUGlwZWxpbmVMZW5ndGgod2lyZSwgUElQRUxJTkVfTUFYX0RVUkFUSU9OKVxuXG4gIHRyeVNlbGVjdFdpcmUoZmFsc2UpIHx8IHRyeVNlbGVjdFdpcmUodHJ1ZSlcblxuICBmdW5jdGlvbiBnZW5QaWVjZUZpbHRlckZ1bmMgKHN0YXJ0LCBlbmQsIHRyaWVkLCByYW5rKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaSA+PSBzdGFydCAmJiBpIDw9IGVuZCAmJiAhKGkgaW4gdHJpZWQpICYmIHdpcmUucGVlclBpZWNlcy5nZXQoaSkgJiYgKCFyYW5rIHx8IHJhbmsoaSkpXG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogRG8gd2UgbmVlZCBib3RoIHZhbGlkYXRlV2lyZSBhbmQgdHJ5U2VsZWN0V2lyZT9cbiAgZnVuY3Rpb24gdmFsaWRhdGVXaXJlICgpIHtcbiAgICBpZiAod2lyZS5yZXF1ZXN0cy5sZW5ndGgpIHJldHVyblxuXG4gICAgdmFyIGkgPSBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBuZXh0ID0gc2VsZi5fc2VsZWN0aW9uc1tpXVxuICAgICAgdmFyIHBpZWNlXG4gICAgICBpZiAoc2VsZi5zdHJhdGVneSA9PT0gJ3JhcmVzdCcpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbmV4dC5mcm9tICsgbmV4dC5vZmZzZXRcbiAgICAgICAgdmFyIGVuZCA9IG5leHQudG9cbiAgICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0ICsgMVxuICAgICAgICB2YXIgdHJpZWQgPSB7fVxuICAgICAgICB2YXIgdHJpZXMgPSAwXG4gICAgICAgIHZhciBmaWx0ZXIgPSBnZW5QaWVjZUZpbHRlckZ1bmMoc3RhcnQsIGVuZCwgdHJpZWQpXG5cbiAgICAgICAgd2hpbGUgKHRyaWVzIDwgbGVuKSB7XG4gICAgICAgICAgcGllY2UgPSBzZWxmLl9yYXJpdHlNYXAuZ2V0UmFyZXN0UGllY2UoZmlsdGVyKVxuICAgICAgICAgIGlmIChwaWVjZSA8IDApIGJyZWFrXG4gICAgICAgICAgaWYgKHNlbGYuX3JlcXVlc3Qod2lyZSwgcGllY2UsIGZhbHNlKSkgcmV0dXJuXG4gICAgICAgICAgdHJpZWRbcGllY2VdID0gdHJ1ZVxuICAgICAgICAgIHRyaWVzICs9IDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChwaWVjZSA9IG5leHQudG87IHBpZWNlID49IG5leHQuZnJvbSArIG5leHQub2Zmc2V0OyAtLXBpZWNlKSB7XG4gICAgICAgICAgaWYgKCF3aXJlLnBlZXJQaWVjZXMuZ2V0KHBpZWNlKSkgY29udGludWVcbiAgICAgICAgICBpZiAoc2VsZi5fcmVxdWVzdCh3aXJlLCBwaWVjZSwgZmFsc2UpKSByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHdpcmUgZmFpbGVkIHRvIHZhbGlkYXRlIGFzIHVzZWZ1bDsgc2hvdWxkIHdlIGNsb3NlIGl0P1xuICAgIC8vIHByb2JhYmx5IG5vdCwgc2luY2UgJ2hhdmUnIGFuZCAnYml0ZmllbGQnIG1lc3NhZ2VzIG1pZ2h0IGJlIGNvbWluZ1xuICB9XG5cbiAgZnVuY3Rpb24gc3BlZWRSYW5rZXIgKCkge1xuICAgIHZhciBzcGVlZCA9IHdpcmUuZG93bmxvYWRTcGVlZCgpIHx8IDFcbiAgICBpZiAoc3BlZWQgPiBTUEVFRF9USFJFU0hPTEQpIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH1cblxuICAgIHZhciBzZWNzID0gTWF0aC5tYXgoMSwgd2lyZS5yZXF1ZXN0cy5sZW5ndGgpICogUGllY2UuQkxPQ0tfTEVOR1RIIC8gc3BlZWRcbiAgICB2YXIgdHJpZXMgPSAxMFxuICAgIHZhciBwdHIgPSAwXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBpZiAoIXRyaWVzIHx8IHNlbGYuYml0ZmllbGQuZ2V0KGluZGV4KSkgcmV0dXJuIHRydWVcblxuICAgICAgdmFyIG1pc3NpbmcgPSBzZWxmLnBpZWNlc1tpbmRleF0ubWlzc2luZ1xuXG4gICAgICBmb3IgKDsgcHRyIDwgc2VsZi53aXJlcy5sZW5ndGg7IHB0cisrKSB7XG4gICAgICAgIHZhciBvdGhlcldpcmUgPSBzZWxmLndpcmVzW3B0cl1cbiAgICAgICAgdmFyIG90aGVyU3BlZWQgPSBvdGhlcldpcmUuZG93bmxvYWRTcGVlZCgpXG5cbiAgICAgICAgaWYgKG90aGVyU3BlZWQgPCBTUEVFRF9USFJFU0hPTEQpIGNvbnRpbnVlXG4gICAgICAgIGlmIChvdGhlclNwZWVkIDw9IHNwZWVkKSBjb250aW51ZVxuICAgICAgICBpZiAoIW90aGVyV2lyZS5wZWVyUGllY2VzLmdldChpbmRleCkpIGNvbnRpbnVlXG4gICAgICAgIGlmICgobWlzc2luZyAtPSBvdGhlclNwZWVkICogc2VjcykgPiAwKSBjb250aW51ZVxuXG4gICAgICAgIHRyaWVzLS1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2h1ZmZsZVByaW9yaXR5IChpKSB7XG4gICAgdmFyIGxhc3QgPSBpXG4gICAgZm9yICh2YXIgaiA9IGk7IGogPCBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aCAmJiBzZWxmLl9zZWxlY3Rpb25zW2pdLnByaW9yaXR5OyBqKyspIHtcbiAgICAgIGxhc3QgPSBqXG4gICAgfVxuICAgIHZhciB0bXAgPSBzZWxmLl9zZWxlY3Rpb25zW2ldXG4gICAgc2VsZi5fc2VsZWN0aW9uc1tpXSA9IHNlbGYuX3NlbGVjdGlvbnNbbGFzdF1cbiAgICBzZWxmLl9zZWxlY3Rpb25zW2xhc3RdID0gdG1wXG4gIH1cblxuICBmdW5jdGlvbiB0cnlTZWxlY3RXaXJlIChob3Rzd2FwKSB7XG4gICAgaWYgKHdpcmUucmVxdWVzdHMubGVuZ3RoID49IG1heE91dHN0YW5kaW5nUmVxdWVzdHMpIHJldHVybiB0cnVlXG4gICAgdmFyIHJhbmsgPSBzcGVlZFJhbmtlcigpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gc2VsZi5fc2VsZWN0aW9uc1tpXVxuXG4gICAgICB2YXIgcGllY2VcbiAgICAgIGlmIChzZWxmLnN0cmF0ZWd5ID09PSAncmFyZXN0Jykge1xuICAgICAgICB2YXIgc3RhcnQgPSBuZXh0LmZyb20gKyBuZXh0Lm9mZnNldFxuICAgICAgICB2YXIgZW5kID0gbmV4dC50b1xuICAgICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQgKyAxXG4gICAgICAgIHZhciB0cmllZCA9IHt9XG4gICAgICAgIHZhciB0cmllcyA9IDBcbiAgICAgICAgdmFyIGZpbHRlciA9IGdlblBpZWNlRmlsdGVyRnVuYyhzdGFydCwgZW5kLCB0cmllZCwgcmFuaylcblxuICAgICAgICB3aGlsZSAodHJpZXMgPCBsZW4pIHtcbiAgICAgICAgICBwaWVjZSA9IHNlbGYuX3Jhcml0eU1hcC5nZXRSYXJlc3RQaWVjZShmaWx0ZXIpXG4gICAgICAgICAgaWYgKHBpZWNlIDwgMCkgYnJlYWtcblxuICAgICAgICAgIC8vIHJlcXVlc3QgYWxsIG5vbi1yZXNlcnZlZCBibG9ja3MgaW4gdGhpcyBwaWVjZVxuICAgICAgICAgIHdoaWxlIChzZWxmLl9yZXF1ZXN0KHdpcmUsIHBpZWNlLCBzZWxmLl9jcml0aWNhbFtwaWVjZV0gfHwgaG90c3dhcCkpIHt9XG5cbiAgICAgICAgICBpZiAod2lyZS5yZXF1ZXN0cy5sZW5ndGggPCBtYXhPdXRzdGFuZGluZ1JlcXVlc3RzKSB7XG4gICAgICAgICAgICB0cmllZFtwaWVjZV0gPSB0cnVlXG4gICAgICAgICAgICB0cmllcysrXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0LnByaW9yaXR5KSBzaHVmZmxlUHJpb3JpdHkoaSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHBpZWNlID0gbmV4dC5mcm9tICsgbmV4dC5vZmZzZXQ7IHBpZWNlIDw9IG5leHQudG87IHBpZWNlKyspIHtcbiAgICAgICAgICBpZiAoIXdpcmUucGVlclBpZWNlcy5nZXQocGllY2UpIHx8ICFyYW5rKHBpZWNlKSkgY29udGludWVcblxuICAgICAgICAgIC8vIHJlcXVlc3QgYWxsIG5vbi1yZXNlcnZlZCBibG9ja3MgaW4gcGllY2VcbiAgICAgICAgICB3aGlsZSAoc2VsZi5fcmVxdWVzdCh3aXJlLCBwaWVjZSwgc2VsZi5fY3JpdGljYWxbcGllY2VdIHx8IGhvdHN3YXApKSB7fVxuXG4gICAgICAgICAgaWYgKHdpcmUucmVxdWVzdHMubGVuZ3RoIDwgbWF4T3V0c3RhbmRpbmdSZXF1ZXN0cykgY29udGludWVcblxuICAgICAgICAgIGlmIChuZXh0LnByaW9yaXR5KSBzaHVmZmxlUHJpb3JpdHkoaSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsZWQgcGVyaW9kaWNhbGx5IHRvIHVwZGF0ZSB0aGUgY2hva2VkIHN0YXR1cyBvZiBhbGwgcGVlcnMsIGhhbmRsaW5nIG9wdGltaXN0aWNcbiAqIHVuY2hva2luZyBhcyBkZXNjcmliZWQgaW4gQkVQMy5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX3JlY2hva2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYucmVhZHkpIHJldHVyblxuXG4gIGlmIChzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1RpbWUgPiAwKSBzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1RpbWUgLT0gMVxuICBlbHNlIHNlbGYuX3JlY2hva2VPcHRpbWlzdGljV2lyZSA9IG51bGxcblxuICB2YXIgcGVlcnMgPSBbXVxuXG4gIHNlbGYud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgIGlmICghd2lyZS5pc1NlZWRlciAmJiB3aXJlICE9PSBzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1dpcmUpIHtcbiAgICAgIHBlZXJzLnB1c2goe1xuICAgICAgICB3aXJlOiB3aXJlLFxuICAgICAgICBkb3dubG9hZFNwZWVkOiB3aXJlLmRvd25sb2FkU3BlZWQoKSxcbiAgICAgICAgdXBsb2FkU3BlZWQ6IHdpcmUudXBsb2FkU3BlZWQoKSxcbiAgICAgICAgc2FsdDogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgaXNDaG9rZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHBlZXJzLnNvcnQocmVjaG9rZVNvcnQpXG5cbiAgdmFyIHVuY2hva2VJbnRlcmVzdGVkID0gMFxuICB2YXIgaSA9IDBcbiAgZm9yICg7IGkgPCBwZWVycy5sZW5ndGggJiYgdW5jaG9rZUludGVyZXN0ZWQgPCBzZWxmLl9yZWNob2tlTnVtU2xvdHM7ICsraSkge1xuICAgIHBlZXJzW2ldLmlzQ2hva2VkID0gZmFsc2VcbiAgICBpZiAocGVlcnNbaV0ud2lyZS5wZWVySW50ZXJlc3RlZCkgdW5jaG9rZUludGVyZXN0ZWQgKz0gMVxuICB9XG5cbiAgLy8gT3B0aW1pc3RpY2FsbHkgdW5jaG9rZSBhIHBlZXJcbiAgaWYgKCFzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1dpcmUgJiYgaSA8IHBlZXJzLmxlbmd0aCAmJiBzZWxmLl9yZWNob2tlTnVtU2xvdHMpIHtcbiAgICB2YXIgY2FuZGlkYXRlcyA9IHBlZXJzLnNsaWNlKGkpLmZpbHRlcihmdW5jdGlvbiAocGVlcikgeyByZXR1cm4gcGVlci53aXJlLnBlZXJJbnRlcmVzdGVkIH0pXG4gICAgdmFyIG9wdGltaXN0aWMgPSBjYW5kaWRhdGVzW3JhbmRvbUludChjYW5kaWRhdGVzLmxlbmd0aCldXG5cbiAgICBpZiAob3B0aW1pc3RpYykge1xuICAgICAgb3B0aW1pc3RpYy5pc0Nob2tlZCA9IGZhbHNlXG4gICAgICBzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1dpcmUgPSBvcHRpbWlzdGljLndpcmVcbiAgICAgIHNlbGYuX3JlY2hva2VPcHRpbWlzdGljVGltZSA9IFJFQ0hPS0VfT1BUSU1JU1RJQ19EVVJBVElPTlxuICAgIH1cbiAgfVxuXG4gIC8vIFVuY2hva2UgYmVzdCBwZWVyc1xuICBwZWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgaWYgKHBlZXIud2lyZS5hbUNob2tpbmcgIT09IHBlZXIuaXNDaG9rZWQpIHtcbiAgICAgIGlmIChwZWVyLmlzQ2hva2VkKSBwZWVyLndpcmUuY2hva2UoKVxuICAgICAgZWxzZSBwZWVyLndpcmUudW5jaG9rZSgpXG4gICAgfVxuICB9KVxuXG4gIGZ1bmN0aW9uIHJlY2hva2VTb3J0IChwZWVyQSwgcGVlckIpIHtcbiAgICAvLyBQcmVmZXIgaGlnaGVyIGRvd25sb2FkIHNwZWVkXG4gICAgaWYgKHBlZXJBLmRvd25sb2FkU3BlZWQgIT09IHBlZXJCLmRvd25sb2FkU3BlZWQpIHtcbiAgICAgIHJldHVybiBwZWVyQi5kb3dubG9hZFNwZWVkIC0gcGVlckEuZG93bmxvYWRTcGVlZFxuICAgIH1cblxuICAgIC8vIFByZWZlciBoaWdoZXIgdXBsb2FkIHNwZWVkXG4gICAgaWYgKHBlZXJBLnVwbG9hZFNwZWVkICE9PSBwZWVyQi51cGxvYWRTcGVlZCkge1xuICAgICAgcmV0dXJuIHBlZXJCLnVwbG9hZFNwZWVkIC0gcGVlckEudXBsb2FkU3BlZWRcbiAgICB9XG5cbiAgICAvLyBQcmVmZXIgdW5jaG9rZWRcbiAgICBpZiAocGVlckEud2lyZS5hbUNob2tpbmcgIT09IHBlZXJCLndpcmUuYW1DaG9raW5nKSB7XG4gICAgICByZXR1cm4gcGVlckEud2lyZS5hbUNob2tpbmcgPyAxIDogLTFcbiAgICB9XG5cbiAgICAvLyBSYW5kb20gb3JkZXJcbiAgICByZXR1cm4gcGVlckEuc2FsdCAtIHBlZXJCLnNhbHRcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGNhbmNlbCBhIHNsb3cgYmxvY2sgcmVxdWVzdCBmcm9tIGFub3RoZXIgd2lyZSBzdWNoIHRoYXQgdGhlXG4gKiBnaXZlbiB3aXJlIG1heSBlZmZlY3RpdmVseSBzd2FwIG91dCB0aGUgcmVxdWVzdCBmb3Igb25lIG9mIGl0cyBvd24uXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9ob3Rzd2FwID0gZnVuY3Rpb24gKHdpcmUsIGluZGV4KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBzcGVlZCA9IHdpcmUuZG93bmxvYWRTcGVlZCgpXG4gIGlmIChzcGVlZCA8IFBpZWNlLkJMT0NLX0xFTkdUSCkgcmV0dXJuIGZhbHNlXG4gIGlmICghc2VsZi5fcmVzZXJ2YXRpb25zW2luZGV4XSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIHIgPSBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdXG4gIGlmICghcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIG1pblNwZWVkID0gSW5maW5pdHlcbiAgdmFyIG1pbldpcmVcblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlcldpcmUgPSByW2ldXG4gICAgaWYgKCFvdGhlcldpcmUgfHwgb3RoZXJXaXJlID09PSB3aXJlKSBjb250aW51ZVxuXG4gICAgdmFyIG90aGVyU3BlZWQgPSBvdGhlcldpcmUuZG93bmxvYWRTcGVlZCgpXG4gICAgaWYgKG90aGVyU3BlZWQgPj0gU1BFRURfVEhSRVNIT0xEKSBjb250aW51ZVxuICAgIGlmICgyICogb3RoZXJTcGVlZCA+IHNwZWVkIHx8IG90aGVyU3BlZWQgPiBtaW5TcGVlZCkgY29udGludWVcblxuICAgIG1pbldpcmUgPSBvdGhlcldpcmVcbiAgICBtaW5TcGVlZCA9IG90aGVyU3BlZWRcbiAgfVxuXG4gIGlmICghbWluV2lyZSkgcmV0dXJuIGZhbHNlXG5cbiAgZm9yIChpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocltpXSA9PT0gbWluV2lyZSkgcltpXSA9IG51bGxcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBtaW5XaXJlLnJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlcSA9IG1pbldpcmUucmVxdWVzdHNbaV1cbiAgICBpZiAocmVxLnBpZWNlICE9PSBpbmRleCkgY29udGludWVcblxuICAgIHNlbGYucGllY2VzW2luZGV4XS5jYW5jZWwoKHJlcS5vZmZzZXQgLyBQaWVjZS5CTE9DS19MRU5HVEgpIHwgMClcbiAgfVxuXG4gIHNlbGYuZW1pdCgnaG90c3dhcCcsIG1pbldpcmUsIHdpcmUsIGluZGV4KVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlcXVlc3QgYSBibG9jayBmcm9tIHRoZSBnaXZlbiB3aXJlLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uICh3aXJlLCBpbmRleCwgaG90c3dhcCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG51bVJlcXVlc3RzID0gd2lyZS5yZXF1ZXN0cy5sZW5ndGhcbiAgdmFyIGlzV2ViU2VlZCA9IHdpcmUudHlwZSA9PT0gJ3dlYlNlZWQnXG5cbiAgaWYgKHNlbGYuYml0ZmllbGQuZ2V0KGluZGV4KSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIG1heE91dHN0YW5kaW5nUmVxdWVzdHMgPSBpc1dlYlNlZWRcbiAgICA/IE1hdGgubWluKFxuICAgICAgICBnZXRQaWVjZVBpcGVsaW5lTGVuZ3RoKHdpcmUsIFBJUEVMSU5FX01BWF9EVVJBVElPTiwgc2VsZi5waWVjZUxlbmd0aCksXG4gICAgICAgIHNlbGYubWF4V2ViQ29ubnNcbiAgICAgIClcbiAgICA6IGdldEJsb2NrUGlwZWxpbmVMZW5ndGgod2lyZSwgUElQRUxJTkVfTUFYX0RVUkFUSU9OKVxuXG4gIGlmIChudW1SZXF1ZXN0cyA+PSBtYXhPdXRzdGFuZGluZ1JlcXVlc3RzKSByZXR1cm4gZmFsc2VcbiAgLy8gdmFyIGVuZEdhbWUgPSAod2lyZS5yZXF1ZXN0cy5sZW5ndGggPT09IDAgJiYgc2VsZi5zdG9yZS5udW1NaXNzaW5nIDwgMzApXG5cbiAgdmFyIHBpZWNlID0gc2VsZi5waWVjZXNbaW5kZXhdXG4gIHZhciByZXNlcnZhdGlvbiA9IGlzV2ViU2VlZCA/IHBpZWNlLnJlc2VydmVSZW1haW5pbmcoKSA6IHBpZWNlLnJlc2VydmUoKVxuXG4gIGlmIChyZXNlcnZhdGlvbiA9PT0gLTEgJiYgaG90c3dhcCAmJiBzZWxmLl9ob3Rzd2FwKHdpcmUsIGluZGV4KSkge1xuICAgIHJlc2VydmF0aW9uID0gaXNXZWJTZWVkID8gcGllY2UucmVzZXJ2ZVJlbWFpbmluZygpIDogcGllY2UucmVzZXJ2ZSgpXG4gIH1cbiAgaWYgKHJlc2VydmF0aW9uID09PSAtMSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIHIgPSBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdXG4gIGlmICghcikgciA9IHNlbGYuX3Jlc2VydmF0aW9uc1tpbmRleF0gPSBbXVxuICB2YXIgaSA9IHIuaW5kZXhPZihudWxsKVxuICBpZiAoaSA9PT0gLTEpIGkgPSByLmxlbmd0aFxuICByW2ldID0gd2lyZVxuXG4gIHZhciBjaHVua09mZnNldCA9IHBpZWNlLmNodW5rT2Zmc2V0KHJlc2VydmF0aW9uKVxuICB2YXIgY2h1bmtMZW5ndGggPSBpc1dlYlNlZWQgPyBwaWVjZS5jaHVua0xlbmd0aFJlbWFpbmluZyhyZXNlcnZhdGlvbikgOiBwaWVjZS5jaHVua0xlbmd0aChyZXNlcnZhdGlvbilcblxuICB3aXJlLnJlcXVlc3QoaW5kZXgsIGNodW5rT2Zmc2V0LCBjaHVua0xlbmd0aCwgZnVuY3Rpb24gb25DaHVuayAoZXJyLCBjaHVuaykge1xuICAgIC8vIFRPRE86IHdoYXQgaXMgdGhpcyBmb3I/XG4gICAgaWYgKCFzZWxmLnJlYWR5KSByZXR1cm4gc2VsZi5vbmNlKCdyZWFkeScsIGZ1bmN0aW9uICgpIHsgb25DaHVuayhlcnIsIGNodW5rKSB9KVxuXG4gICAgaWYgKHJbaV0gPT09IHdpcmUpIHJbaV0gPSBudWxsXG5cbiAgICBpZiAocGllY2UgIT09IHNlbGYucGllY2VzW2luZGV4XSkgcmV0dXJuIG9uVXBkYXRlVGljaygpXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBzZWxmLl9kZWJ1ZyhcbiAgICAgICAgJ2Vycm9yIGdldHRpbmcgcGllY2UgJXMgKG9mZnNldDogJXMgbGVuZ3RoOiAlcykgZnJvbSAlczogJXMnLFxuICAgICAgICBpbmRleCwgY2h1bmtPZmZzZXQsIGNodW5rTGVuZ3RoLCB3aXJlLnJlbW90ZUFkZHJlc3MgKyAnOicgKyB3aXJlLnJlbW90ZVBvcnQsXG4gICAgICAgIGVyci5tZXNzYWdlXG4gICAgICApXG4gICAgICBpc1dlYlNlZWQgPyBwaWVjZS5jYW5jZWxSZW1haW5pbmcocmVzZXJ2YXRpb24pIDogcGllY2UuY2FuY2VsKHJlc2VydmF0aW9uKVxuICAgICAgb25VcGRhdGVUaWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnKFxuICAgICAgJ2dvdCBwaWVjZSAlcyAob2Zmc2V0OiAlcyBsZW5ndGg6ICVzKSBmcm9tICVzJyxcbiAgICAgIGluZGV4LCBjaHVua09mZnNldCwgY2h1bmtMZW5ndGgsIHdpcmUucmVtb3RlQWRkcmVzcyArICc6JyArIHdpcmUucmVtb3RlUG9ydFxuICAgIClcblxuICAgIGlmICghcGllY2Uuc2V0KHJlc2VydmF0aW9uLCBjaHVuaywgd2lyZSkpIHJldHVybiBvblVwZGF0ZVRpY2soKVxuXG4gICAgdmFyIGJ1ZiA9IHBpZWNlLmZsdXNoKClcblxuICAgIC8vIFRPRE86IG1pZ2h0IG5lZWQgdG8gc2V0IHNlbGYucGllY2VzW2luZGV4XSA9IG51bGwgaGVyZSBzaW5jZSBzaGExIGlzIGFzeW5jXG5cbiAgICBzaGExKGJ1ZiwgZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIGlmIChoYXNoID09PSBzZWxmLl9oYXNoZXNbaW5kZXhdKSB7XG4gICAgICAgIGlmICghc2VsZi5waWVjZXNbaW5kZXhdKSByZXR1cm5cbiAgICAgICAgc2VsZi5fZGVidWcoJ3BpZWNlIHZlcmlmaWVkICVzJywgaW5kZXgpXG5cbiAgICAgICAgc2VsZi5waWVjZXNbaW5kZXhdID0gbnVsbFxuICAgICAgICBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdID0gbnVsbFxuICAgICAgICBzZWxmLmJpdGZpZWxkLnNldChpbmRleCwgdHJ1ZSlcblxuICAgICAgICBzZWxmLnN0b3JlLnB1dChpbmRleCwgYnVmKVxuXG4gICAgICAgIHNlbGYud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgICAgICAgIHdpcmUuaGF2ZShpbmRleClcbiAgICAgICAgfSlcblxuICAgICAgICBzZWxmLl9jaGVja0RvbmUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5waWVjZXNbaW5kZXhdID0gbmV3IFBpZWNlKHBpZWNlLmxlbmd0aClcbiAgICAgICAgc2VsZi5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQaWVjZSAnICsgaW5kZXggKyAnIGZhaWxlZCB2ZXJpZmljYXRpb24nKSlcbiAgICAgIH1cbiAgICAgIG9uVXBkYXRlVGljaygpXG4gICAgfSlcbiAgfSlcblxuICBmdW5jdGlvbiBvblVwZGF0ZVRpY2sgKCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBzZWxmLl91cGRhdGUoKSB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX2NoZWNrRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgLy8gYXJlIGFueSBuZXcgZmlsZXMgZG9uZT9cbiAgc2VsZi5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgaWYgKGZpbGUuZG9uZSkgcmV0dXJuXG4gICAgZm9yICh2YXIgaSA9IGZpbGUuX3N0YXJ0UGllY2U7IGkgPD0gZmlsZS5fZW5kUGllY2U7ICsraSkge1xuICAgICAgaWYgKCFzZWxmLmJpdGZpZWxkLmdldChpKSkgcmV0dXJuXG4gICAgfVxuICAgIGZpbGUuZG9uZSA9IHRydWVcbiAgICBmaWxlLmVtaXQoJ2RvbmUnKVxuICAgIHNlbGYuX2RlYnVnKCdmaWxlIGRvbmU6ICcgKyBmaWxlLm5hbWUpXG4gIH0pXG5cbiAgLy8gaXMgdGhlIHRvcnJlbnQgZG9uZT8gKGlmIGFsbCBjdXJyZW50IHNlbGVjdGlvbnMgYXJlIHNhdGlzZmllZCwgb3IgdGhlcmUgYXJlXG4gIC8vIG5vIHNlbGVjdGlvbnMsIHRoZW4gdG9ycmVudCBpcyBkb25lKVxuICB2YXIgZG9uZSA9IHRydWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cbiAgICBmb3IgKHZhciBwaWVjZSA9IHNlbGVjdGlvbi5mcm9tOyBwaWVjZSA8PSBzZWxlY3Rpb24udG87IHBpZWNlKyspIHtcbiAgICAgIGlmICghc2VsZi5iaXRmaWVsZC5nZXQocGllY2UpKSB7XG4gICAgICAgIGRvbmUgPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRvbmUpIGJyZWFrXG4gIH1cbiAgaWYgKCFzZWxmLmRvbmUgJiYgZG9uZSkge1xuICAgIHNlbGYuZG9uZSA9IHRydWVcbiAgICBzZWxmLl9kZWJ1ZygndG9ycmVudCBkb25lOiAnICsgc2VsZi5pbmZvSGFzaClcbiAgICBpZiAoc2VsZi5kaXNjb3ZlcnkudHJhY2tlcikge1xuICAgICAgc2VsZi5kaXNjb3ZlcnkudHJhY2tlci5jb21wbGV0ZSgpXG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZG9uZScpXG4gIH1cblxuICBzZWxmLl9nY1NlbGVjdGlvbnMoKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHN0cmVhbXMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuICBpZiAoIXNlbGYucmVhZHkpIHJldHVybiBzZWxmLm9uY2UoJ3JlYWR5JywgZnVuY3Rpb24gKCkgeyBzZWxmLmxvYWQoc3RyZWFtcywgY2IpIH0pXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0cmVhbXMpKSBzdHJlYW1zID0gWyBzdHJlYW1zIF1cbiAgaWYgKCFjYikgY2IgPSBub29wXG5cbiAgdmFyIHJlYWRhYmxlID0gbmV3IE11bHRpU3RyZWFtKHN0cmVhbXMpXG4gIHZhciB3cml0YWJsZSA9IG5ldyBDaHVua1N0b3JlV3JpdGVTdHJlYW0oc2VsZi5zdG9yZSwgc2VsZi5waWVjZUxlbmd0aClcblxuICBwdW1wKHJlYWRhYmxlLCB3cml0YWJsZSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5waWVjZXMuZm9yRWFjaChmdW5jdGlvbiAocGllY2UsIGluZGV4KSB7XG4gICAgICBzZWxmLnBpZWNlc1tpbmRleF0gPSBudWxsXG4gICAgICBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdID0gbnVsbFxuICAgICAgc2VsZi5iaXRmaWVsZC5zZXQoaW5kZXgsIHRydWUpXG4gICAgfSlcbiAgICBzZWxmLl9jaGVja0RvbmUoKVxuICAgIGNiKG51bGwpXG4gIH0pXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmNyZWF0ZVNlcnZlciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICh0eXBlb2YgU2VydmVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ25vZGUuanMtb25seSBtZXRob2QnKVxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuICB2YXIgc2VydmVyID0gbmV3IFNlcnZlcih0aGlzLCBvcHRzKVxuICB0aGlzLl9zZXJ2ZXJzLnB1c2goc2VydmVyKVxuICByZXR1cm4gc2VydmVyXG59XG5cblRvcnJlbnQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZWJ1ZygncGF1c2UnKVxuICB0aGlzLnBhdXNlZCA9IHRydWVcbn1cblxuVG9ycmVudC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZWJ1ZygncmVzdW1lJylcbiAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICB0aGlzLl9kcmFpbigpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgYXJnc1swXSA9ICdbJyArIHRoaXMuX2RlYnVnSWQgKyAnXSAnICsgYXJnc1swXVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmdzKVxufVxuXG4vKipcbiAqIFBvcCBhIHBlZXIgb2ZmIHRoZSBGSUZPIHF1ZXVlIGFuZCBjb25uZWN0IHRvIGl0LiBXaGVuIF9kcmFpbigpIGdldHMgY2FsbGVkLFxuICogdGhlIHF1ZXVlIHdpbGwgdXN1YWxseSBoYXZlIG9ubHkgb25lIHBlZXIgaW4gaXQsIGV4Y2VwdCB3aGVuIHRoZXJlIGFyZSB0b29cbiAqIG1hbnkgcGVlcnMgKG92ZXIgYHRoaXMubWF4Q29ubnNgKSBpbiB3aGljaCBjYXNlIHRoZXkgd2lsbCBqdXN0IHNpdCBpbiB0aGVcbiAqIHF1ZXVlIHVudGlsIGFub3RoZXIgY29ubmVjdGlvbiBjbG9zZXMuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX2RlYnVnKCdfZHJhaW4gbnVtQ29ubnMgJXMgbWF4Q29ubnMgJXMnLCBzZWxmLl9udW1Db25ucywgc2VsZi5jbGllbnQubWF4Q29ubnMpXG4gIGlmICh0eXBlb2YgbmV0LmNvbm5lY3QgIT09ICdmdW5jdGlvbicgfHwgc2VsZi5kZXN0cm95ZWQgfHwgc2VsZi5wYXVzZWQgfHxcbiAgICAgIHNlbGYuX251bUNvbm5zID49IHNlbGYuY2xpZW50Lm1heENvbm5zKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fZGVidWcoJ2RyYWluICglcyBxdWV1ZWQsICVzLyVzIHBlZXJzKScsIHNlbGYuX251bVF1ZXVlZCwgc2VsZi5udW1QZWVycywgc2VsZi5jbGllbnQubWF4Q29ubnMpXG5cbiAgdmFyIHBlZXIgPSBzZWxmLl9xdWV1ZS5zaGlmdCgpXG4gIGlmICghcGVlcikgcmV0dXJuIC8vIHF1ZXVlIGNvdWxkIGJlIGVtcHR5XG5cbiAgdGhpcy5fZGVidWcoJ3RjcCBjb25uZWN0IGF0dGVtcHQgdG8gJXMnLCBwZWVyLmFkZHIpXG5cbiAgdmFyIHBhcnRzID0gYWRkclRvSVBQb3J0KHBlZXIuYWRkcilcbiAgdmFyIG9wdHMgPSB7XG4gICAgaG9zdDogcGFydHNbMF0sXG4gICAgcG9ydDogcGFydHNbMV1cbiAgfVxuXG4gIHZhciBjb25uID0gcGVlci5jb25uID0gbmV0LmNvbm5lY3Qob3B0cylcblxuICBjb25uLm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7IHBlZXIub25Db25uZWN0KCkgfSlcbiAgY29ubi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgcGVlci5kZXN0cm95KGVycikgfSlcbiAgcGVlci5zdGFydENvbm5lY3RUaW1lb3V0KClcblxuICAvLyBXaGVuIGNvbm5lY3Rpb24gY2xvc2VzLCBhdHRlbXB0IHJlY29ubmVjdCBhZnRlciB0aW1lb3V0ICh3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYpXG4gIGNvbm4ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAvLyBUT0RPOiBJZiB0b3JyZW50IGlzIGRvbmUsIGRvIG5vdCB0cnkgdG8gcmVjb25uZWN0IGFmdGVyIGEgdGltZW91dFxuXG4gICAgaWYgKHBlZXIucmV0cmllcyA+PSBSRUNPTk5FQ1RfV0FJVC5sZW5ndGgpIHtcbiAgICAgIHNlbGYuX2RlYnVnKFxuICAgICAgICAnY29ubiAlcyBjbG9zZWQ6IHdpbGwgbm90IHJlLWFkZCAobWF4ICVzIGF0dGVtcHRzKScsXG4gICAgICAgIHBlZXIuYWRkciwgUkVDT05ORUNUX1dBSVQubGVuZ3RoXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgbXMgPSBSRUNPTk5FQ1RfV0FJVFtwZWVyLnJldHJpZXNdXG4gICAgc2VsZi5fZGVidWcoXG4gICAgICAnY29ubiAlcyBjbG9zZWQ6IHdpbGwgcmUtYWRkIHRvIHF1ZXVlIGluICVzbXMgKGF0dGVtcHQgJXMpJyxcbiAgICAgIHBlZXIuYWRkciwgbXMsIHBlZXIucmV0cmllcyArIDFcbiAgICApXG5cbiAgICB2YXIgcmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gcmVjb25uZWN0VGltZW91dCAoKSB7XG4gICAgICB2YXIgbmV3UGVlciA9IHNlbGYuX2FkZFBlZXIocGVlci5hZGRyKVxuICAgICAgaWYgKG5ld1BlZXIpIG5ld1BlZXIucmV0cmllcyA9IHBlZXIucmV0cmllcyArIDFcbiAgICB9LCBtcylcbiAgICBpZiAocmVjb25uZWN0VGltZW91dC51bnJlZikgcmVjb25uZWN0VGltZW91dC51bnJlZigpXG4gIH0pXG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgc3RyaW5nIGlzIHZhbGlkIElQdjQvNiBhZGRyZXNzLlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl92YWxpZEFkZHIgPSBmdW5jdGlvbiAoYWRkcikge1xuICB2YXIgcGFydHNcbiAgdHJ5IHtcbiAgICBwYXJ0cyA9IGFkZHJUb0lQUG9ydChhZGRyKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGhvc3QgPSBwYXJ0c1swXVxuICB2YXIgcG9ydCA9IHBhcnRzWzFdXG4gIHJldHVybiBwb3J0ID4gMCAmJiBwb3J0IDwgNjU1MzUgJiZcbiAgICAhKGhvc3QgPT09ICcxMjcuMC4wLjEnICYmIHBvcnQgPT09IHRoaXMuY2xpZW50LnRvcnJlbnRQb3J0KVxufVxuXG5mdW5jdGlvbiBnZXRCbG9ja1BpcGVsaW5lTGVuZ3RoICh3aXJlLCBkdXJhdGlvbikge1xuICByZXR1cm4gMiArIE1hdGguY2VpbChkdXJhdGlvbiAqIHdpcmUuZG93bmxvYWRTcGVlZCgpIC8gUGllY2UuQkxPQ0tfTEVOR1RIKVxufVxuXG5mdW5jdGlvbiBnZXRQaWVjZVBpcGVsaW5lTGVuZ3RoICh3aXJlLCBkdXJhdGlvbiwgcGllY2VMZW5ndGgpIHtcbiAgcmV0dXJuIDEgKyBNYXRoLmNlaWwoZHVyYXRpb24gKiB3aXJlLmRvd25sb2FkU3BlZWQoKSAvIHBpZWNlTGVuZ3RoKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBpbiBbMCxoaWdoKVxuICovXG5mdW5jdGlvbiByYW5kb21JbnQgKGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiBoaWdoIHwgMFxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFdlYkNvbm5cblxudmFyIEJpdEZpZWxkID0gcmVxdWlyZSgnYml0ZmllbGQnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd3ZWJ0b3JyZW50OndlYmNvbm4nKVxudmFyIGdldCA9IHJlcXVpcmUoJ3NpbXBsZS1nZXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNoYTEgPSByZXF1aXJlKCdzaW1wbGUtc2hhMScpXG52YXIgV2lyZSA9IHJlcXVpcmUoJ2JpdHRvcnJlbnQtcHJvdG9jb2wnKVxuXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuaW5oZXJpdHMoV2ViQ29ubiwgV2lyZSlcblxuLyoqXG4gKiBDb252ZXJ0cyByZXF1ZXN0cyBmb3IgdG9ycmVudCBibG9ja3MgaW50byBodHRwIHJhbmdlIHJlcXVlc3RzLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB3ZWIgc2VlZCB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b3JyZW50XG4gKi9cbmZ1bmN0aW9uIFdlYkNvbm4gKHVybCwgdG9ycmVudCkge1xuICBXaXJlLmNhbGwodGhpcylcblxuICB0aGlzLnVybCA9IHVybFxuICB0aGlzLndlYlBlZXJJZCA9IHNoYTEuc3luYyh1cmwpXG4gIHRoaXMuX3RvcnJlbnQgPSB0b3JyZW50XG5cbiAgdGhpcy5faW5pdCgpXG59XG5cbldlYkNvbm4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5zZXRLZWVwQWxpdmUodHJ1ZSlcblxuICBzZWxmLm9uY2UoJ2hhbmRzaGFrZScsIGZ1bmN0aW9uIChpbmZvSGFzaCwgcGVlcklkKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzZWxmLmhhbmRzaGFrZShpbmZvSGFzaCwgc2VsZi53ZWJQZWVySWQpXG4gICAgdmFyIG51bVBpZWNlcyA9IHNlbGYuX3RvcnJlbnQucGllY2VzLmxlbmd0aFxuICAgIHZhciBiaXRmaWVsZCA9IG5ldyBCaXRGaWVsZChudW1QaWVjZXMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtUGllY2VzOyBpKyspIHtcbiAgICAgIGJpdGZpZWxkLnNldChpLCB0cnVlKVxuICAgIH1cbiAgICBzZWxmLmJpdGZpZWxkKGJpdGZpZWxkKVxuICB9KVxuXG4gIHNlbGYub25jZSgnaW50ZXJlc3RlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1ZygnaW50ZXJlc3RlZCcpXG4gICAgc2VsZi51bmNob2tlKClcbiAgfSlcblxuICBzZWxmLm9uKCd1bmludGVyZXN0ZWQnLCBmdW5jdGlvbiAoKSB7IGRlYnVnKCd1bmludGVyZXN0ZWQnKSB9KVxuICBzZWxmLm9uKCdjaG9rZScsIGZ1bmN0aW9uICgpIHsgZGVidWcoJ2Nob2tlJykgfSlcbiAgc2VsZi5vbigndW5jaG9rZScsIGZ1bmN0aW9uICgpIHsgZGVidWcoJ3VuY2hva2UnKSB9KVxuICBzZWxmLm9uKCdiaXRmaWVsZCcsIGZ1bmN0aW9uICgpIHsgZGVidWcoJ2JpdGZpZWxkJykgfSlcblxuICBzZWxmLm9uKCdyZXF1ZXN0JywgZnVuY3Rpb24gKHBpZWNlSW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKCdyZXF1ZXN0IHBpZWNlSW5kZXg9JWQgb2Zmc2V0PSVkIGxlbmd0aD0lZCcsIHBpZWNlSW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuICAgIHNlbGYuaHR0cFJlcXVlc3QocGllY2VJbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGNhbGxiYWNrKVxuICB9KVxufVxuXG5XZWJDb25uLnByb3RvdHlwZS5odHRwUmVxdWVzdCA9IGZ1bmN0aW9uIChwaWVjZUluZGV4LCBvZmZzZXQsIGxlbmd0aCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwaWVjZU9mZnNldCA9IHBpZWNlSW5kZXggKiBzZWxmLl90b3JyZW50LnBpZWNlTGVuZ3RoXG4gIHZhciByYW5nZVN0YXJ0ID0gcGllY2VPZmZzZXQgKyBvZmZzZXQgLyogb2Zmc2V0IHdpdGhpbiB3aG9sZSB0b3JyZW50ICovXG4gIHZhciByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyBsZW5ndGggLSAxXG5cbiAgLy8gV2ViIHNlZWQgVVJMIGZvcm1hdDpcbiAgLy8gRm9yIHNpbmdsZS1maWxlIHRvcnJlbnRzLCBtYWtlIEhUVFAgcmFuZ2UgcmVxdWVzdHMgZGlyZWN0bHkgdG8gdGhlIHdlYiBzZWVkIFVSTFxuICAvLyBGb3IgbXVsdGktZmlsZSB0b3JyZW50cywgYWRkIHRoZSB0b3JyZW50IGZvbGRlciBhbmQgZmlsZSBuYW1lIHRvIHRoZSBVUkxcbiAgdmFyIGZpbGVzID0gc2VsZi5fdG9ycmVudC5maWxlc1xuICB2YXIgcmVxdWVzdHNcbiAgaWYgKGZpbGVzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmVxdWVzdHMgPSBbe1xuICAgICAgdXJsOiBzZWxmLnVybCxcbiAgICAgIHN0YXJ0OiByYW5nZVN0YXJ0LFxuICAgICAgZW5kOiByYW5nZUVuZFxuICAgIH1dXG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcXVlc3RlZEZpbGVzID0gZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICByZXR1cm4gZmlsZS5vZmZzZXQgPD0gcmFuZ2VFbmQgJiYgKGZpbGUub2Zmc2V0ICsgZmlsZS5sZW5ndGgpID4gcmFuZ2VTdGFydFxuICAgIH0pXG4gICAgaWYgKHJlcXVlc3RlZEZpbGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGZpbGUgY29ycmVzcG9ubmRpbmcgdG8gd2ViIHNlZWQgcmFuZ2UgcmVxdWVzdCcpKVxuICAgIH1cblxuICAgIHJlcXVlc3RzID0gcmVxdWVzdGVkRmlsZXMubWFwKGZ1bmN0aW9uIChyZXF1ZXN0ZWRGaWxlKSB7XG4gICAgICB2YXIgZmlsZUVuZCA9IHJlcXVlc3RlZEZpbGUub2Zmc2V0ICsgcmVxdWVzdGVkRmlsZS5sZW5ndGggLSAxXG4gICAgICB2YXIgdXJsID0gc2VsZi51cmwgK1xuICAgICAgICAoc2VsZi51cmxbc2VsZi51cmwubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcnIDogJy8nKSArXG4gICAgICAgIHJlcXVlc3RlZEZpbGUucGF0aFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGZpbGVPZmZzZXRJblJhbmdlOiBNYXRoLm1heChyZXF1ZXN0ZWRGaWxlLm9mZnNldCAtIHJhbmdlU3RhcnQsIDApLFxuICAgICAgICBzdGFydDogTWF0aC5tYXgocmFuZ2VTdGFydCAtIHJlcXVlc3RlZEZpbGUub2Zmc2V0LCAwKSxcbiAgICAgICAgZW5kOiBNYXRoLm1pbihmaWxlRW5kLCByYW5nZUVuZCAtIHJlcXVlc3RlZEZpbGUub2Zmc2V0KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBOb3cgbWFrZSBhbGwgdGhlIEhUVFAgcmVxdWVzdHMgd2UgbmVlZCBpbiBvcmRlciB0byBsb2FkIHRoaXMgcGllY2VcbiAgLy8gVXN1YWxseSB0aGF0J3Mgb25lIHJlcXVlc3RzLCBidXQgc29tZXRpbWVzIGl0IHdpbGwgYmUgbXVsdGlwbGVcbiAgLy8gU2VuZCByZXF1ZXN0cyBpbiBwYXJhbGxlbCBhbmQgd2FpdCBmb3IgdGhlbSBhbGwgdG8gY29tZSBiYWNrXG4gIHZhciBudW1SZXF1ZXN0c1N1Y2NlZWRlZCA9IDBcbiAgdmFyIGhhc0Vycm9yID0gZmFsc2VcblxuICB2YXIgcmV0XG4gIGlmIChyZXF1ZXN0cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aClcbiAgfVxuXG4gIHJlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICB2YXIgdXJsID0gcmVxdWVzdC51cmxcbiAgICB2YXIgc3RhcnQgPSByZXF1ZXN0LnN0YXJ0XG4gICAgdmFyIGVuZCA9IHJlcXVlc3QuZW5kXG4gICAgZGVidWcoXG4gICAgICAnUmVxdWVzdGluZyB1cmw9JXMgcGllY2VJbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkIHN0YXJ0PSVkIGVuZD0lZCcsXG4gICAgICB1cmwsIHBpZWNlSW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBzdGFydCwgZW5kXG4gICAgKVxuICAgIHZhciBvcHRzID0ge1xuICAgICAgdXJsOiB1cmwsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAndXNlci1hZ2VudCc6ICdXZWJUb3JyZW50LycgKyBWRVJTSU9OICsgJyAoaHR0cHM6Ly93ZWJ0b3JyZW50LmlvKScsXG4gICAgICAgIHJhbmdlOiAnYnl0ZXM9JyArIHN0YXJ0ICsgJy0nICsgZW5kXG4gICAgICB9XG4gICAgfVxuICAgIGdldC5jb25jYXQob3B0cywgZnVuY3Rpb24gKGVyciwgcmVzLCBkYXRhKSB7XG4gICAgICBpZiAoaGFzRXJyb3IpIHJldHVyblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBoYXNFcnJvciA9IHRydWVcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXMuc3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgICAgaGFzRXJyb3IgPSB0cnVlXG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgSFRUUCBzdGF0dXMgY29kZSAnICsgcmVzLnN0YXR1c0NvZGUpKVxuICAgICAgfVxuICAgICAgZGVidWcoJ0dvdCBkYXRhIG9mIGxlbmd0aCAlZCcsIGRhdGEubGVuZ3RoKVxuXG4gICAgICBpZiAocmVxdWVzdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIENvbW1vbiBjYXNlOiBmZXRjaCBwaWVjZSBpbiBhIHNpbmdsZSBIVFRQIHJlcXVlc3QsIHJldHVybiBkaXJlY3RseVxuICAgICAgICBjYihudWxsLCBkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmFyZSBjYXNlOiByZWNvbnN0cnVjdCBtdWx0aXBsZSBIVFRQIHJlcXVlc3RzIGFjcm9zcyAyKyBmaWxlcyBpbnRvIG9uZVxuICAgICAgICAvLyBwaWVjZSBidWZmZXJcbiAgICAgICAgZGF0YS5jb3B5KHJldCwgcmVxdWVzdC5maWxlT2Zmc2V0SW5SYW5nZSlcbiAgICAgICAgaWYgKCsrbnVtUmVxdWVzdHNTdWNjZWVkZWQgPT09IHJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgICAgIGNiKG51bGwsIHJldClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbldlYkNvbm4ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIFdpcmUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKVxuICB0aGlzLl90b3JyZW50ID0gbnVsbFxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1widmVyc2lvblwiOlwiMC45NC40XCJ9IiwiLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xuLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYVxuLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcbi8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5LlxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHlcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XG4gIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpXG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKVxuXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgd3JhcHBlcltrXSA9IGZuW2tdXG4gIH0pXG5cbiAgcmV0dXJuIHdyYXBwZXJcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7XG4gICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXRba10gPSBjYltrXVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCIvKipcbiAqIEdpdmVuIGEgbnVtYmVyLCByZXR1cm4gYSB6ZXJvLWZpbGxlZCBzdHJpbmcuXG4gKiBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI2NzI4My9cbiAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gbnVtYmVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gemVyb0ZpbGwgKHdpZHRoLCBudW1iZXIsIHBhZCkge1xuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG51bWJlciwgcGFkKSB7XG4gICAgICByZXR1cm4gemVyb0ZpbGwod2lkdGgsIG51bWJlciwgcGFkKVxuICAgIH1cbiAgfVxuICBpZiAocGFkID09PSB1bmRlZmluZWQpIHBhZCA9ICcwJ1xuICB3aWR0aCAtPSBudW1iZXIudG9TdHJpbmcoKS5sZW5ndGhcbiAgaWYgKHdpZHRoID4gMCkgcmV0dXJuIG5ldyBBcnJheSh3aWR0aCArICgvXFwuLy50ZXN0KG51bWJlcikgPyAyIDogMSkpLmpvaW4ocGFkKSArIG51bWJlclxuICByZXR1cm4gbnVtYmVyICsgJydcbn1cbiJdfQ==
