(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var http = require('http');
var MultiStream = require('multistream');
var util = require('util');
//var Readable = require('stream').Readable;
var readableStream = require('readable-stream');
var Videostream = require('videostream');
var WebTorrent = require('webtorrent');
var SimplePeer = require('simple-peer');
var ut_pex = require('ut_pex');
var parseTorrent = require('parse-torrent');


 /**
 * @module OakStreaming
 */
module.exports = OakStreaming;


 /**
 * Creates a new OakStreaming instance which has the methods streamVideo, loadVideo, addPeer and on.
 * @constructor
 */ 
function OakStreaming(OakName){
   this.peerId = Math.floor(Math.random() * Math.pow(10,300) + 1);
   this.simplePeerCreationCounter = 0;
   this.connectionsWaitingForSignalingData = [];
   this.theTorrent = null;
   this.peersToAdd = [];
   this.notificationsBecauseNewWires = 0;
   
   console.log("In OakStreaming constructor. this.name: " + OakName);
   this.OakName = OakName;
     
   
   this.streamVideo = streamVideo;
   this.loadVideo = loadVideo;
   this.addSimplePeerInstance = addSimplePeerInstance;
   this.on = function(){};
   this.forTesting_connectedToNewWebTorrentPeer = null;
   
   /*
   this.streamVideo = function(a,b,c,d,e){streamVideo.call(self, a, b, c, d, e)};
   this.loadVideo = function(a,b,c){loadVideo.call(self, a, b, c)};
   this.addSimplePeerInstance = function(a,b,c){addSimplePeerInstance.call(self, a, b, c)};
   this.on = function(){};
   this.forTesting_connectedToNewWebTorrentPeer = function(){};
   */
   
   this.createSignalingData = function (callback){
      var alreadyCalledCallback = false;
      console.log("Archemage");
      var oakNumber = this.simplePeerCreationCounter;
      console.log("In createSignalingData oakNumber: " + oakNumber);
      this.connectionsWaitingForSignalingData[oakNumber] = new SimplePeer({initiator: true, tickle: false});
      this.simplePeerCreationCounter++;
      
      this.connectionsWaitingForSignalingData[oakNumber].on('signal', function (signalingData){
         if(!alreadyCalledCallback){
            alreadyCalledCallback = true;
            signalingData.oakNumber = oakNumber;
            callback(signalingData);
         }
      });
   };
   
   this.createSignalingDataResponse = function (signalingData, callback){
      console.log("Pala");
      var oakNumber = signalingData.oakNumber;
      console.log("In createSignalingDataResponse zu Beginn oakNumber: " + oakNumber);
      delete signalingData.oakNumber;
      
      var myPeer = new SimplePeer({initiator: false, tickle: false});
      var index = this.simplePeerCreationCounter;
      this.connectionsWaitingForSignalingData[index] = myPeer;
      this.simplePeerCreationCounter++;
      
      myPeer.on('signal', function (answerSignalingData){
         console.log("In createSignalingDataResponse nach onSignal oakNumber: " + oakNumber);
         answerSignalingData.oakNumber = oakNumber;
         console.log("In createSignalingDataResponse  object that is returned with callback: " + JSON.stringify(answerSignalingData));
         callback(answerSignalingData);
      });
      myPeer.signal(signalingData);
      
      var self = this;
      myPeer.on('connect', function(){
         self.addSimplePeerInstance(self.connectionsWaitingForSignalingData[index], {}, function(){console.log("addSimplePeerInstance ended");});
      });
   };
   
   this.processSignalingResponse = function (signalingData, callback){
      console.log("In processSignalingResponse  signalingData paramter: " + JSON.stringify(signalingData));
      var oakNumber = signalingData.oakNumber;
      delete signalingData.oakNumber;
      console.log("In processSignalingResponse  oakNumber: " + oakNumber);
      console.log("this.connectionsWaitingForSignalingData: " + this.connectionsWaitingForSignalingData);
      var self = this;
      (this.connectionsWaitingForSignalingData[oakNumber]).on('connect', function (){
         console.log('CONNECT');
         self.addSimplePeerInstance(self.connectionsWaitingForSignalingData[oakNumber]);
         self.connectionsWaitingForSignalingData[oakNumber] = undefined;
         callback();
      });
      console.log("In processSignalingResponse  object that is passed to .signal(): " + JSON.stringify(signalingData));
      this.connectionsWaitingForSignalingData[oakNumber].signal(signalingData);
   };
}

 
 /**
 * @typedef StreamInformationObject
 * @type {object}
 * @property {string} magnetURI - Magnet URI of the torrent. If this property is undefined, no video data will be requested from the WebTorrent network.
 * @property {number} videoFileSize - The size in byte of the video file that was passed as an argument.
 * @property {string} XHRPath - The file path (e.g. /example.mp4 or /videos/example2.mp4) that will be used for the XML HTTP Requests to the Web server. Via these XML HTTP Requests, video data will be requested from the Web sever. If this property is undefined, no video data will be requested from the Web server.
 */
 
/**
 * @callback OakStreaming~streamVideoFinished
 * @param {StreamInformationObject} streamInformationObject - An object that other clients/peers can pass as an argument to their loadVideo method to download the video from other clients/peers and/or the Web Server.
 */ 

/**
 * Streams a video file to all other clients/peers.
 * @param {object} videoFile - The video file that should be streamed to the other clients/peers. This paramter can either be a {@link https://developer.mozilla.org/en-US/docs/Web/API/File|W3C File object}, a {@link https://developer.mozilla.org/en-US/docs/Web/API/FileList|W3C FileList}, a {@link https://nodejs.org/api/buffer.html|Node Buffer object} or a {@link https://nodejs.org/api/stream.html#stream_class_stream_readable|Readable stream object}.
 * @param {object} [options] - Options for the creation of the StreamInformationObject, that gets passed as an argument to the callback function.
 * @param {string} options.XHRPath - The path that will be used for the XML HTTP Request (XHR). If the option object or this property of the option object is undefined, no video data will be requested from the server.
 * @param {OakStreaming~streamVideoFinished} callback - This callback function gets called with the generated StreamInformationObject at the end of the execution of streamVideo.
 */
function streamVideo(videoFile, options, callback, returnTorrent, destroyTorrent){ 
   var webTorrentClient = new WebTorrent();
   ////console.log("streamVideo is executed");
   ////console.log("videoFile: " + videoFile);
   ////console.log("options: " + options);
   ////console.log("callback: " + callback);
   var self = this; 
   
   
   var seedingOption = {};
   if(options.webTorrentTrackers){
      seedingOption.announceList = options.webTorrentTrackers;
   }
   
   webTorrentClient.seed(videoFile, seedingOption, function(torrent){
      console.log("torrent file is seeded");
      
      console.log("In loadVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets created");
      self.forTesting_connectedToNewWebTorrentPeer = function(callback){
         console.log("In loadVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets executed");
         if(self.notificationsBecauseNewWires <= 0){
            self.notificationsBecauseNewWires--;
            var callbackCalled = false;
            
            torrent.on('wire', function(wire){
               if(!callbackCalled){
                  callback();
                  callbackCalled = true;
               }
            });
         } else {
            self.notificationsBecauseNewWires--;            
            callback();
         }
      };
      
      torrent.on('wire', function (wire){
         self.notificationsBecauseNewWires++;  
      });
      
      
      ////console.log("Video file was seeded");
      var streamInformationObject = {};
      //streamInformationObject.torrent = torrent;
      if(options.webTorrentTrackers){
         streamInformationObject.magnetURI = torrent.magnetURI;
         // Sind dann ja schon im torrent file drin      streamInformationObject.webTorrentTrackers = options.webTorrentTrackers;
      }
      
      streamInformationObject.bufferSize = options.bufferSize;
      streamInformationObject.videoFileSize = torrent.files[0].length;
      streamInformationObject.XHRPath = options.XHRPath;
      streamInformationObject.torrentFile = torrent.torrentFile;
      
      
      //////console.log("Creaded streamInformationObject:\n" + JSON.stringify(streamInformationObject));
      if(returnTorrent === "It's a test"){
         if(destroyTorrent){
            self.notificationsBecauseNewWires = 0;
            torrent.destroy();
            delete webTorrentClient;
         }
         setTimeout(function(){callback(streamInformationObject, torrent);},0);
      } else {
         setTimeout(function(){callback(streamInformationObject);},0);
      }
   });
}


/**
 * @callback OakStreaming~loadedVideoFinished
 */ 
 
/**
 * Streams a video file to all other clients/peers.
 * @param {StreamInformationObject} streamInformationObject - This object contains all data that is needed to initiate loading the video from other peers and/or a Web server. StreamInformationObjects can be created by the {@link streamVideo|streamVideo} method.
 * @param {OakStreaming~loadedVideoFinished} callback - This callback gets called when the video has been loaded entirely into the buffer of the video player.
 */
function loadVideo(streamInformationObject, callback, endIfVideoLoaded){
   console.log("Lich");
   
   //////console.log("I entered this.loadVideo");
   //////console.log("option paramter:\n" + JSON.stringify(streamInformationObject));
   var deliveryByServer = streamInformationObject.XHRPath ? true : false;
   var deliveryByWebtorrent = streamInformationObject.torrentFile ? true : false;
   var webTorrentTrackers = streamInformationObject.webTorrentTrackers;
   //var deliveryByWebtorrent = streamInformationObject.magnetURI ? true : false;
   var MAGNET_URI = streamInformationObject.magnetURI;
   //console.log("streamInformationObject.XHRPath: " + streamInformationObject.XHRPath);
   var PATH_TO_VIDEO_FILE = streamInformationObject.XHRPath;
   var SIZE_OF_VIDEO_FILE = streamInformationObject.videoFileSize;
   var THE_RECEIVED_TORRENT_FILE = streamInformationObject.torrentFile;
   
   var VIDEO_BUFFER_SIZE = streamInformationObject.videoBufferSize || 50000000; // This is the minomum byte range that the WebTorrent client will download in advance (regarding the current playback position) with a sequential chunk selection strategy. This means the video buffer size in byte
   var CREATE_READSTREAM_REQUEST_SIZE = streamInformationObject.createReadstreamRequestSize || 50000000; // The size of the createReadstream WebTorrent requests in bytes. 
   
   var DOWNLOAD_FROM_SERVER_TIME_RANGE = streamInformationObject.downloadFromServerTimeRange || 5; // in seconds
   var UPLOAD_LIMIT = streamInformationObject.uploadLimit || 2; // multiplied by number of downloaded bytes
   var ADDITION_TO_UPLOAD_LIMIT = streamInformationObject.additionToUploadLimit || 500000; // amount of byte added to upload limit
   var XHR_REQUEST_SIZE = streamInformationObject.xhrRequestSize || 50000; // in byte
   var THRESHOLD_FOR_RETURNING_OF_ANSWER_STREAM = streamInformationObject.thresholdForReturningAnswerStream || 50000; // in byte

   var CHECK_IF_BUFFER_FULL_ENOUGH_INTERVAL = streamInformationObject.checkIfBufferFullEnoughInterval || 300; // in miliseconds
   var CHECK_IF_ANSWERSTREAM_READY_INTERVAL = streamInformationObject.checkIfAnswerstreamReadyInterval || 200; // in miliseconds
   var UPDATE_CHART_INTERVAL = streamInformationObject.updateChartInterval || 1000; // in miliseconds
   var CHOKE_IF_NECESSARY_INTERVAL = streamInformationObject.chokeIfNecessaryInterval || 500; // in miliseconds
   var CHECK_IF_NEW_CREATE_READSTREAM_NECESSARY_INTERVAL = streamInformationObject.checkIfNewCreateReadstreamInterval || 500 ;
   
   var self = this;
   var endStreaming = false;
   var webTorrentClient = null;
   var wires = [];
   var consoleCounter = 0;
   var globalvideostreamRequestNumber = 0;
   var bytesReceivedFromServer = 0;
   var webTorrentFile;
   var videostreamRequestHandlers = [];
   var inCritical = true;
   var videoCompletelyLoaded = false;
   var bytesTakenFromWebTorrent = 0;
   var bytesTakenFromServer = 0;   
   
   
   var myVideo = document.querySelector('video');
   myVideo.addEventListener('error', function (err){
      console.error(myVideo.error);
   });
   
   function MyReadableStream(options){
      readableStream.Readable.call(this, options);
   }
   util.inherits(MyReadableStream, readableStream.Readable);
   MyReadableStream.prototype._read = function(size){};
   
  
   if(deliveryByWebtorrent){
      webTorrentClient = new WebTorrent();
          
      //THE_RECEIVED_TORRENT_FILE 
     
      webTorrentClient.add(MAGNET_URI, function (torrent){              
         console.log("webTorrentClient.add   torrent meta data ready");         
         self.theTorrent = torrent;
         
         for(var j=0; j< self.peersToAdd.length; j++){
            self.theTorrent.addPeer(self.peersToAdd[j][0]);
            if(self.peersToAdd[j][1]){
               (self.peersToAdd[j][1])();
            }
         } 
         
         webTorrentFile = torrent.files[0];
         //console.log("In loadVideo typeof webTorrentFile after assignment: " + typeof webTorrentFile);

         console.log("In loadVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets created");
         self.forTesting_connectedToNewWebTorrentPeer = function(callback){
            console.log("In loadVideo     " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer   gets called");
            if(self.notificationsBecauseNewWires <= 0){
               self.notificationsBecauseNewWires--;
               var callbackCalled = false;
               
               torrent.on('wire', function(wire){
                  if(!callbackCalled){
                     callback();
                     callbackCalled = true;
                  }
               });
            } else {
               self.notificationsBecauseNewWires--;            
               callback();
            }
         };
         
         torrent.on('wire', function (wire){
            console.log("torrent.on('wire', ..) is fired");
            wires.push(wire);
            if(!window.firstWire){
               window.firstWire = wire;
            }
            self.notificationsBecauseNewWires++;
            
            
            wire.use(ut_pex());
            //wire.ut_pex.start();
            
            /*
            wire.ut_pex.on('peer', function (peer){
               this.theTorrent.addPeer(peer);
               // got a peer
               // probably add it to peer connections queue
            });
            */
         });

         for(var i=0, length=videostreamRequestHandlers.length; i<length; i++){
            var thisRequest = videostreamRequestHandlers[i];
            if(thisRequest.currentCB !== null){
               //console.log("In onTorrent nachträglich webtorrent stream erzeugen  thisRequest.start: " + thisRequest.start);
               //console.log("In onTorrent  webTorrentFile.length: " + webTorrentFile.length);
                           
               var endCreateReadStream;
               if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                  endCreateReadStream = webTorrentFile.length-1;
               } else {
                  endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
               }
                   
               thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
               /*
               thisRequest.on('end', function(){
                  if(thisRequest.currentCB !== null && thisRequest.start > thisRequest.lastEndCreateReadStream && thisRequest.start < thisRequest.videoFileSize){
                     var endCreateReadStream;
                     if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                        endCreateReadStream = webTorrentFile.length-1;
                     } else {
                        endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                     }                
                     thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                     thisRequest.oldStartWebTorrent = thisRequest.start;
                     thisRequest.webTorrentStream.unpipe();
                     thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                  }             
               });
               */
               thisRequest.oldStartWebTorrent = thisRequest.start;
               thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
            }
         }
      });
   }
   
   
   var file = function (path){
      this.path = path;
   };
   file.prototype.createReadStream = function (opts){
      if(opts.start > SIZE_OF_VIDEO_FILE){
         //console.log("opts.start > SIZE_OF_VIDEO_FILE there cb(null,null) every time");
         return (new MultiStream(function (cb){cb(null, null);}));
      }
      inCritical = true;
      //console.log(consoleCounter++ + " called createreadStream ");
      //console.log(consoleCounter++ + " opts.start: " + opts.start);
      //console.log(consoleCounter++ + " opts.end: " + opts.end);

      var thisRequest = new VideostreamRequestHandler(++globalvideostreamRequestNumber, opts, this);
     
      if(opts.end && !isNaN(opts.end)){
         thisRequest.end = opts.end + 1;
      } else {
         thisRequest.end = SIZE_OF_VIDEO_FILE;
      }
      
      var MyWriteableStream = function(highWaterMark){
         readableStream.Writable.call(this, highWaterMark);
      };
      util.inherits(MyWriteableStream, readableStream.Writable);
      MyWriteableStream.prototype._write = function(chunk, encoding, done){
         //console.log("MyWriteableStream _write is called");       
         if(thisRequest.start-thisRequest.oldStartWebTorrent < chunk.length){
            ////////console.log("MyWriteableStream _write: pushing received data in answerStream")
            bytesTakenFromWebTorrent += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
            var streamHasMemoryLeft = thisRequest.answerStream.push(chunk.slice(thisRequest.start-thisRequest.oldStartWebTorrent, chunk.length));
            thisRequest.bytesInAnswerStream += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
            
            if(streamHasMemoryLeft){            
               if(thisRequest.currentCB !== null && thisRequest.start >= thisRequest.end){
                  var theCallbackFunction = thisRequest.currentCB;
                  thisRequest.currentCB = null;
                  thisRequest.answerStream.push(null);
                  thisRequest.bytesInAnswerStream = 0;
                  var res = thisRequest.answerStream;
                  thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                  //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                  theCallbackFunction(null, res);
               }
            } else {
               if(thisRequest.currentCB === null){
                  if(thisRequest.webTorrentStream){
                     thisRequest.webTorrentStream.pause();
                  }
                  thisRequest.noMoreData = true;
               } else {
                  var theCallbackFunction = thisRequest.currentCB;
                  thisRequest.currentCB = null;
                  thisRequest.answerStream.push(null);
                  thisRequest.bytesInAnswerStream = 0;
                  var res = thisRequest.answerStream;
                  thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                  //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                  theCallbackFunction(null, res);
               }
            }
               thisRequest.start += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
         }
         //ceckIfAnswerStreamReady(thisRequest);
         thisRequest.oldStartWebTorrent += chunk.length;
         done();
      };
      thisRequest.collectorStreamForWebtorrent = new MyWriteableStream({highWaterMark: 50000000});
      videostreamRequestHandlers.push(thisRequest);

      if(webTorrentFile && self.theTorrent.uploaded <= UPLOAD_LIMIT * self.theTorrent.downloaded + ADDITION_TO_UPLOAD_LIMIT){
         ////////console.log("after new videostreamRequest creating a corresponding webtorrent stream");
         ////console.log("opts.start: " + opts.start);
         ////console.log("webTorrentFile.length: " + webTorrentFile.length);
          
         var endCreateReadStream;
         if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
            endCreateReadStream = webTorrentFile.length-1;
         } else {
            endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
         }
         thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
         thisRequest.lastEndCreateReadStream = endCreateReadStream;
         thisRequest.oldStartWebTorrent = thisRequest.start;
         
         thisRequest.webTorrentStream.unpipe();
         thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
      }

      var multi = new MultiStream(function (cb){
         //console.log("ReadableStream request number " + thisRequest.readStreamNumber + "    does a cb request");
        
         if(thisRequest.end >= 0 && thisRequest.start >= thisRequest.end){
            //console.log("called cb(null,null) from " + thisRequest.readStreamNumber); 
            thisRequest.req = null;
            return cb(null, null);
         }
        
         thisRequest.CBNumber++;
         if(consoleCounter<20){
            //////console.log(consoleCounter++ + "    " + thisRequest.CBNumber + ". call of function(cb) from " + videostreamRequestNumber);
            ////////console.log(consoleCounter++ + "    start: " + thisRequest.start);
         }
         thisRequest.currentCB = cb;
         thisRequest.noMoreData = false;
      
         if(!ceckIfAnswerStreamReady(thisRequest)){
            if(thisRequest.webTorrentStream){
               thisRequest.webTorrentStream.resume();
            } else if(webTorrentFile){
               ////////console.log("New cb function was called and I subsequently create a new torrentStream for it because non existed before for this videostreamRequest");
               ////console.log("After new Multistream. thisRequest.start: " + thisRequest.start);
               ////console.log("webTorrentFile.length: " + webTorrentFile.length);
               var endCreateReadStream;
               if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                  endCreateReadStream = webTorrentFile.length-1;
               } else {
                  endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
               }
               thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
               thisRequest.lastEndCreateReadStream = endCreateReadStream;
               thisRequest.oldStartWebTorrent = thisRequest.start;
               
               thisRequest.webTorrentStream.unpipe();
               thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
            }

            if(deliveryByServer && inCritical && !thisRequest.XHRConducted){
               conductXHR(thisRequest);
            }
         }
      });
      ////////console.log(consoleCounter++ + " terminate createReadStream");
      var destroy = multi.destroy;
      multi.destroy = function(){
         if (thisRequest.req) {
            thisRequest.req.destroy();
         }
         destroy.call(multi);
      };
      return multi;
   };
  
   
   
   
   var frequentlyCheckIfNewCreateReadStreamNecessary = (function (){
      return function(){
         if(videoCompletelyLoaded){
            return;
         }
      
        if(myVideo.duration){
            var timeRanges = myVideo.buffered;
         
            for (var i = 0, length = timeRanges.length; i < length; i++){
               if (myVideo.currentTime >= timeRanges.start(i) && myVideo.currentTime <= timeRanges.end(i)+3) {
                  if (timeRanges.end(i) - myVideo.currentTime <= VIDEO_BUFFER_SIZE) {
                     for (var i = 0, length = videostreamRequestHandlers.length; i < length; i++) {
                        var thisRequest = videostreamRequestHandlers[i];
                        
                        if(thisRequest.currentCB !== null && thisRequest.start > thisRequest.lastEndCreateReadStream && thisRequest.start < thisRequest.videoFileSize){
                           var endCreateReadStream;
                           if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                              endCreateReadStream = webTorrentFile.length-1;
                           } else {
                              endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                           }                
                           thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                           thisRequest.oldStartWebTorrent = thisRequest.start;
                           thisRequest.webTorrentStream.unpipe();
                           thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                        }
                     }
                  }
               }
            }
            setTimeout(frequentlyCheckIfNewCreateReadStreamNecessary, CHECK_IF_NEW_CREATE_READSTREAM_NECESSARY_INTERVAL);
         }
      }   
   })();
   frequentlyCheckIfNewCreateReadStreamNecessary();
   
   
   function ceckIfAnswerStreamReady(thisRequest){
      ////////console.log("At the beginning of thisRequest.bytesInAnswerStream: " + thisRequest.bytesInAnswerStream);
      ////////console.log("In ceckIfAnswerStreamReady of videostreamRequest number " + thisRequest.readStreamNumber +  ". thisRequest.bytesInAnswerStream: " + thisRequest.bytesInAnswerStream + "     thisRequest.currentCB: " + thisRequest.currentCB);
      if (thisRequest.currentCB && ((thisRequest.bytesInAnswerStream >= THRESHOLD_FOR_RETURNING_OF_ANSWER_STREAM) || (thisRequest.start >= SIZE_OF_VIDEO_FILE))){
         ////////console.log("answerStream from videostream Request number " + thisRequest.readStreamNumber + " and CB number " + thisRequest.CBNumber + " gets returned");
         // //////console.log("Returing answerStream out of ceckIfAnswerStreamReady()");
         var theCallbackFunction = thisRequest.currentCB;
         thisRequest.currentCB = null;
         thisRequest.answerStream.push(null);
         if (thisRequest.webTorrentStream){
            thisRequest.webTorrentStream.pause();
         }
         thisRequest.bytesInAnswerStream = 0;
         var res = thisRequest.answerStream;
         thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
         //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
         theCallbackFunction(null, res);
         return true;
      }
      return false;
   };

   var chokeIfNecessary = (function(){
      return function (){
         if (self.theTorrent && self.theTorrent.uploaded >= self.theTorrent.downloaded * UPLOAD_LIMIT + ADDITION_TO_UPLOAD_LIMIT) {
            /* mache ich schon in einer anderen frequent methode
            if(videoCompletelyLoaded){
               self.theTorrent.destroy();
               delete webTorrentClient;
               endStreaming = true;
               return;
            }
            */
            for (var i = 0, length = wires.length; i < length; i++){
               //console.log("I choked a peer");
               wires[i].choke();
            }
         }
         setTimeout(chokeIfNecessary, CHOKE_IF_NECESSARY_INTERVAL);
      };
   })();

   var updateChart = (function(){
      return function(){
         if(endStreaming){
            return;
         }
         if(self.theTorrent && webTorrentFile){
            document.getElementById("WebTorrent-received").innerHTML = "webTorrentFile.length: " + webTorrentFile.length + "\n torrent.downloaded: " + self.theTorrent.downloaded + "\n torrent.uploaded: " + self.theTorrent.uploaded + "\n torrent.progress: " + self.theTorrent.progress + "\n Bytes received from server: " + bytesReceivedFromServer + "\n Bytes taken from server delivery: " + bytesTakenFromServer + "\n Bytes taken from WebTorrent delivery: " + bytesTakenFromWebTorrent;
         }
         setTimeout(updateChart, UPDATE_CHART_INTERVAL);
      };
   })();
    
   function VideostreamRequestHandler(readStreamNumber, opts, self) {
      this.readStreamNumber = readStreamNumber;
      this.opts = opts;
      this.start = opts.start || 0;
      this.oldStartWebTorrent = -42;
      this.oldStartServer = -42;
      this.currentCB = null;
      this.CBNumber = 0;
      this.webTorrentStream = null;
      this.answerStream = new MyReadableStream({highWaterMark: 5000000});
      this.bytesInAnswerStream = 0;
      this.collectorStreamForWebtorrent = null;
      this.XHRConducted = false;
      this.end = -42;
      this.self = self;
      this.bytesTakenFromWebTorrent = 0;
      this.bytesTakenFromServer = 0;
      this.noMoreData = false;
      this.req = null;
      this.lastEndCreateReadStream = -42;
   }

   var frequentlyCeckIfAnswerStreamReady = (function (){
      return function(){
         if(videoCompletelyLoaded){
            return;
         }
         for (var i = 0, length = videostreamRequestHandlers.length; i < length; i++) {
            ceckIfAnswerStreamReady(videostreamRequestHandlers[i]);
         }
         setTimeout(frequentlyCeckIfAnswerStreamReady, CHECK_IF_ANSWERSTREAM_READY_INTERVAL);
      };
   })();

   var checkIfBufferFullEnough = (function(){
      return function(){
         //console.log("checkIfBufferFullEnough is called");
         if(videoCompletelyLoaded){
            return;
         }
         //console.log("video.duration: " + myVideo.duration);
         if(myVideo.duration){
            var timeRanges = myVideo.buffered;
            if(timeRanges.length >= 1){
               //console.log("timeRanges.start(0): " + timeRanges.start(0));
               //console.log("timeRanges.end(0): " + timeRanges.end(0));
               
               if(timeRanges.start(0) == 0 && timeRanges.end(0) == myVideo.duration){
                 // console.log("In checkIfBufferFullEnough: callback should be called");
                  videoCompletelyLoaded = true;
                  if(callback){
                     if(endIfVideoLoaded){
                        callback();
                     } else {
                        callback(self.theTorrent);
                     }
                  }
                  if(endIfVideoLoaded){
                     if(self.theTorrent){
                        self.theTorrent.destroy();
                        delete webTorrentClient;
                     }
                     endStreaming = true;
                     return;                 
                  } 
               }
            }
            inCritical = true;              
            for (var i = 0, length = timeRanges.length; i < length; i++) {
               ////////console.log("Time range number " + i + ": start(" + timeRanges.start(i) + ") end(" + timeRanges.end(i) + ")");
               if (myVideo.currentTime >= timeRanges.start(i) && myVideo.currentTime <= timeRanges.end(i)) {
                  if (timeRanges.end(i) - myVideo.currentTime >= DOWNLOAD_FROM_SERVER_TIME_RANGE) {
                     inCritical = false;
                     ////////console.log("I set inCritical to false");
                  }
               }
            }
            if (deliveryByServer && inCritical) {
               for (var j = 0, length = videostreamRequestHandlers.length; j < length; j++) {
                  if (videostreamRequestHandlers[j].currentCB !== null && videostreamRequestHandlers[j].XHRConducted === false) {
                     conductXHR(videostreamRequestHandlers[j]);
                  }
               }
            }
         }
         setTimeout(checkIfBufferFullEnough, CHECK_IF_BUFFER_FULL_ENOUGH_INTERVAL);
      }
   })();

   function conductXHR(thisRequest) {
      if(thisRequest.currentCB === null){
         return;
      }
      thisRequest.XHRConducted = true;
      var reqStart = thisRequest.start;
      var reqEnd = reqStart + XHR_REQUEST_SIZE;

      if (thisRequest.end >= 0 && reqEnd > thisRequest.end) {
         reqEnd = thisRequest.end;
      }
      if (reqStart >= reqEnd) {
         thisRequest.req = null;
         //console.log("called cb(null,null)");
         return thisRequest.currentCB(null, null);
      }

      /* glaube ich unnötiger und/oder gefährlicher müll
      if (reqStart >= reqEnd) {
      req = null;
      return thisRequest.currentCB(null, null);
      }
      */
      if (consoleCounter < 10000000) {
         //////////console.log(consoleCounter++ + "  videoStream " + thisRequest.readStreamNumber + "  CB number " + thisRequest.CBNumber + "    reqStart: " + reqStart);
         //////////console.log(consoleCounter++ + "  Multistream " + thisRequest.readStreamNumber + "   CB number " + thisRequest.CBNumber + "    reqEnd: " + reqEnd);
      }

      var XHRDataHandler = function (chunk){
         bytesReceivedFromServer += chunk.length;
         //console.log("ReadableStream request number " + thisRequest.readStreamNumber + " received a chunk of length " + chunk.length);
         if(thisRequest.noMoreData){
            thisRequest.oldStartServer += chunk.length;
            return;
         }
         if (thisRequest.start - thisRequest.oldStartServer < chunk.length){         
            bytesTakenFromServer += chunk.length - (thisRequest.start - thisRequest.oldStartServer);
            thisRequest.bytesInAnswerStream += chunk.length - (thisRequest.start - thisRequest.oldStartServer);
            var myBuffer = chunk.slice(thisRequest.start - thisRequest.oldStartServer, chunk.length);
            //console.log("In XHRDataHandler   myBuffer.length: " + myBuffer.length);
            var StreamHasMemoryLeft = thisRequest.answerStream.push(myBuffer);         
            if(!StreamHasMemoryLeft){
               if(thisRequest.currentCB !== null){
                  var theCallbackFunction = thisRequest.currentCB;
                  thisRequest.currentCB = null;
                  thisRequest.answerStream.push(null);
                  thisRequest.bytesInAnswerStream = 0;
                  var res = thisRequest.answerStream;
                  thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                  //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                  theCallbackFunction(null, res); 
               } else {
                  thisRequest.noMoreData = true;
                  if(thisRequest.webTorrentStream){
                     thisRequest.webTorrentStream.pause();
                  }
               }
            } else {
               if (thisRequest.start >= SIZE_OF_VIDEO_FILE && thisRequest.currentCB !== null){
                  var theCallbackFunction = thisRequest.currentCB;
                  thisRequest.currentCB = null;
                  thisRequest.answerStream.push(null);
                  thisRequest.bytesInAnswerStream = 0;
                  var res = thisRequest.answerStream;
                  thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                  //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                  theCallbackFunction(null, res);
               }
            } 
            thisRequest.start += chunk.length - (thisRequest.start - thisRequest.oldStartServer);            
         }
         thisRequest.oldStartServer += chunk.length;
      }

      var XHREnd = function (){
         //console.log("ReadableStream request number " + thisRequest.readStreamNumber + " XHREnd");
         if (consoleCounter < 1000000000000){
            //////////console.log("XHREnd from videostreamRequest number " + thisRequest.readStreamNumber);
         }
         if(thisRequest.bytesInAnswerStream > 0 && thisRequest.currentCB !== null){
            thisRequest.answerStream.push(null);
            thisRequest.bytesInAnswerStream = 0;
            var res = thisRequest.answerStream;
            thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
            var theCallbackFunction = thisRequest.currentCB;
            thisRequest.currentCB = null;
            //console.log("XHREnd: called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
            theCallbackFunction(null, res);
         }
         thisRequest.XHRConducted = false;
      }  
      
      thisRequest.oldStartServer = reqStart;
      
      //console.log("At htto.get   reqStart: " + reqStart + "     reqEnd: " + reqEnd);

      thisRequest.req = http.get({
            path: thisRequest.self.path,
            hostname: 'localhost',
            port: 8080,
            headers: {
               range: 'bytes=' + reqStart + '-' + (reqEnd-1)
            }
        }, function (res){
            var contentRange = res.headers['content-range'];
            if (contentRange) {
               thisRequest.fileSize = parseInt(contentRange.split('/')[1], 10);
            }
            //////////console.log("I return currentCB with http response stream");
            ////////////console.log("function(res) is executed from readstream number " + createReadStreamCounter + " and CB number " + thisCBNumber);
            res.on('end', XHREnd);
            res.on('data', XHRDataHandler);
         }
      );
   }
   chokeIfNecessary();
   updateChart();
   frequentlyCeckIfAnswerStreamReady();
   checkIfBufferFullEnough();

   //////console.log("I call Videostream constructor");
   Videostream(new file(PATH_TO_VIDEO_FILE), myVideo);
}


function addSimplePeerInstance(simplePeerInstance, options, callback){
   // The method add a simplePeer to the WebTorrent swarm instance
   if(this.theTorrent){
      if(this.theTorrent.infoHash){
         this.theTorrent.addPeer(simplePeerInstance);
         if(callback){
            callback();
         }
      } else {
         this.theTorrent.on('infoHash', function() {this.theTorrent.addPeer(simplePeerInstance); if(callback){callback()}});
      }
   } else {
      var pair = [];
      pair.push(simplePeerInstance);
      pair.push(callback);
      this.peersToAdd.push(pair);
   }
}


function on(type, callback){
   // call callback when event of type "type" happend
   // bisher nur das event "foundNewPeerViaTracker" geplant
}
},{"http":140,"multistream":89,"parse-torrent":97,"readable-stream":117,"simple-peer":126,"ut_pex":161,"util":169,"videostream":171,"webtorrent":172}],2:[function(require,module,exports){
var Y = require("yjs");
require("y-array")(Y);
require("y-memory")(Y);
require("y-websockets-client")(Y);
require("y-map")(Y);
var OakStreaming = require('./OakStreaming');
var myStreaming = new OakStreaming();

var theSharedMap = null;
var streamSource = false;

/*
document.querySelector('form').addEventListener('submit', function (ev) {
  ev.preventDefault();
   myStreaming.loadVideo(JSON.parse(document.querySelector('#incoming').value), function(){console.log("All video data has been received");});
});
*/

Y({
  db: {
    name: 'memory'
  },
  connector: {
     //url : "https://yjs.dbis.rwth-aachen.de:5078",
    name: 'websockets-client', // choose the WebRTC connector
    room: 'WebTorrent-Streaming-yeah'
  },
  share: {
     myMap : 'Map'
   // textarea: 'Text' // y.share.textarea is of type Y.Text
  }
  // types: ['Richtext', 'Array'] // optional list of types you want to import
}).then(function (y){
  // bind the textarea to a shared text element
  theSharedMap = y.share.myMap;
  y.share.myMap.observe(function(event){
      console.log("The following event-type was thrown: "+ event.type)
      console.log("The event was executed on: "+ event.name)
      console.log("The event object has more information:")
      console.log(event);
      if(!streamSource){
         console.log("Video gets loaded");
         myStreaming.loadVideo(theSharedMap.get("streamInformationObject"), function(){console.log("All video data has been received");});
         console.log("After myStreaming.loadVideo(..) in myMap.observe(..)");
      }
  });
});

window.handleFiles = function(files){   //XHRPath : "/" + files[0].name, 
   streamSource = true;
   myStreaming.streamVideo(files[0], {webTorrentTrackers: [["ws://localhost:8081"],["wss://tracker.webtorrent.io"]]}, function(streamInformationObject){
      console.log("streamInformationObject:\n" + JSON.stringify(streamInformationObject));
     theSharedMap.set("streamInformationObject", streamInformationObject);
   });
}
},{"./OakStreaming":1,"y-array":183,"y-map":184,"y-memory":185,"y-websockets-client":187,"yjs":195}],3:[function(require,module,exports){
var ADDR_RE = /^\[?([^\]]+)\]?:(\d+)$/ // ipv4/ipv6/hostname + port

var cache = {}

// reset cache when it gets to 100,000 elements (~ 600KB of ipv4 addresses)
// so it will not grow to consume all memory in long-running processes
var size = 0

module.exports = function addrToIPPort (addr) {
  if (size === 100000) module.exports.reset()
  if (!cache[addr]) {
    var m = ADDR_RE.exec(addr)
    if (!m) throw new Error('invalid addr: ' + addr)
    cache[addr] = [ m[1], Number(m[2]) ]
    size += 1
  }
  return cache[addr]
}

module.exports.reset = function reset () {
  cache = {}
  size = 0
}

},{}],4:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],5:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],6:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],7:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],8:[function(require,module,exports){
'use strict'

exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],9:[function(require,module,exports){
(function (Buffer){
/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode (data, start, end, encoding) {
  if (typeof start !== 'number' && encoding == null) {
    encoding = start
    start = undefined
  }

  if (typeof end !== 'number' && encoding == null) {
    encoding = end
    end = undefined
  }

  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !(Buffer.isBuffer(data))
    ? new Buffer(data)
    : data.slice(start, end)

  decode.bytes = decode.data.length

  return decode.next()
}

decode.bytes = 0
decode.position = 0
decode.data = null
decode.encoding = null

decode.next = function () {
  switch (decode.data[decode.position]) {
    case 0x64:
      return decode.dictionary()
    case 0x6C:
      return decode.list()
    case 0x69:
      return decode.integer()
    default:
      return decode.buffer()
  }
}

decode.find = function (chr) {
  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while (i < c) {
    if (d[i] === chr) return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode(chr) + '" [0x' +
    chr.toString(16) + ']'
  )
}

decode.dictionary = function () {
  decode.position++

  var dict = {}

  while (decode.data[decode.position] !== 0x65) {
    dict[decode.buffer()] = decode.next()
  }

  decode.position++

  return dict
}

decode.list = function () {
  decode.position++

  var lst = []

  while (decode.data[decode.position] !== 0x65) {
    lst.push(decode.next())
  }

  decode.position++

  return lst
}

decode.integer = function () {
  var end = decode.find(0x65)
  var number = decode.data.toString('ascii', decode.position + 1, end)

  decode.position += end + 1 - decode.position

  return parseInt(number, 10)
}

decode.buffer = function () {
  var sep = decode.find(0x3A)
  var length = parseInt(decode.data.toString('ascii', decode.position, sep), 10)
  var end = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString(decode.encoding, sep, end)
    : decode.data.slice(sep, end)
}

module.exports = decode

}).call(this,require("buffer").Buffer)

},{"buffer":25}],10:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode (data, buffer, offset) {
  var buffers = []
  var result = null

  encode._encode(buffers, data)
  result = Buffer.concat(buffers)
  encode.bytes = result.length

  if (Buffer.isBuffer(buffer)) {
    result.copy(buffer, offset)
    return buffer
  }

  return result
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function (buffers, data) {
  if (Buffer.isBuffer(data)) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return
  }

  switch (typeof data) {
    case 'string':
      encode.buffer(buffers, data)
      break
    case 'number':
      encode.number(buffers, data)
      break
    case 'object':
      data.constructor === Array
        ? encode.list(buffers, data)
        : encode.dict(buffers, data)
      break
    case 'boolean':
      encode.number(buffers, data ? 1 : 0)
      break
  }
}

var buffE = new Buffer('e')
var buffD = new Buffer('d')
var buffL = new Buffer('l')

encode.buffer = function (buffers, data) {
  buffers.push(new Buffer(Buffer.byteLength(data) + ':' + data))
}

encode.number = function (buffers, data) {
  var maxLo = 0x80000000
  var hi = (data / maxLo) << 0
  var lo = (data % maxLo) << 0
  var val = hi * maxLo + lo

  buffers.push(new Buffer('i' + val + 'e'))

  if (val !== data && !encode._floatConversionDetected) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "' + data + '":',
      'Bencoding only defines support for integers, value was converted to "' + val + '"'
    )
    console.trace()
  }
}

encode.dict = function (buffers, data) {
  buffers.push(buffD)

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys(data).sort()
  var kl = keys.length

  for (; j < kl; j++) {
    k = keys[j]
    encode.buffer(buffers, k)
    encode._encode(buffers, data[k])
  }

  buffers.push(buffE)
}

encode.list = function (buffers, data) {
  var i = 0
  var c = data.length
  buffers.push(buffL)

  for (; i < c; i++) {
    encode._encode(buffers, data[i])
  }

  buffers.push(buffE)
}

module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":25}],11:[function(require,module,exports){
var bencode = module.exports

bencode.encode = require('./encode')
bencode.decode = require('./decode')

/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */
bencode.byteLength = bencode.encodingLength = function (value) {
  return bencode.encode(value).length
}

},{"./decode":9,"./encode":10}],12:[function(require,module,exports){
module.exports = function(haystack, needle, comparator, low, high) {
  var mid, cmp;

  if(low === undefined)
    low = 0;

  else {
    low = low|0;
    if(low < 0 || low >= haystack.length)
      throw new RangeError("invalid lower bound");
  }

  if(high === undefined)
    high = haystack.length - 1;

  else {
    high = high|0;
    if(high < low || high >= haystack.length)
      throw new RangeError("invalid upper bound");
  }

  while(low <= high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle, mid, haystack);

    /* Too low. */
    if(cmp < 0.0)
      low  = mid + 1;

    /* Too high. */
    else if(cmp > 0.0)
      high = mid - 1;

    /* Key found. */
    else
      return mid;
  }

  /* Key not found. */
  return ~low;
}

},{}],13:[function(require,module,exports){
(function (Buffer){
var Container = typeof Buffer !== "undefined" ? Buffer //in node, use buffers
		: typeof Int8Array !== "undefined" ? Int8Array //in newer browsers, use webgl int8arrays
		: function(l){ var a = new Array(l); for(var i = 0; i < l; i++) a[i]=0; }; //else, do something similar

function BitField(data, opts){
	if(!(this instanceof BitField)) {
		return new BitField(data, opts);
	}

	if(arguments.length === 0){
		data = 0;
	}

	this.grow = opts && (isFinite(opts.grow) && getByteSize(opts.grow) || opts.grow) || 0;

	if(typeof data === "number" || data === undefined){
		data = new Container(getByteSize(data));
		if(data.fill && !data._isBuffer) data.fill(0); // clear node buffers of garbage
	}
	this.buffer = data;
}

function getByteSize(num){
	var out = num >> 3;
	if(num % 8 !== 0) out++;
	return out;
}

BitField.prototype.get = function(i){
	var j = i >> 3;
	return (j < this.buffer.length) &&
		!!(this.buffer[j] & (128 >> (i % 8)));
};

BitField.prototype.set = function(i, b){
	var j = i >> 3;
	if (b || arguments.length === 1){
		if (this.buffer.length < j + 1) this._grow(Math.max(j + 1, Math.min(2 * this.buffer.length, this.grow)));
		// Set
		this.buffer[j] |= 128 >> (i % 8);
	} else if (j < this.buffer.length) {
		/// Clear
		this.buffer[j] &= ~(128 >> (i % 8));
	}
};

BitField.prototype._grow = function(length) {
	if (this.buffer.length < length && length <= this.grow) {
		var newBuffer = new Container(length);
		if (newBuffer.fill) newBuffer.fill(0);
		if (this.buffer.copy) this.buffer.copy(newBuffer, 0);
		else {
			for(var i = 0; i < this.buffer.length; i++) {
				newBuffer[i] = this.buffer[i];
			}
		}
		this.buffer = newBuffer;
	}
};

if(typeof module !== "undefined") module.exports = BitField;

}).call(this,require("buffer").Buffer)

},{"buffer":25}],14:[function(require,module,exports){
module.exports = Wire

var bencode = require('bencode')
var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('bittorrent-protocol')
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var speedometer = require('speedometer')
var stream = require('readable-stream')

var BITFIELD_GROW = 400000
var KEEP_ALIVE_TIMEOUT = 55000

var MESSAGE_PROTOCOL = Buffer.from('\u0013BitTorrent protocol')
var MESSAGE_KEEP_ALIVE = Buffer.from([0x00, 0x00, 0x00, 0x00])
var MESSAGE_CHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x00])
var MESSAGE_UNCHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x01])
var MESSAGE_INTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x02])
var MESSAGE_UNINTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x03])

var MESSAGE_RESERVED = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
var MESSAGE_PORT = [0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00]

function Request (piece, offset, length, callback) {
  this.piece = piece
  this.offset = offset
  this.length = length
  this.callback = callback
}

inherits(Wire, stream.Duplex)

function Wire () {
  if (!(this instanceof Wire)) return new Wire()
  stream.Duplex.call(this)

  this._debugId = hat(32)
  this._debug('new wire')

  this.peerId = null // remote peer id (hex string)
  this.peerIdBuffer = null // remote peer id (buffer)
  this.type = null // connection type ('webrtc', 'tcpIncoming', 'tcpOutgoing', 'webSeed')

  this.amChoking = true // are we choking the peer?
  this.amInterested = false // are we interested in the peer?

  this.peerChoking = true // is the peer choking us?
  this.peerInterested = false // is the peer interested in us?

  // The largest torrent that I know of (the Geocities archive) is ~641 GB and has
  // ~41,000 pieces. Therefore, cap bitfield to 10x larger (400,000 bits) to support all
  // possible torrents but prevent malicious peers from growing bitfield to fill memory.
  this.peerPieces = new BitField(0, { grow: BITFIELD_GROW })

  this.peerExtensions = {}

  this.requests = [] // outgoing
  this.peerRequests = [] // incoming

  this.extendedMapping = {} // number -> string, ex: 1 -> 'ut_metadata'
  this.peerExtendedMapping = {} // string -> number, ex: 9 -> 'ut_metadata'

  // The extended handshake to send, minus the "m" field, which gets automatically
  // filled from `this.extendedMapping`
  this.extendedHandshake = {}

  this.peerExtendedHandshake = {} // remote peer's extended handshake

  this._ext = {}  // string -> function, ex 'ut_metadata' -> ut_metadata()
  this._nextExt = 1

  this.uploaded = 0
  this.downloaded = 0
  this.uploadSpeed = speedometer()
  this.downloadSpeed = speedometer()

  this._keepAliveInterval = null
  this._timeout = null
  this._timeoutMs = 0

  this.destroyed = false // was the wire ended by calling `destroy`?
  this._finished = false

  this._parserSize = 0 // number of needed bytes to parse next message from remote peer
  this._parser = null // function to call once `this._parserSize` bytes are available

  this._buffer = [] // incomplete message data
  this._bufferSize = 0 // cached total length of buffers in `this._buffer`

  this.on('finish', this._onFinish)

  this._parseHandshake()
}

/**
 * Set whether to send a "keep-alive" ping (sent every 55s)
 * @param {boolean} enable
 */
Wire.prototype.setKeepAlive = function (enable) {
  var self = this
  self._debug('setKeepAlive %s', enable)
  clearInterval(self._keepAliveInterval)
  if (enable === false) return
  self._keepAliveInterval = setInterval(function () {
    self.keepAlive()
  }, KEEP_ALIVE_TIMEOUT)
}

/**
 * Set the amount of time to wait before considering a request to be "timed out"
 * @param {number} ms
 * @param {boolean=} unref (should the timer be unref'd? default: false)
 */
Wire.prototype.setTimeout = function (ms, unref) {
  this._debug('setTimeout ms=%d unref=%s', ms, unref)
  this._clearTimeout()
  this._timeoutMs = ms
  this._timeoutUnref = !!unref
  this._updateTimeout()
}

Wire.prototype.destroy = function () {
  if (this.destroyed) return
  this.destroyed = true
  this._debug('destroy')
  this.emit('close')
  this.end()
}

Wire.prototype.end = function () {
  this._debug('end')
  this._onUninterested()
  this._onChoke()
  stream.Duplex.prototype.end.apply(this, arguments)
}

/**
 * Use the specified protocol extension.
 * @param  {function} Extension
 */
Wire.prototype.use = function (Extension) {
  var name = Extension.prototype.name
  if (!name) {
    throw new Error('Extension class requires a "name" property on the prototype')
  }
  this._debug('use extension.name=%s', name)

  var ext = this._nextExt
  var handler = new Extension(this)

  function noop () {}

  if (typeof handler.onHandshake !== 'function') {
    handler.onHandshake = noop
  }
  if (typeof handler.onExtendedHandshake !== 'function') {
    handler.onExtendedHandshake = noop
  }
  if (typeof handler.onMessage !== 'function') {
    handler.onMessage = noop
  }

  this.extendedMapping[ext] = name
  this._ext[name] = handler
  this[name] = handler

  this._nextExt += 1
}

//
// OUTGOING MESSAGES
//

/**
 * Message "keep-alive": <len=0000>
 */
Wire.prototype.keepAlive = function () {
  this._debug('keep-alive')
  this._push(MESSAGE_KEEP_ALIVE)
}

/**
 * Message: "handshake" <pstrlen><pstr><reserved><info_hash><peer_id>
 * @param  {Buffer|string} infoHash (as Buffer or *hex* string)
 * @param  {Buffer|string} peerId
 * @param  {Object} extensions
 */
Wire.prototype.handshake = function (infoHash, peerId, extensions) {
  var infoHashBuffer, peerIdBuffer
  if (typeof infoHash === 'string') {
    infoHashBuffer = Buffer.from(infoHash, 'hex')
  } else {
    infoHashBuffer = infoHash
    infoHash = infoHashBuffer.toString('hex')
  }
  if (typeof peerId === 'string') {
    peerIdBuffer = Buffer.from(peerId, 'hex')
  } else {
    peerIdBuffer = peerId
    peerId = peerIdBuffer.toString('hex')
  }

  if (infoHashBuffer.length !== 20 || peerIdBuffer.length !== 20) {
    throw new Error('infoHash and peerId MUST have length 20')
  }

  this._debug('handshake i=%s p=%s exts=%o', infoHash, peerId, extensions)

  var reserved = Buffer.from(MESSAGE_RESERVED)

  // enable extended message
  reserved[5] |= 0x10

  if (extensions && extensions.dht) reserved[7] |= 1

  this._push(Buffer.concat([MESSAGE_PROTOCOL, reserved, infoHashBuffer, peerIdBuffer]))
  this._handshakeSent = true

  if (this.peerExtensions.extended && !this._extendedHandshakeSent) {
    // Peer's handshake indicated support already
    // (incoming connection)
    this._sendExtendedHandshake()
  }
}

/* Peer supports BEP-0010, send extended handshake.
 *
 * This comes after the 'handshake' event to give the user a chance to populate
 * `this.extendedHandshake` and `this.extendedMapping` before the extended handshake
 * is sent to the remote peer.
 */
Wire.prototype._sendExtendedHandshake = function () {
  // Create extended message object from registered extensions
  var msg = extend(this.extendedHandshake)
  msg.m = {}
  for (var ext in this.extendedMapping) {
    var name = this.extendedMapping[ext]
    msg.m[name] = Number(ext)
  }

  // Send extended handshake
  this.extended(0, bencode.encode(msg))
  this._extendedHandshakeSent = true
}

/**
 * Message "choke": <len=0001><id=0>
 */
Wire.prototype.choke = function () {
  if (this.amChoking) return
  this.amChoking = true
  this._debug('choke')
  this.peerRequests.splice(0, this.peerRequests.length)
  this._push(MESSAGE_CHOKE)
}

/**
 * Message "unchoke": <len=0001><id=1>
 */
Wire.prototype.unchoke = function () {
  if (!this.amChoking) return
  this.amChoking = false
  this._debug('unchoke')
  this._push(MESSAGE_UNCHOKE)
}

/**
 * Message "interested": <len=0001><id=2>
 */
Wire.prototype.interested = function () {
  if (this.amInterested) return
  this.amInterested = true
  this._debug('interested')
  this._push(MESSAGE_INTERESTED)
}

/**
 * Message "uninterested": <len=0001><id=3>
 */
Wire.prototype.uninterested = function () {
  if (!this.amInterested) return
  this.amInterested = false
  this._debug('uninterested')
  this._push(MESSAGE_UNINTERESTED)
}

/**
 * Message "have": <len=0005><id=4><piece index>
 * @param  {number} index
 */
Wire.prototype.have = function (index) {
  this._debug('have %d', index)
  this._message(4, [index], null)
}

/**
 * Message "bitfield": <len=0001+X><id=5><bitfield>
 * @param  {BitField|Buffer} bitfield
 */
Wire.prototype.bitfield = function (bitfield) {
  this._debug('bitfield')
  if (!Buffer.isBuffer(bitfield)) bitfield = bitfield.buffer
  this._message(5, [], bitfield)
}

/**
 * Message "request": <len=0013><id=6><index><begin><length>
 * @param  {number}   index
 * @param  {number}   offset
 * @param  {number}   length
 * @param  {function} cb
 */
Wire.prototype.request = function (index, offset, length, cb) {
  if (!cb) cb = function () {}
  if (this._finished) return cb(new Error('wire is closed'))
  if (this.peerChoking) return cb(new Error('peer is choking'))

  this._debug('request index=%d offset=%d length=%d', index, offset, length)

  this.requests.push(new Request(index, offset, length, cb))
  this._updateTimeout()
  this._message(6, [index, offset, length], null)
}

/**
 * Message "piece": <len=0009+X><id=7><index><begin><block>
 * @param  {number} index
 * @param  {number} offset
 * @param  {Buffer} buffer
 */
Wire.prototype.piece = function (index, offset, buffer) {
  this._debug('piece index=%d offset=%d', index, offset)
  this.uploaded += buffer.length
  this.uploadSpeed(buffer.length)
  this.emit('upload', buffer.length)
  this._message(7, [index, offset], buffer)
}

/**
 * Message "cancel": <len=0013><id=8><index><begin><length>
 * @param  {number} index
 * @param  {number} offset
 * @param  {number} length
 */
Wire.prototype.cancel = function (index, offset, length) {
  this._debug('cancel index=%d offset=%d length=%d', index, offset, length)
  this._callback(
    pull(this.requests, index, offset, length),
    new Error('request was cancelled'),
    null
  )
  this._message(8, [index, offset, length], null)
}

/**
 * Message: "port" <len=0003><id=9><listen-port>
 * @param {Number} port
 */
Wire.prototype.port = function (port) {
  this._debug('port %d', port)
  var message = Buffer.from(MESSAGE_PORT)
  message.writeUInt16BE(port, 5)
  this._push(message)
}

/**
 * Message: "extended" <len=0005+X><id=20><ext-number><payload>
 * @param  {number|string} ext
 * @param  {Object} obj
 */
Wire.prototype.extended = function (ext, obj) {
  this._debug('extended ext=%s', ext)
  if (typeof ext === 'string' && this.peerExtendedMapping[ext]) {
    ext = this.peerExtendedMapping[ext]
  }
  if (typeof ext === 'number') {
    var extId = Buffer.from([ext])
    var buf = Buffer.isBuffer(obj) ? obj : bencode.encode(obj)

    this._message(20, [], Buffer.concat([extId, buf]))
  } else {
    throw new Error('Unrecognized extension: ' + ext)
  }
}

/**
 * Duplex stream method. Called whenever the remote peer stream wants data. No-op
 * since we'll just push data whenever we get it.
 */
Wire.prototype._read = function () {}

/**
 * Send a message to the remote peer.
 */
Wire.prototype._message = function (id, numbers, data) {
  var dataLength = data ? data.length : 0
  var buffer = Buffer.allocUnsafe(5 + 4 * numbers.length)

  buffer.writeUInt32BE(buffer.length + dataLength - 4, 0)
  buffer[4] = id
  for (var i = 0; i < numbers.length; i++) {
    buffer.writeUInt32BE(numbers[i], 5 + 4 * i)
  }

  this._push(buffer)
  if (data) this._push(data)
}

Wire.prototype._push = function (data) {
  if (this._finished) return
  return this.push(data)
}

//
// INCOMING MESSAGES
//

Wire.prototype._onKeepAlive = function () {
  this._debug('got keep-alive')
  this.emit('keep-alive')
}

Wire.prototype._onHandshake = function (infoHashBuffer, peerIdBuffer, extensions) {
  var infoHash = infoHashBuffer.toString('hex')
  var peerId = peerIdBuffer.toString('hex')

  this._debug('got handshake i=%s p=%s exts=%o', infoHash, peerId, extensions)

  this.peerId = peerId
  this.peerIdBuffer = peerIdBuffer
  this.peerExtensions = extensions

  this.emit('handshake', infoHash, peerId, extensions)

  var name
  for (name in this._ext) {
    this._ext[name].onHandshake(infoHash, peerId, extensions)
  }

  if (extensions.extended && this._handshakeSent &&
      !this._extendedHandshakeSent) {
    // outgoing connection
    this._sendExtendedHandshake()
  }
}

Wire.prototype._onChoke = function () {
  this.peerChoking = true
  this._debug('got choke')
  this.emit('choke')
  while (this.requests.length) {
    this._callback(this.requests.shift(), new Error('peer is choking'), null)
  }
}

Wire.prototype._onUnchoke = function () {
  this.peerChoking = false
  this._debug('got unchoke')
  this.emit('unchoke')
}

Wire.prototype._onInterested = function () {
  this.peerInterested = true
  this._debug('got interested')
  this.emit('interested')
}

Wire.prototype._onUninterested = function () {
  this.peerInterested = false
  this._debug('got uninterested')
  this.emit('uninterested')
}

Wire.prototype._onHave = function (index) {
  if (this.peerPieces.get(index)) return
  this._debug('got have %d', index)

  this.peerPieces.set(index, true)
  this.emit('have', index)
}

Wire.prototype._onBitField = function (buffer) {
  this.peerPieces = new BitField(buffer)
  this._debug('got bitfield')
  this.emit('bitfield', this.peerPieces)
}

Wire.prototype._onRequest = function (index, offset, length) {
  var self = this
  if (self.amChoking) return
  self._debug('got request index=%d offset=%d length=%d', index, offset, length)

  var respond = function (err, buffer) {
    if (request !== pull(self.peerRequests, index, offset, length)) return
    if (err) return self._debug('error satisfying request index=%d offset=%d length=%d (%s)', index, offset, length, err.message)
    self.piece(index, offset, buffer)
  }

  var request = new Request(index, offset, length, respond)
  self.peerRequests.push(request)
  self.emit('request', index, offset, length, respond)
}

Wire.prototype._onPiece = function (index, offset, buffer) {
  this._debug('got piece index=%d offset=%d', index, offset)
  this._callback(pull(this.requests, index, offset, buffer.length), null, buffer)
  this.downloaded += buffer.length
  this.downloadSpeed(buffer.length)
  this.emit('download', buffer.length)
  this.emit('piece', index, offset, buffer)
}

Wire.prototype._onCancel = function (index, offset, length) {
  this._debug('got cancel index=%d offset=%d length=%d', index, offset, length)
  pull(this.peerRequests, index, offset, length)
  this.emit('cancel', index, offset, length)
}

Wire.prototype._onPort = function (port) {
  this._debug('got port %d', port)
  this.emit('port', port)
}

Wire.prototype._onExtended = function (ext, buf) {
  if (ext === 0) {
    var info
    try {
      info = bencode.decode(buf)
    } catch (err) {
      this._debug('ignoring invalid extended handshake: %s', err.message || err)
    }

    if (!info) return
    this.peerExtendedHandshake = info

    var name
    if (typeof info.m === 'object') {
      for (name in info.m) {
        this.peerExtendedMapping[name] = Number(info.m[name].toString())
      }
    }
    for (name in this._ext) {
      if (this.peerExtendedMapping[name]) {
        this._ext[name].onExtendedHandshake(this.peerExtendedHandshake)
      }
    }
    this._debug('got extended handshake')
    this.emit('extended', 'handshake', this.peerExtendedHandshake)
  } else {
    if (this.extendedMapping[ext]) {
      ext = this.extendedMapping[ext] // friendly name for extension
      if (this._ext[ext]) {
        // there is an registered extension handler, so call it
        this._ext[ext].onMessage(buf)
      }
    }
    this._debug('got extended message ext=%s', ext)
    this.emit('extended', ext, buf)
  }
}

Wire.prototype._onTimeout = function () {
  this._debug('request timed out')
  this._callback(this.requests.shift(), new Error('request has timed out'), null)
  this.emit('timeout')
}

/**
 * Duplex stream method. Called whenever the remote peer has data for us. Data that the
 * remote peer sends gets buffered (i.e. not actually processed) until the right number
 * of bytes have arrived, determined by the last call to `this._parse(number, callback)`.
 * Once enough bytes have arrived to process the message, the callback function
 * (i.e. `this._parser`) gets called with the full buffer of data.
 * @param  {Buffer} data
 * @param  {string} encoding
 * @param  {function} cb
 */
Wire.prototype._write = function (data, encoding, cb) {
  this._bufferSize += data.length
  this._buffer.push(data)

  while (this._bufferSize >= this._parserSize) {
    var buffer = (this._buffer.length === 1)
      ? this._buffer[0]
      : Buffer.concat(this._buffer)
    this._bufferSize -= this._parserSize
    this._buffer = this._bufferSize
      ? [buffer.slice(this._parserSize)]
      : []
    this._parser(buffer.slice(0, this._parserSize))
  }

  cb(null) // Signal that we're ready for more data
}

Wire.prototype._callback = function (request, err, buffer) {
  if (!request) return

  this._clearTimeout()

  if (!this.peerChoking && !this._finished) this._updateTimeout()
  request.callback(err, buffer)
}

Wire.prototype._clearTimeout = function () {
  if (!this._timeout) return

  clearTimeout(this._timeout)
  this._timeout = null
}

Wire.prototype._updateTimeout = function () {
  var self = this
  if (!self._timeoutMs || !self.requests.length || self._timeout) return

  self._timeout = setTimeout(function () {
    self._onTimeout()
  }, self._timeoutMs)
  if (self._timeoutUnref && self._timeout.unref) self._timeout.unref()
}

/**
 * Takes a number of bytes that the local peer is waiting to receive from the remote peer
 * in order to parse a complete message, and a callback function to be called once enough
 * bytes have arrived.
 * @param  {number} size
 * @param  {function} parser
 */
Wire.prototype._parse = function (size, parser) {
  this._parserSize = size
  this._parser = parser
}

/**
 * Handle the first 4 bytes of a message, to determine the length of bytes that must be
 * waited for in order to have the whole message.
 * @param  {Buffer} buffer
 */
Wire.prototype._onMessageLength = function (buffer) {
  var length = buffer.readUInt32BE(0)
  if (length > 0) {
    this._parse(length, this._onMessage)
  } else {
    this._onKeepAlive()
    this._parse(4, this._onMessageLength)
  }
}

/**
 * Handle a message from the remote peer.
 * @param  {Buffer} buffer
 */
Wire.prototype._onMessage = function (buffer) {
  this._parse(4, this._onMessageLength)
  switch (buffer[0]) {
    case 0:
      return this._onChoke()
    case 1:
      return this._onUnchoke()
    case 2:
      return this._onInterested()
    case 3:
      return this._onUninterested()
    case 4:
      return this._onHave(buffer.readUInt32BE(1))
    case 5:
      return this._onBitField(buffer.slice(1))
    case 6:
      return this._onRequest(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.readUInt32BE(9))
    case 7:
      return this._onPiece(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.slice(9))
    case 8:
      return this._onCancel(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.readUInt32BE(9))
    case 9:
      return this._onPort(buffer.readUInt16BE(1))
    case 20:
      return this._onExtended(buffer.readUInt8(1), buffer.slice(2))
    default:
      this._debug('got unknown message')
      return this.emit('unknownmessage', buffer)
  }
}

Wire.prototype._parseHandshake = function () {
  var self = this
  self._parse(1, function (buffer) {
    var pstrlen = buffer.readUInt8(0)
    self._parse(pstrlen + 48, function (handshake) {
      var protocol = handshake.slice(0, pstrlen)
      if (protocol.toString() !== 'BitTorrent protocol') {
        self._debug('Error: wire not speaking BitTorrent protocol (%s)', protocol.toString())
        self.end()
        return
      }
      handshake = handshake.slice(pstrlen)
      self._onHandshake(handshake.slice(8, 28), handshake.slice(28, 48), {
        dht: !!(handshake[7] & 0x01), // see bep_0005
        extended: !!(handshake[5] & 0x10) // see bep_0010
      })
      self._parse(4, self._onMessageLength)
    })
  })
}

Wire.prototype._onFinish = function () {
  this._finished = true

  this.push(null) // stream cannot be half open, so signal the end of it
  while (this.read()) {} // consume and discard the rest of the stream data

  clearInterval(this._keepAliveInterval)
  this._parse(Number.MAX_VALUE, function () {})
  this.peerRequests = []
  while (this.requests.length) {
    this._callback(this.requests.shift(), new Error('wire was closed'), null)
  }
}

Wire.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}

function pull (requests, piece, offset, length) {
  for (var i = 0; i < requests.length; i++) {
    var req = requests[i]
    if (req.piece !== piece || req.offset !== offset || req.length !== length) continue

    if (i === 0) requests.shift()
    else requests.splice(i, 1)

    return req
  }
  return null
}

},{"bencode":11,"bitfield":13,"debug":39,"hat":65,"inherits":70,"readable-stream":117,"safe-buffer":123,"speedometer":139,"xtend":181}],15:[function(require,module,exports){
(function (process){
module.exports = Client

var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('bittorrent-tracker')
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var inherits = require('inherits')
var once = require('once')
var parallel = require('run-parallel')
var Peer = require('simple-peer')
var uniq = require('uniq')
var url = require('url')

var common = require('./lib/common')
var HTTPTracker = require('./lib/client/http-tracker') // empty object in browser
var UDPTracker = require('./lib/client/udp-tracker') // empty object in browser
var WebSocketTracker = require('./lib/client/websocket-tracker')

inherits(Client, EventEmitter)

/**
 * BitTorrent tracker client.
 *
 * Find torrent peers, to help a torrent client participate in a torrent swarm.
 *
 * @param {Object} opts                          options object
 * @param {string|Buffer} opts.infoHash          torrent info hash
 * @param {string|Buffer} opts.peerId            peer id
 * @param {string|Array.<string>} opts.announce  announce
 * @param {number} opts.port                     torrent client listening port
 * @param {function} opts.getAnnounceOpts        callback to provide data to tracker
 * @param {number} opts.rtcConfig                RTCPeerConnection configuration object
 * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)
 */
function Client (opts) {
  var self = this
  if (!(self instanceof Client)) return new Client(opts)
  EventEmitter.call(self)
  if (!opts) opts = {}

  if (!opts.peerId) throw new Error('Option `peerId` is required')
  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!opts.announce) throw new Error('Option `announce` is required')
  if (!process.browser && !opts.port) throw new Error('Option `port` is required')

  // required
  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : opts.peerId.toString('hex')
  self._peerIdBuffer = Buffer.from(self.peerId, 'hex')
  self._peerIdBinary = self._peerIdBuffer.toString('binary')

  self.infoHash = typeof opts.infoHash === 'string'
    ? opts.infoHash
    : opts.infoHash.toString('hex')
  self._infoHashBuffer = Buffer.from(self.infoHash, 'hex')
  self._infoHashBinary = self._infoHashBuffer.toString('binary')

  self._port = opts.port

  self.destroyed = false

  self._rtcConfig = opts.rtcConfig
  self._wrtc = opts.wrtc
  self._getAnnounceOpts = opts.getAnnounceOpts

  debug('new client %s', self.infoHash)

  var webrtcSupport = self._wrtc !== false && (!!self._wrtc || Peer.WEBRTC_SUPPORT)

  var announce = (typeof opts.announce === 'string')
    ? [ opts.announce ]
    : opts.announce == null
      ? []
      : opts.announce

  announce = announce.map(function (announceUrl) {
    announceUrl = announceUrl.toString()
    if (announceUrl[announceUrl.length - 1] === '/') {
      // remove trailing slash from trackers to catch duplicates
      announceUrl = announceUrl.substring(0, announceUrl.length - 1)
    }
    return announceUrl
  })

  announce = uniq(announce)

  self._trackers = announce
    .map(function (announceUrl) {
      var protocol = url.parse(announceUrl).protocol
      if ((protocol === 'http:' || protocol === 'https:') &&
          typeof HTTPTracker === 'function') {
        return new HTTPTracker(self, announceUrl)
      } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {
        return new UDPTracker(self, announceUrl)
      } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {
        // Skip ws:// trackers on https:// sites because they throw SecurityError
        if (protocol === 'ws:' && typeof window !== 'undefined' &&
            window.location.protocol === 'https:') {
          nextTickWarn(new Error('Unsupported tracker protocol: ' + announceUrl))
          return null
        }
        return new WebSocketTracker(self, announceUrl)
      } else {
        nextTickWarn(new Error('Unsupported tracker protocol: ' + announceUrl))
        return null
      }
    })
    .filter(Boolean)

  function nextTickWarn (err) {
    process.nextTick(function () {
      self.emit('warning', err)
    })
  }
}

/**
 * Simple convenience function to scrape a tracker for an info hash without needing to
 * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple
 * torrents at the same time.
 * @params {Object} opts
 * @param  {string|Array.<string>} opts.infoHash
 * @param  {string} opts.announce
 * @param  {function} cb
 */
Client.scrape = function (opts, cb) {
  cb = once(cb)

  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!opts.announce) throw new Error('Option `announce` is required')

  var clientOpts = extend(opts, {
    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,
    peerId: Buffer.from('01234567890123456789'), // dummy value
    port: 6881 // dummy value
  })

  var client = new Client(clientOpts)
  client.once('error', cb)

  var len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1
  var results = {}
  client.on('scrape', function (data) {
    len -= 1
    results[data.infoHash] = data
    if (len === 0) {
      client.destroy()
      var keys = Object.keys(results)
      if (keys.length === 1) {
        cb(null, results[keys[0]])
      } else {
        cb(null, results)
      }
    }
  })

  opts.infoHash = Array.isArray(opts.infoHash)
    ? opts.infoHash.map(function (infoHash) {
      return Buffer.from(infoHash, 'hex')
    })
    : Buffer.from(opts.infoHash, 'hex')
  client.scrape({ infoHash: opts.infoHash })
  return client
}

/**
 * Send a `start` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.start = function (opts) {
  var self = this
  debug('send `start`')
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'started'
  self._announce(opts)

  // start announcing on intervals
  self._trackers.forEach(function (tracker) {
    tracker.setInterval()
  })
}

/**
 * Send a `stop` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.stop = function (opts) {
  var self = this
  debug('send `stop`')
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'stopped'
  self._announce(opts)
}

/**
 * Send a `complete` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.complete = function (opts) {
  var self = this
  debug('send `complete`')
  if (!opts) opts = {}
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'completed'
  self._announce(opts)
}

/**
 * Send a `update` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.update = function (opts) {
  var self = this
  debug('send `update`')
  opts = self._defaultAnnounceOpts(opts)
  if (opts.event) delete opts.event
  self._announce(opts)
}

Client.prototype._announce = function (opts) {
  var self = this
  self._trackers.forEach(function (tracker) {
    // tracker should not modify `opts` object, it's passed to all trackers
    tracker.announce(opts)
  })
}

/**
 * Send a scrape request to the trackers.
 * @param {Object} opts
 */
Client.prototype.scrape = function (opts) {
  var self = this
  debug('send `scrape`')
  if (!opts) opts = {}
  self._trackers.forEach(function (tracker) {
    // tracker should not modify `opts` object, it's passed to all trackers
    tracker.scrape(opts)
  })
}

Client.prototype.setInterval = function (intervalMs) {
  var self = this
  debug('setInterval %d', intervalMs)
  self._trackers.forEach(function (tracker) {
    tracker.setInterval(intervalMs)
  })
}

Client.prototype.destroy = function (cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  debug('destroy')

  var tasks = self._trackers.map(function (tracker) {
    return function (cb) {
      tracker.destroy(cb)
    }
  })

  parallel(tasks, cb)

  self._trackers = []
  self._getAnnounceOpts = null
}

Client.prototype._defaultAnnounceOpts = function (opts) {
  var self = this
  if (!opts) opts = {}

  if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS

  if (opts.uploaded == null) opts.uploaded = 0
  if (opts.downloaded == null) opts.downloaded = 0

  if (self._getAnnounceOpts) opts = extend(opts, self._getAnnounceOpts())
  return opts
}

}).call(this,require('_process'))

},{"./lib/client/http-tracker":22,"./lib/client/udp-tracker":22,"./lib/client/websocket-tracker":17,"./lib/common":18,"_process":104,"debug":39,"events":58,"inherits":70,"once":91,"run-parallel":121,"safe-buffer":123,"simple-peer":126,"uniq":156,"url":158,"xtend":181}],16:[function(require,module,exports){
module.exports = Tracker

var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')

inherits(Tracker, EventEmitter)

function Tracker (client, announceUrl) {
  var self = this
  EventEmitter.call(self)
  self.client = client
  self.announceUrl = announceUrl

  self.interval = null
  self.destroyed = false
}

Tracker.prototype.setInterval = function (intervalMs) {
  var self = this
  if (intervalMs == null) intervalMs = self.DEFAULT_ANNOUNCE_INTERVAL

  clearInterval(self.interval)

  if (intervalMs) {
    self.interval = setInterval(function () {
      self.announce(self.client._defaultAnnounceOpts())
    }, intervalMs)
    if (self.interval.unref) self.interval.unref()
  }
}

},{"events":58,"inherits":70}],17:[function(require,module,exports){
module.exports = WebSocketTracker

var debug = require('debug')('bittorrent-tracker:websocket-tracker')
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var Peer = require('simple-peer')
var Socket = require('simple-websocket')

var common = require('../common')
var Tracker = require('./tracker')

// Use a socket pool, so tracker clients share WebSocket objects for the same server.
// In practice, WebSockets are pretty slow to establish, so this gives a nice performance
// boost, and saves browser resources.
var socketPool = {}

var RECONNECT_MINIMUM = 15 * 1000
var RECONNECT_MAXIMUM = 30 * 60 * 1000
var RECONNECT_VARIANCE = 30 * 1000
var OFFER_TIMEOUT = 50 * 1000

inherits(WebSocketTracker, Tracker)

function WebSocketTracker (client, announceUrl, opts) {
  var self = this
  Tracker.call(self, client, announceUrl)
  debug('new websocket tracker %s', announceUrl)

  self.peers = {} // peers (offer id -> peer)
  self.socket = null

  self.reconnecting = false
  self.retries = 0
  self.reconnectTimer = null

  self._openSocket()
}

WebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1000 // 30 seconds

WebSocketTracker.prototype.announce = function (opts) {
  var self = this
  if (self.destroyed || self.reconnecting) return
  if (!self.socket.connected) {
    self.socket.once('connect', function () {
      self.announce(opts)
    })
    return
  }

  var params = extend(opts, {
    action: 'announce',
    info_hash: self.client._infoHashBinary,
    peer_id: self.client._peerIdBinary
  })
  if (self._trackerId) params.trackerid = self._trackerId

  if (opts.event === 'stopped') {
    // Don't include offers with 'stopped' event
    self._send(params)
  } else {
    // Limit the number of offers that are generated, since it can be slow
    var numwant = Math.min(opts.numwant, 5)

    self._generateOffers(numwant, function (offers) {
      params.numwant = numwant
      params.offers = offers
      self._send(params)
    })
  }
}

WebSocketTracker.prototype.scrape = function (opts) {
  var self = this
  if (self.destroyed || self.reconnecting) return
  if (!self.socket.connected) {
    self.socket.once('connect', function () {
      self.scrape(opts)
    })
    return
  }

  var infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)
    ? opts.infoHash.map(function (infoHash) {
      return infoHash.toString('binary')
    })
    : (opts.infoHash && opts.infoHash.toString('binary')) || self.client._infoHashBinary
  var params = {
    action: 'scrape',
    info_hash: infoHashes
  }

  self._send(params)
}

WebSocketTracker.prototype.destroy = function (cb) {
  var self = this
  if (!cb) cb = noop
  if (self.destroyed) return cb(null)

  self.destroyed = true

  clearInterval(self.interval)
  clearTimeout(self.reconnectTimer)

  if (self.socket) {
    self.socket.removeListener('connect', self._onSocketConnectBound)
    self.socket.removeListener('data', self._onSocketDataBound)
    self.socket.removeListener('close', self._onSocketCloseBound)
    self.socket.removeListener('error', self._onSocketErrorBound)
  }

  self._onSocketConnectBound = null
  self._onSocketErrorBound = null
  self._onSocketDataBound = null
  self._onSocketCloseBound = null

  // Destroy peers
  for (var peerId in self.peers) {
    var peer = self.peers[peerId]
    clearTimeout(peer.trackerTimeout)
    peer.destroy()
  }
  self.peers = null

  if (socketPool[self.announceUrl]) {
    socketPool[self.announceUrl].consumers -= 1
  }

  if (socketPool[self.announceUrl].consumers === 0) {
    delete socketPool[self.announceUrl]

    try {
      self.socket.on('error', noop) // ignore all future errors
      self.socket.destroy(cb)
    } catch (err) {
      cb(null)
    }
  } else {
    cb(null)
  }

  self.socket = null
}

WebSocketTracker.prototype._openSocket = function () {
  var self = this
  self.destroyed = false

  if (!self.peers) self.peers = {}

  self._onSocketConnectBound = function () {
    self._onSocketConnect()
  }
  self._onSocketErrorBound = function (err) {
    self._onSocketError(err)
  }
  self._onSocketDataBound = function (data) {
    self._onSocketData(data)
  }
  self._onSocketCloseBound = function () {
    self._onSocketClose()
  }

  self.socket = socketPool[self.announceUrl]
  if (self.socket) {
    socketPool[self.announceUrl].consumers += 1
  } else {
    self.socket = socketPool[self.announceUrl] = new Socket(self.announceUrl)
    self.socket.consumers = 1
    self.socket.on('connect', self._onSocketConnectBound)
  }

  self.socket.on('data', self._onSocketDataBound)
  self.socket.on('close', self._onSocketCloseBound)
  self.socket.on('error', self._onSocketErrorBound)
}

WebSocketTracker.prototype._onSocketConnect = function () {
  var self = this
  if (self.destroyed) return

  if (self.reconnecting) {
    self.reconnecting = false
    self.retries = 0
    self.announce(self.client._defaultAnnounceOpts())
  }
}

WebSocketTracker.prototype._onSocketData = function (data) {
  var self = this
  if (self.destroyed) return

  try {
    data = JSON.parse(data)
  } catch (err) {
    self.client.emit('warning', new Error('Invalid tracker response'))
    return
  }

  if (data.action === 'announce') {
    self._onAnnounceResponse(data)
  } else if (data.action === 'scrape') {
    self._onScrapeResponse(data)
  } else {
    self._onSocketError(new Error('invalid action in WS response: ' + data.action))
  }
}

WebSocketTracker.prototype._onAnnounceResponse = function (data) {
  var self = this

  if (data.info_hash !== self.client._infoHashBinary) {
    debug(
      'ignoring websocket data from %s for %s (looking for %s: reused socket)',
      self.announceUrl, common.binaryToHex(data.info_hash), self.client.infoHash
    )
    return
  }

  if (data.peer_id && data.peer_id === self.client._peerIdBinary) {
    // ignore offers/answers from this client
    return
  }

  debug(
    'received %s from %s for %s',
    JSON.stringify(data), self.announceUrl, self.client.infoHash
  )

  var failure = data['failure reason']
  if (failure) return self.client.emit('warning', new Error(failure))

  var warning = data['warning message']
  if (warning) self.client.emit('warning', new Error(warning))

  var interval = data.interval || data['min interval']
  if (interval) self.setInterval(interval * 1000)

  var trackerId = data['tracker id']
  if (trackerId) {
    // If absent, do not discard previous trackerId value
    self._trackerId = trackerId
  }

  if (data.complete != null) {
    self.client.emit('update', {
      announce: self.announceUrl,
      complete: data.complete,
      incomplete: data.incomplete
    })
  }

  var peer
  if (data.offer && data.peer_id) {
    debug('creating peer (from remote offer)')
    peer = new Peer({
      trickle: false,
      config: self.client._rtcConfig,
      wrtc: self.client._wrtc
    })
    peer.id = common.binaryToHex(data.peer_id)
    peer.once('signal', function (answer) {
      var params = {
        action: 'announce',
        info_hash: self.client._infoHashBinary,
        peer_id: self.client._peerIdBinary,
        to_peer_id: data.peer_id,
        answer: answer,
        offer_id: data.offer_id
      }
      if (self._trackerId) params.trackerid = self._trackerId
      self._send(params)
    })
    peer.signal(data.offer)
    self.client.emit('peer', peer)
  }

  if (data.answer && data.peer_id) {
    var offerId = common.binaryToHex(data.offer_id)
    peer = self.peers[offerId]
    if (peer) {
      peer.id = common.binaryToHex(data.peer_id)
      peer.signal(data.answer)
      self.client.emit('peer', peer)

      clearTimeout(peer.trackerTimeout)
      peer.trackerTimeout = null
      delete self.peers[offerId]
    } else {
      debug('got unexpected answer: ' + JSON.stringify(data.answer))
    }
  }
}

WebSocketTracker.prototype._onScrapeResponse = function (data) {
  var self = this
  data = data.files || {}

  var keys = Object.keys(data)
  if (keys.length === 0) {
    self.client.emit('warning', new Error('invalid scrape response'))
    return
  }

  keys.forEach(function (infoHash) {
    var response = data[infoHash]
    // TODO: optionally handle data.flags.min_request_interval
    // (separate from announce interval)
    self.client.emit('scrape', {
      announce: self.announceUrl,
      infoHash: common.binaryToHex(infoHash),
      complete: response.complete,
      incomplete: response.incomplete,
      downloaded: response.downloaded
    })
  })
}

WebSocketTracker.prototype._onSocketClose = function () {
  var self = this
  if (self.destroyed) return
  self.destroy()
  self._startReconnectTimer()
}

WebSocketTracker.prototype._onSocketError = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroy()
  // errors will often happen if a tracker is offline, so don't treat it as fatal
  self.client.emit('warning', err)
  self._startReconnectTimer()
}

WebSocketTracker.prototype._startReconnectTimer = function () {
  var self = this
  var ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, self.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)

  self.reconnecting = true
  clearTimeout(self.reconnectTimer)
  self.reconnectTimer = setTimeout(function () {
    self.retries++
    self._openSocket()
  }, ms)
  if (self.reconnectTimer.unref) self.reconnectTimer.unref()

  debug('reconnecting socket in %s ms', ms)
}

WebSocketTracker.prototype._send = function (params) {
  var self = this
  if (self.destroyed) return

  var message = JSON.stringify(params)
  debug('send %s', message)
  self.socket.send(message)
}

WebSocketTracker.prototype._generateOffers = function (numwant, cb) {
  var self = this
  var offers = []
  debug('generating %s offers', numwant)

  for (var i = 0; i < numwant; ++i) {
    generateOffer()
  }
  checkDone()

  function generateOffer () {
    var offerId = hat(160)
    debug('creating peer (from _generateOffers)')
    var peer = self.peers[offerId] = new Peer({
      initiator: true,
      trickle: false,
      config: self.client._rtcConfig,
      wrtc: self.client._wrtc
    })
    peer.once('signal', function (offer) {
      offers.push({
        offer: offer,
        offer_id: common.hexToBinary(offerId)
      })
      checkDone()
    })
    peer.trackerTimeout = setTimeout(function () {
      debug('tracker timeout: destroying peer')
      peer.trackerTimeout = null
      delete self.peers[offerId]
      peer.destroy()
    }, OFFER_TIMEOUT)
    if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()
  }

  function checkDone () {
    if (offers.length === numwant) {
      debug('generated %s offers', numwant)
      cb(offers)
    }
  }
}

function noop () {}

},{"../common":18,"./tracker":16,"debug":39,"hat":65,"inherits":70,"simple-peer":126,"simple-websocket":128,"xtend":181}],18:[function(require,module,exports){
/**
 * Functions/constants needed by both the client and server.
 */

var Buffer = require('safe-buffer').Buffer
var extend = require('xtend/mutable')

exports.DEFAULT_ANNOUNCE_PEERS = 50
exports.MAX_ANNOUNCE_PEERS = 82

exports.binaryToHex = function (str) {
  if (typeof str !== 'string') {
    str = String(str)
  }
  return Buffer.from(str, 'binary').toString('hex')
}

exports.hexToBinary = function (str) {
  if (typeof str !== 'string') {
    str = String(str)
  }
  return Buffer.from(str, 'hex').toString('binary')
}

var config = require('./common-node')
extend(exports, config)

},{"./common-node":22,"safe-buffer":123,"xtend/mutable":182}],19:[function(require,module,exports){
(function (Buffer){
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  var reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, new Buffer(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this,require("buffer").Buffer)

},{"buffer":25}],20:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],21:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits');
var Transform = require('readable-stream').Transform;
var defined = require('defined');

module.exports = Block;
inherits(Block, Transform);

function Block (size, opts) {
    if (!(this instanceof Block)) return new Block(size, opts);
    Transform.call(this);
    if (!opts) opts = {};
    if (typeof size === 'object') {
        opts = size;
        size = opts.size;
    }
    this.size = size || 512;
    
    if (opts.nopad) this._zeroPadding = false;
    else this._zeroPadding = defined(opts.zeroPadding, true);
    
    this._buffered = [];
    this._bufferedBytes = 0;
}

Block.prototype._transform = function (buf, enc, next) {
    this._bufferedBytes += buf.length;
    this._buffered.push(buf);
    
    while (this._bufferedBytes >= this.size) {
        var b = Buffer.concat(this._buffered);
        this._bufferedBytes -= this.size;
        this.push(b.slice(0, this.size));
        this._buffered = [ b.slice(this.size, b.length) ];
    }
    next();
};

Block.prototype._flush = function () {
    if (this._bufferedBytes && this._zeroPadding) {
        var zeroes = new Buffer(this.size - this._bufferedBytes);
        zeroes.fill(0);
        this._buffered.push(zeroes);
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
    }
    else if (this._bufferedBytes) {
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
    }
    this.push(null);
};

}).call(this,require("buffer").Buffer)

},{"buffer":25,"defined":41,"inherits":70,"readable-stream":117}],22:[function(require,module,exports){

},{}],23:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],24:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":25}],25:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; i++) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  that.write(string, encoding)
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

function arrayIndexOf (arr, val, byteOffset, encoding) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var foundIndex = -1
  for (var i = 0; byteOffset + i < arrLength; i++) {
    if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
      if (foundIndex === -1) foundIndex = i
      if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize
    } else {
      if (foundIndex !== -1) i -= i - foundIndex
      foundIndex = -1
    }
  }
  return -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  if (Buffer.isBuffer(val)) {
    // special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(this, val, byteOffset, encoding)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset, encoding)
  }

  throw new TypeError('val must be string, number or Buffer')
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; i++) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; i++) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":8,"ieee754":67,"isarray":76}],26:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],27:[function(require,module,exports){
module.exports = ChunkStoreWriteStream

var BlockStream = require('block-stream2')
var inherits = require('inherits')
var stream = require('readable-stream')

inherits(ChunkStoreWriteStream, stream.Writable)

function ChunkStoreWriteStream (store, chunkLength, opts) {
  var self = this
  if (!(self instanceof ChunkStoreWriteStream)) {
    return new ChunkStoreWriteStream(store, chunkLength, opts)
  }
  stream.Writable.call(self, opts)
  if (!opts) opts = {}

  if (!store || !store.put || !store.get) {
    throw new Error('First argument must be an abstract-chunk-store compliant store')
  }
  chunkLength = Number(chunkLength)
  if (!chunkLength) throw new Error('Second argument must be a chunk length')

  self._blockstream = new BlockStream(chunkLength, { zeroPadding: false })

  self._blockstream
    .on('data', onData)
    .on('error', function (err) { self.destroy(err) })

  var index = 0
  function onData (chunk) {
    if (self.destroyed) return
    store.put(index, chunk)
    index += 1
  }

  self.on('finish', function () { this._blockstream.end() })
}

ChunkStoreWriteStream.prototype._write = function (chunk, encoding, callback) {
  this._blockstream.write(chunk, encoding, callback)
}

ChunkStoreWriteStream.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
}

},{"block-stream2":21,"inherits":70,"readable-stream":117}],28:[function(require,module,exports){
module.exports = function(target, numbers) {
  var closest = Infinity
  var difference = 0
  var winner = null

  numbers.sort(function(a, b) {
    return a - b
  })

  for (var i = 0, l = numbers.length; i < l; i++) {  
    difference = Math.abs(target - numbers[i])
    if (difference >= closest) {
      break
    }
    closest = difference
    winner = numbers[i]
  }

  return winner
}

},{}],29:[function(require,module,exports){
var ipaddr = require('ipaddr.js');

module.exports = compact2string = function (buf) {
  switch(buf.length) {
  case 6:
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3] + ":" + buf.readUInt16BE(4);
    break;
  case 18:
    var hexGroups = [];
    for(var i = 0; i < 8; i++) {
      hexGroups.push(buf.readUInt16BE(i * 2).toString(16));
    }
    var host = ipaddr.parse(hexGroups.join(":")).toString();
    return "[" + host + "]:" + buf.readUInt16BE(16);
  default:
    throw new Error("Invalid Compact IP/PORT, It should contain 6 or 18 bytes");
  }
};

compact2string.multi = function (buf) {
  if(buf.length % 6 !== 0)
    throw new Error("buf length isn't multiple of compact IP/PORTs (6 bytes)");

  var output = [];
  for (var i = 0; i <= buf.length - 1; i = i + 6) {
    output.push(compact2string(buf.slice(i, i + 6)));
  }

  return output;
};

compact2string.multi6 = function (buf) {
  if(buf.length % 18 !== 0)
    throw new Error("buf length isn't multiple of compact IP6/PORTs (18 bytes)");

  var output = [];
  for (var i = 0; i <= buf.length - 1; i = i + 18) {
    output.push(compact2string(buf.slice(i, i + 18)));
  }

  return output;
};

},{"ipaddr.js":71}],30:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],31:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],32:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],33:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":73}],34:[function(require,module,exports){
(function (process,global,Buffer){
module.exports = createTorrent
module.exports.parseInput = parseInput

module.exports.announceList = [
  [ 'udp://tracker.openbittorrent.com:80' ],
  [ 'udp://tracker.internetwarriors.net:1337' ],
  [ 'udp://tracker.leechers-paradise.org:6969' ],
  [ 'udp://tracker.coppersurfer.tk:6969' ],
  [ 'udp://exodus.desync.com:6969' ],
  [ 'wss://tracker.webtorrent.io' ],
  [ 'wss://tracker.btorrent.xyz' ],
  [ 'wss://tracker.openwebtorrent.com' ],
  [ 'wss://tracker.fastcast.nz' ]
]

var bencode = require('bencode')
var BlockStream = require('block-stream2')
var calcPieceLength = require('piece-length')
var corePath = require('path')
var extend = require('xtend')
var FileReadStream = require('filestream/read')
var flatten = require('flatten')
var fs = require('fs')
var isFile = require('is-file')
var junk = require('junk')
var MultiStream = require('multistream')
var once = require('once')
var parallel = require('run-parallel')
var sha1 = require('simple-sha1')
var stream = require('readable-stream')

/**
 * Create a torrent.
 * @param  {string|File|FileList|Buffer|Stream|Array.<string|File|Buffer|Stream>} input
 * @param  {Object} opts
 * @param  {string=} opts.name
 * @param  {Date=} opts.creationDate
 * @param  {string=} opts.comment
 * @param  {string=} opts.createdBy
 * @param  {boolean|number=} opts.private
 * @param  {number=} opts.pieceLength
 * @param  {Array.<Array.<string>>=} opts.announceList
 * @param  {Array.<string>=} opts.urlList
 * @param  {function} cb
 * @return {Buffer} buffer of .torrent file data
 */
function createTorrent (input, opts, cb) {
  if (typeof opts === 'function') return createTorrent(input, null, opts)
  opts = opts ? extend(opts) : {}

  _parseInput(input, opts, function (err, files, singleFileTorrent) {
    if (err) return cb(err)
    opts.singleFileTorrent = singleFileTorrent
    onFiles(files, opts, cb)
  })
}

function parseInput (input, opts, cb) {
  if (typeof opts === 'function') return parseInput(input, null, opts)
  opts = opts ? extend(opts) : {}
  _parseInput(input, opts, cb)
}

/**
 * Parse input file and return file information.
 */
function _parseInput (input, opts, cb) {
  if (Array.isArray(input) && input.length === 0) throw new Error('invalid input type')

  if (isFileList(input)) input = Array.prototype.slice.call(input)
  if (!Array.isArray(input)) input = [ input ]

  // In Electron, use the true file path
  input = input.map(function (item) {
    if (isBlob(item) && typeof item.path === 'string') return item.path
    return item
  })

  // If there's just one file, allow the name to be set by `opts.name`
  if (input.length === 1 && typeof input[0] !== 'string' && !input[0].name) input[0].name = opts.name

  var commonPrefix = null
  input.forEach(function (item, i) {
    if (typeof item === 'string') {
      return
    }

    var path = item.fullPath || item.name
    if (!path) {
      path = 'Unknown File ' + (i + 1)
      item.unknownName = true
    }

    item.path = path.split('/')

    // Remove initial slash
    if (!item.path[0]) {
      item.path.shift()
    }

    if (item.path.length < 2) { // No real prefix
      commonPrefix = null
    } else if (i === 0 && input.length > 1) { // The first file has a prefix
      commonPrefix = item.path[0]
    } else if (item.path[0] !== commonPrefix) { // The prefix doesn't match
      commonPrefix = null
    }
  })

  // remove junk files
  input = input.filter(function (item) {
    if (typeof item === 'string') {
      return true
    }
    var filename = item.path[item.path.length - 1]
    return notHidden(filename) && junk.not(filename)
  })

  if (commonPrefix) {
    input.forEach(function (item) {
      var pathless = (Buffer.isBuffer(item) || isReadable(item)) && !item.path
      if (typeof item === 'string' || pathless) return
      item.path.shift()
    })
  }

  if (!opts.name && commonPrefix) {
    opts.name = commonPrefix
  }

  if (!opts.name) {
    // use first user-set file name
    input.some(function (item) {
      if (typeof item === 'string') {
        opts.name = corePath.basename(item)
        return true
      } else if (!item.unknownName) {
        opts.name = item.path[item.path.length - 1]
        return true
      }
    })
  }

  if (!opts.name) {
    opts.name = 'Unnamed Torrent ' + Date.now()
  }

  var numPaths = input.reduce(function (sum, item) {
    return sum + Number(typeof item === 'string')
  }, 0)

  var isSingleFileTorrent = (input.length === 1)

  if (input.length === 1 && typeof input[0] === 'string') {
    if (typeof fs.stat !== 'function') {
      throw new Error('filesystem paths do not work in the browser')
    }
    // If there's a single path, verify it's a file before deciding this is a single
    // file torrent
    isFile(input[0], function (err, pathIsFile) {
      if (err) return cb(err)
      isSingleFileTorrent = pathIsFile
      processInput()
    })
  } else {
    process.nextTick(function () {
      processInput()
    })
  }

  function processInput () {
    parallel(input.map(function (item) {
      return function (cb) {
        var file = {}

        if (isBlob(item)) {
          file.getStream = getBlobStream(item)
          file.length = item.size
        } else if (Buffer.isBuffer(item)) {
          file.getStream = getBufferStream(item)
          file.length = item.length
        } else if (isReadable(item)) {
          file.getStream = getStreamStream(item, file)
          file.length = 0
        } else if (typeof item === 'string') {
          if (typeof fs.stat !== 'function') {
            throw new Error('filesystem paths do not work in the browser')
          }
          var keepRoot = numPaths > 1 || isSingleFileTorrent
          getFiles(item, keepRoot, cb)
          return // early return!
        } else {
          throw new Error('invalid input type')
        }
        file.path = item.path
        cb(null, file)
      }
    }), function (err, files) {
      if (err) return cb(err)
      files = flatten(files)
      cb(null, files, isSingleFileTorrent)
    })
  }
}

function getFiles (path, keepRoot, cb) {
  traversePath(path, getFileInfo, function (err, files) {
    if (err) return cb(err)

    if (Array.isArray(files)) files = flatten(files)
    else files = [ files ]

    path = corePath.normalize(path)
    if (keepRoot) {
      path = path.slice(0, path.lastIndexOf(corePath.sep) + 1)
    }
    if (path[path.length - 1] !== corePath.sep) path += corePath.sep

    files.forEach(function (file) {
      file.getStream = getFilePathStream(file.path)
      file.path = file.path.replace(path, '').split(corePath.sep)
    })
    cb(null, files)
  })
}

function getFileInfo (path, cb) {
  cb = once(cb)
  fs.stat(path, function (err, stat) {
    if (err) return cb(err)
    var info = {
      length: stat.size,
      path: path
    }
    cb(null, info)
  })
}

function traversePath (path, fn, cb) {
  fs.readdir(path, function (err, entries) {
    if (err && err.code === 'ENOTDIR') {
      // this is a file
      fn(path, cb)
    } else if (err) {
      // real error
      cb(err)
    } else {
      // this is a folder
      parallel(entries.filter(notHidden).filter(junk.not).map(function (entry) {
        return function (cb) {
          traversePath(corePath.join(path, entry), fn, cb)
        }
      }), cb)
    }
  })
}

function notHidden (file) {
  return file[0] !== '.'
}

function getPieceList (files, pieceLength, cb) {
  cb = once(cb)
  var pieces = []
  var length = 0

  var streams = files.map(function (file) {
    return file.getStream
  })

  var remainingHashes = 0
  var pieceNum = 0
  var ended = false

  var multistream = new MultiStream(streams)
  var blockstream = new BlockStream(pieceLength, { zeroPadding: false })

  multistream.on('error', onError)

  multistream
    .pipe(blockstream)
    .on('data', onData)
    .on('end', onEnd)
    .on('error', onError)

  function onData (chunk) {
    length += chunk.length

    var i = pieceNum
    sha1(chunk, function (hash) {
      pieces[i] = hash
      remainingHashes -= 1
      maybeDone()
    })
    remainingHashes += 1
    pieceNum += 1
  }

  function onEnd () {
    ended = true
    maybeDone()
  }

  function onError (err) {
    cleanup()
    cb(err)
  }

  function cleanup () {
    multistream.removeListener('error', onError)
    blockstream.removeListener('data', onData)
    blockstream.removeListener('end', onEnd)
    blockstream.removeListener('error', onError)
  }

  function maybeDone () {
    if (ended && remainingHashes === 0) {
      cleanup()
      cb(null, new Buffer(pieces.join(''), 'hex'), length)
    }
  }
}

function onFiles (files, opts, cb) {
  var announceList = opts.announceList

  if (!announceList) {
    if (typeof opts.announce === 'string') announceList = [ [ opts.announce ] ]
    else if (Array.isArray(opts.announce)) {
      announceList = opts.announce.map(function (u) { return [ u ] })
    }
  }

  if (!announceList) announceList = []

  if (global.WEBTORRENT_ANNOUNCE) {
    if (typeof global.WEBTORRENT_ANNOUNCE === 'string') {
      announceList.push([ [ global.WEBTORRENT_ANNOUNCE ] ])
    } else if (Array.isArray(global.WEBTORRENT_ANNOUNCE)) {
      announceList = announceList.concat(global.WEBTORRENT_ANNOUNCE.map(function (u) {
        return [ u ]
      }))
    }
  }

  // When no trackers specified, use some reasonable defaults
  if (opts.announce === undefined && opts.announceList === undefined) {
    announceList = announceList.concat(module.exports.announceList)
  }

  if (typeof opts.urlList === 'string') opts.urlList = [ opts.urlList ]

  var torrent = {
    info: {
      name: opts.name
    },
    'creation date': Math.ceil((Number(opts.creationDate) || Date.now()) / 1000),
    encoding: 'UTF-8'
  }

  if (announceList.length !== 0) {
    torrent.announce = announceList[0][0]
    torrent['announce-list'] = announceList
  }

  if (opts.comment !== undefined) torrent.comment = opts.comment

  if (opts.createdBy !== undefined) torrent['created by'] = opts.createdBy

  if (opts.private !== undefined) torrent.info.private = Number(opts.private)

  // "ssl-cert" key is for SSL torrents, see:
  //   - http://blog.libtorrent.org/2012/01/bittorrent-over-ssl/
  //   - http://www.libtorrent.org/manual-ref.html#ssl-torrents
  //   - http://www.libtorrent.org/reference-Create_Torrents.html
  if (opts.sslCert !== undefined) torrent.info['ssl-cert'] = opts.sslCert

  if (opts.urlList !== undefined) torrent['url-list'] = opts.urlList

  var pieceLength = opts.pieceLength || calcPieceLength(files.reduce(sumLength, 0))
  torrent.info['piece length'] = pieceLength

  getPieceList(files, pieceLength, function (err, pieces, torrentLength) {
    if (err) return cb(err)
    torrent.info.pieces = pieces

    files.forEach(function (file) {
      delete file.getStream
    })

    if (opts.singleFileTorrent) {
      torrent.info.length = torrentLength
    } else {
      torrent.info.files = files
    }

    cb(null, bencode.encode(torrent))
  })
}

/**
 * Accumulator to sum file lengths
 * @param  {number} sum
 * @param  {Object} file
 * @return {number}
 */
function sumLength (sum, file) {
  return sum + file.length
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

/**
 * Check if `obj` is a W3C `FileList` object
 * @param  {*} obj
 * @return {boolean}
 */
function isFileList (obj) {
  return typeof FileList === 'function' && obj instanceof FileList
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'
}

/**
 * Convert a `File` to a lazy readable stream.
 * @param  {File|Blob} file
 * @return {function}
 */
function getBlobStream (file) {
  return function () {
    return new FileReadStream(file)
  }
}

/**
 * Convert a `Buffer` to a lazy readable stream.
 * @param  {Buffer} buffer
 * @return {function}
 */
function getBufferStream (buffer) {
  return function () {
    var s = new stream.PassThrough()
    s.end(buffer)
    return s
  }
}

/**
 * Convert a file path to a lazy readable stream.
 * @param  {string} path
 * @return {function}
 */
function getFilePathStream (path) {
  return function () {
    return fs.createReadStream(path)
  }
}

/**
 * Convert a readable stream to a lazy readable stream. Adds instrumentation to track
 * the number of bytes in the stream and set `file.length`.
 *
 * @param  {Stream} stream
 * @param  {Object} file
 * @return {function}
 */
function getStreamStream (readable, file) {
  return function () {
    var counter = new stream.Transform()
    counter._transform = function (buf, enc, done) {
      file.length += buf.length
      this.push(buf)
      done()
    }
    readable.pipe(counter)
    return counter
  }
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":104,"bencode":35,"block-stream2":21,"buffer":25,"filestream/read":59,"flatten":60,"fs":23,"is-file":74,"junk":78,"multistream":89,"once":91,"path":101,"piece-length":102,"readable-stream":117,"run-parallel":121,"simple-sha1":127,"xtend":181}],35:[function(require,module,exports){
var bencode = module.exports

bencode.encode = require( './lib/encode' )
bencode.decode = require( './lib/decode' )

/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */
bencode.byteLength = bencode.encodingLength = function( value ) {
  return bencode.encode( value ).length
}

},{"./lib/decode":36,"./lib/encode":38}],36:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":37,"buffer":25}],37:[function(require,module,exports){
var Dict = module.exports = function Dict() {
  Object.defineProperty(this, "_keys", {
    enumerable: false,
    value: [],
  })
}

Dict.prototype.binaryKeys = function binaryKeys() {
  return this._keys.slice()
}

Dict.prototype.binarySet = function binarySet(key, value) {
  this._keys.push(key)

  this[key] = value
}

},{}],38:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":25}],39:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":40}],40:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":88}],41:[function(require,module,exports){
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],42:[function(require,module,exports){
var once = require('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback();
	};

	var onend = function() {
		readable = false;
		if (!writable) callback();
	};

	var onexit = function(exitCode) {
		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', callback);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', callback);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;
},{"once":91}],43:[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":44}],44:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":45,"engine.io-parser":54}],45:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

  // other options for Node.js client
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
  }

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function(){
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if('function' == typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' == typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./transport":46,"./transports":47,"component-emitter":53,"debug":39,"engine.io-parser":54,"indexof":69,"parsejson":98,"parseqs":99,"parseuri":100}],46:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":53,"engine.io-parser":54}],47:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling-jsonp":48,"./polling-xhr":49,"./websocket":51,"xmlhttprequest-ssl":52}],48:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  }
  else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":50,"component-inherit":32}],49:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":50,"component-emitter":53,"component-inherit":32,"debug":39,"xmlhttprequest-ssl":52}],50:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":46,"component-inherit":32,"debug":39,"engine.io-parser":54,"parseqs":99,"xmlhttprequest-ssl":52,"yeast":188}],51:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  try {
    WebSocket = require('ws');
  } catch (e) { }
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'buffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function(packet) {
      parser.encodePacket(packet, self.supportsBinary, function(data) {
        if (!BrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        //Sometimes the websocket has already been closed but the browser didn't
        //have a chance of informing us about it yet, in that case send will
        //throw an error
        try {
          if (BrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e){
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done(){
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function(){
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../transport":46,"component-inherit":32,"debug":39,"engine.io-parser":54,"parseqs":99,"ws":22,"yeast":188}],52:[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":64}],53:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],54:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./keys":55,"after":4,"arraybuffer.slice":5,"base64-arraybuffer":7,"blob":20,"has-binary":56,"utf8":166}],55:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],56:[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":57}],57:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],58:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],59:[function(require,module,exports){
var Readable = require('readable-stream').Readable;
var inherits = require('inherits');
var reExtension = /^.*\.(\w+)$/;
var toBuffer = require('typedarray-to-buffer');

function FileReadStream(file, opts) {
  var readStream = this;
  if (! (this instanceof FileReadStream)) {
    return new FileReadStream(file, opts);
  }
  opts = opts || {};

  // inherit readable
  Readable.call(this, opts);

  // save the read offset
  this._offset = 0;
  this._ready = false;
  this._file = file;
  this._size = file.size;
  this._chunkSize = opts.chunkSize || Math.max(this._size / 1000, 200 * 1024);

  // create the reader
  this.reader = new FileReader();

  // generate the header blocks that we will send as part of the initial payload
  this._generateHeaderBlocks(file, opts, function(err, blocks) {
    // if we encountered an error, emit it
    if (err) {
      return readStream.emit('error', err);
    }

    // push the header blocks out to the stream
    if (Array.isArray(blocks)) {
      blocks.forEach(function (block) {
        readStream.push(block);
      });
    }

    readStream._ready = true;
    readStream.emit('_ready');
  });
}

inherits(FileReadStream, Readable);
module.exports = FileReadStream;

FileReadStream.prototype._generateHeaderBlocks = function(file, opts, callback) {
  callback(null, []);
};

FileReadStream.prototype._read = function() {
  if (!this._ready) {
    this.once('_ready', this._read.bind(this));
    return;
  }
  var readStream = this;
  var reader = this.reader;

  var startOffset = this._offset;
  var endOffset = this._offset + this._chunkSize;
  if (endOffset > this._size) endOffset = this._size;

  if (startOffset === this._size) {
    this.destroy();
    this.push(null);
    return;
  }

  reader.onload = function() {
    // update the stream offset
    readStream._offset = endOffset;

    // get the data chunk
    readStream.push(toBuffer(reader.result));
  }
  reader.onerror = function() {
    readStream.emit('error', reader.error);
  }

  reader.readAsArrayBuffer(this._file.slice(startOffset, endOffset));
};

FileReadStream.prototype.destroy = function() {
  this._file = null;
  if (this.reader) {
    this.reader.onload = null;
    this.reader.onerror = null;
    try { this.reader.abort(); } catch (e) {};
  }
  this.reader = null;
}

},{"inherits":70,"readable-stream":117,"typedarray-to-buffer":154}],60:[function(require,module,exports){
module.exports = function flatten(list, depth) {
  depth = (typeof depth == 'number') ? depth : Infinity;

  if (!depth) {
    if (Array.isArray(list)) {
      return list.map(function(i) { return i; });
    }
    return list;
  }

  return _flatten(list, 1);

  function _flatten(list, d) {
    return list.reduce(function (acc, item) {
      if (Array.isArray(item) && d < depth) {
        return acc.concat(_flatten(item, d + 1));
      }
      else {
        return acc.concat(item);
      }
    }, []);
  }
};

},{}],61:[function(require,module,exports){
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof window === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection ||
      window.webkitRTCPeerConnection,
    RTCSessionDescription: window.RTCSessionDescription ||
      window.mozRTCSessionDescription || window.webkitRTCSessionDescription,
    RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate ||
      window.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],62:[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":63}],63:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"dup":57}],64:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],65:[function(require,module,exports){
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};

},{}],66:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":140}],67:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],68:[function(require,module,exports){
(function (process){
module.exports = ImmediateStore

function ImmediateStore (store) {
  if (!(this instanceof ImmediateStore)) return new ImmediateStore(store)

  this.store = store
  this.chunkLength = store.chunkLength

  if (!this.store || !this.store.get || !this.store.put) {
    throw new Error('First argument must be abstract-chunk-store compliant')
  }

  this.mem = []
}

ImmediateStore.prototype.put = function (index, buf, cb) {
  var self = this
  self.mem[index] = buf
  self.store.put(index, buf, function (err) {
    self.mem[index] = null
    if (cb) cb(err)
  })
}

ImmediateStore.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)

  var start = (opts && opts.offset) || 0
  var end = opts && opts.length && (start + opts.length)

  var buf = this.mem[index]
  if (buf) return nextTick(cb, null, opts ? buf.slice(start, end) : buf)

  this.store.get(index, opts, cb)
}

ImmediateStore.prototype.close = function (cb) {
  this.store.close(cb)
}

ImmediateStore.prototype.destroy = function (cb) {
  this.store.destroy(cb)
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    if (cb) cb(err, val)
  })
}

}).call(this,require('_process'))

},{"_process":104}],69:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],70:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],71:[function(require,module,exports){
(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

  ipaddr = {};

  root = this;

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var rangeName, rangeSubnets, subnet, _i, _len;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
        subnet = rangeSubnets[_i];
        if (address.match.apply(address, subnet)) {
          return rangeName;
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var octet, _i, _len;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (_i = 0, _len = octets.length; _i < _len; _i++) {
        octet = octets[_i];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var _ref;
      if (cidrRange === void 0) {
        _ref = other, other = _ref[0], cidrRange = _ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, octet, stop, zeros, zerotable, _i;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = _i = 3; _i >= 0; i = _i += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var _i, _len, _ref, _results;
        _ref = match.slice(1, 6);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(parseIntAuto(part));
        }
        return _results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var _i, _results;
        _results = [];
        for (shift = _i = 0; _i <= 24; shift = _i += 8) {
          _results.push((value >> shift) & 0xff);
        }
        return _results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts) {
      var i, part, _i, _j, _len, _ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = _i = 0; _i <= 14; i = _i += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      _ref = this.parts;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        part = _ref[_j];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      var compactStringParts, part, pushPart, state, stringParts, _i, _len;
      stringParts = (function() {
        var _i, _len, _ref, _results;
        _ref = this.parts;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(16));
        }
        return _results;
      }).call(this);
      compactStringParts = [];
      pushPart = function(part) {
        return compactStringParts.push(part);
      };
      state = 0;
      for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
        part = stringParts[_i];
        switch (state) {
          case 0:
            if (part === '0') {
              pushPart('');
            } else {
              pushPart(part);
            }
            state = 1;
            break;
          case 1:
            if (part === '0') {
              state = 2;
            } else {
              pushPart(part);
            }
            break;
          case 2:
            if (part !== '0') {
              pushPart('');
              pushPart(part);
              state = 3;
            }
            break;
          case 3:
            pushPart(part);
        }
      }
      if (state === 2) {
        pushPart('');
        pushPart('');
      }
      return compactStringParts.join(":");
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, part, _i, _len, _ref;
      bytes = [];
      _ref = this.parts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var part;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.parts;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(16));
        }
        return _results;
      }).call(this)).join(":");
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var _ref;
      if (cidrRange === void 0) {
        _ref = other, other = _ref[0], cidrRange = _ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, _ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  ipv6Regexes = {
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    return (function() {
      var _i, _len, _ref, _results;
      _ref = string.split(":");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        _results.push(parseInt(part, 16));
      }
      return _results;
    })();
  };

  ipaddr.IPv6.parser = function(string) {
    var match, octet, octets, parts, _i, _len;
    if (string.match(ipv6Regexes['native'])) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      parts = expandIPv6(match[1].slice(0, -1), 6);
      if (parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (_i = 0, _len = octets.length; _i < _len; _i++) {
          octet = octets[_i];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        parts.push(octets[0] << 8 | octets[1]);
        parts.push(octets[2] << 8 | octets[3]);
        return parts;
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      new this(this.parser(string));
      return true;
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (_error) {
      e = _error;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (_error) {
        e = _error;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);

},{}],72:[function(require,module,exports){
/* (c) 2016 Ari Porad (@ariporad) <http://ariporad.com>. License: ariporad.mit-license.org */

// Partially from http://stackoverflow.com/a/94049/1928484, and from another SO answer, which told me that the highest
// char code that's ascii is 127, but I can't find the link for. Sorry.

var MAX_ASCII_CHAR_CODE = 127;

module.exports = function isAscii(str) {
  for (var i = 0, strLen = str.length; i < strLen; ++i) {
    if (str.charCodeAt(i) > MAX_ASCII_CHAR_CODE) return false;
  }
  return true;
};

},{}],73:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],74:[function(require,module,exports){
'use strict';

var fs = require('fs');

module.exports = function isFile(path, cb){
  if(!cb)return isFileSync(path);

  fs.stat(path, function(err, stats){
    if(err)return cb(err);
    return cb(null, stats.isFile());
  });
};

module.exports.sync = isFileSync;

function isFileSync(path){
  return fs.existsSync(path) && fs.statSync(path).isFile();
}

},{"fs":23}],75:[function(require,module,exports){
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

},{}],76:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],77:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],78:[function(require,module,exports){
'use strict';

// // All
// /^npm-debug\.log$/,   // npm error log
// /^\..*\.swp$/,        // vim state
// // OS X
// /^\.DS_Store$/,       // stores custom folder attributes
// /^\.AppleDouble$/,    // stores additional file resources
// /^\.LSOverride$/,     // contains the absolute path to the app to be used
// /^Icon[\r\?]?/,       // custom Finder icon
// /^\._.*/,             // thumbnail
// /^\.Spotlight-V100$/,  // file that might appear on external disk
// /\.Trashes/,          // file that might appear on external disk
// /^__MACOSX$/,         // resource fork
// // Linux
// /~$/,                 // backup file
// // Windows
// /^Thumbs\.db$/,       // image file cache
// /^ehthumbs\.db$/,     // folder config file
// /^Desktop\.ini$/      // stores custom folder attributes

exports.re = /^npm-debug\.log$|^\..*\.swp$|^\.DS_Store$|^\.AppleDouble$|^\.LSOverride$|^Icon[\r\?]?|^\._.*|^\.Spotlight-V100$|\.Trashes|^__MACOSX$|~$|^Thumbs\.db$|^ehthumbs\.db$|^Desktop\.ini$/;

exports.is = function (filename) {
	return exports.re.test(filename);
};

exports.not = exports.isnt = function (filename) {
	return !exports.is(filename);
};

},{}],79:[function(require,module,exports){
(function (Buffer){
module.exports = magnetURIDecode
module.exports.decode = magnetURIDecode
module.exports.encode = magnetURIEncode

var base32 = require('thirty-two')
var extend = require('xtend')
var uniq = require('uniq')

/**
 * Parse a magnet URI and return an object of keys/values
 *
 * @param  {string} uri
 * @return {Object} parsed uri
 */
function magnetURIDecode (uri) {
  var result = {}
  var data = uri.split('magnet:?')[1]

  var params = (data && data.length >= 0)
    ? data.split('&')
    : []

  params.forEach(function (param) {
    var keyval = param.split('=')

    // This keyval is invalid, skip it
    if (keyval.length !== 2) return

    var key = keyval[0]
    var val = keyval[1]

    // Clean up torrent name
    if (key === 'dn') val = decodeURIComponent(val).replace(/\+/g, ' ')

    // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded
    // URIs, so decode them
    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
      val = decodeURIComponent(val)
    }

    // Return keywords as an array
    if (key === 'kt') val = decodeURIComponent(val).split('+')

    // If there are repeated parameters, return an array of values
    if (result[key]) {
      if (Array.isArray(result[key])) {
        result[key].push(val)
      } else {
        var old = result[key]
        result[key] = [old, val]
      }
    } else {
      result[key] = val
    }
  })

  // Convenience properties for parity with `parse-torrent-file` module
  var m
  if (result.xt) {
    var xts = Array.isArray(result.xt) ? result.xt : [ result.xt ]
    xts.forEach(function (xt) {
      if ((m = xt.match(/^urn:btih:(.{40})/))) {
        result.infoHash = m[1].toLowerCase()
      } else if ((m = xt.match(/^urn:btih:(.{32})/))) {
        var decodedStr = base32.decode(m[1])
        result.infoHash = new Buffer(decodedStr, 'binary').toString('hex')
      }
    })
  }
  if (result.infoHash) result.infoHashBuffer = new Buffer(result.infoHash, 'hex')

  if (result.dn) result.name = result.dn
  if (result.kt) result.keywords = result.kt

  if (typeof result.tr === 'string') result.announce = [ result.tr ]
  else if (Array.isArray(result.tr)) result.announce = result.tr
  else result.announce = []

  result.urlList = []
  if (typeof result.as === 'string' || Array.isArray(result.as)) {
    result.urlList = result.urlList.concat(result.as)
  }
  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {
    result.urlList = result.urlList.concat(result.ws)
  }

  uniq(result.announce)
  uniq(result.urlList)

  return result
}

function magnetURIEncode (obj) {
  obj = extend(obj) // clone obj, so we can mutate it

  // support using convenience names, in addition to spec names
  // (example: `infoHash` for `xt`, `name` for `dn`)
  if (obj.infoHashBuffer) obj.xt = 'urn:btih:' + obj.infoHashBuffer.toString('hex')
  if (obj.infoHash) obj.xt = 'urn:btih:' + obj.infoHash
  if (obj.name) obj.dn = obj.name
  if (obj.keywords) obj.kt = obj.keywords
  if (obj.announce) obj.tr = obj.announce
  if (obj.urlList) {
    obj.ws = obj.urlList
    delete obj.as
  }

  var result = 'magnet:?'
  Object.keys(obj)
    .filter(function (key) {
      return key.length === 2
    })
    .forEach(function (key, i) {
      var values = Array.isArray(obj[key]) ? obj[key] : [ obj[key] ]
      values.forEach(function (val, j) {
        if ((i > 0 || j > 0) && (key !== 'kt' || j === 0)) result += '&'

        if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+')
        if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
          val = encodeURIComponent(val)
        }
        if (key === 'kt') val = encodeURIComponent(val)

        if (key === 'kt' && j > 0) result += '+' + val
        else result += key + '=' + val
      })
    })

  return result
}

}).call(this,require("buffer").Buffer)

},{"buffer":25,"thirty-two":148,"uniq":156,"xtend":181}],80:[function(require,module,exports){
module.exports = MediaElementWrapper

var inherits = require('inherits')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var MediaSource = typeof window !== 'undefined' && window.MediaSource

var DEFAULT_BUFFER_DURATION = 60 // seconds

function MediaElementWrapper (elem, opts) {
  var self = this
  if (!(self instanceof MediaElementWrapper)) return new MediaElementWrapper(elem, opts)

  if (!MediaSource) throw new Error('web browser lacks MediaSource support')

  if (!opts) opts = {}
  self._bufferDuration = opts.bufferDuration || DEFAULT_BUFFER_DURATION
  self._elem = elem
  self._mediaSource = new MediaSource()
  self._streams = []
  self.detailedError = null

  self._errorHandler = function () {
    self._elem.removeEventListener('error', self._errorHandler)
    var streams = self._streams.slice()
    streams.forEach(function (stream) {
      stream.destroy(self._elem.error)
    })
  }
  self._elem.addEventListener('error', self._errorHandler)

  self._elem.src = window.URL.createObjectURL(self._mediaSource)
}

/*
 * `obj` can be a previous value returned by this function
 * or a string
 */
MediaElementWrapper.prototype.createWriteStream = function (obj) {
  var self = this

  return new MediaSourceStream(self, obj)
}

/*
 * Use to trigger an error on the underlying media element
 */
MediaElementWrapper.prototype.error = function (err) {
  var self = this

  // be careful not to overwrite any existing detailedError values
  if (!self.detailedError) {
    self.detailedError = err
  }
  try {
    self._mediaSource.endOfStream('decode')
  } catch (err) {}
}

inherits(MediaSourceStream, stream.Writable)

function MediaSourceStream (wrapper, obj) {
  var self = this
  stream.Writable.call(self)

  self._wrapper = wrapper
  self._elem = wrapper._elem
  self._mediaSource = wrapper._mediaSource
  self._allStreams = wrapper._streams
  self._allStreams.push(self)
  self._bufferDuration = wrapper._bufferDuration
  self._sourceBuffer = null

  self._openHandler = function () {
    self._onSourceOpen()
  }
  self._flowHandler = function () {
    self._flow()
  }

  if (typeof obj === 'string') {
    self._type = obj
    // Need to create a new sourceBuffer
    if (self._mediaSource.readyState === 'open') {
      self._createSourceBuffer()
    } else {
      self._mediaSource.addEventListener('sourceopen', self._openHandler)
    }
  } else if (obj._sourceBuffer === null) {
    obj.destroy()
    self._type = obj._type // The old stream was created but hasn't finished initializing
    self._mediaSource.addEventListener('sourceopen', self._openHandler)
  } else if (obj._sourceBuffer) {
    obj.destroy()
    self._type = obj._type
    self._sourceBuffer = obj._sourceBuffer // Copy over the old sourceBuffer
    self._sourceBuffer.addEventListener('updateend', self._flowHandler)
  } else {
    throw new Error('The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function')
  }

  self._elem.addEventListener('timeupdate', self._flowHandler)

  self.on('error', function (err) {
    self._wrapper.error(err)
  })

  self.on('finish', function () {
    if (self.destroyed) return
    self._finished = true
    if (self._allStreams.every(function (other) { return other._finished })) {
      try {
        self._mediaSource.endOfStream()
      } catch (err) {}
    }
  })
}

MediaSourceStream.prototype._onSourceOpen = function () {
  var self = this
  if (self.destroyed) return

  self._mediaSource.removeEventListener('sourceopen', self._openHandler)
  self._createSourceBuffer()
}

MediaSourceStream.prototype.destroy = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true

  // Remove from allStreams
  self._allStreams.splice(self._allStreams.indexOf(self), 1)

  self._mediaSource.removeEventListener('sourceopen', self._openHandler)
  self._elem.removeEventListener('timeupdate', self._flowHandler)
  if (self._sourceBuffer) {
    self._sourceBuffer.removeEventListener('updateend', self._flowHandler)
    if (self._mediaSource.readyState === 'open') {
      self._sourceBuffer.abort()
    }
  }

  if (err) self.emit('error', err)
  self.emit('close')
}

MediaSourceStream.prototype._createSourceBuffer = function () {
  var self = this
  if (self.destroyed) return

  if (MediaSource.isTypeSupported(self._type)) {
    self._sourceBuffer = self._mediaSource.addSourceBuffer(self._type)
    self._sourceBuffer.addEventListener('updateend', self._flowHandler)
    if (self._cb) {
      var cb = self._cb
      self._cb = null
      cb()
    }
  } else {
    self.destroy(new Error('The provided type is not supported'))
  }
}

MediaSourceStream.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return
  if (!self._sourceBuffer) {
    self._cb = function (err) {
      if (err) return cb(err)
      self._write(chunk, encoding, cb)
    }
    return
  }

  if (self._sourceBuffer.updating) {
    return cb(new Error('Cannot append buffer while source buffer updating'))
  }

  try {
    self._sourceBuffer.appendBuffer(toArrayBuffer(chunk))
  } catch (err) {
    // appendBuffer can throw for a number of reasons, most notably when the data
    // being appended is invalid or if appendBuffer is called after another error
    // already occurred on the media element. In Chrome, there may be useful debugging
    // info in chrome://media-internals
    self.destroy(err)
    return
  }
  self._cb = cb
}

MediaSourceStream.prototype._flow = function () {
  var self = this

  if (self.destroyed || !self._sourceBuffer || self._sourceBuffer.updating) {
    return
  }

  if (self._mediaSource.readyState === 'open') {
    // check buffer size
    if (self._getBufferDuration() > self._bufferDuration) {
      return
    }
  }

  if (self._cb) {
    var cb = self._cb
    self._cb = null
    cb()
  }
}

// TODO: if zero actually works in all browsers, remove the logic associated with this below
var EPSILON = 0

MediaSourceStream.prototype._getBufferDuration = function () {
  var self = this

  var buffered = self._sourceBuffer.buffered
  var currentTime = self._elem.currentTime
  var bufferEnd = -1 // end of the buffer
  // This is a little over complex because some browsers seem to separate the
  // buffered region into multiple sections with slight gaps.
  for (var i = 0; i < buffered.length; i++) {
    var start = buffered.start(i)
    var end = buffered.end(i) + EPSILON

    if (start > currentTime) {
      // Reached past the joined buffer
      break
    } else if (bufferEnd >= 0 || currentTime <= end) {
      // Found the start/continuation of the joined buffer
      bufferEnd = end
    }
  }

  var bufferedTime = bufferEnd - currentTime
  if (bufferedTime < 0) {
    bufferedTime = 0
  }

  return bufferedTime
}

},{"inherits":70,"readable-stream":117,"to-arraybuffer":151}],81:[function(require,module,exports){
(function (process){
module.exports = Storage

function Storage (chunkLength, opts) {
  if (!(this instanceof Storage)) return new Storage(chunkLength, opts)
  if (!opts) opts = {}

  this.chunkLength = Number(chunkLength)
  if (!this.chunkLength) throw new Error('First argument must be a chunk length')

  this.chunks = []
  this.closed = false
  this.length = Number(opts.length) || Infinity

  if (this.length !== Infinity) {
    this.lastChunkLength = (this.length % this.chunkLength) || this.chunkLength
    this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1
  }
}

Storage.prototype.put = function (index, buf, cb) {
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))

  var isLastChunk = (index === this.lastChunkIndex)
  if (isLastChunk && buf.length !== this.lastChunkLength) {
    return nextTick(cb, new Error('Last chunk length must be ' + this.lastChunkLength))
  }
  if (!isLastChunk && buf.length !== this.chunkLength) {
    return nextTick(cb, new Error('Chunk length must be ' + this.chunkLength))
  }
  this.chunks[index] = buf
  nextTick(cb, null)
}

Storage.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))
  var buf = this.chunks[index]
  if (!buf) return nextTick(cb, new Error('Chunk not found'))
  if (!opts) return nextTick(cb, null, buf)
  var offset = opts.offset || 0
  var len = opts.length || (buf.length - offset)
  nextTick(cb, null, buf.slice(offset, len + offset))
}

Storage.prototype.close = Storage.prototype.destroy = function (cb) {
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))
  this.closed = true
  this.chunks = null
  nextTick(cb, null)
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    if (cb) cb(err, val)
  })
}

}).call(this,require('_process'))

},{"_process":104}],82:[function(require,module,exports){
(function (Buffer){
// This is an intentionally recursive require. I don't like it either.
var Box = require('./index')
var Descriptor = require('./descriptor')

var TIME_OFFSET = 2082844800000

/*
TODO:
test these
add new box versions
*/

// These have 'version' and 'flags' fields in the headers
exports.fullBoxes = {}
var fullBoxes = [
  'mvhd',
  'tkhd',
  'mdhd',
  'vmhd',
  'smhd',
  'stsd',
  'esds',
  'stsz',
  'stco',
  'stss',
  'stts',
  'ctts',
  'stsc',
  'dref',
  'elst',
  'hdlr',
  'mehd',
  'trex',
  'mfhd',
  'tfhd',
  'tfdt',
  'trun'
]
fullBoxes.forEach(function (type) {
  exports.fullBoxes[type] = true
})

exports.ftyp = {}
exports.ftyp.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.ftyp.encodingLength(box))
  var brands = box.compatibleBrands || []
  buf.write(box.brand, 0, 4, 'ascii')
  buf.writeUInt32BE(box.brandVersion, 4)
  for (var i = 0; i < brands.length; i++) buf.write(brands[i], 8 + (i * 4), 4, 'ascii')
  exports.ftyp.encode.bytes = 8 + brands.length * 4
  return buf
}
exports.ftyp.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var brand = buf.toString('ascii', 0, 4)
  var version = buf.readUInt32BE(4)
  var compatibleBrands = []
  for (var i = 8; i < buf.length; i += 4) compatibleBrands.push(buf.toString('ascii', i, i + 4))
  return {
    brand: brand,
    brandVersion: version,
    compatibleBrands: compatibleBrands
  }
}
exports.ftyp.encodingLength = function (box) {
  return 8 + (box.compatibleBrands || []).length * 4
}

exports.mvhd = {}
exports.mvhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(96)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.timeScale || 0, 8)
  buf.writeUInt32BE(box.duration || 0, 12)
  writeFixed32(box.preferredRate || 0, buf, 16)
  writeFixed16(box.preferredVolume || 0, buf, 20)
  writeReserved(buf, 22, 32)
  writeMatrix(box.matrix, buf, 32)
  buf.writeUInt32BE(box.previewTime || 0, 68)
  buf.writeUInt32BE(box.previewDuration || 0, 72)
  buf.writeUInt32BE(box.posterTime || 0, 76)
  buf.writeUInt32BE(box.selectionTime || 0, 80)
  buf.writeUInt32BE(box.selectionDuration || 0, 84)
  buf.writeUInt32BE(box.currentTime || 0, 88)
  buf.writeUInt32BE(box.nextTrackId || 0, 92)
  exports.mvhd.encode.bytes = 96
  return buf
}
exports.mvhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    preferredRate: readFixed32(buf, 16),
    preferredVolume: readFixed16(buf, 20),
    matrix: readMatrix(buf.slice(32, 68)),
    previewTime: buf.readUInt32BE(68),
    previewDuration: buf.readUInt32BE(72),
    posterTime: buf.readUInt32BE(76),
    selectionTime: buf.readUInt32BE(80),
    selectionDuration: buf.readUInt32BE(84),
    currentTime: buf.readUInt32BE(88),
    nextTrackId: buf.readUInt32BE(92)
  }
}
exports.mvhd.encodingLength = function (box) {
  return 96
}

exports.tkhd = {}
exports.tkhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(80)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.trackId || 0, 8)
  writeReserved(buf, 12, 16)
  buf.writeUInt32BE(box.duration || 0, 16)
  writeReserved(buf, 20, 28)
  buf.writeUInt16BE(box.layer || 0, 28)
  buf.writeUInt16BE(box.alternateGroup || 0, 30)
  buf.writeUInt16BE(box.volume || 0, 32)
  writeMatrix(box.matrix, buf, 36)
  buf.writeUInt32BE(box.trackWidth || 0, 72)
  buf.writeUInt32BE(box.trackHeight || 0, 76)
  exports.tkhd.encode.bytes = 80
  return buf
}
exports.tkhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    trackId: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(16),
    layer: buf.readUInt16BE(28),
    alternateGroup: buf.readUInt16BE(30),
    volume: buf.readUInt16BE(32),
    matrix: readMatrix(buf.slice(36, 72)),
    trackWidth: buf.readUInt32BE(72),
    trackHeight: buf.readUInt32BE(76)
  }
}
exports.tkhd.encodingLength = function (box) {
  return 80
}

exports.mdhd = {}
exports.mdhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(20)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.timeScale || 0, 8)
  buf.writeUInt32BE(box.duration || 0, 12)
  buf.writeUInt16BE(box.language || 0, 16)
  buf.writeUInt16BE(box.quality || 0, 18)
  exports.mdhd.encode.bytes = 20
  return buf
}
exports.mdhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    language: buf.readUInt16BE(16),
    quality: buf.readUInt16BE(18)
  }
}
exports.mdhd.encodingLength = function (box) {
  return 20
}

exports.vmhd = {}
exports.vmhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(8)
  buf.writeUInt16BE(box.graphicsMode || 0, 0)
  var opcolor = box.opcolor || [0, 0, 0]
  buf.writeUInt16BE(opcolor[0], 2)
  buf.writeUInt16BE(opcolor[1], 4)
  buf.writeUInt16BE(opcolor[2], 6)
  exports.vmhd.encode.bytes = 8
  return buf
}
exports.vmhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    graphicsMode: buf.readUInt16BE(0),
    opcolor: [buf.readUInt16BE(2), buf.readUInt16BE(4), buf.readUInt16BE(6)]
  }
}
exports.vmhd.encodingLength = function (box) {
  return 8
}

exports.smhd = {}
exports.smhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)
  buf.writeUInt16BE(box.balance || 0, 0)
  writeReserved(buf, 2, 4)
  exports.smhd.encode.bytes = 4
  return buf
}
exports.smhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    balance: buf.readUInt16BE(0)
  }
}
exports.smhd.encodingLength = function (box) {
  return 4
}

exports.stsd = {}
exports.stsd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.stsd.encodingLength(box))
  var entries = box.entries || []

  buf.writeUInt32BE(entries.length, 0)

  var ptr = 4
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i]
    Box.encode(entry, buf, ptr)
    ptr += Box.encode.bytes
  }

  exports.stsd.encode.bytes = ptr
  return buf
}
exports.stsd.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)
  var ptr = 4

  for (var i = 0; i < num; i++) {
    var entry = Box.decode(buf, ptr, end)
    entries[i] = entry
    ptr += entry.length
  }

  return {
    entries: entries
  }
}
exports.stsd.encodingLength = function (box) {
  var totalSize = 4
  if (!box.entries) return totalSize
  for (var i = 0; i < box.entries.length; i++) {
    totalSize += Box.encodingLength(box.entries[i])
  }
  return totalSize
}

exports.avc1 = exports.VisualSampleEntry = {}
exports.VisualSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.VisualSampleEntry.encodingLength(box))

  writeReserved(buf, 0, 6)
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6)
  writeReserved(buf, 8, 24)
  buf.writeUInt16BE(box.width || 0, 24)
  buf.writeUInt16BE(box.height || 0, 26)
  buf.writeUInt32BE(box.hResolution || 0x480000, 28)
  buf.writeUInt32BE(box.vResolution || 0x480000, 32)
  writeReserved(buf, 36, 40)
  buf.writeUInt16BE(box.frameCount || 1, 40)
  var compressorName = box.compressorName || ''
  var nameLen = Math.min(compressorName.length, 31)
  buf.writeUInt8(nameLen, 42)
  buf.write(compressorName, 43, nameLen, 'utf8')
  buf.writeUInt16BE(box.depth || 0x18, 74)
  buf.writeInt16BE(-1, 76)

  var ptr = 78
  var children = box.children || []
  children.forEach(function (child) {
    Box.encode(child, buf, ptr)
    ptr += Box.encode.bytes
  })
  exports.VisualSampleEntry.encode.bytes = ptr
}
exports.VisualSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  var length = end - offset
  var nameLen = Math.min(buf.readUInt8(42), 31)
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    width: buf.readUInt16BE(24),
    height: buf.readUInt16BE(26),
    hResolution: buf.readUInt32BE(28),
    vResolution: buf.readUInt32BE(32),
    frameCount: buf.readUInt16BE(40),
    compressorName: buf.toString('utf8', 43, 43 + nameLen),
    depth: buf.readUInt16BE(74),
    children: []
  }

  var ptr = 78
  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length)
    box.children.push(child)
    box[child.type] = child
    ptr += child.length
  }

  return box
}
exports.VisualSampleEntry.encodingLength = function (box) {
  var len = 78
  var children = box.children || []
  children.forEach(function (child) {
    len += Box.encodingLength(child)
  })
  return len
}

exports.avcC = {}
exports.avcC.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer(box.buffer.length)

  box.buffer.copy(buf)
  exports.avcC.encode.bytes = box.buffer.length
}
exports.avcC.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)

  return {
    mimeCodec: buf.toString('hex', 1, 4),
    buffer: new Buffer(buf)
  }
}
exports.avcC.encodingLength = function (box) {
  return box.buffer.length
}

exports.mp4a = exports.AudioSampleEntry = {}
exports.AudioSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.AudioSampleEntry.encodingLength(box))

  writeReserved(buf, 0, 6)
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6)
  writeReserved(buf, 8, 16)
  buf.writeUInt16BE(box.channelCount || 2, 16)
  buf.writeUInt16BE(box.sampleSize || 16, 18)
  writeReserved(buf, 20, 24)
  buf.writeUInt32BE(box.sampleRate || 0, 24)

  var ptr = 28
  var children = box.children || []
  children.forEach(function (child) {
    Box.encode(child, buf, ptr)
    ptr += Box.encode.bytes
  })
  exports.AudioSampleEntry.encode.bytes = ptr
}
exports.AudioSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)
  var length = end - offset
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    channelCount: buf.readUInt16BE(16),
    sampleSize: buf.readUInt16BE(18),
    sampleRate: buf.readUInt32BE(24),
    children: []
  }

  var ptr = 28
  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length)
    box.children.push(child)
    box[child.type] = child
    ptr += child.length
  }

  return box
}
exports.AudioSampleEntry.encodingLength = function (box) {
  var len = 28
  var children = box.children || []
  children.forEach(function (child) {
    len += Box.encodingLength(child)
  })
  return len
}

exports.esds = {}
exports.esds.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer(box.buffer.length)

  box.buffer.copy(buf, 0)
  exports.esds.encode.bytes = box.buffer.length
}
exports.esds.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)

  var desc = Descriptor.Descriptor.decode(buf, 0, buf.length)
  var esd = (desc.tagName === 'ESDescriptor') ? desc : {}
  var dcd = esd.DecoderConfigDescriptor || {}
  var oti = dcd.oti || 0
  var dsi = dcd.DecoderSpecificInfo
  var audioConfig = dsi ? (dsi.buffer.readUInt8(0) & 0xf8) >> 3 : 0

  var mimeCodec = null
  if (oti) {
    mimeCodec = oti.toString(16)
    if (audioConfig) {
      mimeCodec += '.' + audioConfig
    }
  }

  return {
    mimeCodec: mimeCodec,
    buffer: new Buffer(buf.slice(0))
  }
}
exports.esds.encodingLength = function (box) {
  return box.buffer.length
}

// TODO: integrate the two versions in a saner way
exports.stsz = {}
exports.stsz.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : Buffer(exports.stsz.encodingLength(box))

  buf.writeUInt32BE(0, 0)
  buf.writeUInt32BE(entries.length, 4)

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 8)
  }

  exports.stsz.encode.bytes = 8 + entries.length * 4
  return buf
}
exports.stsz.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var size = buf.readUInt32BE(0)
  var num = buf.readUInt32BE(4)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    if (size === 0) {
      entries[i] = buf.readUInt32BE(i * 4 + 8)
    } else {
      entries[i] = size
    }
  }

  return {
    entries: entries
  }
}
exports.stsz.encodingLength = function (box) {
  return 8 + box.entries.length * 4
}

exports.stss =
exports.stco = {}
exports.stco.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stco.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 4)
  }

  exports.stco.encode.bytes = 4 + entries.length * 4
  return buf
}
exports.stco.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    entries[i] = buf.readUInt32BE(i * 4 + 4)
  }

  return {
    entries: entries
  }
}
exports.stco.encodingLength = function (box) {
  return 4 + box.entries.length * 4
}

exports.stts = {}
exports.stts.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stts.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4
    buf.writeUInt32BE(entries[i].count || 0, ptr)
    buf.writeUInt32BE(entries[i].duration || 0, ptr + 4)
  }

  exports.stts.encode.bytes = 4 + box.entries.length * 8
  return buf
}
exports.stts.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      duration: buf.readUInt32BE(ptr + 4)
    }
  }

  return {
    entries: entries
  }
}
exports.stts.encodingLength = function (box) {
  return 4 + box.entries.length * 8
}

exports.ctts = {}
exports.ctts.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.ctts.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4
    buf.writeUInt32BE(entries[i].count || 0, ptr)
    buf.writeUInt32BE(entries[i].compositionOffset || 0, ptr + 4)
  }

  exports.ctts.encode.bytes = 4 + entries.length * 8
  return buf
}
exports.ctts.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      compositionOffset: buf.readInt32BE(ptr + 4)
    }
  }

  return {
    entries: entries
  }
}
exports.ctts.encodingLength = function (box) {
  return 4 + box.entries.length * 8
}

exports.stsc = {}
exports.stsc.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stsc.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4
    buf.writeUInt32BE(entries[i].firstChunk || 0, ptr)
    buf.writeUInt32BE(entries[i].samplesPerChunk || 0, ptr + 4)
    buf.writeUInt32BE(entries[i].sampleDescriptionId || 0, ptr + 8)
  }

  exports.stsc.encode.bytes = 4 + entries.length * 12
  return buf
}
exports.stsc.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4
    entries[i] = {
      firstChunk: buf.readUInt32BE(ptr),
      samplesPerChunk: buf.readUInt32BE(ptr + 4),
      sampleDescriptionId: buf.readUInt32BE(ptr + 8)
    }
  }

  return {
    entries: entries
  }
}
exports.stsc.encodingLength = function (box) {
  return 4 + box.entries.length * 12
}

exports.dref = {}
exports.dref.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.dref.encodingLength(box))
  var entries = box.entries || []

  buf.writeUInt32BE(entries.length, 0)

  var ptr = 4
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i]
    var size = (entry.buf ? entry.buf.length : 0) + 4 + 4

    buf.writeUInt32BE(size, ptr)
    ptr += 4

    buf.write(entry.type, ptr, 4, 'ascii')
    ptr += 4

    if (entry.buf) {
      entry.buf.copy(buf, ptr)
      ptr += entry.buf.length
    }
  }

  exports.dref.encode.bytes = ptr
  return buf
}
exports.dref.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)
  var ptr = 4

  for (var i = 0; i < num; i++) {
    var size = buf.readUInt32BE(ptr)
    var type = buf.toString('ascii', ptr + 4, ptr + 8)
    var tmp = buf.slice(ptr + 8, ptr + size)
    ptr += size

    entries[i] = {
      type: type,
      buf: tmp
    }
  }

  return {
    entries: entries
  }
}
exports.dref.encodingLength = function (box) {
  var totalSize = 4
  if (!box.entries) return totalSize
  for (var i = 0; i < box.entries.length; i++) {
    var buf = box.entries[i].buf
    totalSize += (buf ? buf.length : 0) + 4 + 4
  }
  return totalSize
}

exports.elst = {}
exports.elst.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.elst.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4
    buf.writeUInt32BE(entries[i].trackDuration || 0, ptr)
    buf.writeUInt32BE(entries[i].mediaTime || 0, ptr + 4)
    writeFixed32(entries[i].mediaRate || 0, buf, ptr + 8)
  }

  exports.elst.encode.bytes = 4 + entries.length * 12
  return buf
}
exports.elst.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4
    entries[i] = {
      trackDuration: buf.readUInt32BE(ptr),
      mediaTime: buf.readInt32BE(ptr + 4),
      mediaRate: readFixed32(buf, ptr + 8)
    }
  }

  return {
    entries: entries
  }
}
exports.elst.encodingLength = function (box) {
  return 4 + box.entries.length * 12
}

exports.hdlr = {}
exports.hdlr.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.hdlr.encodingLength(box))

  var len = 21 + (box.name || '').length
  buf.fill(0, 0, len)

  buf.write(box.handlerType || '', 4, 4, 'ascii')
  writeString(box.name || '', buf, 20)

  exports.hdlr.encode.bytes = len
  return buf
}
exports.hdlr.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  return {
    handlerType: buf.toString('ascii', 4, 8),
    name: readString(buf, 20, end)
  }
}
exports.hdlr.encodingLength = function (box) {
  return 21 + (box.name || '').length
}

exports.mehd = {}
exports.mehd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.fragmentDuration || 0, 0)
  exports.mehd.encode.bytes = 4
  return buf
}
exports.mehd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    fragmentDuration: buf.readUInt32BE(0)
  }
}
exports.mehd.encodingLength = function (box) {
  return 4
}

exports.trex = {}
exports.trex.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(20)

  buf.writeUInt32BE(box.trackId || 0, 0)
  buf.writeUInt32BE(box.defaultSampleDescriptionIndex || 0, 4)
  buf.writeUInt32BE(box.defaultSampleDuration || 0, 8)
  buf.writeUInt32BE(box.defaultSampleSize || 0, 12)
  buf.writeUInt32BE(box.defaultSampleFlags || 0, 16)
  exports.trex.encode.bytes = 20
  return buf
}
exports.trex.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    trackId: buf.readUInt32BE(0),
    defaultSampleDescriptionIndex: buf.readUInt32BE(4),
    defaultSampleDuration: buf.readUInt32BE(8),
    defaultSampleSize: buf.readUInt32BE(12),
    defaultSampleFlags: buf.readUInt32BE(16)
  }
}
exports.trex.encodingLength = function (box) {
  return 20
}

exports.mfhd = {}
exports.mfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.sequenceNumber || 0, 0)
  exports.mfhd.encode.bytes = 4
  return buf
}
exports.mfhd.decode = function (buf, offset) {
  return {
    sequenceNumber: buf.readUint32BE(0)
  }
}
exports.mfhd.encodingLength = function (box) {
  return 4
}

exports.tfhd = {}
exports.tfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)
  buf.writeUInt32BE(box.trackId, 0)
  exports.tfhd.encode.bytes = 4
  return buf
}
exports.tfhd.decode = function (buf, offset) {
  // TODO: this
}
exports.tfhd.encodingLength = function (box) {
  // TODO: this is wrong!
  return 4
}

exports.tfdt = {}
exports.tfdt.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.baseMediaDecodeTime || 0, 0)
  exports.tfdt.encode.bytes = 4
  return buf
}
exports.tfdt.decode = function (buf, offset) {
  // TODO: this
}
exports.tfdt.encodingLength = function (box) {
  return 4
}

exports.trun = {}
exports.trun.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(8 + box.entries.length * 16)

  // TODO: this is wrong
  buf.writeUInt32BE(box.entries.length, 0)
  buf.writeInt32BE(box.dataOffset, 4)
  var ptr = 8
  for (var i = 0; i < box.entries.length; i++) {
    var entry = box.entries[i]
    buf.writeUInt32BE(entry.sampleDuration, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleSize, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleFlags, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleCompositionTimeOffset, ptr)
    ptr += 4
  }
  exports.trun.encode.bytes = ptr
}
exports.trun.decode = function (buf, offset) {
  // TODO: this
}
exports.trun.encodingLength = function (box) {
  // TODO: this is wrong
  return 8 + box.entries.length * 16
}

exports.mdat = {}
exports.mdat.encode = function (box, buf, offset) {
  if (box.buffer) {
    box.buffer.copy(buf, offset)
    exports.mdat.encode.bytes = box.buffer.length
  } else {
    exports.mdat.encode.bytes = exports.mdat.encodingLength(box)
  }
}
exports.mdat.decode = function (buf, start, end) {
  return {
    buffer: new Buffer(buf.slice(start, end))
  }
}
exports.mdat.encodingLength = function (box) {
  return box.buffer ? box.buffer.length : box.contentLength
}

function writeReserved (buf, offset, end) {
  for (var i = offset; i < end; i++) buf[i] = 0
}

function writeDate (date, buf, offset) {
  buf.writeUInt32BE(Math.floor((date.getTime() + TIME_OFFSET) / 1000), offset)
}

// TODO: think something is wrong here
function writeFixed32 (num, buf, offset) {
  buf.writeUInt16BE(Math.floor(num) % (256 * 256), offset)
  buf.writeUInt16BE(Math.floor(num * 256 * 256) % (256 * 256), offset + 2)
}

function writeFixed16 (num, buf, offset) {
  buf[offset] = Math.floor(num) % 256
  buf[offset + 1] = Math.floor(num * 256) % 256
}

function writeMatrix (list, buf, offset) {
  if (!list) list = [0, 0, 0, 0, 0, 0, 0, 0, 0]
  for (var i = 0; i < list.length; i++) {
    writeFixed32(list[i], buf, offset + i * 4)
  }
}

function writeString (str, buf, offset) {
  var strBuffer = new Buffer(str, 'utf8')
  strBuffer.copy(buf, offset)
  buf[offset + strBuffer.length] = 0
}

function readMatrix (buf) {
  var list = new Array(buf.length / 4)
  for (var i = 0; i < list.length; i++) list[i] = readFixed32(buf, i * 4)
  return list
}

function readDate (buf, offset) {
  return new Date(buf.readUInt32BE(offset) * 1000 - TIME_OFFSET)
}

function readFixed32 (buf, offset) {
  return buf.readUInt16BE(offset) + buf.readUInt16BE(offset + 2) / (256 * 256)
}

function readFixed16 (buf, offset) {
  return buf[offset] + buf[offset + 1] / 256
}

function readString (buf, offset, length) {
  var i
  for (i = 0; i < length; i++) {
    if (buf[offset + i] === 0) {
      break
    }
  }
  return buf.toString('utf8', offset, offset + i)
}

}).call(this,require("buffer").Buffer)

},{"./descriptor":83,"./index":84,"buffer":25}],83:[function(require,module,exports){
(function (Buffer){
var tagToName = {
  0x03: 'ESDescriptor',
  0x04: 'DecoderConfigDescriptor',
  0x05: 'DecoderSpecificInfo',
  0x06: 'SLConfigDescriptor'
}

exports.Descriptor = {}
exports.Descriptor.decode = function (buf, start, end) {
  var tag = buf.readUInt8(start)
  var ptr = start + 1
  var lenByte
  var len = 0
  do {
    lenByte = buf.readUInt8(ptr++)
    len = (len << 7) | (lenByte & 0x7f)
  } while (lenByte & 0x80)

  var obj
  var tagName = tagToName[tag] // May be undefined; that's ok
  if (exports[tagName]) {
    obj = exports[tagName].decode(buf, ptr, end)
  } else {
    obj = {
      buffer: new Buffer(buf.slice(ptr, ptr + len))
    }
  }

  obj.tag = tag
  obj.tagName = tagName
  obj.length = (ptr - start) + len
  obj.contentsLen = len
  return obj
}

exports.DescriptorArray = {}
exports.DescriptorArray.decode = function (buf, start, end) {
  var ptr = start
  var obj = {}
  while (ptr + 2 <= end) {
    var descriptor = exports.Descriptor.decode(buf, ptr, end)
    ptr += descriptor.length
    var tagName = tagToName[descriptor.tag] || ('Descriptor' + descriptor.tag)
    obj[tagName] = descriptor
  }
  return obj
}

exports.ESDescriptor = {}
exports.ESDescriptor.decode = function (buf, start, end) {
  var flags = buf.readUInt8(start + 2)
  var ptr = start + 3
  if (flags & 0x80) {
    ptr += 2
  }
  if (flags & 0x40) {
    var len = buf.readUInt8(ptr)
    ptr += len + 1
  }
  if (flags & 0x20) {
    ptr += 2
  }
  return exports.DescriptorArray.decode(buf, ptr, end)
}

exports.DecoderConfigDescriptor = {}
exports.DecoderConfigDescriptor.decode = function (buf, start, end) {
  var oti = buf.readUInt8(start)
  var obj = exports.DescriptorArray.decode(buf, start + 13, end)
  obj.oti = oti
  return obj
}

}).call(this,require("buffer").Buffer)

},{"buffer":25}],84:[function(require,module,exports){
(function (Buffer){
// var assert = require('assert')
var uint64be = require('uint64be')

var boxes = require('./boxes')

var UINT32_MAX = 4294967295

var Box = exports

/*
 * Lists the proper order for boxes inside containers.
 * Five-character names ending in 's' indicate arrays instead of single elements.
 */
var containers = exports.containers = {
  'moov': ['mvhd', 'meta', 'traks', 'mvex'],
  'trak': ['tkhd', 'tref', 'trgr', 'edts', 'meta', 'mdia', 'udta'],
  'edts': ['elst'],
  'mdia': ['mdhd', 'hdlr', 'elng', 'minf'],
  'minf': ['vmhd', 'smhd', 'hmhd', 'sthd', 'nmhd', 'dinf', 'stbl'],
  'dinf': ['dref'],
  'stbl': ['stsd', 'stts', 'ctts', 'cslg', 'stsc', 'stsz', 'stz2', 'stco', 'co64', 'stss', 'stsh', 'padb', 'stdp', 'sdtp', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios'],
  'mvex': ['mehd', 'trexs', 'leva'],
  'moof': ['mfhd', 'meta', 'trafs'],
  'traf': ['tfhd', 'trun', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios', 'tfdt', 'meta']
}

Box.encode = function (obj, buffer, offset) {
  Box.encodingLength(obj) // sets every level appropriately
  offset = offset || 0
  buffer = buffer || new Buffer(obj.length)
  return Box._encode(obj, buffer, offset)
}

Box._encode = function (obj, buffer, offset) {
  var type = obj.type
  var len = obj.length
  if (len > UINT32_MAX) {
    len = 1
  }
  buffer.writeUInt32BE(len, offset)
  buffer.write(obj.type, offset + 4, 4, 'ascii')
  var ptr = offset + 8
  if (len === 1) {
    uint64be.encode(obj.length, buffer, ptr)
    ptr += 8
  }
  if (boxes.fullBoxes[type]) {
    buffer.writeUInt32BE(obj.flags || 0, ptr)
    buffer.writeUInt8(obj.version || 0, ptr)
    ptr += 4
  }

  if (containers[type]) {
    var contents = containers[type]
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || []
        childType = childType.substr(0, 4)
        entry.forEach(function (child) {
          Box._encode(child, buffer, ptr)
          ptr += Box.encode.bytes
        })
      } else if (obj[childType]) {
        Box._encode(obj[childType], buffer, ptr)
        ptr += Box.encode.bytes
      }
    })
    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        Box._encode(child, buffer, ptr)
        ptr += Box.encode.bytes
      })
    }
  } else if (boxes[type]) {
    var encode = boxes[type].encode
    encode(obj, buffer, ptr)
    ptr += encode.bytes
  } else if (obj.buffer) {
    var buf = obj.buffer
    buf.copy(buffer, ptr)
    ptr += obj.buffer.length
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set')
  }

  Box.encode.bytes = ptr - offset
  // assert.equal(ptr - offset, obj.length, 'Error encoding \'' + type + '\': wrote ' + ptr - offset + ' bytes, expecting ' + obj.length)
  return buffer
}

/*
 * Returns an object with `type` and `size` fields,
 * or if there isn't enough data, returns the total
 * number of bytes needed to read the headers
 */
Box.readHeaders = function (buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  if (end - start < 8) {
    return 8
  }

  var len = buffer.readUInt32BE(start)
  var type = buffer.toString('ascii', start + 4, start + 8)
  var ptr = start + 8

  if (len === 1) {
    if (end - start < 16) {
      return 16
    }

    len = uint64be.decode(buffer, ptr)
    ptr += 8
  }

  var version
  var flags
  if (boxes.fullBoxes[type]) {
    version = buffer.readUInt8(ptr)
    flags = buffer.readUInt32BE(ptr) & 0xffffff
    ptr += 4
  }

  return {
    length: len,
    headersLen: ptr - start,
    contentLen: len - (ptr - start),
    type: type,
    version: version,
    flags: flags
  }
}

Box.decode = function (buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  var headers = Box.readHeaders(buffer, start, end)
  if (!headers || headers.length > end - start) {
    throw new Error('Data too short')
  }

  return Box.decodeWithoutHeaders(headers, buffer, start + headers.headersLen, start + headers.length)
}

Box.decodeWithoutHeaders = function (headers, buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  var type = headers.type
  var obj = {}
  if (containers[type]) {
    obj.otherBoxes = []
    var contents = containers[type]
    var ptr = start
    while (end - ptr >= 8) {
      var child = Box.decode(buffer, ptr, end)
      ptr += child.length
      if (contents.indexOf(child.type) >= 0) {
        obj[child.type] = child
      } else if (contents.indexOf(child.type + 's') >= 0) {
        var childType = child.type + 's'
        var entry = obj[childType] = obj[childType] || []
        entry.push(child)
      } else {
        obj.otherBoxes.push(child)
      }
    }
  } else if (boxes[type]) {
    var decode = boxes[type].decode
    obj = decode(buffer, start, end)
  } else {
    obj.buffer = new Buffer(buffer.slice(start, end))
  }

  obj.length = headers.length
  obj.contentLen = headers.contentLen
  obj.type = headers.type
  obj.version = headers.version
  obj.flags = headers.flags
  return obj
}

Box.encodingLength = function (obj) {
  var type = obj.type

  var len = 8
  if (boxes.fullBoxes[type]) {
    len += 4
  }

  if (containers[type]) {
    var contents = containers[type]
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || []
        childType = childType.substr(0, 4)
        entry.forEach(function (child) {
          child.type = childType
          len += Box.encodingLength(child)
        })
      } else if (obj[childType]) {
        var child = obj[childType]
        child.type = childType
        len += Box.encodingLength(child)
      }
    })
    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        len += Box.encodingLength(child)
      })
    }
  } else if (boxes[type]) {
    len += boxes[type].encodingLength(obj)
  } else if (obj.buffer) {
    len += obj.buffer.length
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set')
  }

  if (len > UINT32_MAX) {
    len += 8
  }

  obj.length = len
  return len
}

}).call(this,require("buffer").Buffer)

},{"./boxes":82,"buffer":25,"uint64be":155}],85:[function(require,module,exports){
(function (Buffer){
var stream = require('readable-stream')
var inherits = require('inherits')
var nextEvent = require('next-event')
var Box = require('mp4-box-encoding')

var EMPTY = new Buffer(0)

module.exports = Decoder

function Decoder () {
  if (!(this instanceof Decoder)) return new Decoder()
  stream.Writable.call(this)

  this.destroyed = false

  this._pending = 0
  this._missing = 0
  this._buf = null
  this._str = null
  this._cb = null
  this._ondrain = null
  this._writeBuffer = null
  this._writeCb = null

  this._ondrain = null
  this._kick()
}

inherits(Decoder, stream.Writable)

Decoder.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  if (err) this.emit('error', err)
  this.emit('close')
}

Decoder.prototype._write = function (data, enc, next) {
  if (this.destroyed) return
  var drained = !this._str || !this._str._writableState.needDrain

  while (data.length && !this.destroyed) {
    if (!this._missing) {
      this._writeBuffer = data
      this._writeCb = next
      return
    }

    var consumed = data.length < this._missing ? data.length : this._missing
    if (this._buf) data.copy(this._buf, this._buf.length - this._missing)
    else if (this._str) drained = this._str.write(consumed === data.length ? data : data.slice(0, consumed))

    this._missing -= consumed

    if (!this._missing) {
      var buf = this._buf
      var cb = this._cb
      var stream = this._str

      this._buf = this._cb = this._str = this._ondrain = null
      drained = true

      if (stream) stream.end()
      if (cb) cb(buf)
    }

    data = consumed === data.length ? EMPTY : data.slice(consumed)
  }

  if (this._pending && !this._missing) {
    this._writeBuffer = data
    this._writeCb = next
    return
  }

  if (drained) next()
  else this._ondrain(next)
}

Decoder.prototype._buffer = function (size, cb) {
  this._missing = size
  this._buf = new Buffer(size)
  this._cb = cb
}

Decoder.prototype._stream = function (size, cb) {
  var self = this
  this._missing = size
  this._str = new MediaData(this)
  this._ondrain = nextEvent(this._str, 'drain')
  this._pending++
  this._str.on('end', function () {
    self._pending--
    self._kick()
  })
  this._cb = cb
  return this._str
}

Decoder.prototype._readBox = function () {
  var self = this
  bufferHeaders(8)

  function bufferHeaders (len, buf) {
    self._buffer(len, function (additionalBuf) {
      if (buf) {
        buf = Buffer.concat(buf, additionalBuf)
      } else {
        buf = additionalBuf
      }
      var headers = Box.readHeaders(buf)
      if (typeof headers === 'number') {
        bufferHeaders(headers - buf.length, buf)
      } else {
        self._pending++
        self._headers = headers
        self.emit('box', headers)
      }
    })
  }
}

Decoder.prototype.stream = function () {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  return self._stream(headers.contentLen, null)
}

Decoder.prototype.decode = function (cb) {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  self._buffer(headers.contentLen, function (buf) {
    var box = Box.decodeWithoutHeaders(headers, buf)
    cb(box)
    self._pending--
    self._kick()
  })
}

Decoder.prototype.ignore = function () {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  this._missing = headers.contentLen
  this._cb = function () {
    self._pending--
    self._kick()
  }
}

Decoder.prototype._kick = function () {
  if (this._pending) return
  if (!this._buf && !this._str) this._readBox()
  if (this._writeBuffer) {
    var next = this._writeCb
    var buffer = this._writeBuffer
    this._writeBuffer = null
    this._writeCb = null
    this._write(buffer, null, next)
  }
}

function MediaData (parent) {
  this._parent = parent
  this.destroyed = false
  stream.PassThrough.call(this)
}

inherits(MediaData, stream.PassThrough)

MediaData.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  this._parent.destroy(err)
  if (err) this.emit('error', err)
  this.emit('close')
}

}).call(this,require("buffer").Buffer)

},{"buffer":25,"inherits":70,"mp4-box-encoding":84,"next-event":90,"readable-stream":117}],86:[function(require,module,exports){
(function (process,Buffer){
var stream = require('readable-stream')
var inherits = require('inherits')
var Box = require('mp4-box-encoding')

module.exports = Encoder

function noop () {}

function Encoder () {
  if (!(this instanceof Encoder)) return new Encoder()
  stream.Readable.call(this)

  this.destroyed = false

  this._reading = false
  this._stream = null
  this._drain = null
  this._want = false
  this._onreadable = onreadable
  this._onend = onend

  var self = this

  function onreadable () {
    if (!self._want) return
    self._want = false
    self._read()
  }

  function onend () {
    self._stream = null
  }
}

inherits(Encoder, stream.Readable)

Encoder.prototype.mediaData =
Encoder.prototype.mdat = function (size, cb) {
  var stream = new MediaData(this)
  this.box({type: 'mdat', contentLength: size, encodeBufferLen: 8, stream: stream}, cb)
  return stream
}

Encoder.prototype.box = function (box, cb) {
  if (!cb) cb = noop
  if (this.destroyed) return cb(new Error('Encoder is destroyed'))

  var buf
  if (box.encodeBufferLen) {
    buf = new Buffer(box.encodeBufferLen)
  }
  if (box.stream) {
    box.buffer = null
    buf = Box.encode(box, buf)
    this.push(buf)
    this._stream = box.stream
    this._stream.on('readable', this._onreadable)
    this._stream.on('end', this._onend)
    this._stream.on('end', cb)
    this._forward()
  } else {
    buf = Box.encode(box, buf)
    var drained = this.push(buf)
    if (drained) return process.nextTick(cb)
    this._drain = cb
  }
}

Encoder.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  if (this._stream && this._stream.destroy) this._stream.destroy()
  this._stream = null
  if (this._drain) {
    var cb = this._drain
    this._drain = null
    cb(err)
  }
  if (err) this.emit('error', err)
  this.emit('close')
}

Encoder.prototype.finalize = function () {
  this.push(null)
}

Encoder.prototype._forward = function () {
  if (!this._stream) return

  while (!this.destroyed) {
    var buf = this._stream.read()

    if (!buf) {
      this._want = !!this._stream
      return
    }

    if (!this.push(buf)) return
  }
}

Encoder.prototype._read = function () {
  if (this._reading || this.destroyed) return
  this._reading = true

  if (this._stream) this._forward()
  if (this._drain) {
    var drain = this._drain
    this._drain = null
    drain()
  }

  this._reading = false
}

function MediaData (parent) {
  this._parent = parent
  this.destroyed = false
  stream.PassThrough.call(this)
}

inherits(MediaData, stream.PassThrough)

MediaData.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  this._parent.destroy(err)
  if (err) this.emit('error', err)
  this.emit('close')
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":104,"buffer":25,"inherits":70,"mp4-box-encoding":84,"readable-stream":117}],87:[function(require,module,exports){
exports.decode = require('./decode')
exports.encode = require('./encode')

},{"./decode":85,"./encode":86}],88:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],89:[function(require,module,exports){
module.exports = MultiStream

var inherits = require('inherits')
var stream = require('readable-stream')

inherits(MultiStream, stream.Readable)

function MultiStream (streams, opts) {
  if (!(this instanceof MultiStream)) return new MultiStream(streams, opts)
  stream.Readable.call(this, opts)

  this.destroyed = false

  this._drained = false
  this._forwarding = false
  this._current = null
  this._queue = (typeof streams === 'function' ? streams : streams.map(toStreams2))

  this._next()
}

MultiStream.obj = function (streams) {
  return new MultiStream(streams, { objectMode: true, highWaterMark: 16 })
}

MultiStream.prototype._read = function () {
  this._drained = true
  this._forward()
}

MultiStream.prototype._forward = function () {
  if (this._forwarding || !this._drained || !this._current) return
  this._forwarding = true

  var chunk
  while ((chunk = this._current.read()) !== null) {
    this._drained = this.push(chunk)
  }

  this._forwarding = false
}

MultiStream.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true

  if (this._current && this._current.destroy) this._current.destroy()
  if (typeof this._queue !== 'function') {
    this._queue.forEach(function (stream) {
      if (stream.destroy) stream.destroy()
    })
  }

  if (err) this.emit('error', err)
  this.emit('close')
}

MultiStream.prototype._next = function () {
  var self = this
  self._current = null

  if (typeof self._queue === 'function') {
    self._queue(function (err, stream) {
      if (err) return self.destroy(err)
      self._gotNextStream(toStreams2(stream))
    })
  } else {
    var stream = self._queue.shift()
    if (typeof stream === 'function') stream = toStreams2(stream())
    self._gotNextStream(stream)
  }
}

MultiStream.prototype._gotNextStream = function (stream) {
  var self = this

  if (!stream) {
    self.push(null)
    self.destroy()
    return
  }

  self._current = stream
  self._forward()

  stream.on('readable', onReadable)
  stream.on('end', onEnd)
  stream.on('error', onError)
  stream.on('close', onClose)

  function onReadable () {
    self._forward()
  }

  function onClose () {
    if (!stream._readableState.ended) {
      self.destroy()
    }
  }

  function onEnd () {
    self._current = null
    stream.removeListener('readable', onReadable)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onError)
    stream.removeListener('close', onClose)
    self._next()
  }

  function onError (err) {
    self.destroy(err)
  }
}

function toStreams2 (s) {
  if (!s || typeof s === 'function' || s._readableState) return s

  var wrap = new stream.Readable().wrap(s)
  if (s.destroy) {
    wrap.destroy = s.destroy.bind(s)
  }
  return wrap
}

},{"inherits":70,"readable-stream":117}],90:[function(require,module,exports){
module.exports = nextEvent

function nextEvent (emitter, name) {
  var next = null
  emitter.on(name, function (data) {
    if (!next) return
    var fn = next
    next = null
    fn(data)
  })

  return function (once) {
    next = once
  }
}

},{}],91:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},{"wrappy":180}],92:[function(require,module,exports){
(function (Buffer){
module.exports = decodeTorrentFile
module.exports.decode = decodeTorrentFile
module.exports.encode = encodeTorrentFile

var bencode = require('bencode')
var path = require('path')
var sha1 = require('simple-sha1')
var uniq = require('uniq')

/**
 * Parse a torrent. Throws an exception if the torrent is missing required fields.
 * @param  {Buffer|Object} torrent
 * @return {Object}        parsed torrent
 */
function decodeTorrentFile (torrent) {
  if (Buffer.isBuffer(torrent)) {
    torrent = bencode.decode(torrent)
  }

  // sanity check
  ensure(torrent.info, 'info')
  ensure(torrent.info['name.utf-8'] || torrent.info.name, 'info.name')
  ensure(torrent.info['piece length'], 'info[\'piece length\']')
  ensure(torrent.info.pieces, 'info.pieces')

  if (torrent.info.files) {
    torrent.info.files.forEach(function (file) {
      ensure(typeof file.length === 'number', 'info.files[0].length')
      ensure(file['path.utf-8'] || file.path, 'info.files[0].path')
    })
  } else {
    ensure(typeof torrent.info.length === 'number', 'info.length')
  }

  var result = {}
  result.info = torrent.info
  result.infoBuffer = bencode.encode(torrent.info)
  result.infoHash = sha1.sync(result.infoBuffer)
  result.infoHashBuffer = new Buffer(result.infoHash, 'hex')

  result.name = (torrent.info['name.utf-8'] || torrent.info.name).toString()

  if (torrent.info.private !== undefined) result.private = !!torrent.info.private

  if (torrent['creation date']) result.created = new Date(torrent['creation date'] * 1000)
  if (torrent['created by']) result.createdBy = torrent['created by'].toString()

  if (Buffer.isBuffer(torrent.comment)) result.comment = torrent.comment.toString()

  // announce and announce-list will be missing if metadata fetched via ut_metadata
  result.announce = []
  if (torrent['announce-list'] && torrent['announce-list'].length) {
    torrent['announce-list'].forEach(function (urls) {
      urls.forEach(function (url) {
        result.announce.push(url.toString())
      })
    })
  } else if (torrent.announce) {
    result.announce.push(torrent.announce.toString())
  }

  // handle url-list (BEP19 / web seeding)
  if (Buffer.isBuffer(torrent['url-list'])) {
    // some clients set url-list to empty string
    torrent['url-list'] = torrent['url-list'].length > 0
      ? [ torrent['url-list'] ]
      : []
  }
  result.urlList = (torrent['url-list'] || []).map(function (url) {
    return url.toString()
  })

  uniq(result.announce)
  uniq(result.urlList)

  var files = torrent.info.files || [ torrent.info ]
  result.files = files.map(function (file, i) {
    var parts = [].concat(result.name, file['path.utf-8'] || file.path || []).map(function (p) {
      return p.toString()
    })
    return {
      path: path.join.apply(null, [path.sep].concat(parts)).slice(1),
      name: parts[parts.length - 1],
      length: file.length,
      offset: files.slice(0, i).reduce(sumLength, 0)
    }
  })

  result.length = files.reduce(sumLength, 0)

  var lastFile = result.files[result.files.length - 1]

  result.pieceLength = torrent.info['piece length']
  result.lastPieceLength = ((lastFile.offset + lastFile.length) % result.pieceLength) || result.pieceLength
  result.pieces = splitPieces(torrent.info.pieces)

  return result
}

/**
 * Convert a parsed torrent object back into a .torrent file buffer.
 * @param  {Object} parsed parsed torrent
 * @return {Buffer}
 */
function encodeTorrentFile (parsed) {
  var torrent = {
    info: parsed.info
  }

  torrent['announce-list'] = (parsed.announce || []).map(function (url) {
    if (!torrent.announce) torrent.announce = url
    url = new Buffer(url, 'utf8')
    return [ url ]
  })

  torrent['url-list'] = parsed.urlList || []

  if (parsed.created) {
    torrent['creation date'] = (parsed.created.getTime() / 1000) | 0
  }

  if (parsed.createdBy) {
    torrent['created by'] = parsed.createdBy
  }

  if (parsed.comment) {
    torrent.comment = parsed.comment
  }

  return bencode.encode(torrent)
}

function sumLength (sum, file) {
  return sum + file.length
}

function splitPieces (buf) {
  var pieces = []
  for (var i = 0; i < buf.length; i += 20) {
    pieces.push(buf.slice(i, i + 20).toString('hex'))
  }
  return pieces
}

function ensure (bool, fieldName) {
  if (!bool) throw new Error('Torrent is missing required field: ' + fieldName)
}

}).call(this,require("buffer").Buffer)

},{"bencode":93,"buffer":25,"path":101,"simple-sha1":127,"uniq":156}],93:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./lib/decode":94,"./lib/encode":96,"dup":35}],94:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":95,"buffer":25}],95:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],96:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":25}],97:[function(require,module,exports){
(function (Buffer,process){
/* global Blob */

module.exports = parseTorrent
module.exports.remote = parseTorrentRemote

var blobToBuffer = require('blob-to-buffer')
var fs = require('fs') // browser exclude
var get = require('simple-get')
var magnet = require('magnet-uri')
var parseTorrentFile = require('parse-torrent-file')

module.exports.toMagnetURI = magnet.encode
module.exports.toTorrentFile = parseTorrentFile.encode

/**
 * Parse a torrent identifier (magnet uri, .torrent file, info hash)
 * @param  {string|Buffer|Object} torrentId
 * @return {Object}
 */
function parseTorrent (torrentId) {
  if (typeof torrentId === 'string' && /magnet:/.test(torrentId)) {
    // magnet uri (string)
    return magnet(torrentId)
  } else if (typeof torrentId === 'string' && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
    // info hash (hex/base-32 string)
    return magnet('magnet:?xt=urn:btih:' + torrentId)
  } else if (Buffer.isBuffer(torrentId) && torrentId.length === 20) {
    // info hash (buffer)
    return magnet('magnet:?xt=urn:btih:' + torrentId.toString('hex'))
  } else if (Buffer.isBuffer(torrentId)) {
    // .torrent file (buffer)
    return parseTorrentFile(torrentId) // might throw
  } else if (torrentId && torrentId.infoHash) {
    // parsed torrent (from `parse-torrent`, `parse-torrent-file`, or `magnet-uri`)
    if (!torrentId.announce) torrentId.announce = []
    if (typeof torrentId.announce === 'string') {
      torrentId.announce = [ torrentId.announce ]
    }
    if (!torrentId.urlList) torrentId.urlList = []
    return torrentId
  } else {
    throw new Error('Invalid torrent identifier')
  }
}

function parseTorrentRemote (torrentId, cb) {
  var parsedTorrent
  if (typeof cb !== 'function') throw new Error('second argument must be a Function')

  try {
    parsedTorrent = parseTorrent(torrentId)
  } catch (err) {
    // If torrent fails to parse, it could be a Blob, http/https URL or
    // filesystem path, so don't consider it an error yet.
  }

  if (parsedTorrent && parsedTorrent.infoHash) {
    process.nextTick(function () {
      cb(null, parsedTorrent)
    })
  } else if (isBlob(torrentId)) {
    blobToBuffer(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error('Error converting Blob: ' + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof get === 'function' && /^https?:/.test(torrentId)) {
    // http, or https url to torrent file
    get.concat({
      url: torrentId,
      headers: { 'user-agent': 'WebTorrent (http://webtorrent.io)' }
    }, function (err, res, torrentBuf) {
      if (err) return cb(new Error('Error downloading torrent: ' + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof fs.readFile === 'function' && typeof torrentId === 'string') {
    // assume it's a filesystem path
    fs.readFile(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error('Invalid torrent identifier'))
      parseOrThrow(torrentBuf)
    })
  } else {
    process.nextTick(function () {
      cb(new Error('Invalid torrent identifier'))
    })
  }

  function parseOrThrow (torrentBuf) {
    try {
      parsedTorrent = parseTorrent(torrentBuf)
    } catch (err) {
      return cb(err)
    }
    if (parsedTorrent && parsedTorrent.infoHash) cb(null, parsedTorrent)
    else cb(new Error('Invalid torrent identifier'))
  }
}

/**
 * Check if `obj` is a W3C `Blob` or `File` object
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

}).call(this,{"isBuffer":require("../is-buffer/index.js")},require('_process'))

},{"../is-buffer/index.js":73,"_process":104,"blob-to-buffer":19,"fs":23,"magnet-uri":79,"parse-torrent-file":92,"simple-get":125}],98:[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],99:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],100:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],101:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":104}],102:[function(require,module,exports){
var closest = require('closest-to')

// Create a range from 16kb–4mb
var sizes = []
for (var i = 14; i <= 22; i++) {
  sizes.push(Math.pow(2, i))
}

module.exports = function(size) {
  return closest(
    size / Math.pow(2, 10), sizes 
  )
}

},{"closest-to":28}],103:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":104}],104:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],105:[function(require,module,exports){
var once = require('once')
var eos = require('end-of-stream')
var fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close() // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump

},{"end-of-stream":42,"fs":23,"once":91}],106:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],107:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],108:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],109:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":107,"./encode":108}],110:[function(require,module,exports){
var iterate = function (list) {
  var offset = 0
  return function () {
    if (offset === list.length) return null

    var len = list.length - offset
    var i = (Math.random() * len) | 0
    var el = list[offset + i]

    var tmp = list[offset]
    list[offset] = el
    list[offset + i] = tmp
    offset++

    return el
  }
}

module.exports = iterate

},{}],111:[function(require,module,exports){
/*
Instance of writable stream.

call .get(length) or .discard(length) to get a stream (relative to the last end)

emits 'stalled' once everything is written


*/
var inherits = require('inherits')
var stream = require('readable-stream')

module.exports = RangeSliceStream

inherits(RangeSliceStream, stream.Writable)

function RangeSliceStream (offset) {
	var self = this
	if (!(self instanceof RangeSliceStream)) return new RangeSliceStream(offset)
	stream.Writable.call(self)

	self.destroyed = false
	self._queue = []
	self._position = offset || 0
	self._cb = null
	self._buffer = null
	self._out = null
}

RangeSliceStream.prototype._write = function (chunk, encoding, cb) {
	var self = this

	var drained = true

	while (true) {
		if (self.destroyed) {
			return
		}

		// Wait for more queue entries
		if (self._queue.length === 0) {
			self._buffer = chunk
			self._cb = cb
			return
		}

		self._buffer = null
		var currRange = self._queue[0]
		// Relative to the start of chunk, what data do we need?
		var writeStart = Math.max(currRange.start - self._position, 0)
		var writeEnd = currRange.end - self._position

		// Check if we need to throw it all away
		if (writeStart >= chunk.length) {
			self._position += chunk.length
			return cb(null)
		}

		// Check if we need to use it all
		var toWrite
		if (writeEnd > chunk.length) {
			self._position += chunk.length
			if (writeStart === 0) {
				toWrite = chunk
			} else {
				toWrite = chunk.slice(writeStart)
			}
			drained = currRange.stream.write(toWrite) && drained
			break
		}

		self._position += writeEnd
		if (writeStart === 0 && writeEnd === chunk.length) {
			toWrite = chunk
		} else {
			toWrite = chunk.slice(writeStart, writeEnd)
		}
		drained = currRange.stream.write(toWrite) && drained
		if (currRange.last) {
			currRange.stream.end()
		}
		chunk = chunk.slice(writeEnd)
		self._queue.shift()
	}

	if (drained) {
		cb(null)
	} else {
		currRange.stream.once('drain', cb.bind(null, null))
	}
}

RangeSliceStream.prototype.slice = function (ranges) {
	var self = this

	if (self.destroyed) return null

	if (!(ranges instanceof Array)) {
		ranges = [ranges]
	}

	var str = new stream.PassThrough()

	ranges.forEach(function (range, i) {
		self._queue.push({
			start: range.start,
			end: range.end,
			stream: str,
			last: i === (ranges.length - 1)
		})
	})
	if (self._buffer) {
		self._write(self._buffer, null, self._cb)
	}

	return str
}

RangeSliceStream.prototype.destroy = function (err) {
	var self = this
	if (self.destroyed) return
	self.destroyed = true

	if (err) self.emit('error', err)
}

},{"inherits":70,"readable-stream":117}],112:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":114,"./_stream_writable":116,"core-util-is":33,"inherits":70,"process-nextick-args":103}],113:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":115,"core-util-is":33,"inherits":70}],114:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var hasPrependListener = typeof EE.prototype.prependListener === 'function';

function prependListener(emitter, event, fn) {
  if (hasPrependListener) return emitter.prependListener(event, fn);

  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS. This is here
  // only because this code needs to continue to work with older versions
  // of Node.js that do not include the prependListener() method. The goal
  // is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var _buf = list[0];
        var cpy = Math.min(n - c, _buf.length);

        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);

        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":112,"_process":104,"buffer":25,"buffer-shims":24,"core-util-is":33,"events":58,"inherits":70,"isarray":76,"process-nextick-args":103,"string_decoder/":147,"util":22}],115:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":112,"core-util-is":33,"inherits":70}],116:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":112,"_process":104,"buffer":25,"buffer-shims":24,"core-util-is":33,"events":58,"inherits":70,"process-nextick-args":103,"util-deprecate":167}],117:[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))

},{"./lib/_stream_duplex.js":112,"./lib/_stream_passthrough.js":113,"./lib/_stream_readable.js":114,"./lib/_stream_transform.js":115,"./lib/_stream_writable.js":116,"_process":104}],118:[function(require,module,exports){
exports.render = render
exports.append = append
var mime = exports.mime = require('./lib/mime.json')

var debug = require('debug')('render-media')
var isAscii = require('is-ascii')
var MediaElementWrapper = require('mediasource')
var path = require('path')
var streamToBlobURL = require('stream-to-blob-url')
var videostream = require('videostream')

var VIDEOSTREAM_EXTS = [ '.mp4', '.m4v', '.m4a' ]

var MEDIASOURCE_VIDEO_EXTS = [ '.mp4', '.m4v', '.webm', '.mkv' ]
var MEDIASOURCE_AUDIO_EXTS = [ '.m4a', '.mp3' ]
var MEDIASOURCE_EXTS = MEDIASOURCE_VIDEO_EXTS.concat(MEDIASOURCE_AUDIO_EXTS)

var AUDIO_EXTS = [ '.wav', '.aac', '.ogg', '.oga' ]
var IMAGE_EXTS = [ '.jpg', '.jpeg', '.png', '.gif', '.bmp' ]
var IFRAME_EXTS = [ '.css', '.html', '.js', '.md', '.pdf', '.txt' ]

var MediaSource = typeof window !== 'undefined' && window.MediaSource

function render (file, elem, cb) {
  validateFile(file)
  if (typeof elem === 'string') elem = document.querySelector(elem)

  renderMedia(file, function (tagName) {
    if (elem.nodeName !== tagName.toUpperCase()) {
      var extname = path.extname(file.name).toLowerCase()

      throw new Error(
        'Cannot render "' + extname + '" inside a "' +
        elem.nodeName.toLowerCase() + '" element, expected "' + tagName + '"'
      )
    }

    return elem
  }, cb)
}

function append (file, rootElem, cb) {
  if (!cb) cb = function () {}
  validateFile(file)
  if (typeof rootElem === 'string') rootElem = document.querySelector(rootElem)

  if (rootElem && (rootElem.nodeName === 'VIDEO' || rootElem.nodeName === 'AUDIO')) {
    throw new Error(
      'Invalid video/audio node argument. Argument must be root element that ' +
      'video/audio tag will be appended to.'
    )
  }

  renderMedia(file, function (tagName) {
    if (tagName === 'video' || tagName === 'audio') return createMedia(tagName)
    else return createElem(tagName)
  }, function (err, elem) {
    if (err && elem) elem.remove()
    cb(err, elem)
  })

  function createMedia (tagName) {
    var elem = createElem(tagName)
    elem.controls = true
    elem.autoplay = true
    rootElem.appendChild(elem)
    return elem
  }

  function createElem (tagName) {
    var elem = document.createElement(tagName)
    rootElem.appendChild(elem)
    return elem
  }
}

function renderMedia (file, getElem, cb) {
  if (!cb) cb = function () {}
  var extname = path.extname(file.name).toLowerCase()
  var currentTime = 0
  var elem

  if (MEDIASOURCE_EXTS.indexOf(extname) >= 0) {
    renderMediaSource()
  } else if (AUDIO_EXTS.indexOf(extname) >= 0) {
    renderAudio()
  } else if (IMAGE_EXTS.indexOf(extname) >= 0) {
    renderImage()
  } else if (IFRAME_EXTS.indexOf(extname) >= 0) {
    renderIframe()
  } else {
    tryRenderIframe()
  }

  function renderMediaSource () {
    var tagName = MEDIASOURCE_VIDEO_EXTS.indexOf(extname) >= 0 ? 'video' : 'audio'

    if (MediaSource) {
      if (VIDEOSTREAM_EXTS.indexOf(extname) >= 0) {
        useVideostream()
      } else {
        useMediaSource()
      }
    } else {
      useBlobURL()
    }

    function useVideostream () {
      debug('Use `videostream` package for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fallbackToMediaSource)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      videostream(file, elem)
    }

    function useMediaSource () {
      debug('Use MediaSource API for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fallbackToBlobURL)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)

      var wrapper = new MediaElementWrapper(elem)
      var writable = wrapper.createWriteStream(getCodec(file.name))
      file.createReadStream().pipe(writable)

      if (currentTime) elem.currentTime = currentTime
    }

    function useBlobURL () {
      debug('Use Blob URL for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fatalError)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      getBlobURL(file, function (err, url) {
        if (err) return fatalError(err)
        elem.src = url
        if (currentTime) elem.currentTime = currentTime
      })
    }

    function fallbackToMediaSource (err) {
      debug('videostream error: fallback to MediaSource API: %o', err.message || err)
      elem.removeEventListener('error', fallbackToMediaSource)
      elem.removeEventListener('canplay', onCanPlay)

      useMediaSource()
    }

    function fallbackToBlobURL (err) {
      debug('MediaSource API error: fallback to Blob URL: %o', err.message || err)
      elem.removeEventListener('error', fallbackToBlobURL)
      elem.removeEventListener('canplay', onCanPlay)

      useBlobURL()
    }

    function prepareElem () {
      if (!elem) {
        elem = getElem(tagName)

        elem.addEventListener('progress', function () {
          currentTime = elem.currentTime
        })
      }
    }
  }

  function renderAudio () {
    elem = getElem('audio')
    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.addEventListener('error', fatalError)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      elem.src = url
    })
  }

  function onLoadStart () {
    elem.removeEventListener('loadstart', onLoadStart)
    elem.play()
  }

  function onCanPlay () {
    elem.removeEventListener('canplay', onCanPlay)
    cb(null, elem)
  }

  function renderImage () {
    elem = getElem('img')
    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.src = url
      elem.alt = file.name
      cb(null, elem)
    })
  }

  function renderIframe () {
    elem = getElem('iframe')

    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.src = url
      if (extname !== '.pdf') elem.sandbox = 'allow-forms allow-scripts'
      cb(null, elem)
    })
  }

  function tryRenderIframe () {
    debug('Unknown file extension "%s" - will attempt to render into iframe', extname)

    var str = ''
    file.createReadStream({ start: 0, end: 1000 })
      .setEncoding('utf8')
      .on('data', function (chunk) {
        str += chunk
      })
      .on('end', done)
      .on('error', cb)

    function done () {
      if (isAscii(str)) {
        debug('File extension "%s" appears ascii, so will render.', extname)
        renderIframe()
      } else {
        debug('File extension "%s" appears non-ascii, will not render.', extname)
        cb(new Error('Unsupported file type "' + extname + '": Cannot append to DOM'))
      }
    }
  }

  function fatalError (err) {
    err.message = 'Error rendering file "' + file.name + '": ' + err.message
    debug(err.message)
    cb(err)
  }
}

function getBlobURL (file, cb) {
  var extname = path.extname(file.name).toLowerCase()
  streamToBlobURL(file.createReadStream(), mime[extname], cb)
}

function validateFile (file) {
  if (file == null) {
    throw new Error('file cannot be null or undefined')
  }
  if (typeof file.name !== 'string') {
    throw new Error('missing or invalid file.name property')
  }
  if (typeof file.createReadStream !== 'function') {
    throw new Error('missing or invalid file.createReadStream property')
  }
}

function getCodec (name) {
  var extname = path.extname(name).toLowerCase()
  return {
    '.m4a': 'audio/mp4; codecs="mp4a.40.5"',
    '.m4v': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.mkv': 'video/webm; codecs="avc1.640029, mp4a.40.5"',
    '.mp3': 'audio/mpeg',
    '.mp4': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.webm': 'video/webm; codecs="vorbis, vp8"'
  }[extname]
}

},{"./lib/mime.json":119,"debug":39,"is-ascii":72,"mediasource":80,"path":101,"stream-to-blob-url":144,"videostream":171}],119:[function(require,module,exports){
module.exports={
  ".3gp": "video/3gpp",
  ".aac": "audio/aac",
  ".aif": "audio/x-aiff",
  ".aiff": "audio/x-aiff",
  ".atom": "application/atom+xml",
  ".avi": "video/x-msvideo",
  ".bmp": "image/bmp",
  ".bz2": "application/x-bzip2",
  ".conf": "text/plain",
  ".css": "text/css",
  ".csv": "text/csv",
  ".diff": "text/x-diff",
  ".doc": "application/msword",
  ".flv": "video/x-flv",
  ".gif": "image/gif",
  ".gz": "application/x-gzip",
  ".htm": "text/html",
  ".html": "text/html",
  ".ico": "image/vnd.microsoft.icon",
  ".ics": "text/calendar",
  ".iso": "application/octet-stream",
  ".jar": "application/java-archive",
  ".jpeg": "image/jpeg",
  ".jpg": "image/jpeg",
  ".js": "application/javascript",
  ".json": "application/json",
  ".less": "text/css",
  ".log": "text/plain",
  ".m3u": "audio/x-mpegurl",
  ".m4a": "audio/mp4",
  ".m4v": "video/mp4",
  ".manifest": "text/cache-manifest",
  ".markdown": "text/x-markdown",
  ".mathml": "application/mathml+xml",
  ".md": "text/x-markdown",
  ".mid": "audio/midi",
  ".midi": "audio/midi",
  ".mov": "video/quicktime",
  ".mp3": "audio/mpeg",
  ".mp4": "video/mp4",
  ".mp4v": "video/mp4",
  ".mpeg": "video/mpeg",
  ".mpg": "video/mpeg",
  ".odp": "application/vnd.oasis.opendocument.presentation",
  ".ods": "application/vnd.oasis.opendocument.spreadsheet",
  ".odt": "application/vnd.oasis.opendocument.text",
  ".oga": "audio/ogg",
  ".ogg": "application/ogg",
  ".pdf": "application/pdf",
  ".png": "image/png",
  ".pps": "application/vnd.ms-powerpoint",
  ".ppt": "application/vnd.ms-powerpoint",
  ".ps": "application/postscript",
  ".psd": "image/vnd.adobe.photoshop",
  ".qt": "video/quicktime",
  ".rar": "application/x-rar-compressed",
  ".rdf": "application/rdf+xml",
  ".rss": "application/rss+xml",
  ".rtf": "application/rtf",
  ".svg": "image/svg+xml",
  ".svgz": "image/svg+xml",
  ".swf": "application/x-shockwave-flash",
  ".tar": "application/x-tar",
  ".tbz": "application/x-bzip-compressed-tar",
  ".text": "text/plain",
  ".tif": "image/tiff",
  ".tiff": "image/tiff",
  ".torrent": "application/x-bittorrent",
  ".ttf": "application/x-font-ttf",
  ".txt": "text/plain",
  ".wav": "audio/wav",
  ".webm": "video/webm",
  ".wma": "audio/x-ms-wma",
  ".wmv": "video/x-ms-wmv",
  ".xls": "application/vnd.ms-excel",
  ".xml": "application/xml",
  ".yaml": "text/yaml",
  ".yml": "text/yaml",
  ".zip": "application/zip"
}

},{}],120:[function(require,module,exports){
(function (process){
module.exports = function (tasks, limit, cb) {
  if (typeof limit !== 'number') throw new Error('second argument must be a Number')
  var results, len, pending, keys, isErrored
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = len = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = len = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (err) isErrored = true
    if (--pending === 0 || err) {
      done(err)
    } else if (!isErrored && next < len) {
      var key
      if (keys) {
        key = keys[next]
        next += 1
        tasks[key](function (err, result) { each(key, err, result) })
      } else {
        key = next
        next += 1
        tasks[key](function (err, result) { each(key, err, result) })
      }
    }
  }

  var next = limit
  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.some(function (key, i) {
      tasks[key](function (err, result) { each(key, err, result) })
      if (i === limit - 1) return true // early return
    })
  } else {
    // array
    tasks.some(function (task, i) {
      task(function (err, result) { each(i, err, result) })
      if (i === limit - 1) return true // early return
    })
  }

  isSync = false
}

}).call(this,require('_process'))

},{"_process":104}],121:[function(require,module,exports){
(function (process){
module.exports = function (tasks, cb) {
  var results, pending, keys
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}

}).call(this,require('_process'))

},{"_process":104}],122:[function(require,module,exports){
(function (global){
/*
 * Rusha, a JavaScript implementation of the Secure Hash Algorithm, SHA-1,
 * as defined in FIPS PUB 180-1, tuned for high performance with large inputs.
 * (http://github.com/srijs/rusha)
 *
 * Inspired by Paul Johnstons implementation (http://pajhome.org.uk/crypt/md5).
 *
 * Copyright (c) 2013 Sam Rijs (http://awesam.de).
 * Released under the terms of the MIT license as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
(function () {
    var util = {
            getDataType: function (data) {
                if (typeof data === 'string') {
                    return 'string';
                }
                if (data instanceof Array) {
                    return 'array';
                }
                if (typeof global !== 'undefined' && global.Buffer && global.Buffer.isBuffer(data)) {
                    return 'buffer';
                }
                if (data instanceof ArrayBuffer) {
                    return 'arraybuffer';
                }
                if (data.buffer instanceof ArrayBuffer) {
                    return 'view';
                }
                if (data instanceof Blob) {
                    return 'blob';
                }
                throw new Error('Unsupported data type.');
            }
        };
    // The Rusha object is a wrapper around the low-level RushaCore.
    // It provides means of converting different inputs to the
    // format accepted by RushaCore as well as other utility methods.
    function Rusha(chunkSize) {
        'use strict';
        // Private object structure.
        var self$2 = { fill: 0 };
        // Calculate the length of buffer that the sha1 routine uses
        // including the padding.
        var padlen = function (len) {
            for (len += 9; len % 64 > 0; len += 1);
            return len;
        };
        var padZeroes = function (bin, len) {
            for (var i = len >> 2; i < bin.length; i++)
                bin[i] = 0;
        };
        var padData = function (bin, chunkLen, msgLen) {
            bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
            bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen >> 29;
            bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
        };
        // Convert a binary string and write it to the heap.
        // A binary string is expected to only contain char codes < 256.
        var convStr = function (H8, H32, start, len, off) {
            var str = this, i, om = off % 4, lm = len % 4, j = len - lm;
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = str.charCodeAt(start);
                case 1:
                    H8[off + 2 | 0] = str.charCodeAt(start + 1);
                case 2:
                    H8[off + 1 | 0] = str.charCodeAt(start + 2);
                case 3:
                    H8[off | 0] = str.charCodeAt(start + 3);
                }
            }
            for (i = om; i < j; i = i + 4 | 0) {
                H32[off + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
            case 2:
                H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
            case 1:
                H8[off + j + 3 | 0] = str.charCodeAt(start + j);
            }
        };
        // Convert a buffer or array and write it to the heap.
        // The buffer or array is expected to only contain elements < 256.
        var convBuf = function (H8, H32, start, len, off) {
            var buf = this, i, om = off % 4, lm = len % 4, j = len - lm;
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = buf[start];
                case 1:
                    H8[off + 2 | 0] = buf[start + 1];
                case 2:
                    H8[off + 1 | 0] = buf[start + 2];
                case 3:
                    H8[off | 0] = buf[start + 3];
                }
            }
            for (i = 4 - om; i < j; i = i += 4 | 0) {
                H32[off + i >> 2] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[start + j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[start + j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[start + j];
            }
        };
        var convBlob = function (H8, H32, start, len, off) {
            var blob = this, i, om = off % 4, lm = len % 4, j = len - lm;
            var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = buf[0];
                case 1:
                    H8[off + 2 | 0] = buf[1];
                case 2:
                    H8[off + 1 | 0] = buf[2];
                case 3:
                    H8[off | 0] = buf[3];
                }
            }
            for (i = 4 - om; i < j; i = i += 4 | 0) {
                H32[off + i >> 2] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[j];
            }
        };
        var convFn = function (data) {
            switch (util.getDataType(data)) {
            case 'string':
                return convStr.bind(data);
            case 'array':
                return convBuf.bind(data);
            case 'buffer':
                return convBuf.bind(data);
            case 'arraybuffer':
                return convBuf.bind(new Uint8Array(data));
            case 'view':
                return convBuf.bind(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            case 'blob':
                return convBlob.bind(data);
            }
        };
        var slice = function (data, offset) {
            switch (util.getDataType(data)) {
            case 'string':
                return data.slice(offset);
            case 'array':
                return data.slice(offset);
            case 'buffer':
                return data.slice(offset);
            case 'arraybuffer':
                return data.slice(offset);
            case 'view':
                return data.buffer.slice(offset);
            }
        };
        // Convert an ArrayBuffer into its hexadecimal string representation.
        var hex = function (arrayBuffer) {
            var i, x, hex_tab = '0123456789abcdef', res = [], binarray = new Uint8Array(arrayBuffer);
            for (i = 0; i < binarray.length; i++) {
                x = binarray[i];
                res[i] = hex_tab.charAt(x >> 4 & 15) + hex_tab.charAt(x >> 0 & 15);
            }
            return res.join('');
        };
        var ceilHeapSize = function (v) {
            // The asm.js spec says:
            // The heap object's byteLength must be either
            // 2^n for n in [12, 24) or 2^24 * n for n ≥ 1.
            // Also, byteLengths smaller than 2^16 are deprecated.
            var p;
            // If v is smaller than 2^16, the smallest possible solution
            // is 2^16.
            if (v <= 65536)
                return 65536;
            // If v < 2^24, we round up to 2^n,
            // otherwise we round up to 2^24 * n.
            if (v < 16777216) {
                for (p = 1; p < v; p = p << 1);
            } else {
                for (p = 16777216; p < v; p += 16777216);
            }
            return p;
        };
        // Initialize the internal data structures to a new capacity.
        var init = function (size) {
            if (size % 64 > 0) {
                throw new Error('Chunk size must be a multiple of 128 bit');
            }
            self$2.maxChunkLen = size;
            self$2.padMaxChunkLen = padlen(size);
            // The size of the heap is the sum of:
            // 1. The padded input message size
            // 2. The extended space the algorithm needs (320 byte)
            // 3. The 160 bit state the algoritm uses
            self$2.heap = new ArrayBuffer(ceilHeapSize(self$2.padMaxChunkLen + 320 + 20));
            self$2.h32 = new Int32Array(self$2.heap);
            self$2.h8 = new Int8Array(self$2.heap);
            self$2.core = new Rusha._core({
                Int32Array: Int32Array,
                DataView: DataView
            }, {}, self$2.heap);
            self$2.buffer = null;
        };
        // Iinitializethe datastructures according
        // to a chunk siyze.
        init(chunkSize || 64 * 1024);
        var initState = function (heap, padMsgLen) {
            var io = new Int32Array(heap, padMsgLen + 320, 5);
            io[0] = 1732584193;
            io[1] = -271733879;
            io[2] = -1732584194;
            io[3] = 271733878;
            io[4] = -1009589776;
        };
        var padChunk = function (chunkLen, msgLen) {
            var padChunkLen = padlen(chunkLen);
            var view = new Int32Array(self$2.heap, 0, padChunkLen >> 2);
            padZeroes(view, chunkLen);
            padData(view, chunkLen, msgLen);
            return padChunkLen;
        };
        // Write data to the heap.
        var write = function (data, chunkOffset, chunkLen) {
            convFn(data)(self$2.h8, self$2.h32, chunkOffset, chunkLen, 0);
        };
        // Initialize and call the RushaCore,
        // assuming an input buffer of length len * 4.
        var coreCall = function (data, chunkOffset, chunkLen, msgLen, finalize) {
            var padChunkLen = chunkLen;
            if (finalize) {
                padChunkLen = padChunk(chunkLen, msgLen);
            }
            write(data, chunkOffset, chunkLen);
            self$2.core.hash(padChunkLen, self$2.padMaxChunkLen);
        };
        var getRawDigest = function (heap, padMaxChunkLen) {
            var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
            var out = new Int32Array(5);
            var arr = new DataView(out.buffer);
            arr.setInt32(0, io[0], false);
            arr.setInt32(4, io[1], false);
            arr.setInt32(8, io[2], false);
            arr.setInt32(12, io[3], false);
            arr.setInt32(16, io[4], false);
            return out;
        };
        // Calculate the hash digest as an array of 5 32bit integers.
        var rawDigest = this.rawDigest = function (str) {
                var msgLen = str.byteLength || str.length || str.size || 0;
                initState(self$2.heap, self$2.padMaxChunkLen);
                var chunkOffset = 0, chunkLen = self$2.maxChunkLen, last;
                for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                    coreCall(str, chunkOffset, chunkLen, msgLen, false);
                }
                coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
                return getRawDigest(self$2.heap, self$2.padMaxChunkLen);
            };
        // The digest and digestFrom* interface returns the hash digest
        // as a hex string.
        this.digest = this.digestFromString = this.digestFromBuffer = this.digestFromArrayBuffer = function (str) {
            return hex(rawDigest(str).buffer);
        };
    }
    ;
    // The low-level RushCore module provides the heart of Rusha,
    // a high-speed sha1 implementation working on an Int32Array heap.
    // At first glance, the implementation seems complicated, however
    // with the SHA1 spec at hand, it is obvious this almost a textbook
    // implementation that has a few functions hand-inlined and a few loops
    // hand-unrolled.
    Rusha._core = function RushaCore(stdlib, foreign, heap) {
        'use asm';
        var H = new stdlib.Int32Array(heap);
        function hash(k, x) {
            // k in bytes
            k = k | 0;
            x = x | 0;
            var i = 0, j = 0, y0 = 0, z0 = 0, y1 = 0, z1 = 0, y2 = 0, z2 = 0, y3 = 0, z3 = 0, y4 = 0, z4 = 0, t0 = 0, t1 = 0;
            y0 = H[x + 320 >> 2] | 0;
            y1 = H[x + 324 >> 2] | 0;
            y2 = H[x + 328 >> 2] | 0;
            y3 = H[x + 332 >> 2] | 0;
            y4 = H[x + 336 >> 2] | 0;
            for (i = 0; (i | 0) < (k | 0); i = i + 64 | 0) {
                z0 = y0;
                z1 = y1;
                z2 = y2;
                z3 = y3;
                z4 = y4;
                for (j = 0; (j | 0) < 64; j = j + 4 | 0) {
                    t1 = H[i + j >> 2] | 0;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[k + j >> 2] = t1;
                }
                for (j = k + 64 | 0; (j | 0) < (k + 80 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 80 | 0; (j | 0) < (k + 160 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) + 1859775393 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 160 | 0; (j | 0) < (k + 240 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | y1 & y3 | y2 & y3) | 0) + ((t1 + y4 | 0) - 1894007588 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 240 | 0; (j | 0) < (k + 320 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) - 899497514 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                y0 = y0 + z0 | 0;
                y1 = y1 + z1 | 0;
                y2 = y2 + z2 | 0;
                y3 = y3 + z3 | 0;
                y4 = y4 + z4 | 0;
            }
            H[x + 320 >> 2] = y0;
            H[x + 324 >> 2] = y1;
            H[x + 328 >> 2] = y2;
            H[x + 332 >> 2] = y3;
            H[x + 336 >> 2] = y4;
        }
        return { hash: hash };
    };
    // If we'e running in Node.JS, export a module.
    if (typeof module !== 'undefined') {
        module.exports = Rusha;
    } else if (typeof window !== 'undefined') {
        window.Rusha = Rusha;
    }
    // If we're running in a webworker, accept
    // messages containing a jobid and a buffer
    // or blob object, and return the hash result.
    if (typeof FileReaderSync !== 'undefined') {
        var reader = new FileReaderSync(), hasher = new Rusha(4 * 1024 * 1024);
        self.onmessage = function onMessage(event) {
            var hash, data = event.data.data;
            try {
                hash = hasher.digest(data);
                self.postMessage({
                    id: event.data.id,
                    hash: hash
                });
            } catch (e) {
                self.postMessage({
                    id: event.data.id,
                    error: e.name
                });
            }
        };
    }
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],123:[function(require,module,exports){
module.exports = require('buffer')

},{"buffer":25}],124:[function(require,module,exports){
(function (Buffer){
module.exports = function (stream, cb) {
  var chunks = []
  stream.on('data', function (chunk) {
    chunks.push(chunk)
  })
  stream.once('end', function () {
    if (cb) cb(null, Buffer.concat(chunks))
    cb = null
  })
  stream.once('error', function (err) {
    if (cb) cb(err)
    cb = null
  })
}

}).call(this,require("buffer").Buffer)

},{"buffer":25}],125:[function(require,module,exports){
(function (Buffer){
module.exports = simpleGet

var extend = require('xtend')
var http = require('http')
var https = require('https')
var once = require('once')
var unzipResponse = require('unzip-response') // excluded from browser build
var url = require('url')

function simpleGet (opts, cb) {
  opts = typeof opts === 'string' ? { url: opts } : extend(opts)
  cb = once(cb)

  if (opts.url) parseOptsUrl(opts)
  if (opts.headers == null) opts.headers = {}
  if (opts.maxRedirects == null) opts.maxRedirects = 10

  var body = opts.body
  opts.body = undefined
  if (body && !opts.method) opts.method = 'POST'

  // Request gzip/deflate
  var customAcceptEncoding = Object.keys(opts.headers).some(function (h) {
    return h.toLowerCase() === 'accept-encoding'
  })
  if (!customAcceptEncoding) opts.headers['accept-encoding'] = 'gzip, deflate'

  // Support http: and https: urls
  var protocol = opts.protocol === 'https:' ? https : http
  var req = protocol.request(opts, function (res) {
    // Follow 3xx redirects
    if (res.statusCode >= 300 && res.statusCode < 400 && 'location' in res.headers) {
      opts.url = res.headers.location
      parseOptsUrl(opts)
      res.resume() // Discard response

      opts.maxRedirects -= 1
      if (opts.maxRedirects > 0) simpleGet(opts, cb)
      else cb(new Error('too many redirects'))

      return
    }

    cb(null, typeof unzipResponse === 'function' ? unzipResponse(res) : res)
  })
  req.on('error', cb)
  req.end(body)
  return req
}

module.exports.concat = function (opts, cb) {
  return simpleGet(opts, function (err, res) {
    if (err) return cb(err)
    var chunks = []
    res.on('data', function (chunk) {
      chunks.push(chunk)
    })
    res.on('end', function () {
      cb(null, res, Buffer.concat(chunks))
    })
  })
}

;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(function (method) {
  module.exports[method] = function (opts, cb) {
    if (typeof opts === 'string') opts = { url: opts }
    opts.method = method.toUpperCase()
    return simpleGet(opts, cb)
  }
})

function parseOptsUrl (opts) {
  var loc = url.parse(opts.url)
  if (loc.hostname) opts.hostname = loc.hostname
  if (loc.port) opts.port = loc.port
  if (loc.protocol) opts.protocol = loc.protocol
  if (loc.auth) opts.auth = loc.auth
  opts.path = loc.path
  delete opts.url
}

}).call(this,require("buffer").Buffer)

},{"buffer":25,"http":140,"https":66,"once":91,"unzip-response":22,"url":158,"xtend":181}],126:[function(require,module,exports){
(function (Buffer){
module.exports = Peer

var debug = require('debug')('simple-peer')
var getBrowserRTC = require('get-browser-rtc')
var hat = require('hat')
var inherits = require('inherits')
var once = require('once')
var stream = require('readable-stream')

inherits(Peer, stream.Duplex)

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
function Peer (opts) {
  var self = this
  if (!(self instanceof Peer)) return new Peer(opts)
  self._debug('new peer %o', opts)

  if (!opts) opts = {}
  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.initiator = opts.initiator || false
  self.channelConfig = opts.channelConfig || Peer.channelConfig
  self.channelName = opts.initiator ? (opts.channelName || hat(160)) : null
  self.config = opts.config || Peer.config
  self.constraints = opts.constraints || Peer.constraints
  self.offerConstraints = opts.offerConstraints
  self.answerConstraints = opts.answerConstraints
  self.reconnectTimer = opts.reconnectTimer || false
  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }
  self.stream = opts.stream || false
  self.trickle = opts.trickle !== undefined ? opts.trickle : true

  self.destroyed = false
  self.connected = false

  // so Peer object always has same shape (V8 optimization)
  self.remoteAddress = undefined
  self.remoteFamily = undefined
  self.remotePort = undefined
  self.localAddress = undefined
  self.localPort = undefined

  self._isWrtc = !!opts.wrtc // HACK: to fix `wrtc` bug. See issue: #60
  self._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
    ? opts.wrtc
    : getBrowserRTC()
  if (!self._wrtc) {
    if (typeof window === 'undefined') {
      throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment')
    } else {
      throw new Error('No WebRTC support: Not a supported browser')
    }
  }

  self._maxBufferedAmount = opts.highWaterMark
  self._pcReady = false
  self._channelReady = false
  self._iceComplete = false // ice candidate trickle done (got null candidate)
  self._channel = null
  self._pendingCandidates = []

  self._chunk = null
  self._cb = null
  self._interval = null
  self._reconnectTimeout = null

  self._pc = new (self._wrtc.RTCPeerConnection)(self.config, self.constraints)
  self._pc.oniceconnectionstatechange = function () {
    self._onIceConnectionStateChange()
  }
  self._pc.onsignalingstatechange = function () {
    self._onSignalingStateChange()
  }
  self._pc.onicecandidate = function (event) {
    self._onIceCandidate(event)
  }

  if (self.stream) self._pc.addStream(self.stream)
  self._pc.onaddstream = function (event) {
    self._onAddStream(event)
  }

  if (self.initiator) {
    self._setupData({
      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)
    })
    self._pc.onnegotiationneeded = once(function () {
      self._createOffer()
    })
    // Only Chrome triggers "negotiationneeded"; this is a workaround for other
    // implementations
    if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {
      self._pc.onnegotiationneeded()
    }
  } else {
    self._pc.ondatachannel = function (event) {
      self._setupData(event)
    }
  }

  self.on('finish', function () {
    if (self.connected) {
      // When local peer is finished writing, close connection to remote peer.
      // Half open connections are currently not supported.
      // Wait a bit before destroying so the datachannel flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If data channel is not connected when local peer is finished writing, wait until
      // data is flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose config, constraints, and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      url: 'stun:23.21.150.121', // deprecated, replaced by `urls`
      urls: 'stun:23.21.150.121'
    }
  ]
}
Peer.constraints = {}
Peer.channelConfig = {}

Object.defineProperty(Peer.prototype, 'bufferSize', {
  get: function () {
    var self = this
    return (self._channel && self._channel.bufferedAmount) || 0
  }
})

Peer.prototype.address = function () {
  var self = this
  return { port: self.localPort, family: 'IPv4', address: self.localAddress }
}

Peer.prototype.signal = function (data) {
  var self = this
  if (self.destroyed) throw new Error('cannot signal after peer is destroyed')
  if (typeof data === 'string') {
    try {
      data = JSON.parse(data)
    } catch (err) {
      data = {}
    }
  }
  self._debug('signal()')

  function addIceCandidate (candidate) {
    try {
      self._pc.addIceCandidate(
        new self._wrtc.RTCIceCandidate(candidate),
        noop,
        function (err) { self._onError(err) }
      )
    } catch (err) {
      self._destroy(new Error('error adding candidate: ' + err.message))
    }
  }

  if (data.sdp) {
    self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data), function () {
      if (self.destroyed) return
      if (self._pc.remoteDescription.type === 'offer') self._createAnswer()

      self._pendingCandidates.forEach(addIceCandidate)
      self._pendingCandidates = []
    }, function (err) { self._onError(err) })
  }
  if (data.candidate) {
    if (self._pc.remoteDescription) addIceCandidate(data.candidate)
    else self._pendingCandidates.push(data.candidate)
  }
  if (!data.sdp && !data.candidate) {
    self._destroy(new Error('signal() called with invalid signal data'))
  }
}

/**
 * Send text/binary data to the remote peer.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Peer.prototype.send = function (chunk) {
  var self = this

  // HACK: `wrtc` module doesn't accept node.js buffer. See issue: #60
  if (Buffer.isBuffer(chunk) && self._isWrtc) {
    chunk = new Uint8Array(chunk)
  }

  var len = chunk.length || chunk.byteLength || chunk.size
  self._channel.send(chunk)
  self._debug('write: %d bytes', len)
}

Peer.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Peer.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  self._debug('destroy (error: %s)', err && err.message)

  self.readable = self.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.destroyed = true
  self.connected = false
  self._pcReady = false
  self._channelReady = false

  self._chunk = null
  self._cb = null
  clearInterval(self._interval)
  clearTimeout(self._reconnectTimeout)

  if (self._pc) {
    try {
      self._pc.close()
    } catch (err) {}

    self._pc.oniceconnectionstatechange = null
    self._pc.onsignalingstatechange = null
    self._pc.onicecandidate = null
    self._pc.onaddstream = null
    self._pc.onnegotiationneeded = null
    self._pc.ondatachannel = null
  }

  if (self._channel) {
    try {
      self._channel.close()
    } catch (err) {}

    self._channel.onmessage = null
    self._channel.onopen = null
    self._channel.onclose = null
  }
  self._pc = null
  self._channel = null

  if (err) self.emit('error', err)
  self.emit('close')
}

Peer.prototype._setupData = function (event) {
  var self = this
  self._channel = event.channel
  self.channelName = self._channel.label

  self._channel.binaryType = 'arraybuffer'
  self._channel.onmessage = function (event) {
    self._onChannelMessage(event)
  }
  self._channel.onopen = function () {
    self._onChannelOpen()
  }
  self._channel.onclose = function () {
    self._onChannelClose()
  }
}

Peer.prototype._read = function () {}

Peer.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self._onError(err)
    }
    if (self._channel.bufferedAmount > self._maxBufferedAmount) {
      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    self._debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Peer.prototype._createOffer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createOffer(function (offer) {
    if (self.destroyed) return
    offer.sdp = self.sdpTransform(offer.sdp)
    self._pc.setLocalDescription(offer, noop, function (err) { self._onError(err) })
    var sendOffer = function () {
      var signal = self._pc.localDescription || offer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
    if (self.trickle || self._iceComplete) sendOffer()
    else self.once('_iceComplete', sendOffer) // wait for candidates
  }, function (err) { self._onError(err) }, self.offerConstraints)
}

Peer.prototype._createAnswer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createAnswer(function (answer) {
    if (self.destroyed) return
    answer.sdp = self.sdpTransform(answer.sdp)
    self._pc.setLocalDescription(answer, noop, function (err) { self._onError(err) })
    var sendAnswer = function () {
      var signal = self._pc.localDescription || answer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
    if (self.trickle || self._iceComplete) sendAnswer()
    else self.once('_iceComplete', sendAnswer)
  }, function (err) { self._onError(err) }, self.answerConstraints)
}

Peer.prototype._onIceConnectionStateChange = function () {
  var self = this
  if (self.destroyed) return
  var iceGatheringState = self._pc.iceGatheringState
  var iceConnectionState = self._pc.iceConnectionState
  self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState)
  self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState)
  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
    clearTimeout(self._reconnectTimeout)
    self._pcReady = true
    self._maybeReady()
  }
  if (iceConnectionState === 'disconnected') {
    if (self.reconnectTimer) {
      // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect
      clearTimeout(self._reconnectTimeout)
      self._reconnectTimeout = setTimeout(function () {
        self._destroy()
      }, self.reconnectTimer)
    } else {
      self._destroy()
    }
  }
  if (iceConnectionState === 'failed') {
    self._destroy()
  }
  if (iceConnectionState === 'closed') {
    self._destroy()
  }
}

Peer.prototype.getStats = function (cb) {
  var self = this
  if (!self._pc.getStats) { // No ability to call stats
    cb([])
  } else if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) { // Mozilla
    self._pc.getStats(null, function (res) {
      var items = []
      res.forEach(function (item) {
        items.push(item)
      })
      cb(items)
    }, function (err) { self._onError(err) })
  } else {
    self._pc.getStats(function (res) { // Chrome
      var items = []
      res.result().forEach(function (result) {
        var item = {}
        result.names().forEach(function (name) {
          item[name] = result.stat(name)
        })
        item.id = result.id
        item.type = result.type
        item.timestamp = result.timestamp
        items.push(item)
      })
      cb(items)
    })
  }
}

Peer.prototype._maybeReady = function () {
  var self = this
  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)
  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return
  self._connecting = true

  self.getStats(function (items) {
    self._connecting = false
    self.connected = true

    var remoteCandidates = {}
    var localCandidates = {}

    function setActiveCandidates (item) {
      var local = localCandidates[item.localCandidateId]
      var remote = remoteCandidates[item.remoteCandidateId]

      if (local) {
        self.localAddress = local.ipAddress
        self.localPort = Number(local.portNumber)
      } else if (typeof item.googLocalAddress === 'string') {
        // Sometimes `item.id` is undefined in `wrtc` and Chrome
        // See: https://github.com/feross/simple-peer/issues/66
        local = item.googLocalAddress.split(':')
        self.localAddress = local[0]
        self.localPort = Number(local[1])
      }
      self._debug('connect local: %s:%s', self.localAddress, self.localPort)

      if (remote) {
        self.remoteAddress = remote.ipAddress
        self.remotePort = Number(remote.portNumber)
        self.remoteFamily = 'IPv4'
      } else if (typeof item.googRemoteAddress === 'string') {
        remote = item.googRemoteAddress.split(':')
        self.remoteAddress = remote[0]
        self.remotePort = Number(remote[1])
        self.remoteFamily = 'IPv4'
      }
      self._debug('connect remote: %s:%s', self.remoteAddress, self.remotePort)
    }

    items.forEach(function (item) {
      if (item.type === 'remotecandidate') remoteCandidates[item.id] = item
      if (item.type === 'localcandidate') localCandidates[item.id] = item
    })

    items.forEach(function (item) {
      var isCandidatePair = (
        (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
        (item.type === 'candidatepair' && item.selected)
      )
      if (isCandidatePair) setActiveCandidates(item)
    })

    if (self._chunk) {
      try {
        self.send(self._chunk)
      } catch (err) {
        return self._onError(err)
      }
      self._chunk = null
      self._debug('sent chunk from "write before connect"')

      var cb = self._cb
      self._cb = null
      cb(null)
    }

    self._interval = setInterval(function () {
      if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return
      self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()

    self._debug('connect')
    self.emit('connect')
  })
}

Peer.prototype._onSignalingStateChange = function () {
  var self = this
  if (self.destroyed) return
  self._debug('signalingStateChange %s', self._pc.signalingState)
  self.emit('signalingStateChange', self._pc.signalingState)
}

Peer.prototype._onIceCandidate = function (event) {
  var self = this
  if (self.destroyed) return
  if (event.candidate && self.trickle) {
    self.emit('signal', {
      candidate: {
        candidate: event.candidate.candidate,
        sdpMLineIndex: event.candidate.sdpMLineIndex,
        sdpMid: event.candidate.sdpMid
      }
    })
  } else if (!event.candidate) {
    self._iceComplete = true
    self.emit('_iceComplete')
  }
}

Peer.prototype._onChannelMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  self._debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) data = new Buffer(data)
  self.push(data)
}

Peer.prototype._onChannelOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self._debug('on channel open')
  self._channelReady = true
  self._maybeReady()
}

Peer.prototype._onChannelClose = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on channel close')
  self._destroy()
}

Peer.prototype._onAddStream = function (event) {
  var self = this
  if (self.destroyed) return
  self._debug('on add stream')
  self.emit('stream', event.stream)
}

Peer.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  self._debug('error %s', err.message || err)
  self._destroy(err)
}

Peer.prototype._debug = function () {
  var self = this
  var args = [].slice.call(arguments)
  var id = self.channelName && self.channelName.substring(0, 7)
  args[0] = '[' + id + '] ' + args[0]
  debug.apply(null, args)
}

function noop () {}

}).call(this,require("buffer").Buffer)

},{"buffer":25,"debug":39,"get-browser-rtc":61,"hat":65,"inherits":70,"once":91,"readable-stream":117}],127:[function(require,module,exports){
var Rusha = require('rusha')

var rusha = new Rusha
var crypto = window.crypto || window.msCrypto || {}
var subtle = crypto.subtle || crypto.webkitSubtle

function sha1sync (buf) {
  return rusha.digest(buf)
}

// Browsers throw if they lack support for an algorithm.
// Promise will be rejected on non-secure origins. (http://goo.gl/lq4gCo)
try {
  subtle.digest({ name: 'sha-1' }, new Uint8Array).catch(function () {
    subtle = false
  })
} catch (err) { subtle = false }

function sha1 (buf, cb) {
  if (!subtle) {
    // Use Rusha
    setTimeout(cb, 0, sha1sync(buf))
    return
  }

  if (typeof buf === 'string') {
    buf = uint8array(buf)
  }

  subtle.digest({ name: 'sha-1' }, buf)
    .then(function succeed (result) {
      cb(hex(new Uint8Array(result)))
    },
    function fail (error) {
      cb(sha1sync(buf))
    })
}

function uint8array (s) {
  var l = s.length
  var array = new Uint8Array(l)
  for (var i = 0; i < l; i++) {
    array[i] = s.charCodeAt(i)
  }
  return array
}

function hex (buf) {
  var l = buf.length
  var chars = []
  for (var i = 0; i < l; i++) {
    var bite = buf[i]
    chars.push((bite >>> 4).toString(16))
    chars.push((bite & 0x0f).toString(16))
  }
  return chars.join('')
}

module.exports = sha1
module.exports.sync = sha1sync

},{"rusha":122}],128:[function(require,module,exports){
(function (process,Buffer){
module.exports = Socket

var debug = require('debug')('simple-websocket')
var inherits = require('inherits')
var stream = require('readable-stream')
var ws = require('ws') // websockets in node - will be empty object in browser

var WebSocket = typeof window !== 'undefined' ? window.WebSocket : ws

inherits(Socket, stream.Duplex)

/**
 * WebSocket. Same API as node core `net.Socket`. Duplex stream.
 * @param {string} url websocket server url
 * @param {Object} opts options to stream.Duplex
 */
function Socket (url, opts) {
  var self = this
  if (!(self instanceof Socket)) return new Socket(url, opts)
  if (!opts) opts = {}
  debug('new websocket: %s %o', url, opts)

  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.url = url
  self.connected = false
  self.destroyed = false

  self._maxBufferedAmount = opts.highWaterMark
  self._chunk = null
  self._cb = null
  self._interval = null

  try {
    self._ws = new WebSocket(self.url)
  } catch (err) {
    process.nextTick(function () {
      self._onError(err)
    })
    return
  }
  self._ws.binaryType = 'arraybuffer'
  self._ws.onopen = function () {
    self._onOpen()
  }
  self._ws.onmessage = function (event) {
    self._onMessage(event)
  }
  self._ws.onclose = function () {
    self._onClose()
  }
  self._ws.onerror = function () {
    self._onError(new Error('connection error to ' + self.url))
  }

  self.on('finish', function () {
    if (self.connected) {
      // When stream is finished writing, close socket connection. Half open connections
      // are currently not supported.
      // Wait a bit before destroying so the socket flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If socket is not connected when stream is finished writing, wait until data is
      // flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Socket.WEBSOCKET_SUPPORT = !!WebSocket

/**
 * Send text/binary data to the WebSocket server.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Socket.prototype.send = function (chunk) {
  var self = this

  var len = chunk.length || chunk.byteLength || chunk.size
  self._ws.send(chunk)
  debug('write: %d bytes', len)
}

Socket.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Socket.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  debug('destroy (error: %s)', err && err.message)

  this.readable = this.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.connected = false
  self.destroyed = true

  clearInterval(self._interval)
  self._interval = null
  self._chunk = null
  self._cb = null

  if (self._ws) {
    var ws = self._ws
    var onClose = function () {
      ws.onclose = null
      self.emit('close')
    }
    if (ws.readyState === WebSocket.CLOSED) {
      onClose()
    } else {
      try {
        ws.onclose = onClose
        ws.close()
      } catch (err) {
        onClose()
      }
    }

    ws.onopen = null
    ws.onmessage = null
    ws.onerror = null
  }
  self._ws = null

  if (err) self.emit('error', err)
}

Socket.prototype._read = function () {}

Socket.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after socket is destroyed'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self._onError(err)
    }
    if (typeof ws !== 'function' && self._ws.bufferedAmount > self._maxBufferedAmount) {
      debug('start backpressure: bufferedAmount %d', self._ws.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Socket.prototype._onMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) data = new Buffer(data)
  self.push(data)
}

Socket.prototype._onOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self.connected = true

  if (self._chunk) {
    try {
      self.send(self._chunk)
    } catch (err) {
      return self._onError(err)
    }
    self._chunk = null
    debug('sent chunk from "write before connect"')

    var cb = self._cb
    self._cb = null
    cb(null)
  }

  // No backpressure in node. The `ws` module has a buggy `bufferedAmount` property.
  // See: https://github.com/websockets/ws/issues/492
  if (typeof ws !== 'function') {
    self._interval = setInterval(function () {
      if (!self._cb || !self._ws || self._ws.bufferedAmount > self._maxBufferedAmount) {
        return
      }
      debug('ending backpressure: bufferedAmount %d', self._ws.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()
  }

  debug('connect')
  self.emit('connect')
}

Socket.prototype._onClose = function () {
  var self = this
  if (self.destroyed) return
  debug('on close')
  self._destroy()
}

Socket.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  debug('error: %s', err.message || err)
  self._destroy(err)
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":104,"buffer":25,"debug":39,"inherits":70,"readable-stream":117,"ws":22}],129:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":130,"./socket":132,"./url":133,"debug":39,"socket.io-parser":135}],130:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function(){
  this.lastPing = new Date;
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function(){
  this.emitAll('pong', new Date - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function(){
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  debug('cleanup');

  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' == this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":131,"./socket":132,"backo2":6,"component-bind":30,"component-emitter":31,"debug":39,"engine.io-client":43,"indexof":69,"socket.io-parser":135}],131:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],132:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":131,"component-bind":30,"component-emitter":31,"debug":39,"has-binary":62,"socket.io-parser":135,"to-array":150}],133:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"debug":39,"parseuri":100}],134:[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./is-buffer":136,"isarray":138}],135:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":134,"./is-buffer":136,"component-emitter":137,"debug":39,"isarray":138,"json3":77}],136:[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],137:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"dup":53}],138:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"dup":57}],139:[function(require,module,exports){
var tick = 1
var maxTick = 65535
var resolution = 4
var inc = function () {
  tick = (tick + 1) & maxTick
}

var timer = setInterval(inc, (1000 / resolution) | 0)
if (timer.unref) timer.unref()

module.exports = function (seconds) {
  var size = resolution * (seconds || 5)
  var buffer = [0]
  var pointer = 1
  var last = (tick - 1) & maxTick

  return function (delta) {
    var dist = (tick - last) & maxTick
    if (dist > size) dist = size
    last = tick

    while (dist--) {
      if (pointer === size) pointer = 0
      buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1]
      pointer++
    }

    if (delta) buffer[pointer - 1] += delta

    var top = buffer[pointer - 1]
    var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer]

    return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length
  }
}

},{}],140:[function(require,module,exports){
(function (global){
var ClientRequest = require('./lib/request')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/request":142,"builtin-status-codes":26,"url":158,"xtend":181}],141:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

var xhr = new global.XMLHttpRequest()
// If location.host is empty, e.g. if this page/worker was loaded
// from a Blob, then use example.com to avoid an error
xhr.open('GET', global.location.host ? '/' : 'https://example.com')

function checkTypeSupport (type) {
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

exports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')
// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')
exports.overrideMimeType = isFunction(xhr.overrideMimeType)
exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
  return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],142:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary) {
	if (capability.fetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary)

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var self = this
	return self._headers[name.toLowerCase()].value
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body
	if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {
		if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	if (self._mode === 'fetch') {
		var headers = Object.keys(headersObj).map(function (name) {
			return [headersObj[name].name, headersObj[name].value]
		})

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headers,
			body: body,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin'
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		Object.keys(headersObj).forEach(function (name) {
			xhr.setRequestHeader(headersObj[name].name, headersObj[name].value)
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	// Currently, there isn't a way to truly abort a fetch.
	// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'user-agent',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":141,"./response":143,"_process":104,"buffer":25,"inherits":70,"readable-stream":117,"to-arraybuffer":151}],143:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		// backwards compatible version of for (<item> of <iterable>):
		// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
		for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
			self.headers[header[0].toLowerCase()] = header[1]
			self.rawHeaders.push(header[0], header[1])
		}

		// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			})
		}
		read()

	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":141,"_process":104,"buffer":25,"inherits":70,"readable-stream":117}],144:[function(require,module,exports){
/* global Blob, URL */

var once = require('once')

module.exports = function getBlobURL (stream, mimeType, cb) {
  cb = once(cb)
  var chunks = []
  stream
    .on('data', function (chunk) {
      chunks.push(chunk)
    })
    .on('end', function () {
      var blob = mimeType ? new Blob(chunks, { type: mimeType }) : new Blob(chunks)
      var url = URL.createObjectURL(blob)
      cb(null, url)
    })
    .on('error', cb)
}

},{"once":91}],145:[function(require,module,exports){
(function (Buffer){
var once = require('once')

module.exports = function getBuffer (stream, length, cb) {
  cb = once(cb)
  var buf = new Buffer(length)
  var offset = 0
  stream
    .on('data', function (chunk) {
      chunk.copy(buf, offset)
      offset += chunk.length
    })
    .on('end', function () { cb(null, buf) })
    .on('error', cb)
}

}).call(this,require("buffer").Buffer)

},{"buffer":25,"once":91}],146:[function(require,module,exports){
(function (Buffer){
var addrToIPPort = require('addr-to-ip-port')
var ipaddr = require('ipaddr.js')

module.exports = function (addrs) {
  if (typeof addrs === 'string') {
    addrs = [ addrs ]
  }

  return Buffer.concat(addrs.map(function (addr) {
    var s = addrToIPPort(addr)
    if (s.length !== 2) {
      throw new Error('invalid address format, expecting: 10.10.10.5:128')
    }

    var ip = ipaddr.parse(s[0])
    var ipBuf = new Buffer(ip.toByteArray())
    var port = Number(s[1])
    var portBuf = new Buffer(2)
    portBuf.writeUInt16BE(port, 0)
    return Buffer.concat([ipBuf, portBuf])
  }))
}

/**
 * Also support this usage:
 *   string2compact.multi([ '10.10.10.5:128', '100.56.58.99:28525' ])
 *
 * for parallelism with the `compact2string` module.
 */
module.exports.multi = module.exports
module.exports.multi6 = module.exports

}).call(this,require("buffer").Buffer)

},{"addr-to-ip-port":3,"buffer":25,"ipaddr.js":71}],147:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":25}],148:[function(require,module,exports){
/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in      
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE.
*/

var base32 = require('./thirty-two');

exports.encode = base32.encode;
exports.decode = base32.decode;

},{"./thirty-two":149}],149:[function(require,module,exports){
(function (Buffer){
/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.                                                                   
*/

var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var byteTable = [
    0xff, 0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff
];

function quintetCount(buff) {
    var quintets = Math.floor(buff.length / 5);
    return buff.length % 5 == 0 ? quintets: quintets + 1;
}

exports.encode = function(plain) {
    if(!Buffer.isBuffer(plain)){
    	plain = new Buffer(plain);
    }
    var i = 0;
    var j = 0;
    var shiftIndex = 0;
    var digit = 0;
    var encoded = new Buffer(quintetCount(plain) * 8);

    /* byte by byte isn't as pretty as quintet by quintet but tests a bit
        faster. will have to revisit. */
    while(i < plain.length) {
        var current = plain[i];
    
        if(shiftIndex > 3) {
            digit = current & (0xff >> shiftIndex);
            shiftIndex = (shiftIndex + 5) % 8;
            digit = (digit << shiftIndex) | ((i + 1 < plain.length) ?
                plain[i + 1] : 0) >> (8 - shiftIndex);
            i++;
        } else {
            digit = (current >> (8 - (shiftIndex + 5))) & 0x1f;
            shiftIndex = (shiftIndex + 5) % 8;            
            if(shiftIndex == 0) i++;
        }
        
        encoded[j] = charTable.charCodeAt(digit);
        j++;
    }

    for(i = j; i < encoded.length; i++)
        encoded[i] = 0x3d; //'='.charCodeAt(0)
        
    return encoded;
};

exports.decode = function(encoded) {
    var shiftIndex = 0;
    var plainDigit = 0;
    var plainChar;
    var plainPos = 0;
    if(!Buffer.isBuffer(encoded)){
    	encoded = new Buffer(encoded);
    }
    var decoded = new Buffer(Math.ceil(encoded.length * 5 / 8));
    
    /* byte by byte isn't as pretty as octet by octet but tests a bit
        faster. will have to revisit. */    
    for(var i = 0; i < encoded.length; i++) {
    	if(encoded[i] == 0x3d){ //'='
    		break;
    	}
    		
        var encodedByte = encoded[i] - 0x30;
        
        if(encodedByte < byteTable.length) {
            plainDigit = byteTable[encodedByte];
            
            if(shiftIndex <= 3) {
                shiftIndex = (shiftIndex + 5) % 8;
                
                if(shiftIndex == 0) {
                    plainChar |= plainDigit;
                    decoded[plainPos] = plainChar;
                    plainPos++;
                    plainChar = 0;
                } else {
                    plainChar |= 0xff & (plainDigit << (8 - shiftIndex));
                }
            } else {
                shiftIndex = (shiftIndex + 5) % 8;
                plainChar |= 0xff & (plainDigit >>> shiftIndex);
                decoded[plainPos] = plainChar;
                plainPos++;

                plainChar = 0xff & (plainDigit << (8 - shiftIndex));
            }
        } else {
        	throw new Error('Invalid input - it is not base32 encoded string');
        }
    }
    return decoded.slice(0, plainPos);
};

}).call(this,require("buffer").Buffer)

},{"buffer":25}],150:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],151:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":25}],152:[function(require,module,exports){
(function (process){
module.exports = Discovery

var debug = require('debug')('torrent-discovery')
var DHT = require('bittorrent-dht/client') // empty object in browser
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var inherits = require('inherits')
var parallel = require('run-parallel')
var Tracker = require('bittorrent-tracker/client')

inherits(Discovery, EventEmitter)

function Discovery (opts) {
  var self = this
  if (!(self instanceof Discovery)) return new Discovery(opts)
  EventEmitter.call(self)

  if (!opts.peerId) throw new Error('Option `peerId` is required')
  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!process.browser && !opts.port) throw new Error('Option `port` is required')

  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : opts.peerId.toString('hex')
  self.infoHash = typeof opts.infoHash === 'string'
    ? opts.infoHash
    : opts.infoHash.toString('hex')
  self._port = opts.port // torrent port

  self.destroyed = false

  self._announce = opts.announce || []
  self._intervalMs = opts.intervalMs || (15 * 60 * 1000)
  self._trackerOpts = null
  self._dhtAnnouncing = false
  self._dhtTimeout = false
  self._internalDHT = false // is the DHT created internally?

  self._onWarning = function (err) {
    self.emit('warning', err)
  }
  self._onError = function (err) {
    self.emit('error', err)
  }
  self._onDHTPeer = function (peer, infoHash) {
    if (infoHash.toString('hex') !== self.infoHash) return
    self.emit('peer', peer.host + ':' + peer.port)
  }
  self._onTrackerPeer = function (peer) {
    self.emit('peer', peer)
  }
  self._onTrackerAnnounce = function () {
    self.emit('trackerAnnounce')
  }

  if (opts.tracker === false) {
    self.tracker = null
  } else if (opts.tracker && typeof opts.tracker === 'object') {
    self._trackerOpts = extend(opts.tracker)
    self.tracker = self._createTracker()
  } else {
    self.tracker = self._createTracker()
  }

  if (opts.dht === false || typeof DHT !== 'function') {
    self.dht = null
  } else if (opts.dht && typeof opts.dht.addNode === 'function') {
    self.dht = opts.dht
  } else if (opts.dht && typeof opts.dht === 'object') {
    self.dht = createDHT(opts.dhtPort, opts.dht)
  } else {
    self.dht = createDHT(opts.dhtPort)
  }

  if (self.dht) {
    self.dht.on('peer', self._onDHTPeer)
    self._dhtAnnounce()
  }

  function createDHT (port, opts) {
    var dht = new DHT(opts)
    dht.on('warning', self._onWarning)
    dht.on('error', self._onError)
    dht.listen(port)
    self._internalDHT = true
    return dht
  }
}

Discovery.prototype.updatePort = function (port) {
  var self = this
  if (port === self._port) return
  self._port = port

  if (self.dht) self._dhtAnnounce()

  if (self.tracker) {
    self.tracker.stop()
    self.tracker.destroy(function () {
      self.tracker = self._createTracker()
    })
  }
}

Discovery.prototype.destroy = function (cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true

  clearTimeout(self._dhtTimeout)

  var tasks = []

  if (self.tracker) {
    self.tracker.stop()
    self.tracker.removeListener('warning', self._onWarning)
    self.tracker.removeListener('error', self._onError)
    self.tracker.removeListener('peer', self._onTrackerPeer)
    self.tracker.removeListener('update', self._onTrackerAnnounce)
    tasks.push(function (cb) {
      self.tracker.destroy(cb)
    })
  }

  if (self.dht) {
    self.dht.removeListener('peer', self._onDHTPeer)
  }

  if (self._internalDHT) {
    self.dht.removeListener('warning', self._onWarning)
    self.dht.removeListener('error', self._onError)
    tasks.push(function (cb) {
      self.dht.destroy(cb)
    })
  }

  parallel(tasks, cb)

  // cleanup
  self.dht = null
  self.tracker = null
  self._announce = null
}

Discovery.prototype._createTracker = function () {
  var self = this

  var opts = extend(self._trackerOpts, {
    infoHash: self.infoHash,
    announce: self._announce,
    peerId: self.peerId,
    port: self._port
  })

  var tracker = new Tracker(opts)
  tracker.on('warning', self._onWarning)
  tracker.on('error', self._onError)
  tracker.on('peer', self._onTrackerPeer)
  tracker.on('update', self._onTrackerAnnounce)
  tracker.setInterval(self._intervalMs)
  tracker.start()
  return tracker
}

Discovery.prototype._dhtAnnounce = function () {
  var self = this
  if (self._dhtAnnouncing) return
  debug('dht announce')

  self._dhtAnnouncing = true
  clearTimeout(self._dhtTimeout)

  self.dht.announce(self.infoHash, self._port, function (err) {
    self._dhtAnnouncing = false
    debug('dht announce complete')

    if (err) self.emit('warning', err)
    self.emit('dhtAnnounce')

    if (!self.destroyed) {
      self._dhtTimeout = setTimeout(function () {
        self._dhtAnnounce()
      }, getRandomTimeout())
      if (self._dhtTimeout.unref) self._dhtTimeout.unref()
    }
  })

  // Returns timeout interval, with some random jitter
  function getRandomTimeout () {
    return self._intervalMs + Math.floor(Math.random() * self._intervalMs / 5)
  }
}

}).call(this,require('_process'))

},{"_process":104,"bittorrent-dht/client":22,"bittorrent-tracker/client":15,"debug":39,"events":58,"inherits":70,"run-parallel":121,"xtend":181}],153:[function(require,module,exports){
(function (Buffer){
module.exports = Piece

var BLOCK_LENGTH = 1 << 14

function Piece (length) {
  if (!(this instanceof Piece)) return new Piece(length)

  this.length = length
  this.missing = length
  this.sources = null

  this._chunks = Math.ceil(length / BLOCK_LENGTH)
  this._remainder = (length % BLOCK_LENGTH) || BLOCK_LENGTH
  this._buffered = 0
  this._buffer = null
  this._cancellations = null
  this._reservations = 0
  this._flushed = false
}

Piece.BLOCK_LENGTH = BLOCK_LENGTH

Piece.prototype.chunkLength = function (i) {
  return i === this._chunks - 1 ? this._remainder : BLOCK_LENGTH
}

Piece.prototype.chunkLengthRemaining = function (i) {
  return this.length - (i * BLOCK_LENGTH)
}

Piece.prototype.chunkOffset = function (i) {
  return i * BLOCK_LENGTH
}

Piece.prototype.reserve = function () {
  if (!this.init()) return -1
  if (this._cancellations.length) return this._cancellations.pop()
  if (this._reservations < this._chunks) return this._reservations++
  return -1
}

Piece.prototype.reserveRemaining = function () {
  if (!this.init()) return -1
  if (this._reservations < this._chunks) {
    var min = this._reservations
    this._reservations = this._chunks
    return min
  }
  return -1
}

Piece.prototype.cancel = function (i) {
  if (!this.init()) return
  this._cancellations.push(i)
}

Piece.prototype.cancelRemaining = function (i) {
  if (!this.init()) return
  this._reservations = i
}

Piece.prototype.get = function (i) {
  if (!this.init()) return null
  return this._buffer[i]
}

Piece.prototype.set = function (i, data, source) {
  if (!this.init()) return false
  var len = data.length
  var blocks = Math.ceil(len / BLOCK_LENGTH)
  for (var j = 0; j < blocks; j++) {
    if (!this._buffer[i + j]) {
      var offset = j * BLOCK_LENGTH
      var splitData = data.slice(offset, offset + BLOCK_LENGTH)
      this._buffered++
      this._buffer[i + j] = splitData
      this.missing -= splitData.length
      if (this.sources.indexOf(source) === -1) {
        this.sources.push(source)
      }
    }
  }
  return this._buffered === this._chunks
}

Piece.prototype.flush = function () {
  if (!this._buffer || this._chunks !== this._buffered) return null
  var buffer = Buffer.concat(this._buffer, this.length)
  this._buffer = null
  this._cancellations = null
  this.sources = null
  this._flushed = true
  return buffer
}

Piece.prototype.init = function () {
  if (this._flushed) return false
  if (this._buffer) return true
  this._buffer = new Array(this._chunks)
  this._cancellations = []
  this.sources = []
  return true
}

}).call(this,require("buffer").Buffer)

},{"buffer":25}],154:[function(require,module,exports){
(function (Buffer){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = require('is-typedarray').strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = new Buffer(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to the `Buffer` constructor
    return new Buffer(arr)
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":25,"is-typedarray":75}],155:[function(require,module,exports){
(function (Buffer){
var UINT_32_MAX = 0xffffffff

exports.encodingLength = function () {
  return 8
}

exports.encode = function (num, buf, offset) {
  if (!buf) buf = new Buffer(8)
  if (!offset) offset = 0

  var top = Math.floor(num / UINT_32_MAX)
  var rem = num - top * UINT_32_MAX

  buf.writeUInt32BE(top, offset)
  buf.writeUInt32BE(rem, offset + 4)
  return buf
}

exports.decode = function (buf, offset) {
  if (!offset) offset = 0

  if (!buf) buf = new Buffer(4)
  if (!offset) offset = 0

  var top = buf.readUInt32BE(offset)
  var rem = buf.readUInt32BE(offset + 4)

  return top * UINT_32_MAX + rem
}

exports.encode.bytes = 8
exports.decode.bytes = 8

}).call(this,require("buffer").Buffer)

},{"buffer":25}],156:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],157:[function(require,module,exports){
module.exports = remove

function remove (arr, i) {
  if (i >= arr.length || i < 0) return
  var last = arr.pop()
  if (i < arr.length) {
    var tmp = arr[i]
    arr[i] = last
    return tmp
  }
  return last
}

},{}],158:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":159,"punycode":106,"querystring":109}],159:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],160:[function(require,module,exports){
var bencode = require('bencode')
var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('ut_metadata')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var sha1 = require('simple-sha1')

var MAX_METADATA_SIZE = 10000000 // 10MB
var BITFIELD_GROW = 1000
var PIECE_LENGTH = 16 * 1024

module.exports = function (metadata) {
  inherits(utMetadata, EventEmitter)

  function utMetadata (wire) {
    EventEmitter.call(this)

    this._wire = wire

    this._metadataComplete = false
    this._metadataSize = null
    this._remainingRejects = null // how many reject messages to tolerate before quitting
    this._fetching = false

    // The largest .torrent file that I know of is ~1-2MB, which is ~100 pieces.
    // Therefore, cap the bitfield to 10x that (1000 pieces) so a malicious peer can't
    // make it grow to fill all memory.
    this._bitfield = new BitField(0, { grow: BITFIELD_GROW })

    if (Buffer.isBuffer(metadata)) {
      this.setMetadata(metadata)
    }
  }

  // Name of the bittorrent-protocol extension
  utMetadata.prototype.name = 'ut_metadata'

  utMetadata.prototype.onHandshake = function (infoHash, peerId, extensions) {
    this._infoHash = infoHash
  }

  utMetadata.prototype.onExtendedHandshake = function (handshake) {
    if (!handshake.m || !handshake.m.ut_metadata) {
      return this.emit('warning', new Error('Peer does not support ut_metadata'))
    }
    if (!handshake.metadata_size) {
      return this.emit('warning', new Error('Peer does not have metadata'))
    }
    if (typeof handshake.metadata_size !== 'number' ||
        MAX_METADATA_SIZE < handshake.metadata_size ||
        handshake.metadata_size <= 0) {
      return this.emit('warning', new Error('Peer gave invalid metadata size'))
    }

    this._metadataSize = handshake.metadata_size
    this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH)
    this._remainingRejects = this._numPieces * 2

    if (this._fetching) {
      this._requestPieces()
    }
  }

  utMetadata.prototype.onMessage = function (buf) {
    var dict, trailer
    try {
      var str = buf.toString()
      var trailerIndex = str.indexOf('ee') + 2
      dict = bencode.decode(str.substring(0, trailerIndex))
      trailer = buf.slice(trailerIndex)
    } catch (err) {
      // drop invalid messages
      return
    }

    switch (dict.msg_type) {
      case 0:
        // ut_metadata request (from peer)
        // example: { 'msg_type': 0, 'piece': 0 }
        this._onRequest(dict.piece)
        break
      case 1:
        // ut_metadata data (in response to our request)
        // example: { 'msg_type': 1, 'piece': 0, 'total_size': 3425 }
        this._onData(dict.piece, trailer, dict.total_size)
        break
      case 2:
        // ut_metadata reject (peer doesn't have piece we requested)
        // { 'msg_type': 2, 'piece': 0 }
        this._onReject(dict.piece)
        break
    }
  }

  /**
   * Ask the peer to send metadata.
   * @public
   */
  utMetadata.prototype.fetch = function () {
    if (this._metadataComplete) {
      return
    }
    this._fetching = true
    if (this._metadataSize) {
      this._requestPieces()
    }
  }

  /**
   * Stop asking the peer to send metadata.
   * @public
   */
  utMetadata.prototype.cancel = function () {
    this._fetching = false
  }

  utMetadata.prototype.setMetadata = function (metadata) {
    if (this._metadataComplete) return true
    debug('set metadata')

    // if full torrent dictionary was passed in, pull out just `info` key
    try {
      var info = bencode.decode(metadata).info
      if (info) {
        metadata = bencode.encode(info)
      }
    } catch (err) {}

    // check hash
    if (this._infoHash && this._infoHash !== sha1.sync(metadata)) {
      return false
    }

    this.cancel()

    this.metadata = metadata
    this._metadataComplete = true
    this._metadataSize = this.metadata.length
    this._wire.extendedHandshake.metadata_size = this._metadataSize

    this.emit('metadata', bencode.encode({ info: bencode.decode(this.metadata) }))

    return true
  }

  utMetadata.prototype._send = function (dict, trailer) {
    var buf = bencode.encode(dict)
    if (Buffer.isBuffer(trailer)) {
      buf = Buffer.concat([buf, trailer])
    }
    this._wire.extended('ut_metadata', buf)
  }

  utMetadata.prototype._request = function (piece) {
    this._send({ msg_type: 0, piece: piece })
  }

  utMetadata.prototype._data = function (piece, buf, totalSize) {
    var msg = { msg_type: 1, piece: piece }
    if (typeof totalSize === 'number') {
      msg.total_size = totalSize
    }
    this._send(msg, buf)
  }

  utMetadata.prototype._reject = function (piece) {
    this._send({ msg_type: 2, piece: piece })
  }

  utMetadata.prototype._onRequest = function (piece) {
    if (!this._metadataComplete) {
      this._reject(piece)
      return
    }
    var start = piece * PIECE_LENGTH
    var end = start + PIECE_LENGTH
    if (end > this._metadataSize) {
      end = this._metadataSize
    }
    var buf = this.metadata.slice(start, end)
    this._data(piece, buf, this._metadataSize)
  }

  utMetadata.prototype._onData = function (piece, buf, totalSize) {
    if (buf.length > PIECE_LENGTH) {
      return
    }
    buf.copy(this.metadata, piece * PIECE_LENGTH)
    this._bitfield.set(piece)
    this._checkDone()
  }

  utMetadata.prototype._onReject = function (piece) {
    if (this._remainingRejects > 0 && this._fetching) {
      // If we haven't been rejected too much, then try to request the piece again
      this._request(piece)
      this._remainingRejects -= 1
    } else {
      this.emit('warning', new Error('Peer sent "reject" too much'))
    }
  }

  utMetadata.prototype._requestPieces = function () {
    this.metadata = Buffer.alloc(this._metadataSize)
    for (var piece = 0; piece < this._numPieces; piece++) {
      this._request(piece)
    }
  }

  utMetadata.prototype._checkDone = function () {
    var done = true
    for (var piece = 0; piece < this._numPieces; piece++) {
      if (!this._bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) return

    // attempt to set metadata -- may fail sha1 check
    var success = this.setMetadata(this.metadata)

    if (!success) {
      this._failedMetadata()
    }
  }

  utMetadata.prototype._failedMetadata = function () {
    // reset bitfield & try again
    this._bitfield = new BitField(0, { grow: BITFIELD_GROW })
    this._remainingRejects -= this._numPieces
    if (this._remainingRejects > 0) {
      this._requestPieces()
    } else {
      this.emit('warning', new Error('Peer sent invalid metadata'))
    }
  }

  return utMetadata
}

},{"bencode":11,"bitfield":13,"debug":39,"events":58,"inherits":70,"safe-buffer":123,"simple-sha1":127}],161:[function(require,module,exports){
(function (Buffer){
/* jshint camelcase: false */

// TODO: ipv6 support
// TODO: parse and send peer flags (currently unused)
// NOTE: addPeer should take in an optional second argument, flags
// TODO: destroy wire if peer sends PEX messages too frequently

var EventEmitter = require('events').EventEmitter
var compact2string = require('compact2string')
var string2compact = require('string2compact')
var bencode = require('bencode')
var inherits = require('inherits')

var PEX_INTERVAL = 65000 // just over one minute
var PEX_MAX_PEERS = 50    // max number of peers to advertise per PEX message

module.exports = function () {
  inherits(ut_pex, EventEmitter)

  function ut_pex (wire) {
    var self = this
    EventEmitter.call(self)

    self._wire = wire
    self._intervalId = null

    self.reset()
  }

  ut_pex.prototype.name = 'ut_pex'

  /**
   * Start sending regular PEX updates to remote peer.
   */
  ut_pex.prototype.start = function () {
    var self = this
    clearInterval(self._intervalId)
    self._intervalId = setInterval(self._sendMessage.bind(self), PEX_INTERVAL)
    if (self._intervalId.unref) self._intervalId.unref()
  }

  /**
   * Stop sending PEX updates to the remote peer.
   */
  ut_pex.prototype.stop = function () {
    var self = this
    clearInterval(self._intervalId)
    self._intervalId = null
  }

  /**
   * Stops sending updates to the remote peer and resets internal state of peers seen.
   */
  ut_pex.prototype.reset = function () {
    var self = this
    self._remoteAddedPeers = {}
    self._remoteDroppedPeers = {}
    self._localAddedPeers = {}
    self._localDroppedPeers = {}
    self.stop()
  }

  /**
   * Adds a peer to the locally discovered peer list for the next PEX message.
   */
  ut_pex.prototype.addPeer = function (peer) {
    var self = this
    if (peer.indexOf(':') < 0) return // disregard invalid peers
    if (peer in self._remoteAddedPeers) return // never advertise peer the remote wire already sent us
    if (peer in self._localDroppedPeers) delete self._localDroppedPeers[peer]
    self._localAddedPeers[peer] = true
  }

  /**
   * Adds a peer to the locally dropped peer list for the next PEX message.
   */
  ut_pex.prototype.dropPeer = function (peer) {
    var self = this
    if (peer.indexOf(':') < 0) return // disregard invalid peers
    if (peer in self._remoteDroppedPeers) return // never advertise peer the remote wire already sent us
    if (peer in self._localAddedPeers) delete self._localAddedPeers[peer]
    self._localDroppedPeers[peer] = true
  }

  ut_pex.prototype.onExtendedHandshake = function (handshake) {
    var self = this
    if (!handshake.m || !handshake.m.ut_pex) {
      return self.emit('warning', new Error('Peer does not support ut_pex'))
    }
  }

  /**
   * PEX messages are bencoded dictionaries with the following keys:
   * 'added'     : array of peers met since last PEX message
   * 'added.f'   : array of flags per peer
   *  '0x01'     : peer prefers encryption
   *  '0x02'     : peer is seeder
   * 'dropped'   : array of peers locally dropped from swarm since last PEX message
   * 'added6'    : ipv6 version of 'added'
   * 'added6.f'  : ipv6 version of 'added.f'
   * 'dropped.f' : ipv6 version of 'dropped'
   *
   * @param {Buffer} buf bencoded PEX dictionary
   */
  ut_pex.prototype.onMessage = function (buf) {
    var self = this
    var message

    try {
      message = bencode.decode(buf)
    } catch (err) {
      // drop invalid messages
      return
    }

    if (message.added) {
      compact2string.multi(message.added).forEach(function (peer) {
        delete self._remoteDroppedPeers[peer]
        if (!(peer in self._remoteAddedPeers)) {
          self._remoteAddedPeers[peer] = true
          self.emit('peer', peer)
        }
      })
    }

    if (message.dropped) {
      compact2string.multi(message.dropped).forEach(function (peer) {
        delete self._remoteAddedPeers[peer]
        if (!(peer in self._remoteDroppedPeers)) {
          self._remoteDroppedPeers[peer] = true
          self.emit('dropped', peer)
        }
      })
    }
  }

  /**
   * Sends a PEX message to the remote peer including information about any locally
   * added / dropped peers.
   */
  ut_pex.prototype._sendMessage = function () {
    var self = this

    var localAdded = Object.keys(self._localAddedPeers).slice(0, PEX_MAX_PEERS)
    var localDropped = Object.keys(self._localDroppedPeers).slice(0, PEX_MAX_PEERS)

    var added = Buffer.concat(localAdded.map(string2compact))
    var dropped = Buffer.concat(localDropped.map(string2compact))

    var addedFlags = Buffer.concat(localAdded.map(function () {
      // TODO: support flags
      return new Buffer([0])
    }))

    // update local deltas
    localAdded.forEach(function (peer) { delete self._localAddedPeers[peer] })
    localDropped.forEach(function (peer) { delete self._localDroppedPeers[peer] })

    // send PEX message
    self._wire.extended('ut_pex', {
      'added': added,
      'added.f': addedFlags,
      'dropped': dropped,
      'added6': new Buffer(0),
      'added6.f': new Buffer(0),
      'dropped6': new Buffer(0)
    })
  }

  return ut_pex
}

}).call(this,require("buffer").Buffer)

},{"bencode":162,"buffer":25,"compact2string":29,"events":58,"inherits":70,"string2compact":146}],162:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./lib/decode":163,"./lib/encode":165,"dup":35}],163:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":164,"buffer":25}],164:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],165:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":25}],166:[function(require,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],167:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],168:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],169:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":168,"_process":104,"inherits":70}],170:[function(require,module,exports){
(function (Buffer){
var bs = require('binary-search')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var mp4 = require('mp4-stream')
var Box = require('mp4-box-encoding')
var RangeSliceStream = require('range-slice-stream')

module.exports = MP4Remuxer

function MP4Remuxer (file) {
	var self = this
	EventEmitter.call(self)
	self._tracks = []
	self._fragmentSequence = 1
	self._file = file
	self._decoder = null
	self._findMoov(0)
}

inherits(MP4Remuxer, EventEmitter)

MP4Remuxer.prototype._findMoov = function (offset) {
	var self = this

	if (self._decoder) {
		self._decoder.destroy()
	}

	self._decoder = mp4.decode()
	var fileStream = self._file.createReadStream({
		start: offset
	})
	fileStream.pipe(self._decoder)

	self._decoder.once('box', function (headers) {
		if (headers.type === 'moov') {
			self._decoder.decode(function (moov) {
				fileStream.destroy()
				try {
					self._processMoov(moov)
				} catch (err) {
					err.message = 'Cannot parse mp4 file: ' + err.message
					self.emit('error', err)
				}
			})
		} else {
			fileStream.destroy()
			self._findMoov(offset + headers.length)
		}
	})
}

function RunLengthIndex (entries, countName) {
	var self = this
	self._entries = entries
	self._countName = countName || 'count'
	self._index = 0
	self._offset = 0

	self.value = self._entries[0]
}

RunLengthIndex.prototype.inc = function () {
	var self = this
	self._offset++
	if (self._offset >= self._entries[self._index][self._countName]) {
		self._index++
		self._offset = 0
	}

	self.value = self._entries[self._index]
}

MP4Remuxer.prototype._processMoov = function (moov) {
	var self = this

	var traks = moov.traks
	self._tracks = []
	self._hasVideo = false
	self._hasAudio = false
	for (var i = 0; i < traks.length; i++) {
		var trak = traks[i]
		var stbl = trak.mdia.minf.stbl
		var stsdEntry = stbl.stsd.entries[0]
		var handlerType = trak.mdia.hdlr.handlerType
		var codec
		var mime
		if (handlerType === 'vide' && stsdEntry.type === 'avc1') {
			if (self._hasVideo) {
				continue
			}
			self._hasVideo = true
			codec = 'avc1'
			if (stsdEntry.avcC) {
				codec += '.' + stsdEntry.avcC.mimeCodec
			}
			mime = 'video/mp4; codecs="' + codec + '"'
		} else if (handlerType === 'soun' && stsdEntry.type === 'mp4a') {
			if (self._hasAudio) {
				continue
			}
			self._hasAudio = true
			codec = 'mp4a'
			if (stsdEntry.esds && stsdEntry.esds.mimeCodec) {
				codec += '.' + stsdEntry.esds.mimeCodec
			}
			mime = 'audio/mp4; codecs="' + codec + '"'
		} else {
			continue
		}

		var samples = []
		var sample = 0

		// Chunk/position data
		var sampleInChunk = 0
		var chunk = 0
		var offsetInChunk = 0
		var sampleToChunkIndex = 0

		// Time data
		var dts = 0
		var decodingTimeEntry = new RunLengthIndex(stbl.stts.entries)
		var presentationOffsetEntry = null
		if (stbl.ctts) {
			presentationOffsetEntry = new RunLengthIndex(stbl.ctts.entries)
		}

		// Sync table index
		var syncSampleIndex = 0

		while (true) {
			var currChunkEntry = stbl.stsc.entries[sampleToChunkIndex]

			// Compute size
			var size = stbl.stsz.entries[sample]

			// Compute time data
			var duration = decodingTimeEntry.value.duration
			var presentationOffset = presentationOffsetEntry ? presentationOffsetEntry.value.compositionOffset : 0

			// Compute sync
			var sync = true
			if (stbl.stss) {
				sync = stbl.stss.entries[syncSampleIndex] === sample + 1
			}

			// Create new sample entry
			samples.push({
				size: size,
				duration: duration,
				dts: dts,
				presentationOffset: presentationOffset,
				sync: sync,
				offset: offsetInChunk + stbl.stco.entries[chunk]
			})

			// Go to next sample
			sample++
			if (sample >= stbl.stsz.entries.length) {
				break
			}

			// Move position/chunk
			sampleInChunk++
			offsetInChunk += size
			if (sampleInChunk >= currChunkEntry.samplesPerChunk) {
				// Move to new chunk
				sampleInChunk = 0
				offsetInChunk = 0
				chunk++
				// Move sample to chunk box index
				var nextChunkEntry = stbl.stsc.entries[sampleToChunkIndex + 1]
				if (nextChunkEntry && chunk + 1 >= nextChunkEntry.firstChunk) {
					sampleToChunkIndex++
				}
			}

			// Move time forward
			dts += duration
			decodingTimeEntry.inc()
			presentationOffsetEntry && presentationOffsetEntry.inc()

			// Move sync table index
			if (sync) {
				syncSampleIndex++
			}
		}

		trak.mdia.mdhd.duration = 0
		trak.tkhd.duration = 0

		var defaultSampleDescriptionIndex = currChunkEntry.sampleDescriptionId

		var trackMoov = {
			type: 'moov',
			mvhd: moov.mvhd,
			traks: [{
				tkhd: trak.tkhd,
				mdia: {
					mdhd: trak.mdia.mdhd,
					hdlr: trak.mdia.hdlr,
					elng: trak.mdia.elng,
					minf: {
						vmhd: trak.mdia.minf.vmhd,
						smhd: trak.mdia.minf.smhd,
						dinf: trak.mdia.minf.dinf,
						stbl: {
							stsd: stbl.stsd,
							stts: empty(),
							ctts: empty(),
							stsc: empty(),
							stsz: empty(),
							stco: empty(),
							stss: empty()
						}
					}
				}
			}],
			mvex: {
				mehd: {
					fragmentDuration: moov.mvhd.duration
				},
				trexs: [{
					trackId: trak.tkhd.trackId,
					defaultSampleDescriptionIndex: defaultSampleDescriptionIndex,
					defaultSampleDuration: 0,
					defaultSampleSize: 0,
					defaultSampleFlags: 0
				}]
			}
		}

		self._tracks.push({
			trackId: trak.tkhd.trackId,
			timeScale: trak.mdia.mdhd.timeScale,
			samples: samples,
			currSample: null,
			currTime: null,
			moov: trackMoov,
			mime: mime
		})
	}

	if (self._tracks.length === 0) {
		self.emit('error', new Error('no playable tracks'))
		return
	}

	// Must be set last since this is used above
	moov.mvhd.duration = 0

	self._ftyp = {
		type: 'ftyp',
		brand: 'iso5',
		brandVersion: 0,
		compatibleBrands: [
			'iso5'
		]
	}

	var ftypBuf = Box.encode(self._ftyp)
	var data = self._tracks.map(function (track) {
		var moovBuf = Box.encode(track.moov)
		return {
			mime: track.mime,
			init: Buffer.concat([ftypBuf, moovBuf])
		}
	})

	self.emit('ready', data)
}

function empty () {
	return {
		version: 0,
		flags: 0,
		entries: []
	}
}

MP4Remuxer.prototype.seek = function (time) {
	var self = this
	if (!self._tracks) {
		throw new Error('Not ready yet; wait for \'ready\' event')
	}

	if (self._fileStream) {
		self._fileStream.destroy()
		self._fileStream = null
	}

	var startOffset = -1
	self._tracks.map(function (track, i) {
		// find the keyframe before the time
		// stream from there
		if (track.outStream) {
			track.outStream.destroy()
		}
		if (track.inStream) {
			track.inStream.destroy()
			track.inStream = null
		}
		var outStream = track.outStream = mp4.encode()
		var fragment = self._generateFragment(i, time)
		if (!fragment) {
			return outStream.finalize()
		}

		if (startOffset === -1 || fragment.ranges[0].start < startOffset) {
			startOffset = fragment.ranges[0].start
		}

		writeFragment(fragment)

		function writeFragment (frag) {
			if (outStream.destroyed) return
			outStream.box(frag.moof, function (err) {
				if (err) return self.emit('error', err)
				if (outStream.destroyed) return
				var slicedStream = track.inStream.slice(frag.ranges)
				slicedStream.pipe(outStream.mediaData(frag.length, function (err) {
					if (err) return self.emit('error', err)
					if (outStream.destroyed) return
					var nextFrag = self._generateFragment(i)
					if (!nextFrag) {
						return outStream.finalize()
					}
					writeFragment(nextFrag)
				}))
			})
		}
	})

	if (startOffset >= 0) {
		var fileStream = self._fileStream = self._file.createReadStream({
			start: startOffset
		})

		self._tracks.forEach(function (track) {
			track.inStream = new RangeSliceStream(startOffset)
			fileStream.pipe(track.inStream)
		})
	}

	return self._tracks.map(function (track) {
		return track.outStream
	})
}

MP4Remuxer.prototype._findSampleBefore = function (trackInd, time) {
	var self = this

	var track = self._tracks[trackInd]
	var scaledTime = Math.floor(track.timeScale * time)
	var sample = bs(track.samples, scaledTime, function (sample, t) {
		var pts = sample.dts + sample.presentationOffset// - track.editShift
		return pts - t
	})
	if (sample === -1) {
		sample = 0
	} else if (sample < 0) {
		sample = -sample - 2
	}
	// sample is now the last sample with dts <= time
	// Find the preceeding sync sample
	while (!track.samples[sample].sync) {
		sample--
	}
	return sample
}

var MIN_FRAGMENT_DURATION = 1 // second

MP4Remuxer.prototype._generateFragment = function (track, time) {
	var self = this
	/*
	1. Find correct sample
	2. Process backward until sync sample found
	3. Process forward until next sync sample after MIN_FRAGMENT_DURATION found
	*/
	var currTrack = self._tracks[track]
	var firstSample
	if (time !== undefined) {
		firstSample = self._findSampleBefore(track, time)
	} else {
		firstSample = currTrack.currSample
	}

	if (firstSample >= currTrack.samples.length)
		return null

	var startDts = currTrack.samples[firstSample].dts

	var totalLen = 0
	var ranges = []
	for (var currSample = firstSample; currSample < currTrack.samples.length; currSample++) {
		var sample = currTrack.samples[currSample]
		if (sample.sync && sample.dts - startDts >= currTrack.timeScale * MIN_FRAGMENT_DURATION) {
			break // This is a reasonable place to end the fragment
		}

		totalLen += sample.size
		var currRange = ranges.length - 1
		if (currRange < 0 || ranges[currRange].end !== sample.offset) {
			// Push a new range
			ranges.push({
				start: sample.offset,
				end: sample.offset + sample.size
			})
		} else {
			ranges[currRange].end += sample.size
		}
	}

	currTrack.currSample = currSample

	return {
		moof: self._generateMoof(track, firstSample, currSample),
		ranges: ranges,
		length: totalLen
	}
}

MP4Remuxer.prototype._generateMoof = function (track, firstSample, lastSample) {
	var self = this

	var currTrack = self._tracks[track]

	var entries = []
	for (var j = firstSample; j < lastSample; j++) {
		var currSample = currTrack.samples[j]
		entries.push({
			sampleDuration: currSample.duration,
			sampleSize: currSample.size,
			sampleFlags: currSample.sync ? 0x2000000 : 0x1010000,
			sampleCompositionTimeOffset: currSample.presentationOffset
		})
	}

	var moof = {
		type: 'moof',
		mfhd: {
			sequenceNumber: self._fragmentSequence++
		},
		trafs: [{
			tfhd: {
				flags: 0x20000, // default-base-is-moof
				trackId: currTrack.trackId
			},
			tfdt: {
				baseMediaDecodeTime: currTrack.samples[firstSample].dts
			},
			trun: {
				flags: 0xf01,
				dataOffset: 8, // The moof size has to be added to this later as well
				entries: entries
			}
		}]
	}

	// Update the offset
	moof.trafs[0].trun.dataOffset += Box.encodingLength(moof)

	return moof
}

}).call(this,require("buffer").Buffer)

},{"binary-search":12,"buffer":25,"events":58,"inherits":70,"mp4-box-encoding":84,"mp4-stream":87,"range-slice-stream":111}],171:[function(require,module,exports){
var MediaElementWrapper = require('mediasource')
var pump = require('pump')

var MP4Remuxer = require('./mp4-remuxer')

module.exports = VideoStream

function VideoStream (file, mediaElem, opts) {
	var self = this
	if (!(this instanceof VideoStream)) return new VideoStream(file, mediaElem, opts)
	opts = opts || {}

	self._elem = mediaElem
	self._elemWrapper = new MediaElementWrapper(mediaElem)
	self._waitingFired = false
	self._trackMeta = null
	self._file = file
	self._tracks = null
	if (self._elem.preload !== 'none') {
		self._createMuxer()
	}

	self._onError = function (err) {
		self.destroy() // don't pass err though so the user doesn't need to listen for errors
	}
	self._onWaiting = function () {
		self._waitingFired = true
		if (!self._muxer) {
			self._createMuxer()
		} else if (self._tracks) {
			self._pump()
		}
	}
	self._elem.addEventListener('waiting', self._onWaiting)
	self._elem.addEventListener('error', self._onError)
}

VideoStream.prototype._createMuxer = function () {
	var self = this
	self._muxer = new MP4Remuxer(self._file)
	self._muxer.on('ready', function (data) {
		self._tracks = data.map(function (trackData) {
			var mediaSource = self._elemWrapper.createWriteStream(trackData.mime)
			mediaSource.on('error', function (err) {
				self._elemWrapper.error(err)
			})
			mediaSource.write(trackData.init)
			return {
				muxed: null,
				mediaSource: mediaSource
			}
		})

		if (self._waitingFired || self._elem.preload === 'auto') {
			self._pump()
		}
	})

	self._muxer.on('error', function (err) {
		self._elemWrapper.error(err)
	})
}

VideoStream.prototype._pump = function () {
	var self = this

	var muxed = self._muxer.seek(self._elem.currentTime, !self._tracks)

	self._tracks.forEach(function (track, i) {
		if (track.muxed) {
			track.muxed.destroy()
			track.mediaSource = self._elemWrapper.createWriteStream(track.mediaSource)
			track.mediaSource.on('error', function (err) {
				self._elemWrapper.error(err)
			})
		}
		track.muxed = muxed[i]
		pump(track.muxed, track.mediaSource)
	})
}

VideoStream.prototype.destroy = function () {
	var self = this
	if (self.destroyed) {
		return
	}
	self.destroyed = true

	self._elem.removeEventListener('waiting', self._onWaiting)
	self._elem.removeEventListener('error', self._onError)

	if (self._tracks) {
		self._tracks.forEach(function (track) {
			track.muxed.destroy()
		})
	}

	self._elem.src = ''
}

},{"./mp4-remuxer":170,"mediasource":80,"pump":105}],172:[function(require,module,exports){
(function (process,global,Buffer){
module.exports = WebTorrent

var concat = require('simple-concat')
var createTorrent = require('create-torrent')
var debug = require('debug')('webtorrent')
var DHT = require('bittorrent-dht/client') // browser exclude
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var loadIPSet = require('load-ip-set') // browser exclude
var parallel = require('run-parallel')
var parseTorrent = require('parse-torrent')
var path = require('path')
var Peer = require('simple-peer')
var speedometer = require('speedometer')
var zeroFill = require('zero-fill')

var TCPPool = require('./lib/tcp-pool') // browser exclude
var Torrent = require('./lib/torrent')

/**
 * WebTorrent version.
 */
var VERSION = require('./package.json').version

/**
 * Version number in Azureus-style. Generated from major and minor semver version.
 * For example:
 *   '0.16.1' -> '0016'
 *   '1.2.5' -> '0102'
 */
var VERSION_STR = VERSION.match(/([0-9]+)/g).slice(0, 2).map(zeroFill(2)).join('')

/**
 * Version prefix string (used in peer ID). WebTorrent uses the Azureus-style
 * encoding: '-', two characters for client id ('WW'), four ascii digits for version
 * number, '-', followed by random numbers.
 * For example:
 *   '-WW0102-'...
 */
var VERSION_PREFIX = '-WW' + VERSION_STR + '-'

inherits(WebTorrent, EventEmitter)

/**
 * WebTorrent Client
 * @param {Object=} opts
 */
function WebTorrent (opts) {
  var self = this
  if (!(self instanceof WebTorrent)) return new WebTorrent(opts)
  EventEmitter.call(self)

  if (!opts) opts = {}

  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : (opts.peerId || new Buffer(VERSION_PREFIX + hat(48))).toString('hex')
  self.peerIdBuffer = new Buffer(self.peerId, 'hex')

  self.nodeId = typeof opts.nodeId === 'string'
    ? opts.nodeId
    : (opts.nodeId && opts.nodeId.toString('hex')) || hat(160)
  self.nodeIdBuffer = new Buffer(self.nodeId, 'hex')

  self.destroyed = false
  self.listening = false
  self.torrentPort = opts.torrentPort || 0
  self.dhtPort = opts.dhtPort || 0
  self.tracker = opts.tracker !== undefined ? opts.tracker : true
  self.torrents = []
  self.maxConns = Number(opts.maxConns) || 55

  self._rtcConfig = opts.rtcConfig
  self._wrtc = opts.wrtc || global.WRTC // to support `webtorrent-hybrid` package

  if (typeof TCPPool === 'function') {
    self._tcpPool = new TCPPool(self)
  } else {
    process.nextTick(function () {
      self._onListening()
    })
  }

  // stats
  self._downloadSpeed = speedometer()
  self._uploadSpeed = speedometer()

  if (opts.dht !== false && typeof DHT === 'function' /* browser exclude */) {
    // use a single DHT instance for all torrents, so the routing table can be reused
    self.dht = new DHT(extend({ nodeId: self.nodeId }, opts.dht))

    self.dht.once('error', function (err) {
      self._destroy(err)
    })

    self.dht.once('listening', function () {
      var address = self.dht.address()
      if (address) self.dhtPort = address.port
    })

    // Ignore warning when there are > 10 torrents in the client
    self.dht.setMaxListeners(0)

    self.dht.listen(self.dhtPort)
  } else {
    self.dht = false
  }

  debug('new webtorrent (peerId %s, nodeId %s)', self.peerId, self.nodeId)

  if (typeof loadIPSet === 'function') {
    loadIPSet(opts.blocklist, {
      headers: { 'user-agent': 'WebTorrent/' + VERSION + ' (http://webtorrent.io)' }
    }, function (err, ipSet) {
      if (err) return self.error('Failed to load blocklist: ' + err.message)
      self.blocked = ipSet
      ready()
    })
  } else process.nextTick(ready)

  function ready () {
    if (self.destroyed) return
    self.ready = true
    self.emit('ready')
  }
}

WebTorrent.WEBRTC_SUPPORT = Peer.WEBRTC_SUPPORT

Object.defineProperty(WebTorrent.prototype, 'downloadSpeed', {
  get: function () { return this._downloadSpeed() }
})

Object.defineProperty(WebTorrent.prototype, 'uploadSpeed', {
  get: function () { return this._uploadSpeed() }
})

Object.defineProperty(WebTorrent.prototype, 'progress', {
  get: function () {
    var torrents = this.torrents.filter(function (torrent) {
      return torrent.progress !== 1
    })
    var downloaded = torrents.reduce(function (total, torrent) {
      return total + torrent.downloaded
    }, 0)
    var length = torrents.reduce(function (total, torrent) {
      return total + (torrent.length || 0)
    }, 0) || 1
    return downloaded / length
  }
})

Object.defineProperty(WebTorrent.prototype, 'ratio', {
  get: function () {
    var uploaded = this.torrents.reduce(function (total, torrent) {
      return total + torrent.uploaded
    }, 0)
    var received = this.torrents.reduce(function (total, torrent) {
      return total + torrent.received
    }, 0) || 1
    return uploaded / received
  }
})

/**
 * Returns the torrent with the given `torrentId`. Convenience method. Easier than
 * searching through the `client.torrents` array. Returns `null` if no matching torrent
 * found.
 *
 * @param  {string|Buffer|Object|Torrent} torrentId
 * @return {Torrent|null}
 */
WebTorrent.prototype.get = function (torrentId) {
  var self = this
  var i, torrent
  var len = self.torrents.length

  if (torrentId instanceof Torrent) {
    for (i = 0; i < len; i++) {
      torrent = self.torrents[i]
      if (torrent === torrentId) return torrent
    }
  } else {
    var parsed
    try { parsed = parseTorrent(torrentId) } catch (err) {}

    if (!parsed) return null
    if (!parsed.infoHash) throw new Error('Invalid torrent identifier')

    for (i = 0; i < len; i++) {
      torrent = self.torrents[i]
      if (torrent.infoHash === parsed.infoHash) return torrent
    }
  }
  return null
}

WebTorrent.prototype.download = function (torrentId, opts, ontorrent) {
  console.warn('WebTorrent: client.download() is deprecated. Use client.add() instead')
  return this.add(torrentId, opts, ontorrent)
}

/**
 * Start downloading a new torrent. Aliased as `client.download`.
 * @param {string|Buffer|Object} torrentId
 * @param {Object} opts torrent-specific options
 * @param {function=} ontorrent called when the torrent is ready (has metadata)
 */
WebTorrent.prototype.add = function (torrentId, opts, ontorrent) {
  var self = this
  if (self.destroyed) throw new Error('client is destroyed')
  if (typeof opts === 'function') return self.add(torrentId, null, opts)

  debug('add')
  opts = opts ? extend(opts) : {}

  var torrent = new Torrent(torrentId, self, opts)
  self.torrents.push(torrent)

  torrent.once('infoHash', onInfoHash)
  torrent.once('ready', onReady)
  torrent.once('close', onClose)

  function onInfoHash () {
    if (self.destroyed) return
    for (var i = 0, len = self.torrents.length; i < len; i++) {
      var t = self.torrents[i]
      if (t.infoHash === torrent.infoHash && t !== torrent) {
        torrent._destroy(new Error('Cannot add duplicate torrent ' + torrent.infoHash))
        return
      }
    }
  }

  function onReady () {
    if (self.destroyed) return
    if (typeof ontorrent === 'function') ontorrent(torrent)
    self.emit('torrent', torrent)
  }

  function onClose () {
    torrent.removeListener('infoHash', onInfoHash)
    torrent.removeListener('ready', onReady)
    torrent.removeListener('close', onClose)
  }

  return torrent
}

/**
 * Start seeding a new file/folder.
 * @param  {string|File|FileList|Buffer|Array.<string|File|Buffer>} input
 * @param  {Object=} opts
 * @param  {function=} onseed called when torrent is seeding
 */
WebTorrent.prototype.seed = function (input, opts, onseed) {
  var self = this
  if (self.destroyed) throw new Error('client is destroyed')
  if (typeof opts === 'function') return self.seed(input, null, opts)

  debug('seed')
  opts = opts ? extend(opts) : {}

  // When seeding from fs path, initialize store from that path to avoid a copy
  if (typeof input === 'string') opts.path = path.dirname(input)
  if (!opts.createdBy) opts.createdBy = 'WebTorrent/' + VERSION_STR
  if (!self.tracker) opts.announce = []

  var torrent = self.add(null, opts, onTorrent)
  var streams

  if (!Array.isArray(input)) input = [ input ]
  parallel(input.map(function (item) {
    return function (cb) {
      if (isReadable(item)) concat(item, cb)
      else cb(null, item)
    }
  }), function (err, input) {
    if (self.destroyed) return
    if (err) return torrent._destroy(err)

    createTorrent.parseInput(input, opts, function (err, files) {
      if (self.destroyed) return
      if (err) return torrent._destroy(err)

      streams = files.map(function (file) {
        return file.getStream
      })

      createTorrent(input, opts, function (err, torrentBuf) {
        if (self.destroyed) return
        if (err) return torrent._destroy(err)

        var existingTorrent = self.get(torrentBuf)
        if (existingTorrent) {
          torrent._destroy(new Error('Cannot add duplicate torrent ' + existingTorrent.infoHash))
        } else {
          torrent._onTorrentId(torrentBuf)
        }
      })
    })
  })

  function onTorrent (torrent) {
    var tasks = [
      function (cb) {
        torrent.load(streams, cb)
      }
    ]
    if (self.dht) {
      tasks.push(function (cb) {
        torrent.once('dhtAnnounce', cb)
      })
    }
    parallel(tasks, function (err) {
      if (self.destroyed) return
      if (err) return torrent._destroy(err)
      _onseed(torrent)
    })
  }

  function _onseed (torrent) {
    debug('on seed')
    if (typeof onseed === 'function') onseed(torrent)
    self.emit('seed', torrent)
  }

  return torrent
}

/**
 * Remove a torrent from the client.
 * @param  {string|Buffer|Torrent}   torrentId
 * @param  {function} cb
 */
WebTorrent.prototype.remove = function (torrentId, cb) {
  debug('remove')
  var torrent = this.get(torrentId)
  if (!torrent) throw new Error('No torrent with id ' + torrentId)
  this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
  var torrent = this.get(torrentId)
  if (!torrent) return
  this.torrents.splice(this.torrents.indexOf(torrent), 1)
  torrent.destroy(cb)
}

WebTorrent.prototype.address = function () {
  if (!this.listening) return null
  return this._tcpPool
    ? this._tcpPool.server.address()
    : { address: '0.0.0.0', family: 'IPv4', port: 0 }
}

/**
 * Destroy the client, including all torrents and connections to peers.
 * @param  {function} cb
 */
WebTorrent.prototype.destroy = function (cb) {
  if (this.destroyed) throw new Error('client already destroyed')
  this._destroy(null, cb)
}

WebTorrent.prototype._destroy = function (err, cb) {
  var self = this
  debug('client destroy')
  self.destroyed = true

  var tasks = self.torrents.map(function (torrent) {
    return function (cb) {
      torrent.destroy(cb)
    }
  })

  if (self._tcpPool) {
    tasks.push(function (cb) {
      self._tcpPool.destroy(cb)
    })
  }

  if (self.dht) {
    tasks.push(function (cb) {
      self.dht.destroy(cb)
    })
  }

  parallel(tasks, cb)

  if (err) self.emit('error', err)

  self.torrents = []
  self._tcpPool = null
  self.dht = null
}

WebTorrent.prototype._onListening = function () {
  this.listening = true

  if (this._tcpPool) {
    // Sometimes server.address() returns `null` in Docker.
    // WebTorrent issue: https://github.com/feross/bittorrent-swarm/pull/18
    var address = this._tcpPool.server.address()
    if (address) this.torrentPort = address.port
  }

  this.emit('listening')
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./lib/tcp-pool":22,"./lib/torrent":177,"./package.json":179,"_process":104,"bittorrent-dht/client":22,"buffer":25,"create-torrent":34,"debug":39,"events":58,"hat":65,"inherits":70,"load-ip-set":22,"parse-torrent":97,"path":101,"run-parallel":121,"simple-concat":124,"simple-peer":126,"speedometer":139,"xtend":181,"zero-fill":196}],173:[function(require,module,exports){
module.exports = FileStream

var debug = require('debug')('webtorrent:file-stream')
var inherits = require('inherits')
var stream = require('readable-stream')

inherits(FileStream, stream.Readable)

/**
 * Readable stream of a torrent file
 *
 * @param {File} file
 * @param {Object} opts
 * @param {number} opts.start stream slice of file, starting from this byte (inclusive)
 * @param {number} opts.end stream slice of file, ending with this byte (inclusive)
 */
function FileStream (file, opts) {
  stream.Readable.call(this, opts)

  this.destroyed = false
  this._torrent = file._torrent

  var start = (opts && opts.start) || 0
  var end = (opts && opts.end && opts.end < file.length)
    ? opts.end
    : file.length - 1

  var pieceLength = file._torrent.pieceLength

  this._startPiece = (start + file.offset) / pieceLength | 0
  this._endPiece = (end + file.offset) / pieceLength | 0

  this._piece = this._startPiece
  this._offset = (start + file.offset) - (this._startPiece * pieceLength)

  this._missing = end - start + 1
  this._reading = false
  this._notifying = false
  this._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)
}

FileStream.prototype._read = function () {
  if (this._reading) return
  this._reading = true
  this._notify()
}

FileStream.prototype._notify = function () {
  var self = this

  if (!self._reading || self._missing === 0) return
  if (!self._torrent.bitfield.get(self._piece)) {
    return self._torrent.critical(self._piece, self._piece + self._criticalLength)
  }

  if (self._notifying) return
  self._notifying = true

  var p = self._piece
  self._torrent.store.get(p, function (err, buffer) {
    self._notifying = false
    if (self.destroyed) return
    if (err) return self._destroy(err)
    debug('read %s (length %s) (err %s)', p, buffer.length, err && err.message)

    if (self._offset) {
      buffer = buffer.slice(self._offset)
      self._offset = 0
    }

    if (self._missing < buffer.length) {
      buffer = buffer.slice(0, self._missing)
    }
    self._missing -= buffer.length

    debug('pushing buffer of length %s', buffer.length)
    self._reading = false
    self.push(buffer)

    if (self._missing === 0) self.push(null)
  })
  self._piece += 1
}

FileStream.prototype.destroy = function (onclose) {
  this._destroy(null, onclose)
}

FileStream.prototype._destroy = function (err, onclose) {
  if (this.destroyed) return
  this.destroyed = true

  if (!this._torrent.destroyed) {
    this._torrent.deselect(this._startPiece, this._endPiece, true)
  }

  if (err) this.emit('error', err)
  this.emit('close')
  if (onclose) onclose()
}

},{"debug":39,"inherits":70,"readable-stream":117}],174:[function(require,module,exports){
(function (process){
module.exports = File

var eos = require('end-of-stream')
var EventEmitter = require('events').EventEmitter
var FileStream = require('./file-stream')
var inherits = require('inherits')
var path = require('path')
var render = require('render-media')
var stream = require('readable-stream')
var streamToBlobURL = require('stream-to-blob-url')
var streamToBuffer = require('stream-with-known-length-to-buffer')

inherits(File, EventEmitter)

function File (torrent, file) {
  EventEmitter.call(this)

  this._torrent = torrent

  this.name = file.name
  this.path = file.path
  this.length = file.length
  this.offset = file.offset

  this.done = false

  var start = file.offset
  var end = start + file.length - 1

  this._startPiece = start / this._torrent.pieceLength | 0
  this._endPiece = end / this._torrent.pieceLength | 0

  if (this.length === 0) {
    this.done = true
    this.emit('done')
  }
}

File.prototype.select = function (priority) {
  if (this.length === 0) return
  this._torrent.select(this._startPiece, this._endPiece, priority)
}

File.prototype.deselect = function () {
  if (this.length === 0) return
  this._torrent.deselect(this._startPiece, this._endPiece, false)
}

File.prototype.createReadStream = function (opts) {
  var self = this
  if (this.length === 0) {
    var empty = new stream.PassThrough()
    process.nextTick(function () {
      empty.end()
    })
    return empty
  }

  var fileStream = new FileStream(self, opts)
  self._torrent.select(fileStream._startPiece, fileStream._endPiece, true, function () {
    fileStream._notify()
  })
  eos(fileStream, function () {
    if (!self._torrent.destroyed) {
      self._torrent.deselect(fileStream._startPiece, fileStream._endPiece, true)
    }
  })
  return fileStream
}

File.prototype.getBuffer = function (cb) {
  streamToBuffer(this.createReadStream(), this.length, cb)
}

File.prototype.getBlobURL = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  var mime = render.mime[path.extname(this.name).toLowerCase()]
  streamToBlobURL(this.createReadStream(), mime, cb)
}

File.prototype.appendTo = function (elem, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.append(this, elem, cb)
}

File.prototype.renderTo = function (elem, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.render(this, elem, cb)
}

File.prototype._destroy = function () {
  this._torrent = null
}

}).call(this,require('_process'))

},{"./file-stream":173,"_process":104,"end-of-stream":42,"events":58,"inherits":70,"path":101,"readable-stream":117,"render-media":118,"stream-to-blob-url":144,"stream-with-known-length-to-buffer":145}],175:[function(require,module,exports){
var arrayRemove = require('unordered-array-remove')
var debug = require('debug')('webtorrent:peer')
var Wire = require('bittorrent-protocol')

var WebConn = require('./webconn')

var CONNECT_TIMEOUT_TCP = 5000
var CONNECT_TIMEOUT_WEBRTC = 25000
var HANDSHAKE_TIMEOUT = 25000

/**
 * WebRTC peer connections start out connected, because WebRTC peers require an
 * "introduction" (i.e. WebRTC signaling), and there's no equivalent to an IP address
 * that lets you refer to a WebRTC endpoint.
 */
exports.createWebRTCPeer = function (conn, swarm) {
  var peer = new Peer(conn.id, 'webrtc')
  peer.conn = conn
  peer.swarm = swarm

  if (peer.conn.connected) {
    peer.onConnect()
  } else {
    peer.conn.once('connect', function () { peer.onConnect() })
    peer.conn.once('error', function (err) { peer.destroy(err) })
    peer.startConnectTimeout()
  }

  return peer
}

/**
 * Incoming TCP peers start out connected, because the remote peer connected to the
 * listening port of the TCP server. Until the remote peer sends a handshake, we don't
 * know what swarm the connection is intended for.
 */
exports.createTCPIncomingPeer = function (conn) {
  var addr = conn.remoteAddress + ':' + conn.remotePort
  var peer = new Peer(addr, 'tcpIncoming')
  peer.conn = conn
  peer.addr = addr

  peer.onConnect()

  return peer
}

/**
 * Outgoing TCP peers start out with just an IP address. At some point (when there is an
 * available connection), the client can attempt to connect to the address.
 */
exports.createTCPOutgoingPeer = function (addr, swarm) {
  var peer = new Peer(addr, 'tcpOutgoing')
  peer.addr = addr
  peer.swarm = swarm

  return peer
}

/**
 * Peer that represents a Web Seed (BEP17 / BEP19).
 */
exports.createWebSeedPeer = function (url, swarm) {
  var peer = new Peer(url, 'webSeed')
  peer.swarm = swarm
  peer.conn = new WebConn(url, swarm)

  peer.onConnect()

  return peer
}

/**
 * Peer. Represents a peer in the torrent swarm.
 *
 * @param {string} id "ip:port" string, peer id (for WebRTC peers), or url (for Web Seeds)
 * @param {string} type the type of the peer
 */
function Peer (id, type) {
  var self = this
  self.id = id
  self.type = type

  debug('new Peer %s', id)

  self.addr = null
  self.conn = null
  self.swarm = null
  self.wire = null

  self.connected = false
  self.destroyed = false
  self.timeout = null // handshake timeout
  self.retries = 0 // outgoing TCP connection retry count

  self.sentHandshake = false
}

/**
 * Called once the peer is connected (i.e. fired 'connect' event)
 * @param {Socket} conn
 */
Peer.prototype.onConnect = function () {
  var self = this
  if (self.destroyed) return
  self.connected = true

  debug('Peer %s connected', self.id)

  clearTimeout(self.connectTimeout)

  var conn = self.conn
  conn.once('end', function () {
    self.destroy()
  })
  conn.once('close', function () {
    self.destroy()
  })
  conn.once('finish', function () {
    self.destroy()
  })
  conn.once('error', function (err) {
    self.destroy(err)
  })

  var wire = self.wire = new Wire()
  wire.type = self.type
  wire.once('end', function () {
    self.destroy()
  })
  wire.once('close', function () {
    self.destroy()
  })
  wire.once('finish', function () {
    self.destroy()
  })
  wire.once('error', function (err) {
    self.destroy(err)
  })

  wire.once('handshake', function (infoHash, peerId) {
    self.onHandshake(infoHash, peerId)
  })
  self.startHandshakeTimeout()

  conn.pipe(wire).pipe(conn)
  if (self.swarm && !self.sentHandshake) self.handshake()
}

/**
 * Called when handshake is received from remote peer.
 * @param {string} infoHash
 * @param {string} peerId
 */
Peer.prototype.onHandshake = function (infoHash, peerId) {
  var self = this
  if (!self.swarm) return // `self.swarm` not set yet, so do nothing

  if (self.swarm.destroyed) return self.destroy(new Error('swarm already destroyed'))
  if (infoHash !== self.swarm.infoHash) {
    return self.destroy(new Error('unexpected handshake info hash for this swarm'))
  }
  if (peerId === self.swarm.peerId) {
    return self.destroy(new Error('refusing to connect to ourselves'))
  }

  debug('Peer %s got handshake %s', self.id, infoHash)

  clearTimeout(self.handshakeTimeout)

  self.retries = 0

  var addr = self.addr
  if (!addr && self.conn.remoteAddress) {
    addr = self.conn.remoteAddress + ':' + self.conn.remotePort
  }
  self.swarm._onWire(self.wire, addr)

  // swarm could be destroyed in user's 'wire' event handler
  if (!self.swarm || self.swarm.destroyed) return

  if (!self.sentHandshake) self.handshake()
}

Peer.prototype.handshake = function () {
  var self = this
  var opts = {
    dht: self.swarm.private ? false : !!self.swarm.client.dht
  }
  self.wire.handshake(self.swarm.infoHash, self.swarm.client.peerId, opts)
  self.sentHandshake = true
}

Peer.prototype.startConnectTimeout = function () {
  var self = this
  clearTimeout(self.connectTimeout)
  self.connectTimeout = setTimeout(function () {
    self.destroy(new Error('connect timeout'))
  }, self.type === 'webrtc' ? CONNECT_TIMEOUT_WEBRTC : CONNECT_TIMEOUT_TCP)
  if (self.connectTimeout.unref) self.connectTimeout.unref()
}

Peer.prototype.startHandshakeTimeout = function () {
  var self = this
  clearTimeout(self.handshakeTimeout)
  self.handshakeTimeout = setTimeout(function () {
    self.destroy(new Error('handshake timeout'))
  }, HANDSHAKE_TIMEOUT)
  if (self.handshakeTimeout.unref) self.handshakeTimeout.unref()
}

Peer.prototype.destroy = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self.connected = false

  debug('destroy %s (error: %s)', self.id, err && (err.message || err))

  clearTimeout(self.connectTimeout)
  clearTimeout(self.handshakeTimeout)

  var swarm = self.swarm
  var conn = self.conn
  var wire = self.wire

  self.swarm = null
  self.conn = null
  self.wire = null

  if (swarm && wire) {
    arrayRemove(swarm.wires, swarm.wires.indexOf(wire))
  }
  if (conn) {
    conn.on('error', noop)
    conn.destroy()
  }
  if (wire) wire.destroy()
  if (swarm) swarm.removePeer(self.id)
}

function noop () {}

},{"./webconn":178,"bittorrent-protocol":14,"debug":39,"unordered-array-remove":157}],176:[function(require,module,exports){
module.exports = RarityMap

/**
 * Mapping of torrent pieces to their respective availability in the torrent swarm. Used
 * by the torrent manager for implementing the rarest piece first selection strategy.
 */
function RarityMap (torrent) {
  var self = this

  self._torrent = torrent
  self._numPieces = torrent.pieces.length
  self._pieces = []

  self._onWire = function (wire) {
    self.recalculate()
    self._initWire(wire)
  }
  self._onWireHave = function (index) {
    self._pieces[index] += 1
  }
  self._onWireBitfield = function () {
    self.recalculate()
  }

  self._torrent.wires.forEach(function (wire) {
    self._initWire(wire)
  })
  self._torrent.on('wire', self._onWire)
  self.recalculate()
}

/**
 * Get the index of the rarest piece. Optionally, pass a filter function to exclude
 * certain pieces (for instance, those that we already have).
 *
 * @param {function} pieceFilterFunc
 * @return {number} index of rarest piece, or -1
 */
RarityMap.prototype.getRarestPiece = function (pieceFilterFunc) {
  if (!pieceFilterFunc) pieceFilterFunc = trueFn

  var candidates = []
  var min = Infinity

  for (var i = 0; i < this._numPieces; ++i) {
    if (!pieceFilterFunc(i)) continue

    var availability = this._pieces[i]
    if (availability === min) {
      candidates.push(i)
    } else if (availability < min) {
      candidates = [ i ]
      min = availability
    }
  }

  if (candidates.length > 0) {
    // if there are multiple pieces with the same availability, choose one randomly
    return candidates[Math.random() * candidates.length | 0]
  } else {
    return -1
  }
}

RarityMap.prototype.destroy = function () {
  var self = this
  self._torrent.removeListener('wire', self._onWire)
  self._torrent.wires.forEach(function (wire) {
    self._cleanupWireEvents(wire)
  })
  self._torrent = null
  self._pieces = null

  self._onWire = null
  self._onWireHave = null
  self._onWireBitfield = null
}

RarityMap.prototype._initWire = function (wire) {
  var self = this

  wire._onClose = function () {
    self._cleanupWireEvents(wire)
    for (var i = 0; i < this._numPieces; ++i) {
      self._pieces[i] -= wire.peerPieces.get(i)
    }
  }

  wire.on('have', self._onWireHave)
  wire.on('bitfield', self._onWireBitfield)
  wire.once('close', wire._onClose)
}

/**
 * Recalculates piece availability across all peers in the torrent.
 */
RarityMap.prototype.recalculate = function () {
  var i
  for (i = 0; i < this._numPieces; ++i) {
    this._pieces[i] = 0
  }

  var numWires = this._torrent.wires.length
  for (i = 0; i < numWires; ++i) {
    var wire = this._torrent.wires[i]
    for (var j = 0; j < this._numPieces; ++j) {
      this._pieces[j] += wire.peerPieces.get(j)
    }
  }
}

RarityMap.prototype._cleanupWireEvents = function (wire) {
  wire.removeListener('have', this._onWireHave)
  wire.removeListener('bitfield', this._onWireBitfield)
  if (wire._onClose) wire.removeListener('close', wire._onClose)
  wire._onClose = null
}

function trueFn () {
  return true
}

},{}],177:[function(require,module,exports){
(function (process,global){
/* global URL, Blob */

module.exports = Torrent

var addrToIPPort = require('addr-to-ip-port')
var BitField = require('bitfield')
var ChunkStoreWriteStream = require('chunk-store-stream/write')
var debug = require('debug')('webtorrent:torrent')
var Discovery = require('torrent-discovery')
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var extendMutable = require('xtend/mutable')
var fs = require('fs')
var FSChunkStore = require('fs-chunk-store') // browser: `memory-chunk-store`
var ImmediateChunkStore = require('immediate-chunk-store')
var inherits = require('inherits')
var MultiStream = require('multistream')
var net = require('net') // browser exclude
var os = require('os') // browser exclude
var parallel = require('run-parallel')
var parallelLimit = require('run-parallel-limit')
var parseTorrent = require('parse-torrent')
var path = require('path')
var pathExists = require('path-exists') // browser exclude
var Piece = require('torrent-piece')
var pump = require('pump')
var randomIterate = require('random-iterate')
var sha1 = require('simple-sha1')
var speedometer = require('speedometer')
var uniq = require('uniq')
var utMetadata = require('ut_metadata')
var utPex = require('ut_pex') // browser exclude

var File = require('./file')
var Peer = require('./peer')
var RarityMap = require('./rarity-map')
var Server = require('./server') // browser exclude

var MAX_BLOCK_LENGTH = 128 * 1024
var PIECE_TIMEOUT = 30000
var CHOKE_TIMEOUT = 5000
var SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH

var PIPELINE_MIN_DURATION = 0.5
var PIPELINE_MAX_DURATION = 1

var RECHOKE_INTERVAL = 10000 // 10 seconds
var RECHOKE_OPTIMISTIC_DURATION = 2 // 30 seconds

var FILESYSTEM_CONCURRENCY = 2

var RECONNECT_WAIT = [ 1000, 5000, 15000 ]

var TMP = typeof pathExists.sync === 'function'
  ? path.join(pathExists.sync('/tmp') ? '/tmp' : os.tmpDir(), 'webtorrent')
  : '/tmp/webtorrent'

inherits(Torrent, EventEmitter)

function Torrent (torrentId, client, opts) {
  EventEmitter.call(this)

  this.client = client
  this._debugId = this.client.peerId.slice(32)

  this._debug('new torrent')

  this.announce = opts.announce
  this.urlList = opts.urlList

  this.path = opts.path
  this._store = opts.store || FSChunkStore
  this._getAnnounceOpts = opts.getAnnounceOpts

  this.strategy = opts.strategy || 'sequential'

  this.maxWebConns = opts.maxWebConns || 4

  this._rechokeNumSlots = (opts.uploads === false || opts.uploads === 0)
    ? 0
    : (+opts.uploads || 10)
  this._rechokeOptimisticWire = null
  this._rechokeOptimisticTime = 0
  this._rechokeIntervalId = null

  this.ready = false
  this.destroyed = false
  this.paused = false
  this.done = false

  this.metadata = null
  this.store = null
  this.files = []
  this.pieces = []

  this._amInterested = false
  this._selections = []
  this._critical = []

  this.wires = [] // open wires (added *after* handshake)

  this._queue = [] // queue of outgoing tcp peers to connect to
  this._peers = {} // connected peers (addr/peerId -> Peer)
  this._peersLength = 0 // number of elements in `this._peers` (cache, for perf)

  // stats
  this.received = 0
  this.uploaded = 0
  this._downloadSpeed = speedometer()
  this._uploadSpeed = speedometer()

  // for cleanup
  this._servers = []

  // TODO: remove this and expose a hook instead
  // optimization: don't recheck every file if it hasn't changed
  this._fileModtimes = opts.fileModtimes

  if (torrentId !== null) this._onTorrentId(torrentId)
}

Object.defineProperty(Torrent.prototype, 'timeRemaining', {
  get: function () {
    if (this.done) return 0
    if (this.downloadSpeed === 0) return Infinity
    return ((this.length - this.downloaded) / this.downloadSpeed) * 1000
  }
})

Object.defineProperty(Torrent.prototype, 'downloaded', {
  get: function () {
    if (!this.bitfield) return 0
    var downloaded = 0
    for (var index = 0, len = this.pieces.length; index < len; ++index) {
      if (this.bitfield.get(index)) { // verified data
        downloaded += (index === len - 1) ? this.lastPieceLength : this.pieceLength
      } else { // "in progress" data
        var piece = this.pieces[index]
        downloaded += (piece.length - piece.missing)
      }
    }
    return downloaded
  }
})

// TODO: re-enable this. The number of missing pieces. Used to implement 'end game' mode.
// Object.defineProperty(Storage.prototype, 'numMissing', {
//   get: function () {
//     var self = this
//     var numMissing = self.pieces.length
//     for (var index = 0, len = self.pieces.length; index < len; index++) {
//       numMissing -= self.bitfield.get(index)
//     }
//     return numMissing
//   }
// })

Object.defineProperty(Torrent.prototype, 'downloadSpeed', {
  get: function () { return this._downloadSpeed() }
})

Object.defineProperty(Torrent.prototype, 'uploadSpeed', {
  get: function () { return this._uploadSpeed() }
})

Object.defineProperty(Torrent.prototype, 'progress', {
  get: function () { return this.length ? this.downloaded / this.length : 0 }
})

Object.defineProperty(Torrent.prototype, 'ratio', {
  get: function () { return this.uploaded / (this.received || 1) }
})

Object.defineProperty(Torrent.prototype, 'numPeers', {
  get: function () { return this.wires.length }
})

Object.defineProperty(Torrent.prototype, 'torrentFileBlobURL', {
  get: function () {
    if (typeof window === 'undefined') throw new Error('browser-only property')
    if (!this.torrentFile) return null
    return URL.createObjectURL(
      new Blob([ this.torrentFile ], { type: 'application/x-bittorrent' })
    )
  }
})

Object.defineProperty(Torrent.prototype, '_numQueued', {
  get: function () {
    return this._queue.length + (this._peersLength - this._numConns)
  }
})

Object.defineProperty(Torrent.prototype, '_numConns', {
  get: function () {
    var self = this
    var numConns = 0
    for (var id in self._peers) {
      if (self._peers[id].connected) numConns += 1
    }
    return numConns
  }
})

// TODO: remove in v2
Object.defineProperty(Torrent.prototype, 'swarm', {
  get: function () {
    console.log('WebTorrent: `torrent.swarm` is deprecated. Use `torrent` directly instead.')
    return this
  }
})

Torrent.prototype._onTorrentId = function (torrentId) {
  var self = this
  if (self.destroyed) return

  var parsedTorrent
  try { parsedTorrent = parseTorrent(torrentId) } catch (err) {}
  if (parsedTorrent) {
    // Attempt to set infoHash property synchronously
    self.infoHash = parsedTorrent.infoHash
    process.nextTick(function () {
      if (self.destroyed) return
      self._onParsedTorrent(parsedTorrent)
    })
  } else {
    // If torrentId failed to parse, it could be in a form that requires an async
    // operation, i.e. http/https link, filesystem path, or Blob.
    parseTorrent.remote(torrentId, function (err, parsedTorrent) {
      if (self.destroyed) return
      if (err) return self._destroy(err)
      self._onParsedTorrent(parsedTorrent)
    })
  }
}

Torrent.prototype._onParsedTorrent = function (parsedTorrent) {
  var self = this
  if (self.destroyed) return

  self._processParsedTorrent(parsedTorrent)

  if (!self.infoHash) {
    return self._destroy(new Error('Malformed torrent data: No info hash'))
  }

  if (!self.path) self.path = path.join(TMP, self.infoHash)

  self._rechokeIntervalId = setInterval(function () {
    self._rechoke()
  }, RECHOKE_INTERVAL)
  if (self._rechokeIntervalId.unref) self._rechokeIntervalId.unref()

  self.emit('infoHash', self.infoHash)
  if (self.destroyed) return // user might destroy torrent in `infoHash` event handler

  if (self.client.listening) {
    self._onListening()
  } else {
    self.client.once('listening', function () {
      self._onListening()
    })
  }
}

Torrent.prototype._processParsedTorrent = function (parsedTorrent) {
  if (this.announce) {
    // Allow specifying trackers via `opts` parameter
    parsedTorrent.announce = parsedTorrent.announce.concat(this.announce)
  }

  if (this.client.tracker && global.WEBTORRENT_ANNOUNCE && !this.private) {
    // So `webtorrent-hybrid` can force specific trackers to be used
    parsedTorrent.announce = parsedTorrent.announce.concat(global.WEBTORRENT_ANNOUNCE)
  }

  if (this.urlList) {
    // Allow specifying web seeds via `opts` parameter
    parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList)
  }

  uniq(parsedTorrent.announce)
  uniq(parsedTorrent.urlList)

  extendMutable(this, parsedTorrent)

  this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent)
  this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent)
}

Torrent.prototype._onListening = function () {
  var self = this
  if (self.discovery || self.destroyed) return
  var trackerOpts = {
    rtcConfig: self.client._rtcConfig,
    wrtc: self.client._wrtc,
    getAnnounceOpts: function () {
      var opts = {
        uploaded: self.uploaded,
        downloaded: self.downloaded,
        left: Math.max(self.length - self.downloaded, 0)
      }
      if (self._getAnnounceOpts) opts = extend(opts, self._getAnnounceOpts())
      return opts
    }
  }

  // begin discovering peers via DHT and trackers
  self.discovery = new Discovery({
    infoHash: self.infoHash,
    announce: self.announce,
    peerId: self.client.peerId,
    dht: !self.private && self.client.dht,
    tracker: self.client.tracker && trackerOpts,
    port: self.client.torrentPort
  })

  self.discovery.on('error', onError)
  self.discovery.on('peer', onPeer)
  self.discovery.on('trackerAnnounce', onTrackerAnnounce)
  self.discovery.on('dhtAnnounce', onDHTAnnounce)
  self.discovery.on('warning', onWarning)

  function onError (err) {
    self._destroy(err)
  }

  function onPeer (peer) {
    // Don't create new outgoing TCP connections when torrent is done
    if (typeof peer === 'string' && self.done) return
    self.addPeer(peer)
  }

  function onTrackerAnnounce () {
    self.emit('trackerAnnounce')
  }

  function onDHTAnnounce () {
    self.emit('dhtAnnounce')
  }

  function onWarning (err) {
    self.emit('warning', err)
  }

  // if full metadata was included in initial torrent id, use it immediately. Otherwise,
  // wait for torrent-discovery to find peers and ut_metadata to get the metadata.
  if (self.info) self._onMetadata(self)
}

/**
 * Called when the full torrent metadata is received.
 */
Torrent.prototype._onMetadata = function (metadata) {
  var self = this
  if (self.metadata || self.destroyed) return
  self._debug('got metadata')

  var parsedTorrent
  if (metadata && metadata.infoHash) {
    // `metadata` is a parsed torrent (from parse-torrent module)
    parsedTorrent = metadata
  } else {
    try {
      parsedTorrent = parseTorrent(metadata)
    } catch (err) {
      return self._destroy(err)
    }
  }

  self._processParsedTorrent(parsedTorrent)
  self.metadata = self.torrentFile

  // add web seed urls (BEP19)
  self.urlList.forEach(function (url) {
    self.addWebSeed(url)
  })

  self._rarityMap = new RarityMap(self)

  self.store = new ImmediateChunkStore(
    new self._store(self.pieceLength, {
      torrent: {
        infoHash: self.infoHash
      },
      files: self.files.map(function (file) {
        return {
          path: path.join(self.path, file.path),
          length: file.length,
          offset: file.offset
        }
      }),
      length: self.length
    })
  )

  self.files = self.files.map(function (file) {
    return new File(self, file)
  })

  self._hashes = self.pieces

  self.pieces = self.pieces.map(function (hash, i) {
    var pieceLength = (i === self.pieces.length - 1)
      ? self.lastPieceLength
      : self.pieceLength
    return new Piece(pieceLength)
  })

  self._reservations = self.pieces.map(function () {
    return []
  })

  self.bitfield = new BitField(self.pieces.length)

  self.wires.forEach(function (wire) {
    // If we didn't have the metadata at the time ut_metadata was initialized for this
    // wire, we still want to make it available to the peer in case they request it.
    if (wire.ut_metadata) wire.ut_metadata.setMetadata(self.metadata)

    self._onWireWithMetadata(wire)
  })

  self._debug('verifying existing torrent data')
  if (self._fileModtimes && self._store === FSChunkStore) {
    // don't verify if the files haven't been modified since we last checked
    self.getFileModtimes(function (err, fileModtimes) {
      if (err) return self._destroy(err)

      var unchanged = self.files.map(function (_, index) {
        return fileModtimes[index] === self._fileModtimes[index]
      }).every(function (x) {
        return x
      })

      if (unchanged) {
        for (var index = 0; index < self.pieces.length; index++) {
          self._markVerified(index)
        }
        self._onStore()
      } else {
        self._verifyPieces()
      }
    })
  } else {
    self._verifyPieces()
  }

  self.emit('metadata')
}

/*
 * TODO: remove this
 * Gets the last modified time of every file on disk for this torrent.
 * Only valid in Node, not in the browser.
 */
Torrent.prototype.getFileModtimes = function (cb) {
  var self = this
  var ret = []
  parallelLimit(self.files.map(function (file, index) {
    return function (cb) {
      fs.stat(path.join(self.path, file.path), function (err, stat) {
        if (err && err.code !== 'ENOENT') return cb(err)
        ret[index] = stat && stat.mtime.getTime()
        cb(null)
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    self._debug('done getting file modtimes')
    cb(err, ret)
  })
}

Torrent.prototype._verifyPieces = function () {
  var self = this
  parallelLimit(self.pieces.map(function (_, index) {
    return function (cb) {
      if (self.destroyed) return cb(new Error('torrent is destroyed'))
      self.store.get(index, function (err, buf) {
        if (err) return cb(null) // ignore error
        sha1(buf, function (hash) {
          if (hash === self._hashes[index]) {
            if (!self.pieces[index]) return
            self._debug('piece verified %s', index)
            self._markVerified(index)
          } else {
            self._debug('piece invalid %s', index)
          }
          cb(null)
        })
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    if (err) return self._destroy(err)
    self._debug('done verifying')
    self._onStore()
  })
}

Torrent.prototype._markVerified = function (index) {
  this.pieces[index] = null
  this._reservations[index] = null
  this.bitfield.set(index, true)
}

/**
 * Called when the metadata, listening server, and underlying chunk store is initialized.
 */
Torrent.prototype._onStore = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on store')

  // start off selecting the entire torrent with low priority
  self.select(0, self.pieces.length - 1, false)

  self.ready = true
  self.emit('ready')

  // Files may start out done if the file was already in the store
  self._checkDone()

  // In case any selections were made before torrent was ready
  self._updateSelections()
}

Torrent.prototype.destroy = function (cb) {
  var self = this
  self._destroy(null, cb)
}

Torrent.prototype._destroy = function (err, cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self._debug('destroy')

  self.client._remove(self)

  clearInterval(self._rechokeIntervalId)

  if (self._rarityMap) {
    self._rarityMap.destroy()
  }

  for (var id in self._peers) {
    self.removePeer(id)
  }

  self.files.forEach(function (file) {
    if (file instanceof File) file._destroy()
  })

  var tasks = self._servers.map(function (server) {
    return function (cb) {
      server.destroy(cb)
    }
  })

  if (self.discovery) {
    tasks.push(function (cb) {
      self.discovery.destroy(cb)
    })
  }

  if (self.store) {
    tasks.push(function (cb) {
      self.store.close(cb)
    })
  }

  parallel(tasks, cb)

  if (err) {
    // Torrent errors are emitted at `torrent.on('error')`. If there are no 'error' event
    // handlers on the torrent instance, the error will be emitted at
    // `client.on('error')`. This prevents crashing the user's program, but it makes it
    // impossible to determine a client error versus a torrent error (where the client
    // is still usable afterwards). Users are recommended for errors in both places
    // to distinguish between the error types.
    if (self.listenerCount('error') === 0) {
      self.client.emit('error', err)
    } else {
      self.emit('error', err)
    }
  }

  self.emit('close')

  self.client = null
  self.files = []
  self.discovery = null
  self.store = null
  self._rarityMap = null
  self._peers = null
  self._servers = null
}

Torrent.prototype.addPeer = function (peer) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.infoHash) throw new Error('addPeer() must not be called before the `infoHash` event')

  if (self.client.blocked) {
    var host
    if (typeof peer === 'string') {
      var parts
      try {
        parts = addrToIPPort(peer)
      } catch (e) {
        self._debug('ignoring peer: invalid %s', peer)
        self.emit('invalidPeer', peer)
        return false
      }
      host = parts[0]
    } else if (typeof peer.remoteAddress === 'string') {
      host = peer.remoteAddress
    }

    if (host && self.client.blocked.contains(host)) {
      self._debug('ignoring peer: blocked %s', peer)
      if (typeof peer !== 'string') peer.destroy()
      self.emit('blockedPeer', peer)
      return false
    }
  }

  var wasAdded = !!self._addPeer(peer)
  if (wasAdded) {
    self.emit('peer', peer)
  } else {
    self.emit('invalidPeer', peer)
  }
  return wasAdded
}

Torrent.prototype._addPeer = function (peer) {
  var self = this
  if (self.destroyed) {
    self._debug('ignoring peer: torrent is destroyed')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }
  if (typeof peer === 'string' && !self._validAddr(peer)) {
    self._debug('ignoring peer: invalid %s', peer)
    return null
  }

  var id = (peer && peer.id) || peer
  if (self._peers[id]) {
    self._debug('ignoring peer: duplicate (%s)', id)
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  if (self.paused) {
    self._debug('ignoring peer: torrent is paused')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  self._debug('add peer %s', id)

  var newPeer
  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    newPeer = Peer.createTCPOutgoingPeer(peer, self)
  } else {
    // `peer` is a WebRTC connection (simple-peer)
    newPeer = Peer.createWebRTCPeer(peer, self)
  }

  self._peers[newPeer.id] = newPeer
  self._peersLength += 1

  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    self._queue.push(newPeer)
    self._drain()
  }

  return newPeer
}

Torrent.prototype.addWebSeed = function (url) {
  if (this.destroyed) throw new Error('torrent is destroyed')

  if (!/^https?:\/\/.+/.test(url)) {
    this._debug('ignoring invalid web seed %s', url)
    this.emit('invalidPeer', url)
    return
  }

  if (this._peers[url]) {
    this._debug('ignoring duplicate web seed %s', url)
    this.emit('invalidPeer', url)
    return
  }

  this._debug('add web seed %s', url)

  var newPeer = Peer.createWebSeedPeer(url, this)
  this._peers[newPeer.id] = newPeer
  this._peersLength += 1

  this.emit('peer', url)
}

/**
 * Called whenever a new incoming TCP peer connects to this torrent swarm. Called with a
 * peer that has already sent a handshake.
 */
Torrent.prototype._addIncomingPeer = function (peer) {
  var self = this
  if (self.destroyed) return peer.destroy(new Error('torrent is destroyed'))
  if (self.paused) return peer.destroy(new Error('torrent is paused'))

  this._debug('add incoming peer %s', peer.id)

  self._peers[peer.id] = peer
  self._peersLength += 1
}

Torrent.prototype.removePeer = function (peer) {
  var self = this
  var id = (peer && peer.id) || peer
  peer = self._peers[id]

  if (!peer) return

  this._debug('removePeer %s', id)

  delete self._peers[id]
  self._peersLength -= 1

  peer.destroy()

  // If torrent swarm was at capacity before, try to open a new connection now
  self._drain()
}

Torrent.prototype.select = function (start, end, priority, notify) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  if (start > end || start < 0 || end >= self.pieces.length) {
    throw new Error('invalid selection ', start, ':', end)
  }
  priority = Number(priority) || 0

  self._debug('select %s-%s (priority %s)', start, end, priority)

  self._selections.push({
    from: start,
    to: end,
    offset: 0,
    priority: priority,
    notify: notify || noop
  })

  self._selections.sort(function (a, b) {
    return b.priority - a.priority
  })

  self._updateSelections()
}

Torrent.prototype.deselect = function (start, end, priority) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  priority = Number(priority) || 0
  self._debug('deselect %s-%s (priority %s)', start, end, priority)

  for (var i = 0; i < self._selections.length; ++i) {
    var s = self._selections[i]
    if (s.from === start && s.to === end && s.priority === priority) {
      self._selections.splice(i--, 1)
      break
    }
  }

  self._updateSelections()
}

Torrent.prototype.critical = function (start, end) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  self._debug('critical %s-%s', start, end)

  for (var i = start; i <= end; ++i) {
    self._critical[i] = true
  }

  self._updateSelections()
}

Torrent.prototype._onWire = function (wire, addr) {
  var self = this
  self._debug('got wire %s (%s)', wire._debugId, addr || 'Unknown')

  wire.on('download', function (downloaded) {
    if (self.destroyed) return
    self.received += downloaded
    self._downloadSpeed(downloaded)
    self.client._downloadSpeed(downloaded)
    self.emit('download', downloaded)
    self.client.emit('download', downloaded)
  })

  wire.on('upload', function (uploaded) {
    if (self.destroyed) return
    self.uploaded += uploaded
    self._uploadSpeed(uploaded)
    self.client._uploadSpeed(uploaded)
    self.emit('upload', uploaded)
    self.client.emit('upload', uploaded)
  })

  self.wires.push(wire)

  if (addr) {
    // Sometimes RTCPeerConnection.getStats() doesn't return an ip:port for peers
    var parts = addrToIPPort(addr)
    wire.remoteAddress = parts[0]
    wire.remotePort = parts[1]
  }

  // When peer sends PORT message, add that DHT node to routing table
  if (self.client.dht && self.client.dht.listening) {
    wire.on('port', function (port) {
      if (self.destroyed || self.client.dht.destroyed) {
        return
      }
      if (!wire.remoteAddress) {
        return self._debug('ignoring PORT from peer with no address')
      }
      if (port === 0 || port > 65536) {
        return self._debug('ignoring invalid PORT from peer')
      }

      self._debug('port: %s (from %s)', port, addr)
      self.client.dht.addNode({ host: wire.remoteAddress, port: port })
    })
  }

  wire.on('timeout', function () {
    self._debug('wire timeout (%s)', addr)
    // TODO: this might be destroying wires too eagerly
    wire.destroy()
  })

  // Timeout for piece requests to this peer
  wire.setTimeout(PIECE_TIMEOUT, true)

  // Send KEEP-ALIVE (every 60s) so peers will not disconnect the wire
  wire.setKeepAlive(true)

  // use ut_metadata extension
  wire.use(utMetadata(self.metadata))

  wire.ut_metadata.on('warning', function (err) {
    self._debug('ut_metadata warning: %s', err.message)
  })

  if (!self.metadata) {
    wire.ut_metadata.on('metadata', function (metadata) {
      self._debug('got metadata via ut_metadata')
      self._onMetadata(metadata)
    })
    wire.ut_metadata.fetch()
  }

  // use ut_pex extension if the torrent is not flagged as private
  if (typeof utPex === 'function' && !self.private) {
    wire.use(utPex())

    wire.ut_pex.on('peer', function (peer) {
      // Only add potential new peers when we're not seeding
      if (self.done) return
      self._debug('ut_pex: got peer: %s (from %s)', peer, addr)
      self.addPeer(peer)
    })

    wire.ut_pex.on('dropped', function (peer) {
      // the remote peer believes a given peer has been dropped from the torrent swarm.
      // if we're not currently connected to it, then remove it from the queue.
      var peerObj = self._peers[peer]
      if (peerObj && !peerObj.connected) {
        self._debug('ut_pex: dropped peer: %s (from %s)', peer, addr)
        self.removePeer(peer)
      }
    })

    wire.once('close', function () {
      // Stop sending updates to remote peer
      wire.ut_pex.reset()
    })
  }

  // Hook to allow user-defined `bittorrent-protocol` extensions
  // More info: https://github.com/feross/bittorrent-protocol#extension-api
  self.emit('wire', wire, addr)

  if (self.metadata) {
    process.nextTick(function () {
      // This allows wire.handshake() to be called (by Peer.onHandshake) before any
      // messages get sent on the wire
      self._onWireWithMetadata(wire)
    })
  }
}

Torrent.prototype._onWireWithMetadata = function (wire) {
  var self = this
  var timeoutId = null

  function onChokeTimeout () {
    if (self.destroyed || wire.destroyed) return

    if (self._numQueued > 2 * (self._numConns - self.numPeers) &&
      wire.amInterested) {
      wire.destroy()
    } else {
      timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
      if (timeoutId.unref) timeoutId.unref()
    }
  }

  var i = 0
  function updateSeedStatus () {
    if (wire.peerPieces.length !== self.pieces.length) return
    for (; i < self.pieces.length; ++i) {
      if (!wire.peerPieces.get(i)) return
    }
    wire.isSeeder = true
    wire.choke() // always choke seeders
  }

  wire.on('bitfield', function () {
    updateSeedStatus()
    self._update()
  })

  wire.on('have', function () {
    updateSeedStatus()
    self._update()
  })

  wire.once('interested', function () {
    wire.unchoke()
  })

  wire.once('close', function () {
    clearTimeout(timeoutId)
  })

  wire.on('choke', function () {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
    if (timeoutId.unref) timeoutId.unref()
  })

  wire.on('unchoke', function () {
    clearTimeout(timeoutId)
    self._update()
  })

  wire.on('request', function (index, offset, length, cb) {
    if (length > MAX_BLOCK_LENGTH) {
      // Per spec, disconnect from peers that request >128KB
      return wire.destroy()
    }
    if (self.pieces[index]) return
    self.store.get(index, { offset: offset, length: length }, cb)
  })

  wire.bitfield(self.bitfield) // always send bitfield (required)
  wire.interested() // always start out interested

  // Send PORT message to peers that support DHT
  if (wire.peerExtensions.dht && self.client.dht && self.client.dht.listening) {
    wire.port(self.client.dht.address().port)
  }

  timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
  if (timeoutId.unref) timeoutId.unref()

  wire.isSeeder = false
  updateSeedStatus()
}

/**
 * Called on selection changes.
 */
Torrent.prototype._updateSelections = function () {
  var self = this
  if (!self.ready || self.destroyed) return

  process.nextTick(function () {
    self._gcSelections()
  })
  self._updateInterest()
  self._update()
}

/**
 * Garbage collect selections with respect to the store's current state.
 */
Torrent.prototype._gcSelections = function () {
  var self = this

  for (var i = 0; i < self._selections.length; i++) {
    var s = self._selections[i]
    var oldOffset = s.offset

    // check for newly downloaded pieces in selection
    while (self.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {
      s.offset++
    }

    if (oldOffset !== s.offset) s.notify()
    if (s.to !== s.from + s.offset) continue
    if (!self.bitfield.get(s.from + s.offset)) continue

    // remove fully downloaded selection
    self._selections.splice(i--, 1) // decrement i to offset splice
    s.notify() // TODO: this may notify twice in a row. is this a problem?
    self._updateInterest()
  }

  if (!self._selections.length) self.emit('idle')
}

/**
 * Update interested status for all peers.
 */
Torrent.prototype._updateInterest = function () {
  var self = this

  var prev = self._amInterested
  self._amInterested = !!self._selections.length

  self.wires.forEach(function (wire) {
    // TODO: only call wire.interested if the wire has at least one piece we need
    if (self._amInterested) wire.interested()
    else wire.uninterested()
  })

  if (prev === self._amInterested) return
  if (self._amInterested) self.emit('interested')
  else self.emit('uninterested')
}

/**
 * Heartbeat to update all peers and their requests.
 */
Torrent.prototype._update = function () {
  var self = this
  if (self.destroyed) return

  // update wires in random order for better request distribution
  var ite = randomIterate(self.wires)
  var wire
  while ((wire = ite())) {
    self._updateWire(wire)
  }
}

/**
 * Attempts to update a peer's requests
 */
Torrent.prototype._updateWire = function (wire) {
  var self = this

  if (wire.peerChoking) return
  if (!wire.downloaded) return validateWire()

  var minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION)
  if (wire.requests.length >= minOutstandingRequests) return
  var maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  trySelectWire(false) || trySelectWire(true)

  function genPieceFilterFunc (start, end, tried, rank) {
    return function (i) {
      return i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i))
    }
  }

  // TODO: Do we need both validateWire and trySelectWire?
  function validateWire () {
    if (wire.requests.length) return

    var i = self._selections.length
    while (i--) {
      var next = self._selections[i]
      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried)

        while (tries < len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece < 0) break
          if (self._request(wire, piece, false)) return
          tried[piece] = true
          tries += 1
        }
      } else {
        for (piece = next.to; piece >= next.from + next.offset; --piece) {
          if (!wire.peerPieces.get(piece)) continue
          if (self._request(wire, piece, false)) return
        }
      }
    }

    // TODO: wire failed to validate as useful; should we close it?
    // probably not, since 'have' and 'bitfield' messages might be coming
  }

  function speedRanker () {
    var speed = wire.downloadSpeed() || 1
    if (speed > SPEED_THRESHOLD) return function () { return true }

    var secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed
    var tries = 10
    var ptr = 0

    return function (index) {
      if (!tries || self.bitfield.get(index)) return true

      var missing = self.pieces[index].missing

      for (; ptr < self.wires.length; ptr++) {
        var otherWire = self.wires[ptr]
        var otherSpeed = otherWire.downloadSpeed()

        if (otherSpeed < SPEED_THRESHOLD) continue
        if (otherSpeed <= speed) continue
        if (!otherWire.peerPieces.get(index)) continue
        if ((missing -= otherSpeed * secs) > 0) continue

        tries--
        return false
      }

      return true
    }
  }

  function shufflePriority (i) {
    var last = i
    for (var j = i; j < self._selections.length && self._selections[j].priority; j++) {
      last = j
    }
    var tmp = self._selections[i]
    self._selections[i] = self._selections[last]
    self._selections[last] = tmp
  }

  function trySelectWire (hotswap) {
    if (wire.requests.length >= maxOutstandingRequests) return true
    var rank = speedRanker()

    for (var i = 0; i < self._selections.length; i++) {
      var next = self._selections[i]

      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried, rank)

        while (tries < len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece < 0) break

          // request all non-reserved blocks in this piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length < maxOutstandingRequests) {
            tried[piece] = true
            tries++
            continue
          }

          if (next.priority) shufflePriority(i)
          return true
        }
      } else {
        for (piece = next.from + next.offset; piece <= next.to; piece++) {
          if (!wire.peerPieces.get(piece) || !rank(piece)) continue

          // request all non-reserved blocks in piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length < maxOutstandingRequests) continue

          if (next.priority) shufflePriority(i)
          return true
        }
      }
    }

    return false
  }
}

/**
 * Called periodically to update the choked status of all peers, handling optimistic
 * unchoking as described in BEP3.
 */
Torrent.prototype._rechoke = function () {
  var self = this
  if (!self.ready) return

  if (self._rechokeOptimisticTime > 0) self._rechokeOptimisticTime -= 1
  else self._rechokeOptimisticWire = null

  var peers = []

  self.wires.forEach(function (wire) {
    if (!wire.isSeeder && wire !== self._rechokeOptimisticWire) {
      peers.push({
        wire: wire,
        downloadSpeed: wire.downloadSpeed(),
        uploadSpeed: wire.uploadSpeed(),
        salt: Math.random(),
        isChoked: true
      })
    }
  })

  peers.sort(rechokeSort)

  var unchokeInterested = 0
  var i = 0
  for (; i < peers.length && unchokeInterested < self._rechokeNumSlots; ++i) {
    peers[i].isChoked = false
    if (peers[i].wire.peerInterested) unchokeInterested += 1
  }

  // Optimistically unchoke a peer
  if (!self._rechokeOptimisticWire && i < peers.length && self._rechokeNumSlots) {
    var candidates = peers.slice(i).filter(function (peer) { return peer.wire.peerInterested })
    var optimistic = candidates[randomInt(candidates.length)]

    if (optimistic) {
      optimistic.isChoked = false
      self._rechokeOptimisticWire = optimistic.wire
      self._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION
    }
  }

  // Unchoke best peers
  peers.forEach(function (peer) {
    if (peer.wire.amChoking !== peer.isChoked) {
      if (peer.isChoked) peer.wire.choke()
      else peer.wire.unchoke()
    }
  })

  function rechokeSort (peerA, peerB) {
    // Prefer higher download speed
    if (peerA.downloadSpeed !== peerB.downloadSpeed) {
      return peerB.downloadSpeed - peerA.downloadSpeed
    }

    // Prefer higher upload speed
    if (peerA.uploadSpeed !== peerB.uploadSpeed) {
      return peerB.uploadSpeed - peerA.uploadSpeed
    }

    // Prefer unchoked
    if (peerA.wire.amChoking !== peerB.wire.amChoking) {
      return peerA.wire.amChoking ? 1 : -1
    }

    // Random order
    return peerA.salt - peerB.salt
  }
}

/**
 * Attempts to cancel a slow block request from another wire such that the
 * given wire may effectively swap out the request for one of its own.
 */
Torrent.prototype._hotswap = function (wire, index) {
  var self = this

  var speed = wire.downloadSpeed()
  if (speed < Piece.BLOCK_LENGTH) return false
  if (!self._reservations[index]) return false

  var r = self._reservations[index]
  if (!r) {
    return false
  }

  var minSpeed = Infinity
  var minWire

  var i
  for (i = 0; i < r.length; i++) {
    var otherWire = r[i]
    if (!otherWire || otherWire === wire) continue

    var otherSpeed = otherWire.downloadSpeed()
    if (otherSpeed >= SPEED_THRESHOLD) continue
    if (2 * otherSpeed > speed || otherSpeed > minSpeed) continue

    minWire = otherWire
    minSpeed = otherSpeed
  }

  if (!minWire) return false

  for (i = 0; i < r.length; i++) {
    if (r[i] === minWire) r[i] = null
  }

  for (i = 0; i < minWire.requests.length; i++) {
    var req = minWire.requests[i]
    if (req.piece !== index) continue

    self.pieces[index].cancel((req.offset / Piece.BLOCK_LENGTH) | 0)
  }

  self.emit('hotswap', minWire, wire, index)
  return true
}

/**
 * Attempts to request a block from the given wire.
 */
Torrent.prototype._request = function (wire, index, hotswap) {
  var self = this
  var numRequests = wire.requests.length
  var isWebSeed = wire.type === 'webSeed'

  if (self.bitfield.get(index)) return false

  var maxOutstandingRequests = isWebSeed
    ? Math.min(
        getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self.pieceLength),
        self.maxWebConns
      )
    : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  if (numRequests >= maxOutstandingRequests) return false
  // var endGame = (wire.requests.length === 0 && self.store.numMissing < 30)

  var piece = self.pieces[index]
  var reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()

  if (reservation === -1 && hotswap && self._hotswap(wire, index)) {
    reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()
  }
  if (reservation === -1) return false

  var r = self._reservations[index]
  if (!r) r = self._reservations[index] = []
  var i = r.indexOf(null)
  if (i === -1) i = r.length
  r[i] = wire

  var chunkOffset = piece.chunkOffset(reservation)
  var chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation)

  wire.request(index, chunkOffset, chunkLength, function onChunk (err, chunk) {
    // TODO: what is this for?
    if (!self.ready) return self.once('ready', function () { onChunk(err, chunk) })

    if (r[i] === wire) r[i] = null

    if (piece !== self.pieces[index]) return onUpdateTick()

    if (err) {
      self._debug(
        'error getting piece %s (offset: %s length: %s) from %s: %s',
        index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort,
        err.message
      )
      isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation)
      onUpdateTick()
      return
    }

    self._debug(
      'got piece %s (offset: %s length: %s) from %s',
      index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort
    )

    if (!piece.set(reservation, chunk, wire)) return onUpdateTick()

    var buf = piece.flush()

    // TODO: might need to set self.pieces[index] = null here since sha1 is async

    sha1(buf, function (hash) {
      if (hash === self._hashes[index]) {
        if (!self.pieces[index]) return
        self._debug('piece verified %s', index)

        self.pieces[index] = null
        self._reservations[index] = null
        self.bitfield.set(index, true)

        self.store.put(index, buf)

        self.wires.forEach(function (wire) {
          wire.have(index)
        })

        self._checkDone()
      } else {
        self.pieces[index] = new Piece(piece.length)
        self.emit('warning', new Error('Piece ' + index + ' failed verification'))
      }
      onUpdateTick()
    })
  })

  function onUpdateTick () {
    process.nextTick(function () { self._update() })
  }

  return true
}

Torrent.prototype._checkDone = function () {
  var self = this
  if (self.destroyed) return

  // are any new files done?
  self.files.forEach(function (file) {
    if (file.done) return
    for (var i = file._startPiece; i <= file._endPiece; ++i) {
      if (!self.bitfield.get(i)) return
    }
    file.done = true
    file.emit('done')
    self._debug('file done: ' + file.name)
  })

  // is the torrent done? (if all current selections are satisfied, or there are
  // no selections, then torrent is done)
  var done = true
  for (var i = 0; i < self._selections.length; i++) {
    var selection = self._selections[i]
    for (var piece = selection.from; piece <= selection.to; piece++) {
      if (!self.bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) break
  }
  if (!self.done && done) {
    self.done = true
    self._debug('torrent done: ' + self.infoHash)
    if (self.discovery.tracker) {
      self.discovery.tracker.complete()
    }
    self.emit('done')
  }

  self._gcSelections()
}

Torrent.prototype.load = function (streams, cb) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.ready) return self.once('ready', function () { self.load(streams, cb) })

  if (!Array.isArray(streams)) streams = [ streams ]
  if (!cb) cb = noop

  var readable = new MultiStream(streams)
  var writable = new ChunkStoreWriteStream(self.store, self.pieceLength)

  pump(readable, writable, function (err) {
    if (err) return cb(err)
    self.pieces.forEach(function (piece, index) {
      self.pieces[index] = null
      self._reservations[index] = null
      self.bitfield.set(index, true)
    })
    self._checkDone()
    cb(null)
  })
}

Torrent.prototype.createServer = function (opts) {
  if (typeof Server !== 'function') throw new Error('node.js-only method')
  if (this.destroyed) throw new Error('torrent is destroyed')
  var server = new Server(this, opts)
  this._servers.push(server)
  return server
}

Torrent.prototype.pause = function () {
  if (this.destroyed) return
  this._debug('pause')
  this.paused = true
}

Torrent.prototype.resume = function () {
  if (this.destroyed) return
  this._debug('resume')
  this.paused = false
  this._drain()
}

Torrent.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}

/**
 * Pop a peer off the FIFO queue and connect to it. When _drain() gets called,
 * the queue will usually have only one peer in it, except when there are too
 * many peers (over `this.maxConns`) in which case they will just sit in the
 * queue until another connection closes.
 */
Torrent.prototype._drain = function () {
  var self = this
  this._debug('_drain numConns %s maxConns %s', self._numConns, self.client.maxConns)
  if (typeof net.connect !== 'function' || self.destroyed || self.paused ||
      self._numConns >= self.client.maxConns) {
    return
  }
  this._debug('drain (%s queued, %s/%s peers)', self._numQueued, self.numPeers, self.client.maxConns)

  var peer = self._queue.shift()
  if (!peer) return // queue could be empty

  this._debug('tcp connect attempt to %s', peer.addr)

  var parts = addrToIPPort(peer.addr)
  var opts = {
    host: parts[0],
    port: parts[1]
  }

  var conn = peer.conn = net.connect(opts)

  conn.once('connect', function () { peer.onConnect() })
  conn.once('error', function (err) { peer.destroy(err) })
  peer.startConnectTimeout()

  // When connection closes, attempt reconnect after timeout (with exponential backoff)
  conn.on('close', function () {
    if (self.destroyed) return

    // TODO: If torrent is done, do not try to reconnect after a timeout

    if (peer.retries >= RECONNECT_WAIT.length) {
      self._debug(
        'conn %s closed: will not re-add (max %s attempts)',
        peer.addr, RECONNECT_WAIT.length
      )
      return
    }

    var ms = RECONNECT_WAIT[peer.retries]
    self._debug(
      'conn %s closed: will re-add to queue in %sms (attempt %s)',
      peer.addr, ms, peer.retries + 1
    )

    var reconnectTimeout = setTimeout(function reconnectTimeout () {
      var newPeer = self._addPeer(peer.addr)
      if (newPeer) newPeer.retries = peer.retries + 1
    }, ms)
    if (reconnectTimeout.unref) reconnectTimeout.unref()
  })
}

/**
 * Returns `true` if string is valid IPv4/6 address.
 * @param {string} addr
 * @return {boolean}
 */
Torrent.prototype._validAddr = function (addr) {
  var parts
  try {
    parts = addrToIPPort(addr)
  } catch (e) {
    return false
  }
  var host = parts[0]
  var port = parts[1]
  return port > 0 && port < 65535 &&
    !(host === '127.0.0.1' && port === this.client.torrentPort)
}

function getBlockPipelineLength (wire, duration) {
  return 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH)
}

function getPiecePipelineLength (wire, duration, pieceLength) {
  return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength)
}

/**
 * Returns a random integer in [0,high)
 */
function randomInt (high) {
  return Math.random() * high | 0
}

function noop () {}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./file":174,"./peer":175,"./rarity-map":176,"./server":22,"_process":104,"addr-to-ip-port":3,"bitfield":13,"chunk-store-stream/write":27,"debug":39,"events":58,"fs":23,"fs-chunk-store":81,"immediate-chunk-store":68,"inherits":70,"multistream":89,"net":22,"os":22,"parse-torrent":97,"path":101,"path-exists":22,"pump":105,"random-iterate":110,"run-parallel":121,"run-parallel-limit":120,"simple-sha1":127,"speedometer":139,"torrent-discovery":152,"torrent-piece":153,"uniq":156,"ut_metadata":160,"ut_pex":22,"xtend":181,"xtend/mutable":182}],178:[function(require,module,exports){
(function (Buffer){
module.exports = WebConn

var BitField = require('bitfield')
var debug = require('debug')('webtorrent:webconn')
var get = require('simple-get')
var inherits = require('inherits')
var sha1 = require('simple-sha1')
var Wire = require('bittorrent-protocol')

inherits(WebConn, Wire)

/**
 * Converts requests for torrent blocks into http range requests.
 * @param {string} url web seed url
 * @param {Object} torrent
 */
function WebConn (url, torrent) {
  Wire.call(this)

  this.url = url
  this.webPeerId = sha1.sync(url)
  this._torrent = torrent

  this._init()
}

WebConn.prototype._init = function () {
  var self = this
  self.setKeepAlive(true)

  self.once('handshake', function (infoHash, peerId) {
    if (self.destroyed) return
    self.handshake(infoHash, self.webPeerId)
    var numPieces = self._torrent.pieces.length
    var bitfield = new BitField(numPieces)
    for (var i = 0; i <= numPieces; i++) {
      bitfield.set(i, true)
    }
    self.bitfield(bitfield)
  })

  self.once('interested', function () {
    debug('interested')
    self.unchoke()
  })

  self.on('uninterested', function () { debug('uninterested') })
  self.on('choke', function () { debug('choke') })
  self.on('unchoke', function () { debug('unchoke') })
  self.on('bitfield', function () { debug('bitfield') })

  self.on('request', function (pieceIndex, offset, length, callback) {
    debug('request pieceIndex=%d offset=%d length=%d', pieceIndex, offset, length)
    self.httpRequest(pieceIndex, offset, length, callback)
  })
}

WebConn.prototype.httpRequest = function (pieceIndex, offset, length, cb) {
  var self = this
  var pieceOffset = pieceIndex * self._torrent.pieceLength
  var rangeStart = pieceOffset + offset /* offset within whole torrent */
  var rangeEnd = rangeStart + length - 1

  // Web seed URL format:
  // For single-file torrents, make HTTP range requests directly to the web seed URL
  // For multi-file torrents, add the torrent folder and file name to the URL
  var files = self._torrent.files
  var requests
  if (files.length <= 1) {
    requests = [{
      url: self.url,
      start: rangeStart,
      end: rangeEnd
    }]
  } else {
    var requestedFiles = files.filter(function (file) {
      return file.offset <= rangeEnd && (file.offset + file.length) > rangeStart
    })
    if (requestedFiles.length < 1) {
      return cb(new Error('Could not find file corresponnding to web seed range request'))
    }

    requests = requestedFiles.map(function (requestedFile) {
      var fileEnd = requestedFile.offset + requestedFile.length - 1
      var url = self.url +
        (self.url[self.url.length - 1] === '/' ? '' : '/') +
        requestedFile.path
      return {
        url: url,
        fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
        start: Math.max(rangeStart - requestedFile.offset, 0),
        end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
      }
    })
  }

  // Now make all the HTTP requests we need in order to load this piece
  // Usually that's one requests, but sometimes it will be multiple
  // Send requests in parallel and wait for them all to come back
  var numRequestsSucceeded = 0
  var hasError = false
  if (requests.length > 1) var ret = new Buffer(length)
  requests.forEach(function (request) {
    var url = request.url
    var start = request.start
    var end = request.end
    debug(
      'Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d',
      url, pieceIndex, offset, length, start, end
    )
    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': 'WebTorrent (http://webtorrent.io)',
        'range': 'bytes=' + start + '-' + end
      }
    }
    get.concat(opts, function (err, res, data) {
      if (hasError) return
      if (err) {
        hasError = true
        return cb(err)
      }
      if (res.statusCode < 200 || res.statusCode >= 300) {
        hasError = true
        return cb(new Error('Unexpected HTTP status code ' + res.statusCode))
      }
      debug('Got data of length %d', data.length)
      if (requests.length === 1) {
        // Common case: fetch piece in a single HTTP request, return directly
        return cb(null, data)
      }
      // Rare case: reconstruct multiple HTTP requests across 2+ files into one piece buffer
      data.copy(ret, request.fileOffsetInRange)
      if (++numRequestsSucceeded === requests.length) {
        cb(null, ret)
      }
    })
  })
}

WebConn.prototype.destroy = function () {
  Wire.prototype.destroy.call(this)
  this._torrent = null
}

}).call(this,require("buffer").Buffer)

},{"bitfield":13,"bittorrent-protocol":14,"buffer":25,"debug":39,"inherits":70,"simple-get":125,"simple-sha1":127}],179:[function(require,module,exports){
module.exports={"version":"0.91.4"}
},{}],180:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],181:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],182:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],183:[function(require,module,exports){
/* global Y */
'use strict'

function extend (Y) {
  class YArray {
    constructor (os, _model, _content) {
      this.os = os
      this._model = _model
      // Array of all the neccessary content
      this._content = _content
      this.eventHandler = new Y.utils.EventHandler((op) => {
        if (op.struct === 'Insert') {
          let pos
          // we check op.left only!,
          // because op.right might not be defined when this is called
          if (op.left === null) {
            pos = 0
          } else {
            pos = 1 + this._content.findIndex(function (c) {
              return Y.utils.compareIds(c.id, op.left)
            })
            if (pos <= 0) {
              throw new Error('Unexpected operation!')
            }
          }
          var values
          var length
          if (op.hasOwnProperty('opContent')) {
            this._content.splice(pos, 0, {
              id: op.id,
              type: op.opContent
            })
            let opContent = op.opContent
            length = 1
            values = () => {
              return new Promise((resolve) => {
                this.os.requestTransaction(function *() {
                  var type = yield* this.getType(opContent)
                  resolve([type])
                })
              })
            }
          } else {
            var contents = op.content.map(function (c, i) {
              return {
                id: [op.id[0], op.id[1] + i],
                val: c
              }
            })
            // insert value in _content
            this._content.splice.apply(this._content, [pos, 0].concat(contents))
            values = op.content
            length = op.content.length
          }
          this.eventHandler.callEventListeners({
            type: 'insert',
            object: this,
            index: pos,
            values: values,
            // valueId: valueId, // TODO: does this still work as expected?
            length: length
          })
        } else if (op.struct === 'Delete') {
          var i = 0 // current position in _content
          for (; i < this._content.length && op.length > 0; i++) {
            var c = this._content[i]
            if (Y.utils.inDeletionRange(op, c.id)) {
              // is in deletion range!
              var delLength
              // check how many character to delete in one flush
              for (delLength = 1;
                    delLength < op.length && i + delLength < this._content.length && Y.utils.inDeletionRange(op, this._content[i + delLength].id);
                    delLength++) {}
              // last operation thas will be deleted
              c = this._content[i + delLength - 1]
              // update delete operation
              op.length -= c.id[1] - op.target[1] + 1
              op.target = [c.id[0], c.id[1] + 1]
              // apply deletion & find send event
              let content = this._content.splice(i, delLength)
              // TODO: how about return types
              let values = content.map(function (c) { return c.val })
              this.eventHandler.callEventListeners({
                type: 'delete',
                object: this,
                index: i,
                values: values,
                _content: content,
                length: delLength
              })
              // with the fresh delete op, we can continue
              // note: we don't have to increment i, because the i-th content was deleted
              // but on the other had, the (i+delLength)-th was not in deletion range
              // So we don't do i--
            }
          }
        } else {
          throw new Error('Unexpected struct!')
        }
      })
    }
    _destroy () {
      this.eventHandler.destroy()
      this.eventHandler = null
      this._content = null
      this._model = null
      this.os = null
    }
    get length () {
      return this._content.length
    }
    get (pos) {
      if (pos == null || typeof pos !== 'number') {
        throw new Error('pos must be a number!')
      }
      if (pos >= this._content.length) {
        return undefined
      }
      if (this._content[pos].type == null) {
        return this._content[pos].val
      } else {
        var oid = this._content[pos].type
        return new Promise((resolve) => {
          this.os.requestTransaction(function *() {
            var type = yield* this.getType(oid)
            resolve(type)
          })
        })
      }
    }
    // only returns primitive values
    toArray () {
      return this._content.map(function (x, i) {
        return x.val
      })
    }
    push (contents) {
      return this.insert(this._content.length, contents)
    }
    insert (pos, contents) {
      if (typeof pos !== 'number') {
        throw new Error('pos must be a number!')
      }
      if (!(contents instanceof Array)) {
        throw new Error('contents must be an Array of objects!')
      }
      if (contents.length === 0) {
        return
      }
      if (pos > this._content.length || pos < 0) {
        throw new Error('This position exceeds the range of the array!')
      }
      var mostLeft = pos === 0 ? null : this._content[pos - 1].id

      var ops = []
      var newTypes = []
      var prevId = mostLeft
      for (var i = 0; i < contents.length;) {
        var op = {
          left: prevId,
          origin: prevId,
          // right: mostRight,
          // NOTE: I intentionally do not define right here, because it could be deleted
          // at the time of inserting this operation (when we get the transaction),
          // and would therefore not defined in this._content
          parent: this._model,
          struct: 'Insert'
        }
        var _content = []
        var typeDefinition
        while (i < contents.length) {
          var val = contents[i++]
          typeDefinition = Y.utils.isTypeDefinition(val)
          if (!typeDefinition) {
            _content.push(val)
          } else if (_content.length > 0) {
            i-- // come back again later
            break
          } else {
            break
          }
        }
        if (_content.length > 0) {
          // content is defined
          op.content = _content
          op.id = this.os.getNextOpId(_content.length)
        } else {
          // otherwise its a type
          var typeid = this.os.getNextOpId(1)
          newTypes.push([typeDefinition, typeid])
          op.opContent = typeid
          op.id = this.os.getNextOpId(1)
        }
        ops.push(op)
        prevId = op.id
      }
      var eventHandler = this.eventHandler
      this.os.requestTransaction(function *() {
        // now we can set the right reference.
        var mostRight
        if (mostLeft != null) {
          var ml = yield* this.getInsertionCleanEnd(mostLeft)
          mostRight = ml.right
        } else {
          mostRight = (yield* this.getOperation(ops[0].parent)).start
        }
        for (var i = 0; i < newTypes.length; i++) {
          yield* this.createType.apply(this, newTypes[i])
        }
        for (var j = 0; j < ops.length; j++) {
          var op = ops[j]
          op.right = mostRight
        }
        yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [ops])
      })
      eventHandler.awaitAndPrematurelyCall(ops)
    }
    delete (pos, length) {
      if (length == null) { length = 1 }
      if (typeof length !== 'number') {
        throw new Error('length must be a number!')
      }
      if (typeof pos !== 'number') {
        throw new Error('pos must be a number!')
      }
      if (pos + length > this._content.length || pos < 0 || length < 0) {
        throw new Error('The deletion range exceeds the range of the array!')
      }
      if (length === 0) {
        return
      }
      var eventHandler = this.eventHandler
      var dels = []
      for (var i = 0; i < length; i = i + delLength) {
        var targetId = this._content[pos + i].id
        var delLength
        // how many insertions can we delete in one deletion?
        for (delLength = 1; i + delLength < length; delLength++) {
          if (!Y.utils.compareIds(this._content[pos + i + delLength].id, [targetId[0], targetId[1] + delLength])) {
            break
          }
        }
        dels.push({
          target: targetId,
          struct: 'Delete',
          length: delLength
        })
      }
      eventHandler.awaitAndPrematurelyCall(dels)
      this.os.requestTransaction(function *() {
        yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [dels])
      })
    }
    observe (f) {
      this.eventHandler.addEventListener(f)
    }
    unobserve (f) {
      this.eventHandler.removeEventListener(f)
    }
    * _changed (transaction, op) {
      if (!op.deleted) {
        if (op.struct === 'Insert') {
          var l = op.left
          var left
          while (l != null) {
            left = yield* transaction.getInsertion(l)
            if (!left.deleted) {
              break
            }
            l = left.left
          }
          op.left = l
        }
        this.eventHandler.receivedOp(op)
      }
    }
  }

  Y.extend('Array', new Y.utils.CustomType({
    name: 'Array',
    class: YArray,
    struct: 'List',
    initType: function * YArrayInitializer (os, model) {
      var _content = []
      yield* Y.Struct.List.map.call(this, model, function (op) {
        if (op.hasOwnProperty('opContent')) {
          _content.push({
            id: op.id,
            type: op.opContent
          })
        } else {
          op.content.forEach(function (c, i) {
            _content.push({
              id: [op.id[0], op.id[1] + i],
              val: op.content[i]
            })
          })
        }
      })
      return new YArray(os, model.id, _content)
    }
  }))
}

module.exports = extend
if (typeof Y !== 'undefined') {
  extend(Y)
}

},{}],184:[function(require,module,exports){
/* global Y */
'use strict'

function extend (Y /* :any */) {
  class YMap {
    /* ::
    _model: Id;
    os: Y.AbstractDatabase;
    map: Object;
    contents: any;
    opContents: Object;
    eventHandler: Function;
    */
    constructor (os, model, contents, opContents) {
      this._model = model.id
      this.os = os
      this.map = Y.utils.copyObject(model.map)
      this.contents = contents
      this.opContents = opContents
      this.eventHandler = new Y.utils.EventHandler(op => {
        var oldValue
        // key is the name to use to access (op)content
        var key = op.struct === 'Delete' ? op.key : op.parentSub

        // compute oldValue
        if (this.opContents[key] != null) {
          let prevType = this.opContents[key]
          oldValue = () => {// eslint-disable-line
            return new Promise((resolve) => {
              this.os.requestTransaction(function *() {// eslint-disable-line
                var type = yield* this.getType(prevType)
                resolve(type)
              })
            })
          }
        } else {
          oldValue = this.contents[key]
        }
        // compute op event
        if (op.struct === 'Insert') {
          if (op.left === null) {
            var value
            // TODO: what if op.deleted??? I partially handles this case here.. (maybe from the previous version)
            if (op.opContent != null) {
              value = () => {// eslint-disable-line
                return new Promise((resolve) => {
                  this.os.requestTransaction(function *() {// eslint-disable-line
                    var type = yield* this.getType(op.opContent)
                    resolve(type)
                  })
                })
              }
              delete this.contents[key]
              if (op.deleted) {
                delete this.opContents[key]
              } else {
                this.opContents[key] = op.opContent
              }
            } else {
              value = op.content[0]
              delete this.opContents[key]
              if (op.deleted) {
                delete this.contents[key]
              } else {
                this.contents[key] = op.content[0]
              }
            }
            this.map[key] = op.id
            if (oldValue === undefined) {
              this.eventHandler.callEventListeners({
                name: key,
                object: this,
                type: 'add',
                value: value
              })
            } else {
              this.eventHandler.callEventListeners({
                name: key,
                object: this,
                oldValue: oldValue,
                type: 'update',
                value: value
              })
            }
          }
        } else if (op.struct === 'Delete') {
          if (Y.utils.compareIds(this.map[key], op.target)) {
            delete this.opContents[key]
            delete this.contents[key]
            this.eventHandler.callEventListeners({
              name: key,
              object: this,
              oldValue: oldValue,
              type: 'delete'
            })
          }
        } else {
          throw new Error('Unexpected Operation!')
        }
      })
    }
    _destroy () {
      this.eventHandler.destroy()
      this.eventHandler = null
      this.contents = null
      this.opContents = null
      this._model = null
      this.os = null
      this.map = null
    }
    get (key) {
      // return property.
      // if property does not exist, return null
      // if property is a type, return a promise
      if (key == null || typeof key !== 'string') {
        throw new Error('You must specify a key (as string)!')
      }
      if (this.opContents[key] == null) {
        return this.contents[key]
      } else {
        return new Promise((resolve) => {
          var oid = this.opContents[key]
          this.os.requestTransaction(function *() {
            var type = yield* this.getType(oid)
            resolve(type)
          })
        })
      }
    }
    keys () {
      return Object.keys(this.contents).concat(Object.keys(this.opContents))
    }
    keysPrimitives () {
      return Object.keys(this.contents)
    }
    keysTypes () {
      return Object.keys(this.opContents)
    }
    /*
      If there is a primitive (not a custom type), then return it.
      Returns all primitive values, if propertyName is specified!
      Note: modifying the return value could result in inconsistencies!
        -- so make sure to copy it first!
    */
    getPrimitive (key) {
      if (key == null) {
        return Y.utils.copyObject(this.contents)
      } else if (typeof key !== 'string') {
        throw new Error('Key is expected to be a string!')
      } else {
        return this.contents[key]
      }
    }
    getType (key) {
      if (key == null || typeof key !== 'string') {
        throw new Error('You must specify a key (as string)!')
      } else if (this.opContents[key] != null) {
        return new Promise((resolve) => {
          var oid = this.opContents[key]
          this.os.requestTransaction(function *() {
            var type = yield* this.getType(oid)
            resolve(type)
          })
        })
      } else {
        return Promise.reject('No property specified for this key!')
      }
    }
    delete (key) {
      var right = this.map[key]
      if (right != null) {
        var del = {
          target: right,
          struct: 'Delete'
        }
        var eventHandler = this.eventHandler
        var modDel = Y.utils.copyObject(del)
        modDel.key = key
        this.os.requestTransaction(function *() {
          yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [[del]])
        })
        // always remember to do that after this.os.requestTransaction
        // (otherwise values might contain a undefined reference to type)
        eventHandler.awaitAndPrematurelyCall([modDel])
      }
    }
    set (key, value) {
      // set property.
      // if property is a type, return a promise
      // if not, apply immediately on this type an call event

      var right = this.map[key] || null
      var insert /* :any */ = {
        id: this.os.getNextOpId(1),
        left: null,
        right: right,
        origin: null,
        parent: this._model,
        parentSub: key,
        struct: 'Insert'
      }
      var eventHandler = this.eventHandler
      return new Promise((resolve) => {
        var typeDefinition = Y.utils.isTypeDefinition(value)
        if (typeDefinition !== false) {
          var typeid = this.os.getNextOpId(1)
          insert.opContent = typeid
          // construct a new type
          this.os.requestTransaction(function *() {
            var type = yield* this.createType(typeDefinition, typeid)
            yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [[insert]])
            resolve(type)
          })
          // always remember to do that after this.os.requestTransaction
          // (otherwise values might contain a undefined reference to type)
          eventHandler.awaitAndPrematurelyCall([insert])
        } else {
          insert.content = [value]
          this.os.requestTransaction(function * () {
            yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [[insert]])
          })
          // always remember to do that after this.os.requestTransaction
          // (otherwise values might contain a undefined reference to type)
          eventHandler.awaitAndPrematurelyCall([insert])
          resolve(value)
        }
      })
    }
    observe (f) {
      this.eventHandler.addEventListener(f)
    }
    unobserve (f) {
      this.eventHandler.removeEventListener(f)
    }
    /*
      Observe a path.

      E.g.
      ```
      o.set('textarea', Y.TextBind)
      o.observePath(['textarea'], function(t){
        // is called whenever textarea is replaced
        t.bind(textarea)
      })

      returns a Promise that contains a function that removes the observer from the path.
    */
    observePath (path, f) {
      var self = this
      function observeProperty (event) {
        // call f whenever path changes
        if (event.name === propertyName) {
          // call this also for delete events!
          var property = self.get(propertyName)
          if (property instanceof Promise) {
            property.then(f)
          } else {
            f(property)
          }
        }
      }

      if (path.length < 1) {
        f(this)
        return Promise.resolve(function () {})
      } else if (path.length === 1) {
        var propertyName = path[0]
        var property = self.get(propertyName)
        if (property instanceof Promise) {
          property.then(f)
        } else {
          f(property)
        }
        this.observe(observeProperty)
        return Promise.resolve(function () {
          self.unobserve(f)
        })
      } else {
        var deleteChildObservers
        var resetObserverPath = function () {
          var promise = self.get(path[0])
          if (!promise instanceof Promise) {
            // its either not defined or a primitive value
            promise = self.set(path[0], Y.Map)
          }
          return promise.then(function (map) {
            return map.observePath(path.slice(1), f)
          }).then(function (_deleteChildObservers) {
            // update deleteChildObservers
            deleteChildObservers = _deleteChildObservers
            return Promise.resolve() // Promise does not return anything
          })
        }
        var observer = function (event) {
          if (event.name === path[0]) {
            if (deleteChildObservers != null) {
              deleteChildObservers()
            }
            if (event.type === 'add' || event.type === 'update') {
              resetObserverPath()
            }
            // TODO: what about the delete events?
          }
        }
        self.observe(observer)
        return resetObserverPath().then(function () {
          // this promise contains a function that deletes all the child observers
          // and how to unobserve the observe from this object
          return Promise.resolve(function () { // eslint-disable-line
            if (deleteChildObservers != null) {
              deleteChildObservers()
            }
            self.unobserve(observer)
          })
        })
      }
    }
    * _changed (transaction, op) {
      if (op.struct === 'Delete') {
        var target = yield* transaction.getOperation(op.target)
        op.key = target.parentSub
      }
      this.eventHandler.receivedOp(op)
    }
  }
  Y.extend('Map', new Y.utils.CustomType({
    name: 'Map',
    class: YMap,
    struct: 'Map',
    initType: function * YMapInitializer (os, model) {
      var contents = {}
      var opContents = {}
      var map = model.map
      for (var name in map) {
        var op = yield* this.getOperation(map[name])
        if (op.opContent != null) {
          opContents[name] = op.opContent
        } else {
          contents[name] = op.content[0]
        }
      }
      return new YMap(os, model, contents, opContents)
    }
  }))
}

module.exports = extend
if (typeof Y !== 'undefined') {
  extend(Y)
}

},{}],185:[function(require,module,exports){
/* global Y */
'use strict'

function extend (Y) {
  require('./RedBlackTree.js')(Y)
  class Transaction extends Y.Transaction {
    constructor (store) {
      super(store)
      this.store = store
      this.ss = store.ss
      this.os = store.os
      this.ds = store.ds
    }
  }
  var Store = Y.utils.RBTree
  var BufferedStore = Y.utils.createSmallLookupBuffer(Store)

  class Database extends Y.AbstractDatabase {
    constructor (y, opts) {
      super(y, opts)
      this.os = new BufferedStore()
      this.ds = new Store()
      this.ss = new BufferedStore()
    }
    logTable () {
      var self = this
      self.requestTransaction(function * () {
        console.log('User: ', this.store.y.connector.userId, "==============================") // eslint-disable-line
        console.log("State Set (SS):", yield* this.getStateSet()) // eslint-disable-line
        console.log("Operation Store (OS):") // eslint-disable-line
        yield* this.os.logTable() // eslint-disable-line
        console.log("Deletion Store (DS):") //eslint-disable-line
        yield* this.ds.logTable() // eslint-disable-line
        if (this.store.gc1.length > 0 || this.store.gc2.length > 0) {
          console.warn('GC1|2 not empty!', this.store.gc1, this.store.gc2)
        }
        if (JSON.stringify(this.store.listenersById) !== '{}') {
          console.warn('listenersById not empty!')
        }
        if (JSON.stringify(this.store.listenersByIdExecuteNow) !== '[]') {
          console.warn('listenersByIdExecuteNow not empty!')
        }
        if (this.store.transactionInProgress) {
          console.warn('Transaction still in progress!')
        }
      }, true)
    }
    transact (makeGen) {
      var t = new Transaction(this)
      while (makeGen !== null) {
        var gen = makeGen.call(t)
        var res = gen.next()
        while (!res.done) {
          res = gen.next(res.value)
        }
        makeGen = this.getNextRequest()
      }
    }
    * destroy () {
      yield* super.destroy()
      delete this.os
      delete this.ss
      delete this.ds
    }
  }
  Y.extend('memory', Database)
}

module.exports = extend
if (typeof Y !== 'undefined') {
  extend(Y)
}

},{"./RedBlackTree.js":186}],186:[function(require,module,exports){
'use strict'

/*
  This file contains a not so fancy implemantion of a Red Black Tree.
*/
module.exports = function (Y) {
  class N {
    // A created node is always red!
    constructor (val) {
      this.val = val
      this.color = true
      this._left = null
      this._right = null
      this._parent = null
      if (val.id === null) {
        throw new Error('You must define id!')
      }
    }
    isRed () { return this.color }
    isBlack () { return !this.color }
    redden () { this.color = true; return this }
    blacken () { this.color = false; return this }
    get grandparent () {
      return this.parent.parent
    }
    get parent () {
      return this._parent
    }
    get sibling () {
      return (this === this.parent.left)
        ? this.parent.right : this.parent.left
    }
    get left () {
      return this._left
    }
    get right () {
      return this._right
    }
    set left (n) {
      if (n !== null) {
        n._parent = this
      }
      this._left = n
    }
    set right (n) {
      if (n !== null) {
        n._parent = this
      }
      this._right = n
    }
    rotateLeft (tree) {
      var parent = this.parent
      var newParent = this.right
      var newRight = this.right.left
      newParent.left = this
      this.right = newRight
      if (parent === null) {
        tree.root = newParent
        newParent._parent = null
      } else if (parent.left === this) {
        parent.left = newParent
      } else if (parent.right === this) {
        parent.right = newParent
      } else {
        throw new Error('The elements are wrongly connected!')
      }
    }
    next () {
      if (this.right !== null) {
        // search the most left node in the right tree
        var o = this.right
        while (o.left !== null) {
          o = o.left
        }
        return o
      } else {
        var p = this
        while (p.parent !== null && p !== p.parent.left) {
          p = p.parent
        }
        return p.parent
      }
    }
    prev () {
      if (this.left !== null) {
        // search the most right node in the left tree
        var o = this.left
        while (o.right !== null) {
          o = o.right
        }
        return o
      } else {
        var p = this
        while (p.parent !== null && p !== p.parent.right) {
          p = p.parent
        }
        return p.parent
      }
    }
    rotateRight (tree) {
      var parent = this.parent
      var newParent = this.left
      var newLeft = this.left.right
      newParent.right = this
      this.left = newLeft
      if (parent === null) {
        tree.root = newParent
        newParent._parent = null
      } else if (parent.left === this) {
        parent.left = newParent
      } else if (parent.right === this) {
        parent.right = newParent
      } else {
        throw new Error('The elements are wrongly connected!')
      }
    }
    getUncle () {
      // we can assume that grandparent exists when this is called!
      if (this.parent === this.parent.parent.left) {
        return this.parent.parent.right
      } else {
        return this.parent.parent.left
      }
    }
  }

  class RBTree {
    constructor () {
      this.root = null
      this.length = 0
    }
    * findNext (id) {
      return yield* this.findWithLowerBound([id[0], id[1] + 1])
    }
    * findPrev (id) {
      return yield* this.findWithUpperBound([id[0], id[1] - 1])
    }
    findNodeWithLowerBound (from) {
      if (from === void 0) {
        throw new Error('You must define from!')
      }
      var o = this.root
      if (o === null) {
        return null
      } else {
        while (true) {
          if ((from === null || Y.utils.smaller(from, o.val.id)) && o.left !== null) {
            // o is included in the bound
            // try to find an element that is closer to the bound
            o = o.left
          } else if (from !== null && Y.utils.smaller(o.val.id, from)) {
            // o is not within the bound, maybe one of the right elements is..
            if (o.right !== null) {
              o = o.right
            } else {
              // there is no right element. Search for the next bigger element,
              // this should be within the bounds
              return o.next()
            }
          } else {
            return o
          }
        }
      }
    }
    findNodeWithUpperBound (to) {
      if (to === void 0) {
        throw new Error('You must define from!')
      }
      var o = this.root
      if (o === null) {
        return null
      } else {
        while (true) {
          if ((to === null || Y.utils.smaller(o.val.id, to)) && o.right !== null) {
            // o is included in the bound
            // try to find an element that is closer to the bound
            o = o.right
          } else if (to !== null && Y.utils.smaller(to, o.val.id)) {
            // o is not within the bound, maybe one of the left elements is..
            if (o.left !== null) {
              o = o.left
            } else {
              // there is no left element. Search for the prev smaller element,
              // this should be within the bounds
              return o.prev()
            }
          } else {
            return o
          }
        }
      }
    }
    findSmallestNode () {
      var o = this.root
      while (o != null && o.left != null) {
        o = o.left
      }
      return o
    }
    * findWithLowerBound (from) {
      var n = this.findNodeWithLowerBound(from)
      return n == null ? null : n.val
    }
    * findWithUpperBound (to) {
      var n = this.findNodeWithUpperBound(to)
      return n == null ? null : n.val
    }
    * iterate (t, from, to, f) {
      var o
      if (from === null) {
        o = this.findSmallestNode()
      } else {
        o = this.findNodeWithLowerBound(from)
      }
      while (o !== null && (to === null || Y.utils.smaller(o.val.id, to) || Y.utils.compareIds(o.val.id, to))) {
        yield* f.call(t, o.val)
        o = o.next()
      }
      return true
    }
    * logTable (from, to, filter) {
      if (filter == null) {
        filter = function () {
          return true
        }
      }
      if (from == null) { from = null }
      if (to == null) { to = null }
      var os = []
      yield* this.iterate(this, from, to, function * (o) {
        if (filter(o)) {
          var o_ = {}
          for (var key in o) {
            if (typeof o[key] === 'object') {
              o_[key] = JSON.stringify(o[key])
            } else {
              o_[key] = o[key]
            }
          }
          os.push(o_)
        }
      })
      if (console.table != null) {
        console.table(os)
      }
    }
    * find (id) {
      var n
      return (n = this.findNode(id)) ? n.val : null
    }
    findNode (id) {
      if (id == null || id.constructor !== Array) {
        throw new Error('Expect id to be an array!')
      }
      var o = this.root
      if (o === null) {
        return false
      } else {
        while (true) {
          if (o === null) {
            return false
          }
          if (Y.utils.smaller(id, o.val.id)) {
            o = o.left
          } else if (Y.utils.smaller(o.val.id, id)) {
            o = o.right
          } else {
            return o
          }
        }
      }
    }
    * delete (id) {
      if (id == null || id.constructor !== Array) {
        throw new Error('id is expected to be an Array!')
      }
      var d = this.findNode(id)
      if (d == null) {
        // throw new Error('Element does not exist!')
        return
      }
      this.length--
      if (d.left !== null && d.right !== null) {
        // switch d with the greates element in the left subtree.
        // o should have at most one child.
        var o = d.left
        // find
        while (o.right !== null) {
          o = o.right
        }
        // switch
        d.val = o.val
        d = o
      }
      // d has at most one child
      // let n be the node that replaces d
      var isFakeChild
      var child = d.left || d.right
      if (child === null) {
        isFakeChild = true
        child = new N({id: 0})
        child.blacken()
        d.right = child
      } else {
        isFakeChild = false
      }

      if (d.parent === null) {
        if (!isFakeChild) {
          this.root = child
          child.blacken()
          child._parent = null
        } else {
          this.root = null
        }
        return
      } else if (d.parent.left === d) {
        d.parent.left = child
      } else if (d.parent.right === d) {
        d.parent.right = child
      } else {
        throw new Error('Impossible!')
      }
      if (d.isBlack()) {
        if (child.isRed()) {
          child.blacken()
        } else {
          this._fixDelete(child)
        }
      }
      this.root.blacken()
      if (isFakeChild) {
        if (child.parent.left === child) {
          child.parent.left = null
        } else if (child.parent.right === child) {
          child.parent.right = null
        } else {
          throw new Error('Impossible #3')
        }
      }
    }
    _fixDelete (n) {
      function isBlack (node) {
        return node !== null ? node.isBlack() : true
      }
      function isRed (node) {
        return node !== null ? node.isRed() : false
      }
      if (n.parent === null) {
        // this can only be called after the first iteration of fixDelete.
        return
      }
      // d was already replaced by the child
      // d is not the root
      // d and child are black
      var sibling = n.sibling
      if (isRed(sibling)) {
        // make sibling the grandfather
        n.parent.redden()
        sibling.blacken()
        if (n === n.parent.left) {
          n.parent.rotateLeft(this)
        } else if (n === n.parent.right) {
          n.parent.rotateRight(this)
        } else {
          throw new Error('Impossible #2')
        }
        sibling = n.sibling
      }
      // parent, sibling, and children of n are black
      if (n.parent.isBlack() &&
        sibling.isBlack() &&
        isBlack(sibling.left) &&
        isBlack(sibling.right)
      ) {
        sibling.redden()
        this._fixDelete(n.parent)
      } else if (n.parent.isRed() &&
        sibling.isBlack() &&
        isBlack(sibling.left) &&
        isBlack(sibling.right)
      ) {
        sibling.redden()
        n.parent.blacken()
      } else {
        if (n === n.parent.left &&
          sibling.isBlack() &&
          isRed(sibling.left) &&
          isBlack(sibling.right)
        ) {
          sibling.redden()
          sibling.left.blacken()
          sibling.rotateRight(this)
          sibling = n.sibling
        } else if (n === n.parent.right &&
          sibling.isBlack() &&
          isRed(sibling.right) &&
          isBlack(sibling.left)
        ) {
          sibling.redden()
          sibling.right.blacken()
          sibling.rotateLeft(this)
          sibling = n.sibling
        }
        sibling.color = n.parent.color
        n.parent.blacken()
        if (n === n.parent.left) {
          sibling.right.blacken()
          n.parent.rotateLeft(this)
        } else {
          sibling.left.blacken()
          n.parent.rotateRight(this)
        }
      }
    }
    * put (v) {
      if (v == null || v.id == null || v.id.constructor !== Array) {
        throw new Error('v is expected to have an id property which is an Array!')
      }
      var node = new N(v)
      if (this.root !== null) {
        var p = this.root // p abbrev. parent
        while (true) {
          if (Y.utils.smaller(node.val.id, p.val.id)) {
            if (p.left === null) {
              p.left = node
              break
            } else {
              p = p.left
            }
          } else if (Y.utils.smaller(p.val.id, node.val.id)) {
            if (p.right === null) {
              p.right = node
              break
            } else {
              p = p.right
            }
          } else {
            p.val = node.val
            return p
          }
        }
        this._fixInsert(node)
      } else {
        this.root = node
      }
      this.length++
      this.root.blacken()
      return node
    }
    _fixInsert (n) {
      if (n.parent === null) {
        n.blacken()
        return
      } else if (n.parent.isBlack()) {
        return
      }
      var uncle = n.getUncle()
      if (uncle !== null && uncle.isRed()) {
        // Note: parent: red, uncle: red
        n.parent.blacken()
        uncle.blacken()
        n.grandparent.redden()
        this._fixInsert(n.grandparent)
      } else {
        // Note: parent: red, uncle: black or null
        // Now we transform the tree in such a way that
        // either of these holds:
        //   1) grandparent.left.isRed
        //     and grandparent.left.left.isRed
        //   2) grandparent.right.isRed
        //     and grandparent.right.right.isRed
        if (n === n.parent.right && n.parent === n.grandparent.left) {
          n.parent.rotateLeft(this)
          // Since we rotated and want to use the previous
          // cases, we need to set n in such a way that
          // n.parent.isRed again
          n = n.left
        } else if (n === n.parent.left && n.parent === n.grandparent.right) {
          n.parent.rotateRight(this)
          // see above
          n = n.right
        }
        // Case 1) or 2) hold from here on.
        // Now traverse grandparent, make parent a black node
        // on the highest level which holds two red nodes.
        n.parent.blacken()
        n.grandparent.redden()
        if (n === n.parent.left) {
          // Case 1
          n.grandparent.rotateRight(this)
        } else {
          // Case 2
          n.grandparent.rotateLeft(this)
        }
      }
    }
    * flush () {}
  }

  Y.utils.RBTree = RBTree
}

},{}],187:[function(require,module,exports){
(function (global){
/* global Y, global */
'use strict'

// socket.io requires utf8. This package checks if it is required by requirejs.
// If window.require is set, then it will define itself as a module. This is erratic behavior and
// results in socket.io having a "bad request".
// This is why we undefine global.define (it is set by requirejs) before we require socket.io-client.
var define = global.define
global.define = null
var io = require('socket.io-client')
// redefine global.define
global.define = define

function extend (Y) {
  class Connector extends Y.AbstractConnector {
    constructor (y, options) {
      if (options === undefined) {
        throw new Error('Options must not be undefined!')
      }
      if (options.room == null) {
        throw new Error('You must define a room name!')
      }
      options.role = 'slave'
      super(y, options)
      this.options = options
      options.url = options.url || 'https://yjs.dbis.rwth-aachen.de:5072'
      var socket = options.socket || io(options.url)
      this.socket = socket
      var self = this

      this._onConnect = function joinRoom () {
        socket.emit('joinRoom', options.room)
        self.userJoined('server', 'master')
      }

      socket.on('connect', this._onConnect)
      if (socket.connected) {
        this._onConnect()
      } else {
        socket.connect()
      }

      this._onYjsEvent = function (message) {
        if (message.type != null) {
          if (message.type === 'sync done') {
            var userId = socket.id
            if (socket._yjs_connection_counter == null) {
              socket._yjs_connection_counter = 1
            } else {
              userId += socket._yjs_connection_counter++
            }
            self.setUserId(userId)
          }
          if (message.room === options.room) {
            self.receiveMessage('server', message)
          }
        }
      }
      socket.on('yjsEvent', this._onYjsEvent)

      this._onDisconnect = function (peer) {
        self.userLeft('server')
      }
      socket.on('disconnect', this._onDisconnect)
    }
    disconnect () {
      this.socket.emit('leaveRoom', this.options.room)
      if (!this.options.socket) {
        this.socket.disconnect()
      }
      super.disconnect()
    }
    destroy () {
      this.disconnect()
      this.socket.off('disconnect', this._onDisconnect)
      this.socket.off('yjsEvent', this._onYjsEvent)
      this.socket.off('connect', this._onConnect)
      if (!this.options.socket) {
        this.socket.destroy()
      }
      this.socket = null
    }
    reconnect () {
      this.socket.connect()
      super.reconnect()
    }
    send (uid, message) {
      message.room = this.options.room
      this.socket.emit('yjsEvent', message)
    }
    broadcast (message) {
      message.room = this.options.room
      this.socket.emit('yjsEvent', message)
    }
    isDisconnected () {
      return this.socket.disconnected
    }
  }
  Connector.io = io
  Y.extend('websockets-client', Connector)
}

module.exports = extend
if (typeof Y !== 'undefined') {
  extend(Y)
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"socket.io-client":129}],188:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],189:[function(require,module,exports){
/* @flow */
'use strict'

module.exports = function (Y/* :any */) {
  class AbstractConnector {
    /* ::
    y: YConfig;
    role: SyncRole;
    connections: Object;
    isSynced: boolean;
    userEventListeners: Array<Function>;
    whenSyncedListeners: Array<Function>;
    currentSyncTarget: ?UserId;
    syncingClients: Array<UserId>;
    forwardToSyncingClients: boolean;
    debug: boolean;
    broadcastedHB: boolean;
    syncStep2: Promise;
    userId: UserId;
    send: Function;
    broadcast: Function;
    broadcastOpBuffer: Array<Operation>;
    protocolVersion: number;
    */
    /*
      opts contains the following information:
       role : String Role of this client ("master" or "slave")
       userId : String Uniquely defines the user.
       debug: Boolean Whether to print debug messages (optional)
    */
    constructor (y, opts) {
      this.y = y
      if (opts == null) {
        opts = {}
      }
      if (opts.role == null || opts.role === 'master') {
        this.role = 'master'
      } else if (opts.role === 'slave') {
        this.role = 'slave'
      } else {
        throw new Error("Role must be either 'master' or 'slave'!")
      }
      this.y.db.forwardAppliedOperations = opts.forwardAppliedOperations || false
      this.role = opts.role
      this.connections = {}
      this.isSynced = false
      this.userEventListeners = []
      this.whenSyncedListeners = []
      this.currentSyncTarget = null
      this.syncingClients = []
      this.forwardToSyncingClients = opts.forwardToSyncingClients !== false
      this.debug = opts.debug === true
      this.broadcastedHB = false
      this.syncStep2 = Promise.resolve()
      this.broadcastOpBuffer = []
      this.protocolVersion = 11
    }
    reconnect () {
    }
    disconnect () {
      this.connections = {}
      this.isSynced = false
      this.currentSyncTarget = null
      this.broadcastedHB = false
      this.syncingClients = []
      this.whenSyncedListeners = []
      return this.y.db.stopGarbageCollector()
    }
    setUserId (userId) {
      if (this.userId == null) {
        this.userId = userId
        return this.y.db.setUserId(userId)
      } else {
        return null
      }
    }
    onUserEvent (f) {
      this.userEventListeners.push(f)
    }
    userLeft (user) {
      if (this.connections[user] != null) {
        delete this.connections[user]
        if (user === this.currentSyncTarget) {
          this.currentSyncTarget = null
          this.findNextSyncTarget()
        }
        this.syncingClients = this.syncingClients.filter(function (cli) {
          return cli !== user
        })
        for (var f of this.userEventListeners) {
          f({
            action: 'userLeft',
            user: user
          })
        }
      }
    }
    userJoined (user, role) {
      if (role == null) {
        throw new Error('You must specify the role of the joined user!')
      }
      if (this.connections[user] != null) {
        throw new Error('This user already joined!')
      }
      this.connections[user] = {
        isSynced: false,
        role: role
      }
      for (var f of this.userEventListeners) {
        f({
          action: 'userJoined',
          user: user,
          role: role
        })
      }
      if (this.currentSyncTarget == null) {
        this.findNextSyncTarget()
      }
    }
    // Execute a function _when_ we are connected.
    // If not connected, wait until connected
    whenSynced (f) {
      if (this.isSynced) {
        f()
      } else {
        this.whenSyncedListeners.push(f)
      }
    }
    /*

     returns false, if there is no sync target
     true otherwise
    */
    findNextSyncTarget () {
      if (this.currentSyncTarget != null || this.isSynced) {
        return // "The current sync has not finished!"
      }

      var syncUser = null
      for (var uid in this.connections) {
        if (!this.connections[uid].isSynced) {
          syncUser = uid
          break
        }
      }
      var conn = this
      if (syncUser != null) {
        this.currentSyncTarget = syncUser
        this.y.db.requestTransaction(function *() {
          var stateSet = yield* this.getStateSet()
          var deleteSet = yield* this.getDeleteSet()
          conn.send(syncUser, {
            type: 'sync step 1',
            stateSet: stateSet,
            deleteSet: deleteSet,
            protocolVersion: conn.protocolVersion
          })
        })
      } else {
        this.y.db.requestTransaction(function *() {
          // it is crucial that isSynced is set at the time garbageCollectAfterSync is called
          conn.isSynced = true
          yield* this.garbageCollectAfterSync()
          // call whensynced listeners
          for (var f of conn.whenSyncedListeners) {
            f()
          }
          conn.whenSyncedListeners = []
        })
      }
    }
    send (uid, message) {
      if (this.debug) {
        console.log(`send ${this.userId} -> ${uid}: ${message.type}`, message) // eslint-disable-line
      }
    }
    /*
      Buffer operations, and broadcast them when ready.
    */
    broadcastOps (ops) {
      ops = ops.map(function (op) {
        return Y.Struct[op.struct].encode(op)
      })
      var self = this
      function broadcastOperations () {
        if (self.broadcastOpBuffer.length > 0) {
          self.broadcast({
            type: 'update',
            ops: self.broadcastOpBuffer
          })
          self.broadcastOpBuffer = []
        }
      }
      if (this.broadcastOpBuffer.length === 0) {
        this.broadcastOpBuffer = ops
        if (this.y.db.transactionInProgress) {
          this.y.db.whenTransactionsFinished().then(broadcastOperations)
        } else {
          setTimeout(broadcastOperations, 0)
        }
      } else {
        this.broadcastOpBuffer = this.broadcastOpBuffer.concat(ops)
      }
    }
    /*
      You received a raw message, and you know that it is intended for Yjs. Then call this function.
    */
    receiveMessage (sender/* :UserId */, message/* :Message */) {
      if (sender === this.userId) {
        return
      }
      if (this.debug) {
        console.log(`receive ${sender} -> ${this.userId}: ${message.type}`, JSON.parse(JSON.stringify(message))) // eslint-disable-line
      }
      if (message.protocolVersion != null && message.protocolVersion !== this.protocolVersion) {
        console.error(
          `You tried to sync with a yjs instance that has a different protocol version
          (You: ${this.protocolVersion}, Client: ${message.protocolVersion}).
          The sync was stopped. You need to upgrade your dependencies (especially Yjs & the Connector)!
          `)
        this.send(sender, {
          type: 'sync stop',
          protocolVersion: this.protocolVersion
        })
        return
      }
      if (message.type === 'sync step 1') {
        let conn = this
        let m = message
        this.y.db.requestTransaction(function *() {
          var currentStateSet = yield* this.getStateSet()
          yield* this.applyDeleteSet(m.deleteSet)

          var ds = yield* this.getDeleteSet()
          var ops = yield* this.getOperations(m.stateSet)
          conn.send(sender, {
            type: 'sync step 2',
            os: ops,
            stateSet: currentStateSet,
            deleteSet: ds,
            protocolVersion: this.protocolVersion
          })
          if (this.forwardToSyncingClients) {
            conn.syncingClients.push(sender)
            setTimeout(function () {
              conn.syncingClients = conn.syncingClients.filter(function (cli) {
                return cli !== sender
              })
              conn.send(sender, {
                type: 'sync done'
              })
            }, 5000) // TODO: conn.syncingClientDuration)
          } else {
            conn.send(sender, {
              type: 'sync done'
            })
          }
          conn._setSyncedWith(sender)
        })
      } else if (message.type === 'sync step 2') {
        let conn = this
        var broadcastHB = !this.broadcastedHB
        this.broadcastedHB = true
        var db = this.y.db
        var defer = {}
        defer.promise = new Promise(function (resolve) {
          defer.resolve = resolve
        })
        this.syncStep2 = defer.promise
        let m /* :MessageSyncStep2 */ = message
        db.requestTransaction(function * () {
          yield* this.applyDeleteSet(m.deleteSet)
          this.store.apply(m.os)
          db.requestTransaction(function * () {
            var ops = yield* this.getOperations(m.stateSet)
            if (ops.length > 0) {
              if (!broadcastHB) { // TODO: consider to broadcast here..
                conn.send(sender, {
                  type: 'update',
                  ops: ops
                })
              } else {
                // broadcast only once!
                conn.broadcastOps(ops)
              }
            }
            defer.resolve()
          })
        })
      } else if (message.type === 'sync done') {
        var self = this
        this.syncStep2.then(function () {
          self._setSyncedWith(sender)
        })
      } else if (message.type === 'update') {
        if (this.forwardToSyncingClients) {
          for (var client of this.syncingClients) {
            this.send(client, message)
          }
        }
        if (this.y.db.forwardAppliedOperations) {
          var delops = message.ops.filter(function (o) {
            return o.struct === 'Delete'
          })
          if (delops.length > 0) {
            this.broadcastOps(delops)
          }
        }
        this.y.db.apply(message.ops)
      }
    }
    _setSyncedWith (user) {
      var conn = this.connections[user]
      if (conn != null) {
        conn.isSynced = true
      }
      if (user === this.currentSyncTarget) {
        this.currentSyncTarget = null
        this.findNextSyncTarget()
      }
    }
    /*
      Currently, the HB encodes operations as JSON. For the moment I want to keep it
      that way. Maybe we support encoding in the HB as XML in the future, but for now I don't want
      too much overhead. Y is very likely to get changed a lot in the future

      Because we don't want to encode JSON as string (with character escaping, wich makes it pretty much unreadable)
      we encode the JSON as XML.

      When the HB support encoding as XML, the format should look pretty much like this.

      does not support primitive values as array elements
      expects an ltx (less than xml) object
    */
    parseMessageFromXml (m/* :any */) {
      function parseArray (node) {
        for (var n of node.children) {
          if (n.getAttribute('isArray') === 'true') {
            return parseArray(n)
          } else {
            return parseObject(n)
          }
        }
      }
      function parseObject (node/* :any */) {
        var json = {}
        for (var attrName in node.attrs) {
          var value = node.attrs[attrName]
          var int = parseInt(value, 10)
          if (isNaN(int) || ('' + int) !== value) {
            json[attrName] = value
          } else {
            json[attrName] = int
          }
        }
        for (var n/* :any */ in node.children) {
          var name = n.name
          if (n.getAttribute('isArray') === 'true') {
            json[name] = parseArray(n)
          } else {
            json[name] = parseObject(n)
          }
        }
        return json
      }
      parseObject(m)
    }
    /*
      encode message in xml
      we use string because Strophe only accepts an "xml-string"..
      So {a:4,b:{c:5}} will look like
      <y a="4">
        <b c="5"></b>
      </y>
      m - ltx element
      json - Object
    */
    encodeMessageToXml (msg, obj) {
      // attributes is optional
      function encodeObject (m, json) {
        for (var name in json) {
          var value = json[name]
          if (name == null) {
            // nop
          } else if (value.constructor === Object) {
            encodeObject(m.c(name), value)
          } else if (value.constructor === Array) {
            encodeArray(m.c(name), value)
          } else {
            m.setAttribute(name, value)
          }
        }
      }
      function encodeArray (m, array) {
        m.setAttribute('isArray', 'true')
        for (var e of array) {
          if (e.constructor === Object) {
            encodeObject(m.c('array-element'), e)
          } else {
            encodeArray(m.c('array-element'), e)
          }
        }
      }
      if (obj.constructor === Object) {
        encodeObject(msg.c('y', { xmlns: 'http://y.ninja/connector-stanza' }), obj)
      } else if (obj.constructor === Array) {
        encodeArray(msg.c('y', { xmlns: 'http://y.ninja/connector-stanza' }), obj)
      } else {
        throw new Error("I can't encode this json!")
      }
    }
  }
  Y.AbstractConnector = AbstractConnector
}

},{}],190:[function(require,module,exports){
/* global getRandom, async */
'use strict'

module.exports = function (Y) {
  var globalRoom = {
    users: {},
    buffers: {}, // TODO: reimplement this idea. This does not cover all cases!! Here, you have a queue which is unrealistic (i.e. think about multiple incoming connections)
    removeUser: function (user) {
      for (var i in this.users) {
        this.users[i].userLeft(user)
      }
      delete this.users[user]
      delete this.buffers[user]
    },
    addUser: function (connector) {
      this.users[connector.userId] = connector
      this.buffers[connector.userId] = {}
      for (var uname in this.users) {
        if (uname !== connector.userId) {
          var u = this.users[uname]
          u.userJoined(connector.userId, 'master')
          connector.userJoined(u.userId, 'master')
        }
      }
    },
    whenTransactionsFinished: function () {
      var ps = []
      for (var name in this.users) {
        ps.push(this.users[name].y.db.whenTransactionsFinished())
      }
      return Promise.all(ps)
    },
    flushOne: function flushOne () {
      var bufs = []
      for (var receiver in globalRoom.buffers) {
        let buff = globalRoom.buffers[receiver]
        var push = false
        for (let sender in buff) {
          if (buff[sender].length > 0) {
            push = true
            break
          }
        }
        if (push) {
          bufs.push(receiver)
        }
      }
      if (bufs.length > 0) {
        var userId = getRandom(bufs)
        let buff = globalRoom.buffers[userId]
        let sender = getRandom(Object.keys(buff))
        var m = buff[sender].shift()
        if (buff[sender].length === 0) {
          delete buff[sender]
        }
        var user = globalRoom.users[userId]
        user.receiveMessage(m[0], m[1])
        return user.y.db.whenTransactionsFinished()
      } else {
        return false
      }
    },
    flushAll: function () {
      return new Promise(function (resolve) {
        // flushes may result in more created operations,
        // flush until there is nothing more to flush
        function nextFlush () {
          var c = globalRoom.flushOne()
          if (c) {
            while (c) {
              c = globalRoom.flushOne()
            }
            globalRoom.whenTransactionsFinished().then(nextFlush)
          } else {
            setTimeout(function () {
              var c = globalRoom.flushOne()
              if (c) {
                c.then(function () {
                  globalRoom.whenTransactionsFinished().then(nextFlush)
                })
              } else {
                resolve()
              }
            }, 0)
          }
        }
        globalRoom.whenTransactionsFinished().then(nextFlush)
      })
    }
  }
  Y.utils.globalRoom = globalRoom

  var userIdCounter = 0

  class Test extends Y.AbstractConnector {
    constructor (y, options) {
      if (options === undefined) {
        throw new Error('Options must not be undefined!')
      }
      options.role = 'master'
      options.forwardToSyncingClients = false
      super(y, options)
      this.setUserId((userIdCounter++) + '').then(() => {
        globalRoom.addUser(this)
      })
      this.globalRoom = globalRoom
      this.syncingClientDuration = 0
    }
    receiveMessage (sender, m) {
      super.receiveMessage(sender, JSON.parse(JSON.stringify(m)))
    }
    send (userId, message) {
      var buffer = globalRoom.buffers[userId]
      if (buffer != null) {
        if (buffer[this.userId] == null) {
          buffer[this.userId] = []
        }
        buffer[this.userId].push(JSON.parse(JSON.stringify([this.userId, message])))
      }
    }
    broadcast (message) {
      for (var key in globalRoom.buffers) {
        var buff = globalRoom.buffers[key]
        if (buff[this.userId] == null) {
          buff[this.userId] = []
        }
        buff[this.userId].push(JSON.parse(JSON.stringify([this.userId, message])))
      }
    }
    isDisconnected () {
      return globalRoom.users[this.userId] == null
    }
    reconnect () {
      if (this.isDisconnected()) {
        globalRoom.addUser(this)
        super.reconnect()
      }
      return Y.utils.globalRoom.flushAll()
    }
    disconnect () {
      if (!this.isDisconnected()) {
        globalRoom.removeUser(this.userId)
        super.disconnect()
      }
      return this.y.db.whenTransactionsFinished()
    }
    flush () {
      var self = this
      return async(function * () {
        var buff = globalRoom.buffers[self.userId]
        while (Object.keys(buff).length > 0) {
          var sender = getRandom(Object.keys(buff))
          var m = buff[sender].shift()
          if (buff[sender].length === 0) {
            delete buff[sender]
          }
          this.receiveMessage(m[0], m[1])
        }
        yield self.whenTransactionsFinished()
      })
    }
  }

  Y.Test = Test
}

},{}],191:[function(require,module,exports){
/* @flow */
'use strict'

module.exports = function (Y /* :any */) {
  /*
    Partial definition of an OperationStore.
    TODO: name it Database, operation store only holds operations.

    A database definition must alse define the following methods:
    * logTable() (optional)
      - show relevant information information in a table
    * requestTransaction(makeGen)
      - request a transaction
    * destroy()
      - destroy the database
  */
  class AbstractDatabase {
    /* ::
    y: YConfig;
    forwardAppliedOperations: boolean;
    listenersById: Object;
    listenersByIdExecuteNow: Array<Object>;
    listenersByIdRequestPending: boolean;
    initializedTypes: Object;
    whenUserIdSetListener: ?Function;
    waitingTransactions: Array<Transaction>;
    transactionInProgress: boolean;
    executeOrder: Array<Object>;
    gc1: Array<Struct>;
    gc2: Array<Struct>;
    gcTimeout: number;
    gcInterval: any;
    garbageCollect: Function;
    executeOrder: Array<any>; // for debugging only
    userId: UserId;
    opClock: number;
    transactionsFinished: ?{promise: Promise, resolve: any};
    transact: (x: ?Generator) => any;
    */
    constructor (y, opts) {
      this.y = y
      var os = this
      this.userId = null
      var resolve
      this.userIdPromise = new Promise(function (r) {
        resolve = r
      })
      this.userIdPromise.resolve = resolve
      // whether to broadcast all applied operations (insert & delete hook)
      this.forwardAppliedOperations = false
      // E.g. this.listenersById[id] : Array<Listener>
      this.listenersById = {}
      // Execute the next time a transaction is requested
      this.listenersByIdExecuteNow = []
      // A transaction is requested
      this.listenersByIdRequestPending = false
      /* To make things more clear, the following naming conventions:
         * ls : we put this.listenersById on ls
         * l : Array<Listener>
         * id : Id (can't use as property name)
         * sid : String (converted from id via JSON.stringify
                         so we can use it as a property name)

        Always remember to first overwrite
        a property before you iterate over it!
      */
      // TODO: Use ES7 Weak Maps. This way types that are no longer user,
      // wont be kept in memory.
      this.initializedTypes = {}
      this.waitingTransactions = []
      this.transactionInProgress = false
      this.transactionIsFlushed = false
      if (typeof YConcurrency_TestingMode !== 'undefined') {
        this.executeOrder = []
      }
      this.gc1 = [] // first stage
      this.gc2 = [] // second stage -> after that, remove the op
      this.gcTimeout = !opts.gcTimeout ? 50000 : opts.gcTimeouts
      function garbageCollect () {
        return os.whenTransactionsFinished().then(function () {
          if (os.gc1.length > 0 || os.gc2.length > 0) {
            if (!os.y.isConnected()) {
              console.warn('gc should be empty when disconnected!')
            }
            return new Promise((resolve) => {
              os.requestTransaction(function * () {
                if (os.y.connector != null && os.y.connector.isSynced) {
                  for (var i = 0; i < os.gc2.length; i++) {
                    var oid = os.gc2[i]
                    yield* this.garbageCollectOperation(oid)
                  }
                  os.gc2 = os.gc1
                  os.gc1 = []
                }
                // TODO: Use setInterval here instead (when garbageCollect is called several times there will be several timeouts..)
                if (os.gcTimeout > 0) {
                  os.gcInterval = setTimeout(garbageCollect, os.gcTimeout)
                }
                resolve()
              })
            })
          } else {
            // TODO: see above
            if (os.gcTimeout > 0) {
              os.gcInterval = setTimeout(garbageCollect, os.gcTimeout)
            }
            return Promise.resolve()
          }
        })
      }
      this.garbageCollect = garbageCollect
      if (this.gcTimeout > 0) {
        garbageCollect()
      }
    }
    queueGarbageCollector (id) {
      if (this.y.isConnected()) {
        this.gc1.push(id)
      }
    }
    emptyGarbageCollector () {
      return new Promise(resolve => {
        var check = () => {
          if (this.gc1.length > 0 || this.gc2.length > 0) {
            this.garbageCollect().then(check)
          } else {
            resolve()
          }
        }
        setTimeout(check, 0)
      })
    }
    addToDebug () {
      if (typeof YConcurrency_TestingMode !== 'undefined') {
        var command /* :string */ = Array.prototype.map.call(arguments, function (s) {
          if (typeof s === 'string') {
            return s
          } else {
            return JSON.stringify(s)
          }
        }).join('').replace(/"/g, "'").replace(/,/g, ', ').replace(/:/g, ': ')
        this.executeOrder.push(command)
      }
    }
    getDebugData () {
      console.log(this.executeOrder.join('\n'))
    }
    stopGarbageCollector () {
      var self = this
      return new Promise(function (resolve) {
        self.requestTransaction(function * () {
          var ungc /* :Array<Struct> */ = self.gc1.concat(self.gc2)
          self.gc1 = []
          self.gc2 = []
          for (var i = 0; i < ungc.length; i++) {
            var op = yield* this.getOperation(ungc[i])
            if (op != null) {
              delete op.gc
              yield* this.setOperation(op)
            }
          }
          resolve()
        })
      })
    }
    /*
      Try to add to GC.

      TODO: rename this function

      Rulez:
      * Only gc if this user is online
      * The most left element in a list must not be gc'd.
        => There is at least one element in the list

      returns true iff op was added to GC
    */
    * addToGarbageCollector (op, left) {
      if (
        op.gc == null &&
        op.deleted === true
      ) {
        var gc = false
        if (left != null && left.deleted === true) {
          gc = true
        } else if (op.content != null && op.content.length > 1) {
          op = yield* this.getInsertionCleanStart([op.id[0], op.id[1] + 1])
          gc = true
        }
        if (gc) {
          op.gc = true
          yield* this.setOperation(op)
          this.store.queueGarbageCollector(op.id)
          return true
        }
      }
      return false
    }
    removeFromGarbageCollector (op) {
      function filter (o) {
        return !Y.utils.compareIds(o, op.id)
      }
      this.gc1 = this.gc1.filter(filter)
      this.gc2 = this.gc2.filter(filter)
      delete op.gc
    }
    * destroy () {
      clearInterval(this.gcInterval)
      this.gcInterval = null
      for (var key in this.initializedTypes) {
        var type = this.initializedTypes[key]
        if (type._destroy != null) {
          type._destroy()
        } else {
          console.error('The type you included does not provide destroy functionality, it will remain in memory (updating your packages will help).')
        }
      }
    }
    setUserId (userId) {
      if (!this.userIdPromise.inProgress) {
        this.userIdPromise.inProgress = true
        var self = this
        self.requestTransaction(function * () {
          self.userId = userId
          var state = yield* this.getState(userId)
          self.opClock = state.clock
          self.userIdPromise.resolve(userId)
        })
      }
      return this.userIdPromise
    }
    whenUserIdSet (f) {
      this.userIdPromise.then(f)
    }
    getNextOpId (numberOfIds) {
      if (numberOfIds == null) {
        throw new Error('getNextOpId expects the number of created ids to create!')
      } else if (this.userId == null) {
        throw new Error('OperationStore not yet initialized!')
      } else {
        var id = [this.userId, this.opClock]
        this.opClock += numberOfIds
        return id
      }
    }
    /*
      Apply a list of operations.

      * get a transaction
      * check whether all Struct.*.requiredOps are in the OS
      * check if it is an expected op (otherwise wait for it)
      * check if was deleted, apply a delete operation after op was applied
    */
    apply (ops) {
      for (var i = 0; i < ops.length; i++) {
        var o = ops[i]
        if (o.id == null || o.id[0] !== this.y.connector.userId) {
          var required = Y.Struct[o.struct].requiredOps(o)
          if (o.requires != null) {
            required = required.concat(o.requires)
          }
          this.whenOperationsExist(required, o)
        }
      }
    }
    /*
      op is executed as soon as every operation requested is available.
      Note that Transaction can (and should) buffer requests.
    */
    whenOperationsExist (ids, op) {
      if (ids.length > 0) {
        let listener = {
          op: op,
          missing: ids.length
        }

        for (let i = 0; i < ids.length; i++) {
          let id = ids[i]
          let sid = JSON.stringify(id)
          let l = this.listenersById[sid]
          if (l == null) {
            l = []
            this.listenersById[sid] = l
          }
          l.push(listener)
        }
      } else {
        this.listenersByIdExecuteNow.push({
          op: op
        })
      }

      if (this.listenersByIdRequestPending) {
        return
      }

      this.listenersByIdRequestPending = true
      var store = this

      this.requestTransaction(function * () {
        var exeNow = store.listenersByIdExecuteNow
        store.listenersByIdExecuteNow = []

        var ls = store.listenersById
        store.listenersById = {}

        store.listenersByIdRequestPending = false

        for (let key = 0; key < exeNow.length; key++) {
          let o = exeNow[key].op
          yield* store.tryExecute.call(this, o)
        }

        for (var sid in ls) {
          var l = ls[sid]
          var id = JSON.parse(sid)
          var op
          if (typeof id[1] === 'string') {
            op = yield* this.getOperation(id)
          } else {
            op = yield* this.getInsertion(id)
          }
          if (op == null) {
            store.listenersById[sid] = l
          } else {
            for (let i = 0; i < l.length; i++) {
              let listener = l[i]
              let o = listener.op
              if (--listener.missing === 0) {
                yield* store.tryExecute.call(this, o)
              }
            }
          }
        }
      })
    }
    /*
      Actually execute an operation, when all expected operations are available.
    */
    /* :: // TODO: this belongs somehow to transaction
    store: Object;
    getOperation: any;
    isGarbageCollected: any;
    addOperation: any;
    whenOperationsExist: any;
    */
    * tryExecute (op) {
      this.store.addToDebug('yield* this.store.tryExecute.call(this, ', JSON.stringify(op), ')')
      if (op.struct === 'Delete') {
        yield* Y.Struct.Delete.execute.call(this, op)
        // this is now called in Transaction.deleteOperation!
        // yield* this.store.operationAdded(this, op)
      } else {
        // check if this op was defined
        var defined = yield* this.getInsertion(op.id)
        while (defined != null && defined.content != null) {
          // check if this op has a longer content in the case it is defined
          if (defined.id[1] + defined.content.length < op.id[1] + op.content.length) {
            var overlapSize = defined.content.length - (op.id[1] - defined.id[1])
            op.content.splice(0, overlapSize)
            op.id = [op.id[0], op.id[1] + overlapSize]
            op.left = Y.utils.getLastId(defined)
            op.origin = op.left
            defined = yield* this.getOperation(op.id) // getOperation suffices here
          } else {
            break
          }
        }
        if (defined == null) {
          var isGarbageCollected = yield* this.isGarbageCollected(op.id)
          if (!isGarbageCollected) {
            yield* Y.Struct[op.struct].execute.call(this, op)
            yield* this.addOperation(op)
            yield* this.store.operationAdded(this, op)

            // if insertion, try to combine with left
            yield* this.tryCombineWithLeft(op)
          }
        }
      }
    }
    /*
     * Called by a transaction when an operation is added.
     * This function is especially important for y-indexeddb, where several instances may share a single database.
     * Every time an operation is created by one instance, it is send to all other instances and operationAdded is called
     *
     * If it's not a Delete operation:
     *   * Checks if another operation is executable (listenersById)
     *   * Update state, if possible
     *
     * Always:
     *   * Call type
     */
    * operationAdded (transaction, op) {
      if (op.struct === 'Delete') {
        var target = yield* transaction.getInsertion(op.target)
        var type = this.initializedTypes[JSON.stringify(target.parent)]
        if (type != null) {
          yield* type._changed(transaction, op)
        }
      } else {
        // increase SS
        yield* transaction.updateState(op.id[0])
        var opLen = op.content != null ? op.content.length : 1
        for (let i = 0; i < opLen; i++) {
          // notify whenOperation listeners (by id)
          var sid = JSON.stringify([op.id[0], op.id[1] + i])
          var l = this.listenersById[sid]
          delete this.listenersById[sid]
          if (l != null) {
            for (var key in l) {
              var listener = l[key]
              if (--listener.missing === 0) {
                this.whenOperationsExist([], listener.op)
              }
            }
          }
        }
        var t = this.initializedTypes[JSON.stringify(op.parent)]

        // if parent is deleted, mark as gc'd and return
        if (op.parent != null) {
          var parentIsDeleted = yield* transaction.isDeleted(op.parent)
          if (parentIsDeleted) {
            yield* transaction.deleteList(op.id)
            return
          }
        }

        // notify parent, if it was instanciated as a custom type
        if (t != null) {
          let o = Y.utils.copyOperation(op)
          yield* t._changed(transaction, o)
        }
        if (!op.deleted) {
          // Delete if DS says this is actually deleted
          var len = op.content != null ? op.content.length : 1
          var startId = op.id // You must not use op.id in the following loop, because op will change when deleted
          for (let i = 0; i < len; i++) {
            var id = [startId[0], startId[1] + i]
            var opIsDeleted = yield* transaction.isDeleted(id)
            if (opIsDeleted) {
              var delop = {
                struct: 'Delete',
                target: id
              }
              yield* this.tryExecute.call(transaction, delop)
            }
          }
        }
      }
    }
    whenTransactionsFinished () {
      if (this.transactionInProgress) {
        if (this.transactionsFinished == null) {
          var resolve
          var promise = new Promise(function (r) {
            resolve = r
          })
          this.transactionsFinished = {
            resolve: resolve,
            promise: promise
          }
          return promise
        } else {
          return this.transactionsFinished.promise
        }
      } else {
        return Promise.resolve()
      }
    }
    // Check if there is another transaction request.
    // * the last transaction is always a flush :)
    getNextRequest () {
      if (this.waitingTransactions.length === 0) {
        if (this.transactionIsFlushed) {
          this.transactionInProgress = false
          this.transactionIsFlushed = false
          if (this.transactionsFinished != null) {
            this.transactionsFinished.resolve()
            this.transactionsFinished = null
          }
          return null
        } else {
          this.transactionIsFlushed = true
          return function * () {
            yield* this.flush()
          }
        }
      } else {
        this.transactionIsFlushed = false
        return this.waitingTransactions.shift()
      }
    }
    requestTransaction (makeGen/* :any */, callImmediately) {
      this.waitingTransactions.push(makeGen)
      if (!this.transactionInProgress) {
        this.transactionInProgress = true
        setTimeout(() => {
          this.transact(this.getNextRequest())
        }, 0)
      }
    }
  }
  Y.AbstractDatabase = AbstractDatabase
}

},{}],192:[function(require,module,exports){
/* @flow */
'use strict'

/*
 An operation also defines the structure of a type. This is why operation and
 structure are used interchangeably here.

 It must be of the type Object. I hope to achieve some performance
 improvements when working on databases that support the json format.

 An operation must have the following properties:

 * encode
     - Encode the structure in a readable format (preferably string- todo)
 * decode (todo)
     - decode structure to json
 * execute
     - Execute the semantics of an operation.
 * requiredOps
     - Operations that are required to execute this operation.
*/
module.exports = function (Y/* :any */) {
  var Struct = {
    /* This is the only operation that is actually not a structure, because
    it is not stored in the OS. This is why it _does not_ have an id

    op = {
      target: Id
    }
    */
    Delete: {
      encode: function (op) {
        return op
      },
      requiredOps: function (op) {
        return [] // [op.target]
      },
      execute: function * (op) {
        return yield* this.deleteOperation(op.target, op.length || 1)
      }
    },
    Insert: {
      /* {
          content: [any],
          opContent: Id,
          id: Id,
          left: Id,
          origin: Id,
          right: Id,
          parent: Id,
          parentSub: string (optional), // child of Map type
        }
      */
      encode: function (op/* :Insertion */) /* :Insertion */ {
        // TODO: you could not send the "left" property, then you also have to
        // "op.left = null" in $execute or $decode
        var e/* :any */ = {
          id: op.id,
          left: op.left,
          right: op.right,
          origin: op.origin,
          parent: op.parent,
          struct: op.struct
        }
        if (op.parentSub != null) {
          e.parentSub = op.parentSub
        }
        if (op.hasOwnProperty('opContent')) {
          e.opContent = op.opContent
        } else {
          e.content = op.content.slice()
        }

        return e
      },
      requiredOps: function (op) {
        var ids = []
        if (op.left != null) {
          ids.push(op.left)
        }
        if (op.right != null) {
          ids.push(op.right)
        }
        if (op.origin != null && !Y.utils.compareIds(op.left, op.origin)) {
          ids.push(op.origin)
        }
        // if (op.right == null && op.left == null) {
        ids.push(op.parent)

        if (op.opContent != null) {
          ids.push(op.opContent)
        }
        return ids
      },
      getDistanceToOrigin: function * (op) {
        if (op.left == null) {
          return 0
        } else {
          var d = 0
          var o = yield* this.getInsertion(op.left)
          while (!Y.utils.matchesId(o, op.origin)) {
            d++
            if (o.left == null) {
              break
            } else {
              o = yield* this.getInsertion(o.left)
            }
          }
          return d
        }
      },
      /*
      # $this has to find a unique position between origin and the next known character
      # case 1: $origin equals $o.origin: the $creator parameter decides if left or right
      #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4
      #         o2,o3 and o4 origin is 1 (the position of o2)
      #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator
      #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex
      #         therefore $this would be always to the right of o3
      # case 2: $origin < $o.origin
      #         if current $this insert_position > $o origin: $this ins
      #         else $insert_position will not change
      #         (maybe we encounter case 1 later, then this will be to the right of $o)
      # case 3: $origin > $o.origin
      #         $this insert_position is to the left of $o (forever!)
      */
      execute: function * (op) {
        var i // loop counter

        // during this function some ops may get split into two pieces (e.g. with getInsertionCleanEnd)
        // We try to merge them later, if possible
        var tryToRemergeLater = []

        if (op.origin != null) { // TODO: !== instead of !=
          // we save in origin that op originates in it
          // we need that later when we eventually garbage collect origin (see transaction)
          var origin = yield* this.getInsertionCleanEnd(op.origin)
          if (origin.originOf == null) {
            origin.originOf = []
          }
          origin.originOf.push(op.id)
          yield* this.setOperation(origin)
          if (origin.right != null) {
            tryToRemergeLater.push(origin.right)
          }
        }
        var distanceToOrigin = i = yield* Struct.Insert.getDistanceToOrigin.call(this, op) // most cases: 0 (starts from 0)

        // now we begin to insert op in the list of insertions..
        var o
        var parent
        var start

        // find o. o is the first conflicting operation
        if (op.left != null) {
          o = yield* this.getInsertionCleanEnd(op.left)
          if (!Y.utils.compareIds(op.left, op.origin) && o.right != null) {
            // only if not added previously
            tryToRemergeLater.push(o.right)
          }
          o = (o.right == null) ? null : yield* this.getOperation(o.right)
        } else { // left == null
          parent = yield* this.getOperation(op.parent)
          let startId = op.parentSub ? parent.map[op.parentSub] : parent.start
          start = startId == null ? null : yield* this.getOperation(startId)
          o = start
        }

        // make sure to split op.right if necessary (also add to tryCombineWithLeft)
        if (op.right != null) {
          tryToRemergeLater.push(op.right)
          yield* this.getInsertionCleanStart(op.right)
        }

        // handle conflicts
        while (true) {
          if (o != null && !Y.utils.compareIds(o.id, op.right)) {
            var oOriginDistance = yield* Struct.Insert.getDistanceToOrigin.call(this, o)
            if (oOriginDistance === i) {
              // case 1
              if (o.id[0] < op.id[0]) {
                op.left = Y.utils.getLastId(o)
                distanceToOrigin = i + 1 // just ignore o.content.length, doesn't make a difference
              }
            } else if (oOriginDistance < i) {
              // case 2
              if (i - distanceToOrigin <= oOriginDistance) {
                op.left = Y.utils.getLastId(o)
                distanceToOrigin = i + 1 // just ignore o.content.length, doesn't make a difference
              }
            } else {
              break
            }
            i++
            if (o.right != null) {
              o = yield* this.getInsertion(o.right)
            } else {
              o = null
            }
          } else {
            break
          }
        }

        // reconnect..
        var left = null
        var right = null
        if (parent == null) {
          parent = yield* this.getOperation(op.parent)
        }

        // reconnect left and set right of op
        if (op.left != null) {
          left = yield* this.getInsertion(op.left)
          // link left
          op.right = left.right
          left.right = op.id

          yield* this.setOperation(left)
        } else {
          // set op.right from parent, if necessary
          op.right = op.parentSub ? parent.map[op.parentSub] || null : parent.start
        }
        // reconnect right
        if (op.right != null) {
          // TODO: wanna connect right too?
          right = yield* this.getOperation(op.right)
          right.left = Y.utils.getLastId(op)

          // if right exists, and it is supposed to be gc'd. Remove it from the gc
          if (right.gc != null) {
            if (right.content != null && right.content.length > 1) {
              right = yield* this.getInsertionCleanEnd(right.id)
            }
            this.store.removeFromGarbageCollector(right)
          }
          yield* this.setOperation(right)
        }

        // update parents .map/start/end properties
        if (op.parentSub != null) {
          if (left == null) {
            parent.map[op.parentSub] = op.id
            yield* this.setOperation(parent)
          }
          // is a child of a map struct.
          // Then also make sure that only the most left element is not deleted
          // We do not call the type in this case (this is what the third parameter is for)
          if (op.right != null) {
            yield* this.deleteOperation(op.right, 1, true)
          }
          if (op.left != null) {
            yield* this.deleteOperation(op.id, 1, true)
          }
        } else {
          if (right == null || left == null) {
            if (right == null) {
              parent.end = Y.utils.getLastId(op)
            }
            if (left == null) {
              parent.start = op.id
            }
            yield* this.setOperation(parent)
          }
        }

        // try to merge original op.left and op.origin
        for (let i = 0; i < tryToRemergeLater.length; i++) {
          var m = yield* this.getOperation(tryToRemergeLater[i])
          yield* this.tryCombineWithLeft(m)
        }
      }
    },
    List: {
      /*
      {
        start: null,
        end: null,
        struct: "List",
        type: "",
        id: this.os.getNextOpId(1)
      }
      */
      create: function (id) {
        return {
          start: null,
          end: null,
          struct: 'List',
          id: id
        }
      },
      encode: function (op) {
        var e = {
          struct: 'List',
          id: op.id,
          type: op.type
        }
        if (op.requires != null) {
          e.requires = op.requires
        }
        if (op.info != null) {
          e.info = op.info
        }
        return e
      },
      requiredOps: function () {
        /*
        var ids = []
        if (op.start != null) {
          ids.push(op.start)
        }
        if (op.end != null){
          ids.push(op.end)
        }
        return ids
        */
        return []
      },
      execute: function * (op) {
        op.start = null
        op.end = null
      },
      ref: function * (op, pos) {
        if (op.start == null) {
          return null
        }
        var res = null
        var o = yield* this.getOperation(op.start)

        while (true) {
          if (!o.deleted) {
            res = o
            pos--
          }
          if (pos >= 0 && o.right != null) {
            o = yield* this.getOperation(o.right)
          } else {
            break
          }
        }
        return res
      },
      map: function * (o, f) {
        o = o.start
        var res = []
        while (o != null) { // TODO: change to != (at least some convention)
          var operation = yield* this.getOperation(o)
          if (!operation.deleted) {
            res.push(f(operation))
          }
          o = operation.right
        }
        return res
      }
    },
    Map: {
      /*
        {
          map: {},
          struct: "Map",
          type: "",
          id: this.os.getNextOpId(1)
        }
      */
      create: function (id) {
        return {
          id: id,
          map: {},
          struct: 'Map'
        }
      },
      encode: function (op) {
        var e = {
          struct: 'Map',
          type: op.type,
          id: op.id,
          map: {} // overwrite map!!
        }
        if (op.requires != null) {
          e.requires = op.requires
        }
        if (op.info != null) {
          e.info = op.info
        }
        return e
      },
      requiredOps: function () {
        return []
      },
      execute: function * () {},
      /*
        Get a property by name
      */
      get: function * (op, name) {
        var oid = op.map[name]
        if (oid != null) {
          var res = yield* this.getOperation(oid)
          if (res == null || res.deleted) {
            return void 0
          } else if (res.opContent == null) {
            return res.content[0]
          } else {
            return yield* this.getType(res.opContent)
          }
        }
      }
    }
  }
  Y.Struct = Struct
}

},{}],193:[function(require,module,exports){
/* @flow */
'use strict'

/*
  Partial definition of a transaction

  A transaction provides all the the async functionality on a database.

  By convention, a transaction has the following properties:
  * ss for StateSet
  * os for OperationStore
  * ds for DeleteStore

  A transaction must also define the following methods:
  * checkDeleteStoreForState(state)
    - When increasing the state of a user, an operation with an higher id
      may already be garbage collected, and therefore it will never be received.
      update the state to reflect this knowledge. This won't call a method to save the state!
  * getDeleteSet(id)
    - Get the delete set in a readable format:
      {
        "userX": [
          [5,1], // starting from position 5, one operations is deleted
          [9,4]  // starting from position 9, four operations are deleted
        ],
        "userY": ...
      }
  * getOpsFromDeleteSet(ds) -- TODO: just call this.deleteOperation(id) here
    - get a set of deletions that need to be applied in order to get to
      achieve the state of the supplied ds
  * setOperation(op)
    - write `op` to the database.
      Note: this is allowed to return an in-memory object.
      E.g. the Memory adapter returns the object that it has in-memory.
      Changing values on this object will be stored directly in the database
      without calling this function. Therefore,
      setOperation may have no functionality in some adapters. This also has
      implications on the way we use operations that were served from the database.
      We try not to call copyObject, if not necessary.
  * addOperation(op)
    - add an operation to the database.
      This may only be called once for every op.id
      Must return a function that returns the next operation in the database (ordered by id)
  * getOperation(id)
  * removeOperation(id)
    - remove an operation from the database. This is called when an operation
      is garbage collected.
  * setState(state)
    - `state` is of the form
      {
        user: "1",
        clock: 4
      } <- meaning that we have four operations from user "1"
           (with these id's respectively: 0, 1, 2, and 3)
  * getState(user)
  * getStateVector()
    - Get the state of the OS in the form
    [{
      user: "userX",
      clock: 11
    },
     ..
    ]
  * getStateSet()
    - Get the state of the OS in the form
    {
      "userX": 11,
      "userY": 22
    }
   * getOperations(startSS)
     - Get the all the operations that are necessary in order to achive the
       stateSet of this user, starting from a stateSet supplied by another user
   * makeOperationReady(ss, op)
     - this is called only by `getOperations(startSS)`. It makes an operation
       applyable on a given SS.
*/
module.exports = function (Y/* :any */) {
  class TransactionInterface {
    /* ::
    store: Y.AbstractDatabase;
    ds: Store;
    os: Store;
    ss: Store;
    */
    /*
      Get a type based on the id of its model.
      If it does not exist yes, create it.
      TODO: delete type from store.initializedTypes[id] when corresponding id was deleted!
    */
    * getType (id, args) {
      var sid = JSON.stringify(id)
      var t = this.store.initializedTypes[sid]
      if (t == null) {
        var op/* :MapStruct | ListStruct */ = yield* this.getOperation(id)
        if (op != null) {
          t = yield* Y[op.type].typeDefinition.initType.call(this, this.store, op, args)
          this.store.initializedTypes[sid] = t
        }
      }
      return t
    }
    * createType (typedefinition, id) {
      var structname = typedefinition[0].struct
      id = id || this.store.getNextOpId(1)
      var op
      if (id[0] === '_') {
        op = yield* this.getOperation(id)
      } else {
        op = Y.Struct[structname].create(id)
        op.type = typedefinition[0].name
      }
      if (typedefinition[0].appendAdditionalInfo != null) {
        yield* typedefinition[0].appendAdditionalInfo.call(this, op, typedefinition[1])
      }
      if (op[0] === '_') {
        yield* this.setOperation(op)
      } else {
        yield* this.applyCreatedOperations([op])
      }
      return yield* this.getType(id, typedefinition[1])
    }
    /* createType (typedefinition, id) {
      var structname = typedefinition[0].struct
      id = id || this.store.getNextOpId(1)
      var op = Y.Struct[structname].create(id)
      op.type = typedefinition[0].name
      if (typedefinition[0].appendAdditionalInfo != null) {
        yield* typedefinition[0].appendAdditionalInfo.call(this, op, typedefinition[1])
      }
      // yield* this.applyCreatedOperations([op])
      yield* Y.Struct[op.struct].execute.call(this, op)
      yield* this.addOperation(op)
      yield* this.store.operationAdded(this, op)
      return yield* this.getType(id, typedefinition[1])
    }*/
    /*
      Apply operations that this user created (no remote ones!)
        * does not check for Struct.*.requiredOps()
        * also broadcasts it through the connector
    */
    * applyCreatedOperations (ops) {
      var send = []
      for (var i = 0; i < ops.length; i++) {
        var op = ops[i]
        yield* this.store.tryExecute.call(this, op)
        if (op.id == null || typeof op.id[1] !== 'string') {
          send.push(Y.Struct[op.struct].encode(op))
        }
      }
      if (!this.store.y.connector.isDisconnected() && send.length > 0) { // TODO: && !this.store.forwardAppliedOperations (but then i don't send delete ops)
        // is connected, and this is not going to be send in addOperation
        this.store.y.connector.broadcastOps(send)
      }
    }

    * deleteList (start) {
      while (start != null) {
        start = yield* this.getOperation(start)
        if (!start.gc) {
          start.gc = true
          start.deleted = true
          yield* this.setOperation(start)
          var delLength = start.content != null ? start.content.length : 1
          yield* this.markDeleted(start.id, delLength)
          if (start.opContent != null) {
            yield* this.deleteOperation(start.opContent)
          }
          this.store.queueGarbageCollector(start.id)
        }
        start = start.right
      }
    }

    /*
      Mark an operation as deleted, and add it to the GC, if possible.
    */
    * deleteOperation (targetId, length, preventCallType) /* :Generator<any, any, any> */ {
      if (length == null) {
        length = 1
      }
      yield* this.markDeleted(targetId, length)
      while (length > 0) {
        var callType = false
        var target = yield* this.os.findWithUpperBound([targetId[0], targetId[1] + length - 1])
        var targetLength = target != null && target.content != null ? target.content.length : 1
        if (target == null || target.id[0] !== targetId[0] || target.id[1] + targetLength <= targetId[1]) {
          // does not exist or is not in the range of the deletion
          target = null
          length = 0
        } else {
          // does exist, check if it is too long
          if (!target.deleted) {
            if (target.id[1] < targetId[1]) {
              // starts to the left of the deletion range
              target = yield* this.getInsertionCleanStart(targetId)
              targetLength = target.content.length // must have content property!
            }
            if (target.id[1] + targetLength > targetId[1] + length) {
              // ends to the right of the deletion range
              target = yield* this.getInsertionCleanEnd([targetId[0], targetId[1] + length - 1])
              targetLength = target.content.length
            }
          }
          length = target.id[1] - targetId[1]
        }

        if (target != null) {
          if (!target.deleted) {
            callType = true
            // set deleted & notify type
            target.deleted = true
            // delete containing lists
            if (target.start != null) {
              // TODO: don't do it like this .. -.-
              yield* this.deleteList(target.start)
              // yield* this.deleteList(target.id) -- do not gc itself because this may still get referenced
            }
            if (target.map != null) {
              for (var name in target.map) {
                yield* this.deleteList(target.map[name])
              }
              // TODO: here to..  (see above)
              // yield* this.deleteList(target.id) -- see above
            }
            if (target.opContent != null) {
              yield* this.deleteOperation(target.opContent)
              // target.opContent = null
            }
            if (target.requires != null) {
              for (var i = 0; i < target.requires.length; i++) {
                yield* this.deleteOperation(target.requires[i])
              }
            }
          }
          var left
          if (target.left != null) {
            left = yield* this.getInsertion(target.left)
          } else {
            left = null
          }

          // set here because it was deleted and/or gc'd
          yield* this.setOperation(target)

          /*
            Check if it is possible to add right to the gc.
            Because this delete can't be responsible for left being gc'd,
            we don't have to add left to the gc..
          */
          var right
          if (target.right != null) {
            right = yield* this.getOperation(target.right)
          } else {
            right = null
          }
          if (callType && !preventCallType) {
            yield* this.store.operationAdded(this, {
              struct: 'Delete',
              target: target.id,
              length: targetLength
            })
          }
          // need to gc in the end!
          yield* this.store.addToGarbageCollector.call(this, target, left)
          if (right != null) {
            yield* this.store.addToGarbageCollector.call(this, right, target)
          }
        }
      }
    }
    /*
      Mark an operation as deleted&gc'd
    */
    * markGarbageCollected (id, len) {
      // this.mem.push(["gc", id]);
      this.store.addToDebug('yield* this.markGarbageCollected(', id, ', ', len, ')')
      var n = yield* this.markDeleted(id, len)
      if (n.id[1] < id[1] && !n.gc) {
        // un-extend left
        var newlen = n.len - (id[1] - n.id[1])
        n.len -= newlen
        yield* this.ds.put(n)
        n = {id: id, len: newlen, gc: false}
        yield* this.ds.put(n)
      }
      // get prev&next before adding a new operation
      var prev = yield* this.ds.findPrev(id)
      var next = yield* this.ds.findNext(id)

      if (id[1] + len < n.id[1] + n.len && !n.gc) {
        // un-extend right
        yield* this.ds.put({id: [id[0], id[1] + len], len: n.len - len, gc: false})
        n.len = len
      }
      // set gc'd
      n.gc = true
      // can extend left?
      if (
        prev != null &&
        prev.gc &&
        Y.utils.compareIds([prev.id[0], prev.id[1] + prev.len], n.id)
      ) {
        prev.len += n.len
        yield* this.ds.delete(n.id)
        n = prev
        // ds.put n here?
      }
      // can extend right?
      if (
        next != null &&
        next.gc &&
        Y.utils.compareIds([n.id[0], n.id[1] + n.len], next.id)
      ) {
        n.len += next.len
        yield* this.ds.delete(next.id)
      }
      yield* this.ds.put(n)
      yield* this.updateState(n.id[0])
    }
    /*
      Mark an operation as deleted.

      returns the delete node
    */
    * markDeleted (id, length) {
      if (length == null) {
        length = 1
      }
      // this.mem.push(["del", id]);
      var n = yield* this.ds.findWithUpperBound(id)
      if (n != null && n.id[0] === id[0]) {
        if (n.id[1] <= id[1] && id[1] <= n.id[1] + n.len) {
          // id is in n's range
          var diff = id[1] + length - (n.id[1] + n.len) // overlapping right
          if (diff > 0) {
            // id+length overlaps n
            if (!n.gc) {
              n.len += diff
            } else {
              diff = n.id[1] + n.len - id[1] // overlapping left (id till n.end)
              if (diff < length) {
                // a partial deletion
                n = {id: [id[0], id[1] + diff], len: length - diff, gc: false}
                yield* this.ds.put(n)
              } else {
                // already gc'd
                throw new Error('Cannot happen! (it dit though.. :()')
                // return n
              }
            }
          } else {
            // no overlapping, already deleted
            return n
          }
        } else {
          // cannot extend left (there is no left!)
          n = {id: id, len: length, gc: false}
          yield* this.ds.put(n) // TODO: you double-put !!
        }
      } else {
        // cannot extend left
        n = {id: id, len: length, gc: false}
        yield* this.ds.put(n)
      }
      // can extend right?
      var next = yield* this.ds.findNext(n.id)
      if (
        next != null &&
        n.id[0] === next.id[0] &&
        n.id[1] + n.len >= next.id[1]
      ) {
        diff = n.id[1] + n.len - next.id[1] // from next.start to n.end
        while (diff >= 0) {
          // n overlaps with next
          if (next.gc) {
            // gc is stronger, so reduce length of n
            n.len -= diff
            if (diff >= next.len) {
              // delete the missing range after next
              diff = diff - next.len // missing range after next
              if (diff > 0) {
                yield* this.ds.put(n) // unneccessary? TODO!
                yield* this.markDeleted([next.id[0], next.id[1] + next.len], diff)
              }
            }
            break
          } else {
            // we can extend n with next
            if (diff > next.len) {
              // n is even longer than next
              // get next.next, and try to extend it
              var _next = yield* this.ds.findNext(next.id)
              yield* this.ds.delete(next.id)
              if (_next == null || n.id[0] !== _next.id[0]) {
                break
              } else {
                next = _next
                diff = n.id[1] + n.len - next.id[1] // from next.start to n.end
                // continue!
              }
            } else {
              // n just partially overlaps with next. extend n, delete next, and break this loop
              n.len += next.len - diff
              yield* this.ds.delete(next.id)
              break
            }
          }
        }
      }
      yield* this.ds.put(n)
      return n
    }
    /*
      Call this method when the client is connected&synced with the
      other clients (e.g. master). This will query the database for
      operations that can be gc'd and add them to the garbage collector.
    */
    * garbageCollectAfterSync () {
      if (this.store.gc1.length > 0 || this.store.gc2.length > 0) {
        console.warn('gc should be empty after sync')
      }
      yield* this.os.iterate(this, null, null, function * (op) {
        if (op.gc) {
          delete op.gc
          yield* this.setOperation(op)
        }
        if (op.parent != null) {
          var parentDeleted = yield* this.isDeleted(op.parent)
          if (parentDeleted) {
            op.gc = true
            if (!op.deleted) {
              yield* this.markDeleted(op.id, op.content != null ? op.content.length : 1)
              op.deleted = true
              if (op.opContent != null) {
                yield* this.deleteOperation(op.opContent)
              }
              if (op.requires != null) {
                for (var i = 0; i < op.requires.length; i++) {
                  yield* this.deleteOperation(op.requires[i])
                }
              }
            }
            yield* this.setOperation(op)
            this.store.gc1.push(op.id) // this is ok becaues its shortly before sync (otherwise use queueGarbageCollector!)
            return
          }
        }
        if (op.deleted) {
          var left = null
          if (op.left != null) {
            left = yield* this.getInsertion(op.left)
          }
          yield* this.store.addToGarbageCollector.call(this, op, left)
        }
      })
    }
    /*
      Really remove an op and all its effects.
      The complicated case here is the Insert operation:
      * reset left
      * reset right
      * reset parent.start
      * reset parent.end
      * reset origins of all right ops
    */
    * garbageCollectOperation (id) {
      this.store.addToDebug('yield* this.garbageCollectOperation(', id, ')')
      var o = yield* this.getOperation(id)
      yield* this.markGarbageCollected(id, (o != null && o.content != null) ? o.content.length : 1) // always mark gc'd
      // if op exists, then clean that mess up..
      if (o != null) {
        var deps = []
        if (o.opContent != null) {
          deps.push(o.opContent)
        }
        if (o.requires != null) {
          deps = deps.concat(o.requires)
        }
        for (var i = 0; i < deps.length; i++) {
          var dep = yield* this.getOperation(deps[i])
          if (dep != null) {
            if (!dep.deleted) {
              yield* this.deleteOperation(dep.id)
              dep = yield* this.getOperation(dep.id)
            }
            dep.gc = true
            yield* this.setOperation(dep)
            this.store.queueGarbageCollector(dep.id)
          } else {
            yield* this.markGarbageCollected(deps[i], 1)
          }
        }

        // remove gc'd op from the left op, if it exists
        if (o.left != null) {
          var left = yield* this.getInsertion(o.left)
          left.right = o.right
          yield* this.setOperation(left)
        }
        // remove gc'd op from the right op, if it exists
        // also reset origins of right ops
        if (o.right != null) {
          var right = yield* this.getOperation(o.right)
          right.left = o.left

          if (o.originOf != null && o.originOf.length > 0) {
            // find new origin of right ops
            // origin is the first left deleted operation
            var neworigin = o.left
            var neworigin_ = null
            while (neworigin != null) {
              neworigin_ = yield* this.getInsertion(neworigin)
              if (neworigin_.deleted) {
                break
              }
              neworigin = neworigin_.left
            }

            // reset origin of all right ops (except first right - duh!),

            /* ** The following code does not rely on the the originOf property **
                  I recently added originOf to all Insert Operations (see Struct.Insert.execute),
                  which saves which operations originate in a Insert operation.
                  Garbage collecting without originOf is more memory efficient, but is nearly impossible for large texts, or lists!
                  But I keep this code for now
            ```
            // reset origin of right
            right.origin = neworigin
            // search until you find origin pointer to the left of o
            if (right.right != null) {
              var i = yield* this.getOperation(right.right)
              var ids = [o.id, o.right]
              while (ids.some(function (id) {
                return Y.utils.compareIds(id, i.origin)
              })) {
                if (Y.utils.compareIds(i.origin, o.id)) {
                  // reset origin of i
                  i.origin = neworigin
                  yield* this.setOperation(i)
                }
                // get next i
                if (i.right == null) {
                  break
                } else {
                  ids.push(i.id)
                  i = yield* this.getOperation(i.right)
                }
              }
            }
            ```
            */
            // ** Now the new implementation starts **
            // reset neworigin of all originOf[*]
            for (var _i in o.originOf) {
              var originsIn = yield* this.getOperation(o.originOf[_i])
              if (originsIn != null) {
                originsIn.origin = neworigin
                yield* this.setOperation(originsIn)
              }
            }
            if (neworigin != null) {
              if (neworigin_.originOf == null) {
                neworigin_.originOf = o.originOf
              } else {
                neworigin_.originOf = o.originOf.concat(neworigin_.originOf)
              }
              yield* this.setOperation(neworigin_)
            }
            // we don't need to set right here, because
            // right should be in o.originOf => it is set it the previous for loop
          } else {
            // we didn't need to reset the origin of right
            // so we have to set right here
            yield* this.setOperation(right)
          }
        }
        // o may originate in another operation.
        // Since o is deleted, we have to reset o.origin's `originOf` property
        if (o.origin != null) {
          var origin = yield* this.getInsertion(o.origin)
          origin.originOf = origin.originOf.filter(function (_id) {
            return !Y.utils.compareIds(id, _id)
          })
          yield* this.setOperation(origin)
        }
        var parent
        if (o.parent != null) {
          parent = yield* this.getOperation(o.parent)
        }
        // remove gc'd op from parent, if it exists
        if (parent != null) {
          var setParent = false // whether to save parent to the os
          if (o.parentSub != null) {
            if (Y.utils.compareIds(parent.map[o.parentSub], o.id)) {
              setParent = true
              if (o.right != null) {
                parent.map[o.parentSub] = o.right
              } else {
                delete parent.map[o.parentSub]
              }
            }
          } else {
            if (Y.utils.compareIds(parent.start, o.id)) {
              // gc'd op is the start
              setParent = true
              parent.start = o.right
            }
            if (Y.utils.matchesId(o, parent.end)) {
              // gc'd op is the end
              setParent = true
              parent.end = o.left
            }
          }
          if (setParent) {
            yield* this.setOperation(parent)
          }
        }
        // finally remove it from the os
        yield* this.removeOperation(o.id)
      }
    }
    * checkDeleteStoreForState (state) {
      var n = yield* this.ds.findWithUpperBound([state.user, state.clock])
      if (n != null && n.id[0] === state.user && n.gc) {
        state.clock = Math.max(state.clock, n.id[1] + n.len)
      }
    }
    * updateState (user) {
      var state = yield* this.getState(user)
      yield* this.checkDeleteStoreForState(state)
      var o = yield* this.getInsertion([user, state.clock])
      var oLength = (o != null && o.content != null) ? o.content.length : 1
      while (o != null && user === o.id[0] && o.id[1] <= state.clock && o.id[1] + oLength > state.clock) {
        // either its a new operation (1. case), or it is an operation that was deleted, but is not yet in the OS
        state.clock += oLength
        yield* this.checkDeleteStoreForState(state)
        o = yield* this.os.findNext(o.id)
        oLength = (o != null && o.content != null) ? o.content.length : 1
      }
      yield* this.setState(state)
    }
    /*
      apply a delete set in order to get
      the state of the supplied ds
    */
    * applyDeleteSet (ds) {
      var deletions = []

      for (var user in ds) {
        var dv = ds[user]
        var pos = 0
        var d = dv[pos]
        yield* this.ds.iterate(this, [user, 0], [user, Number.MAX_VALUE], function * (n) {
          // cases:
          // 1. d deletes something to the right of n
          //  => go to next n (break)
          // 2. d deletes something to the left of n
          //  => create deletions
          //  => reset d accordingly
          //  *)=> if d doesn't delete anything anymore, go to next d (continue)
          // 3. not 2) and d deletes something that also n deletes
          //  => reset d so that it doesn't contain n's deletion
          //  *)=> if d does not delete anything anymore, go to next d (continue)
          while (d != null) {
            var diff = 0 // describe the diff of length in 1) and 2)
            if (n.id[1] + n.len <= d[0]) {
              // 1)
              break
            } else if (d[0] < n.id[1]) {
              // 2)
              // delete maximum the len of d
              // else delete as much as possible
              diff = Math.min(n.id[1] - d[0], d[1])
              deletions.push([user, d[0], diff, d[2]])
            } else {
              // 3)
              diff = n.id[1] + n.len - d[0] // never null (see 1)
              if (d[2] && !n.gc) {
                // d marks as gc'd but n does not
                // then delete either way
                deletions.push([user, d[0], Math.min(diff, d[1]), d[2]])
              }
            }
            if (d[1] <= diff) {
              // d doesn't delete anything anymore
              d = dv[++pos]
            } else {
              d[0] = d[0] + diff // reset pos
              d[1] = d[1] - diff // reset length
            }
          }
        })
        // for the rest.. just apply it
        for (; pos < dv.length; pos++) {
          d = dv[pos]
          deletions.push([user, d[0], d[1], d[2]])
        }
      }
      for (var i = 0; i < deletions.length; i++) {
        var del = deletions[i]
        // always try to delete..
        yield* this.deleteOperation([del[0], del[1]], del[2])
        if (del[3]) {
          // gc..
          yield* this.markGarbageCollected([del[0], del[1]], del[2]) // always mark gc'd
          // remove operation..
          var counter = del[1] + del[2]
          while (counter >= del[1]) {
            var o = yield* this.os.findWithUpperBound([del[0], counter - 1])
            if (o == null) {
              break
            }
            var oLen = o.content != null ? o.content.length : 1
            if (o.id[0] !== del[0] || o.id[1] + oLen <= del[1]) {
              // not in range
              break
            }
            if (o.id[1] + oLen > del[1] + del[2]) {
              // overlaps right
              o = yield* this.getInsertionCleanEnd([del[0], del[1] + del[2] - 1])
            }
            if (o.id[1] < del[1]) {
              // overlaps left
              o = yield* this.getInsertionCleanStart([del[0], del[1]])
            }
            counter = o.id[1]
            yield* this.garbageCollectOperation(o.id)
          }
        }
        if (this.store.forwardAppliedOperations) {
          var ops = []
          ops.push({struct: 'Delete', target: [d[0], d[1]], length: del[2]})
          this.store.y.connector.broadcastOps(ops)
        }
      }
    }
    * isGarbageCollected (id) {
      var n = yield* this.ds.findWithUpperBound(id)
      return n != null && n.id[0] === id[0] && id[1] < n.id[1] + n.len && n.gc
    }
    /*
      A DeleteSet (ds) describes all the deleted ops in the OS
    */
    * getDeleteSet () {
      var ds = {}
      yield* this.ds.iterate(this, null, null, function * (n) {
        var user = n.id[0]
        var counter = n.id[1]
        var len = n.len
        var gc = n.gc
        var dv = ds[user]
        if (dv === void 0) {
          dv = []
          ds[user] = dv
        }
        dv.push([counter, len, gc])
      })
      return ds
    }
    * isDeleted (id) {
      var n = yield* this.ds.findWithUpperBound(id)
      return n != null && n.id[0] === id[0] && id[1] < n.id[1] + n.len
    }
    * setOperation (op) {
      yield* this.os.put(op)
      return op
    }
    * addOperation (op) {
      yield* this.os.put(op)
      if (!this.store.y.connector.isDisconnected() && this.store.forwardAppliedOperations && typeof op.id[1] !== 'string') {
        // is connected, and this is not going to be send in addOperation
        this.store.y.connector.broadcastOps([op])
      }
    }
    // if insertion, try to combine with left insertion (if both have content property)
    * tryCombineWithLeft (op) {
      if (
        op != null &&
        op.left != null &&
        op.content != null &&
        op.left[0] === op.id[0] &&
        Y.utils.compareIds(op.left, op.origin)
      ) {
        var left = yield* this.getInsertion(op.left)
        if (left.content != null &&
            left.id[1] + left.content.length === op.id[1] &&
            left.originOf.length === 1 &&
            !left.gc && !left.deleted &&
            !op.gc && !op.deleted
        ) {
          // combine!
          if (op.originOf != null) {
            left.originOf = op.originOf
          } else {
            delete left.originOf
          }
          left.content = left.content.concat(op.content)
          left.right = op.right
          yield* this.os.delete(op.id)
          yield* this.setOperation(left)
        }
      }
    }
    * getInsertion (id) {
      var ins = yield* this.os.findWithUpperBound(id)
      if (ins == null) {
        return null
      } else {
        var len = ins.content != null ? ins.content.length : 1 // in case of opContent
        if (id[0] === ins.id[0] && id[1] < ins.id[1] + len) {
          return ins
        } else {
          return null
        }
      }
    }
    * getInsertionCleanStartEnd (id) {
      yield* this.getInsertionCleanStart(id)
      return yield* this.getInsertionCleanEnd(id)
    }
    // Return an insertion such that id is the first element of content
    // This function manipulates an operation, if necessary
    * getInsertionCleanStart (id) {
      var ins = yield* this.getInsertion(id)
      if (ins != null) {
        if (ins.id[1] === id[1]) {
          return ins
        } else {
          var left = Y.utils.copyObject(ins)
          ins.content = left.content.splice(id[1] - ins.id[1])
          ins.id = id
          var leftLid = Y.utils.getLastId(left)
          ins.origin = leftLid
          left.originOf = [ins.id]
          left.right = ins.id
          ins.left = leftLid
          // debugger // check
          yield* this.setOperation(left)
          yield* this.setOperation(ins)
          if (left.gc) {
            this.store.queueGarbageCollector(ins.id)
          }
          return ins
        }
      } else {
        return null
      }
    }
    // Return an insertion such that id is the last element of content
    // This function manipulates an operation, if necessary
    * getInsertionCleanEnd (id) {
      var ins = yield* this.getInsertion(id)
      if (ins != null) {
        if (ins.content == null || (ins.id[1] + ins.content.length - 1 === id[1])) {
          return ins
        } else {
          var right = Y.utils.copyObject(ins)
          right.content = ins.content.splice(id[1] - ins.id[1] + 1) // cut off remainder
          right.id = [id[0], id[1] + 1]
          var insLid = Y.utils.getLastId(ins)
          right.origin = insLid
          ins.originOf = [right.id]
          ins.right = right.id
          right.left = insLid
          // debugger // check
          yield* this.setOperation(right)
          yield* this.setOperation(ins)
          if (ins.gc) {
            this.store.queueGarbageCollector(right.id)
          }
          return ins
        }
      } else {
        return null
      }
    }
    * getOperation (id/* :any */)/* :Transaction<any> */ {
      var o = yield* this.os.find(id)
      if (id[0] !== '_' || o != null) {
        return o
      } else { // type is string
        // generate this operation?
        var comp = id[1].split('_')
        if (comp.length > 1) {
          var struct = comp[0]
          var op = Y.Struct[struct].create(id)
          op.type = comp[1]
          yield* this.setOperation(op)
          return op
        } else {
          // won't be called. but just in case..
          console.error('Unexpected case. How can this happen?')
          debugger // eslint-disable-line
          return null
        }
      }
    }
    * removeOperation (id) {
      yield* this.os.delete(id)
    }
    * setState (state) {
      var val = {
        id: [state.user],
        clock: state.clock
      }
      yield* this.ss.put(val)
    }
    * getState (user) {
      var n = yield* this.ss.find([user])
      var clock = n == null ? null : n.clock
      if (clock == null) {
        clock = 0
      }
      return {
        user: user,
        clock: clock
      }
    }
    * getStateVector () {
      var stateVector = []
      yield* this.ss.iterate(this, null, null, function * (n) {
        stateVector.push({
          user: n.id[0],
          clock: n.clock
        })
      })
      return stateVector
    }
    * getStateSet () {
      var ss = {}
      yield* this.ss.iterate(this, null, null, function * (n) {
        ss[n.id[0]] = n.clock
      })
      return ss
    }
    /*
      Here, we make all missing operations executable for the receiving user.

      Notes:
        startSS: denotes to the SV that the remote user sent
        currSS:  denotes to the state vector that the user should have if he
                 applies all already sent operations (increases is each step)

      We face several problems:
      * Execute op as is won't work because ops depend on each other
       -> find a way so that they do not anymore
      * When changing left, must not go more to the left than the origin
      * When changing right, you have to consider that other ops may have op
        as their origin, this means that you must not set one of these ops
        as the new right (interdependencies of ops)
      * can't just go to the right until you find the first known operation,
        With currSS
          -> interdependency of ops is a problem
        With startSS
          -> leads to inconsistencies when two users join at the same time.
             Then the position depends on the order of execution -> error!

        Solution:
        -> re-create originial situation
          -> set op.left = op.origin (which never changes)
          -> set op.right
               to the first operation that is known (according to startSS)
               or to the first operation that has an origin that is not to the
               right of op.
          -> Enforces unique execution order -> happy user

        Improvements: TODO
          * Could set left to origin, or the first known operation
            (startSS or currSS.. ?)
            -> Could be necessary when I turn GC again.
            -> Is a bad(ish) idea because it requires more computation

      What we do:
      * Iterate over all missing operations.
      * When there is an operation, where the right op is known, send this op all missing ops to the left to the user
      * I explained above what we have to do with each operation. Here is how we do it efficiently:
        1. Go to the left until you find either op.origin, or a known operation (let o denote current operation in the iteration)
        2. Found a known operation -> set op.left = o, and send it to the user. stop
        3. Found o = op.origin -> set op.left = op.origin, and send it to the user. start again from 1. (set op = o)
        4. Found some o -> set o.right = op, o.left = o.origin, send it to the user, continue
    */
    * getOperations (startSS) {
      // TODO: use bounds here!
      if (startSS == null) {
        startSS = {}
      }
      var send = []

      var endSV = yield* this.getStateVector()
      for (var endState of endSV) {
        var user = endState.user
        if (user === '_') {
          continue
        }
        var startPos = startSS[user] || 0
        if (startPos > 0) {
          // There is a change that [user, startPos] is in a composed Insertion (with a smaller counter)
          // find out if that is the case
          var firstMissing = yield* this.getInsertion([user, startPos])
          if (firstMissing != null) {
            // update startPos
            startPos = firstMissing.id[1]
          }
        }
        yield* this.os.iterate(this, [user, startPos], [user, Number.MAX_VALUE], function * (op) {
          op = Y.Struct[op.struct].encode(op)
          if (op.struct !== 'Insert') {
            send.push(op)
          } else if (op.right == null || op.right[1] < (startSS[op.right[0]] || 0)) {
            // case 1. op.right is known
            var o = op
            // Remember: ?
            // -> set op.right
            //    1. to the first operation that is known (according to startSS)
            //    2. or to the first operation that has an origin that is not to the
            //      right of op.
            // For this we maintain a list of ops which origins are not found yet.
            var missing_origins = [op]
            var newright = op.right
            while (true) {
              if (o.left == null) {
                op.left = null
                send.push(op)
                if (!Y.utils.compareIds(o.id, op.id)) {
                  o = Y.Struct[op.struct].encode(o)
                  o.right = missing_origins[missing_origins.length - 1].id
                  send.push(o)
                }
                break
              }
              o = yield* this.getInsertion(o.left)
              // we set another o, check if we can reduce $missing_origins
              while (missing_origins.length > 0 && Y.utils.matchesId(o, missing_origins[missing_origins.length - 1].origin)) {
                missing_origins.pop()
              }
              if (o.id[1] < (startSS[o.id[0]] || 0)) {
                // case 2. o is known
                op.left = Y.utils.getLastId(o)
                send.push(op)
                break
              } else if (Y.utils.matchesId(o, op.origin)) {
                // case 3. o is op.origin
                op.left = op.origin
                send.push(op)
                op = Y.Struct[op.struct].encode(o)
                op.right = newright
                if (missing_origins.length > 0) {
                  console.log('This should not happen .. :( please report this')
                }
                missing_origins = [op]
              } else {
                // case 4. send o, continue to find op.origin
                var s = Y.Struct[op.struct].encode(o)
                s.right = missing_origins[missing_origins.length - 1].id
                s.left = s.origin
                send.push(s)
                missing_origins.push(o)
              }
            }
          }
        })
      }
      return send.reverse()
    }
    /* this is what we used before.. use this as a reference..
    * makeOperationReady (startSS, op) {
      op = Y.Struct[op.struct].encode(op)
      op = Y.utils.copyObject(op) -- use copyoperation instead now!
      var o = op
      var ids = [op.id]
      // search for the new op.right
      // it is either the first known op (according to startSS)
      // or the o that has no origin to the right of op
      // (this is why we use the ids array)
      while (o.right != null) {
        var right = yield* this.getOperation(o.right)
        if (o.right[1] < (startSS[o.right[0]] || 0) || !ids.some(function (id) {
          return Y.utils.compareIds(id, right.origin)
        })) {
          break
        }
        ids.push(o.right)
        o = right
      }
      op.right = o.right
      op.left = op.origin
      return op
    }
    */
    * flush () {
      yield* this.os.flush()
      yield* this.ss.flush()
      yield* this.ds.flush()
    }
  }
  Y.Transaction = TransactionInterface
}

},{}],194:[function(require,module,exports){
/* @flow */
'use strict'

/*
  EventHandler is an helper class for constructing custom types.

  Why: When constructing custom types, you sometimes want your types to work
  synchronous: E.g.
  ``` Synchronous
    mytype.setSomething("yay")
    mytype.getSomething() === "yay"
  ```
  versus
  ``` Asynchronous
    mytype.setSomething("yay")
    mytype.getSomething() === undefined
    mytype.waitForSomething().then(function(){
      mytype.getSomething() === "yay"
    })
  ```

  The structures usually work asynchronously (you have to wait for the
  database request to finish). EventHandler helps you to make your type
  synchronous.
*/
module.exports = function (Y /* : any*/) {
  Y.utils = {}

  class EventListenerHandler {
    constructor () {
      this.eventListeners = []
    }
    destroy () {
      this.eventListeners = null
    }
     /*
      Basic event listener boilerplate...
    */
    addEventListener (f) {
      this.eventListeners.push(f)
    }
    removeEventListener (f) {
      this.eventListeners = this.eventListeners.filter(function (g) {
        return f !== g
      })
    }
    removeAllEventListeners () {
      this.eventListeners = []
    }
    callEventListeners (event) {
      for (var i = 0; i < this.eventListeners.length; i++) {
        try {
          this.eventListeners[i](event)
        } catch (e) {
          console.error('User events must not throw Errors!')
        }
      }
    }
  }
  Y.utils.EventListenerHandler = EventListenerHandler

  class EventHandler extends EventListenerHandler {
    /* ::
    waiting: Array<Insertion | Deletion>;
    awaiting: number;
    onevent: Function;
    eventListeners: Array<Function>;
    */
    /*
      onevent: is called when the structure changes.

      Note: "awaiting opertations" is used to denote operations that were
      prematurely called. Events for received operations can not be executed until
      all prematurely called operations were executed ("waiting operations")
    */
    constructor (onevent /* : Function */) {
      super()
      this.waiting = []
      this.awaiting = 0
      this.onevent = onevent
    }
    destroy () {
      super.destroy()
      this.waiting = null
      this.awaiting = null
      this.onevent = null
    }
    /*
      Call this when a new operation arrives. It will be executed right away if
      there are no waiting operations, that you prematurely executed
    */
    receivedOp (op) {
      if (this.awaiting <= 0) {
        this.onevent(op)
      } else {
        this.waiting.push(op)
      }
    }
    /*
      You created some operations, and you want the `onevent` function to be
      called right away. Received operations will not be executed untill all
      prematurely called operations are executed
    */
    awaitAndPrematurelyCall (ops) {
      this.awaiting++
      ops.map(Y.utils.copyOperation).forEach(this.onevent)
    }
    * awaitOps (transaction, f, args) {
      function notSoSmartSort (array) {
        // this function sorts insertions in a executable order
        var result = []
        while (array.length > 0) {
          for (var i = 0; i < array.length; i++) {
            var independent = true
            for (var j = 0; j < array.length; j++) {
              if (Y.utils.matchesId(array[j], array[i].left)) {
                // array[i] depends on array[j]
                independent = false
                break
              }
            }
            if (independent) {
              result.push(array.splice(i, 1)[0])
              i--
            }
          }
        }
        return result
      }
      var before = this.waiting.length
      // somehow create new operations
      yield* f.apply(transaction, args)
      // remove all appended ops / awaited ops
      this.waiting.splice(before)
      if (this.awaiting > 0) this.awaiting--
      // if there are no awaited ops anymore, we can update all waiting ops, and send execute them (if there are still no awaited ops)
      if (this.awaiting === 0 && this.waiting.length > 0) {
        // update all waiting ops
        for (let i = 0; i < this.waiting.length; i++) {
          var o = this.waiting[i]
          if (o.struct === 'Insert') {
            var _o = yield* transaction.getInsertion(o.id)
            if (!Y.utils.compareIds(_o.id, o.id)) {
              // o got extended
              o.left = [o.id[0], o.id[1] - 1]
            } else if (_o.left == null) {
              o.left = null
            } else {
              // find next undeleted op
              var left = yield* transaction.getInsertion(_o.left)
              while (left.deleted != null) {
                if (left.left != null) {
                  left = yield* transaction.getInsertion(left.left)
                } else {
                  left = null
                  break
                }
              }
              o.left = left != null ? Y.utils.getLastId(left) : null
            }
          }
        }
        // the previous stuff was async, so we have to check again!
        // We also pull changes from the bindings, if there exists such a method, this could increase awaiting too
        if (this._pullChanges != null) {
          this._pullChanges()
        }
        if (this.awaiting === 0) {
          // sort by type, execute inserts first
          var ins = []
          var dels = []
          this.waiting.forEach(function (o) {
            if (o.struct === 'Delete') {
              dels.push(o)
            } else {
              ins.push(o)
            }
          })
          // put in executable order
          ins = notSoSmartSort(ins)
          ins.forEach(this.onevent)
          dels.forEach(this.onevent)
          this.waiting = []
        }
      }
    }
    // TODO: Remove awaitedInserts and awaitedDeletes in favor of awaitedOps, as they are deprecated and do not always work
    // Do this in one of the coming releases that are breaking anyway
    /*
      Call this when you successfully awaited the execution of n Insert operations
    */
    awaitedInserts (n) {
      var ops = this.waiting.splice(this.waiting.length - n)
      for (var oid = 0; oid < ops.length; oid++) {
        var op = ops[oid]
        if (op.struct === 'Insert') {
          for (var i = this.waiting.length - 1; i >= 0; i--) {
            let w = this.waiting[i]
            // TODO: do I handle split operations correctly here? Super unlikely, but yeah..
            // Also: can this case happen? Can op be inserted in the middle of a larger op that is in $waiting?
            if (w.struct === 'Insert') {
              if (Y.utils.matchesId(w, op.left)) {
                // include the effect of op in w
                w.right = op.id
                // exclude the effect of w in op
                op.left = w.left
              } else if (Y.utils.compareIds(w.id, op.right)) {
                // similar..
                w.left = Y.utils.getLastId(op)
                op.right = w.right
              }
            }
          }
        } else {
          throw new Error('Expected Insert Operation!')
        }
      }
      this._tryCallEvents(n)
    }
    /*
      Call this when you successfully awaited the execution of n Delete operations
    */
    awaitedDeletes (n, newLeft) {
      var ops = this.waiting.splice(this.waiting.length - n)
      for (var j = 0; j < ops.length; j++) {
        var del = ops[j]
        if (del.struct === 'Delete') {
          if (newLeft != null) {
            for (var i = 0; i < this.waiting.length; i++) {
              let w = this.waiting[i]
              // We will just care about w.left
              if (w.struct === 'Insert' && Y.utils.compareIds(del.target, w.left)) {
                w.left = newLeft
              }
            }
          }
        } else {
          throw new Error('Expected Delete Operation!')
        }
      }
      this._tryCallEvents(n)
    }
    /* (private)
      Try to execute the events for the waiting operations
    */
    _tryCallEvents () {
      function notSoSmartSort (array) {
        var result = []
        while (array.length > 0) {
          for (var i = 0; i < array.length; i++) {
            var independent = true
            for (var j = 0; j < array.length; j++) {
              if (Y.utils.matchesId(array[j], array[i].left)) {
                // array[i] depends on array[j]
                independent = false
                break
              }
            }
            if (independent) {
              result.push(array.splice(i, 1)[0])
              i--
            }
          }
        }
        return result
      }
      if (this.awaiting > 0) this.awaiting--
      if (this.awaiting === 0 && this.waiting.length > 0) {
        var ins = []
        var dels = []
        this.waiting.forEach(function (o) {
          if (o.struct === 'Delete') {
            dels.push(o)
          } else {
            ins.push(o)
          }
        })
        ins = notSoSmartSort(ins)
        ins.forEach(this.onevent)
        dels.forEach(this.onevent)
        this.waiting = []
      }
    }
  }
  Y.utils.EventHandler = EventHandler

  /*
    A wrapper for the definition of a custom type.
    Every custom type must have three properties:

    * struct
      - Structname of this type
    * initType
      - Given a model, creates a custom type
    * class
      - the constructor of the custom type (e.g. in order to inherit from a type)
  */
  class CustomType { // eslint-disable-line
    /* ::
    struct: any;
    initType: any;
    class: Function;
    name: String;
    */
    constructor (def) {
      if (def.struct == null ||
        def.initType == null ||
        def.class == null ||
        def.name == null
      ) {
        throw new Error('Custom type was not initialized correctly!')
      }
      this.struct = def.struct
      this.initType = def.initType
      this.class = def.class
      this.name = def.name
      if (def.appendAdditionalInfo != null) {
        this.appendAdditionalInfo = def.appendAdditionalInfo
      }
      this.parseArguments = (def.parseArguments || function () {
        return [this]
      }).bind(this)
      this.parseArguments.typeDefinition = this
    }
  }
  Y.utils.CustomType = CustomType

  Y.utils.isTypeDefinition = function isTypeDefinition (v) {
    if (v != null) {
      if (v instanceof Y.utils.CustomType) return [v]
      else if (v.constructor === Array && v[0] instanceof Y.utils.CustomType) return v
      else if (v instanceof Function && v.typeDefinition instanceof Y.utils.CustomType) return [v.typeDefinition]
    }
    return false
  }

  /*
    Make a flat copy of an object
    (just copy properties)
  */
  function copyObject (o) {
    var c = {}
    for (var key in o) {
      c[key] = o[key]
    }
    return c
  }
  Y.utils.copyObject = copyObject

  /*
    Copy an operation, so that it can be manipulated.
    Note: You must not change subproperties (except o.content)!
  */
  function copyOperation (o) {
    o = copyObject(o)
    if (o.content != null) {
      o.content = o.content.map(function (c) { return c })
    }
    return o
  }

  Y.utils.copyOperation = copyOperation

  /*
    Defines a smaller relation on Id's
  */
  function smaller (a, b) {
    return a[0] < b[0] || (a[0] === b[0] && (a[1] < b[1] || typeof a[1] < typeof b[1]))
  }
  Y.utils.smaller = smaller

  function inDeletionRange (del, ins) {
    return del.target[0] === ins[0] && del.target[1] <= ins[1] && ins[1] < del.target[1] + (del.length || 1)
  }
  Y.utils.inDeletionRange = inDeletionRange

  function compareIds (id1, id2) {
    if (id1 == null || id2 == null) {
      return id1 === id2
    } else {
      return id1[0] === id2[0] && id1[1] === id2[1]
    }
  }
  Y.utils.compareIds = compareIds

  function matchesId (op, id) {
    if (id == null || op == null) {
      return id === op
    } else {
      if (id[0] === op.id[0]) {
        if (op.content == null) {
          return id[1] === op.id[1]
        } else {
          return id[1] >= op.id[1] && id[1] < op.id[1] + op.content.length
        }
      }
    }
  }
  Y.utils.matchesId = matchesId

  function getLastId (op) {
    if (op.content == null || op.content.length === 1) {
      return op.id
    } else {
      return [op.id[0], op.id[1] + op.content.length - 1]
    }
  }
  Y.utils.getLastId = getLastId

  function createEmptyOpsArray (n) {
    var a = new Array(n)
    for (var i = 0; i < a.length; i++) {
      a[i] = {
        id: [null, null]
      }
    }
    return a
  }

  function createSmallLookupBuffer (Store) {
    /*
      This buffer implements a very small buffer that temporarily stores operations
      after they are read / before they are written.
      The buffer basically implements FIFO. Often requested lookups will be re-queued every time they are looked up / written.

      It can speed up lookups on Operation Stores and State Stores. But it does not require notable use of memory or processing power.

      Good for os and ss, bot not for ds (because it often uses methods that require a flush)

      I tried to optimize this for performance, therefore no highlevel operations.
    */
    class SmallLookupBuffer extends Store {
      constructor (arg1, arg2) {
        // super(...arguments) -- do this when this is supported by stable nodejs
        super(arg1, arg2)
        this.writeBuffer = createEmptyOpsArray(5)
        this.readBuffer = createEmptyOpsArray(10)
      }
      * find (id, noSuperCall) {
        var i, r
        for (i = this.readBuffer.length - 1; i >= 0; i--) {
          r = this.readBuffer[i]
          // we don't have to use compareids, because id is always defined!
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            // found r
            // move r to the end of readBuffer
            for (; i < this.readBuffer.length - 1; i++) {
              this.readBuffer[i] = this.readBuffer[i + 1]
            }
            this.readBuffer[this.readBuffer.length - 1] = r
            return r
          }
        }
        var o
        for (i = this.writeBuffer.length - 1; i >= 0; i--) {
          r = this.writeBuffer[i]
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            o = r
            break
          }
        }
        if (i < 0 && noSuperCall === undefined) {
          // did not reach break in last loop
          // read id and put it to the end of readBuffer
          o = yield* super.find(id)
        }
        if (o != null) {
          for (i = 0; i < this.readBuffer.length - 1; i++) {
            this.readBuffer[i] = this.readBuffer[i + 1]
          }
          this.readBuffer[this.readBuffer.length - 1] = o
        }
        return o
      }
      * put (o) {
        var id = o.id
        var i, r // helper variables
        for (i = this.writeBuffer.length - 1; i >= 0; i--) {
          r = this.writeBuffer[i]
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            // is already in buffer
            // forget r, and move o to the end of writeBuffer
            for (; i < this.writeBuffer.length - 1; i++) {
              this.writeBuffer[i] = this.writeBuffer[i + 1]
            }
            this.writeBuffer[this.writeBuffer.length - 1] = o
            break
          }
        }
        if (i < 0) {
          // did not reach break in last loop
          // write writeBuffer[0]
          var write = this.writeBuffer[0]
          if (write.id[0] !== null) {
            yield* super.put(write)
          }
          // put o to the end of writeBuffer
          for (i = 0; i < this.writeBuffer.length - 1; i++) {
            this.writeBuffer[i] = this.writeBuffer[i + 1]
          }
          this.writeBuffer[this.writeBuffer.length - 1] = o
        }
        // check readBuffer for every occurence of o.id, overwrite if found
        // whether found or not, we'll append o to the readbuffer
        for (i = 0; i < this.readBuffer.length - 1; i++) {
          r = this.readBuffer[i + 1]
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            this.readBuffer[i] = o
          } else {
            this.readBuffer[i] = r
          }
        }
        this.readBuffer[this.readBuffer.length - 1] = o
      }
      * delete (id) {
        var i, r
        for (i = 0; i < this.readBuffer.length; i++) {
          r = this.readBuffer[i]
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            this.readBuffer[i] = {
              id: [null, null]
            }
          }
        }
        yield* this.flush()
        yield* super.delete(id)
      }
      * findWithLowerBound (id) {
        var o = yield* this.find(id, true)
        if (o != null) {
          return o
        } else {
          yield* this.flush()
          return yield* super.findWithLowerBound.apply(this, arguments)
        }
      }
      * findWithUpperBound (id) {
        var o = yield* this.find(id, true)
        if (o != null) {
          return o
        } else {
          yield* this.flush()
          return yield* super.findWithUpperBound.apply(this, arguments)
        }
      }
      * findNext () {
        yield* this.flush()
        return yield* super.findNext.apply(this, arguments)
      }
      * findPrev () {
        yield* this.flush()
        return yield* super.findPrev.apply(this, arguments)
      }
      * iterate () {
        yield* this.flush()
        yield* super.iterate.apply(this, arguments)
      }
      * flush () {
        for (var i = 0; i < this.writeBuffer.length; i++) {
          var write = this.writeBuffer[i]
          if (write.id[0] !== null) {
            yield* super.put(write)
            this.writeBuffer[i] = {
              id: [null, null]
            }
          }
        }
      }
    }
    return SmallLookupBuffer
  }
  Y.utils.createSmallLookupBuffer = createSmallLookupBuffer
}

},{}],195:[function(require,module,exports){
/* @flow */
'use strict'

require('./Connector.js')(Y)
require('./Database.js')(Y)
require('./Transaction.js')(Y)
require('./Struct.js')(Y)
require('./Utils.js')(Y)
require('./Connectors/Test.js')(Y)

var requiringModules = {}

module.exports = Y
Y.requiringModules = requiringModules

Y.extend = function (name, value) {
  if (value instanceof Y.utils.CustomType) {
    Y[name] = value.parseArguments
  } else {
    Y[name] = value
  }
  if (requiringModules[name] != null) {
    requiringModules[name].resolve()
    delete requiringModules[name]
  }
}

Y.requestModules = requestModules
function requestModules (modules) {
  // determine if this module was compiled for es5 or es6 (y.js vs. y.es6)
  // if Insert.execute is a Function, then it isnt a generator..
  // then load the es5(.js) files..
  var extention = typeof regeneratorRuntime !== 'undefined' ? '.js' : '.es6'
  var promises = []
  for (var i = 0; i < modules.length; i++) {
    var module = modules[i].split('(')[0]
    var modulename = 'y-' + module.toLowerCase()
    if (Y[module] == null) {
      if (requiringModules[module] == null) {
        // module does not exist
        if (typeof window !== 'undefined' && window.Y !== 'undefined') {
          var imported = document.createElement('script')
          imported.src = Y.sourceDir + '/' + modulename + '/' + modulename + extention
          document.head.appendChild(imported)

          let requireModule = {}
          requiringModules[module] = requireModule
          requireModule.promise = new Promise(function (resolve) {
            requireModule.resolve = resolve
          })
          promises.push(requireModule.promise)
        } else {
          console.info('YJS: Please do not depend on automatic requiring of modules anymore! Extend modules as follows `require(\'y-modulename\')(Y)`')
          require(modulename)(Y)
        }
      } else {
        promises.push(requiringModules[modules[i]].promise)
      }
    }
  }
  return Promise.all(promises)
}

/* ::
type MemoryOptions = {
  name: 'memory'
}
type IndexedDBOptions = {
  name: 'indexeddb',
  namespace: string
}
type DbOptions = MemoryOptions | IndexedDBOptions

type WebRTCOptions = {
  name: 'webrtc',
  room: string
}
type WebsocketsClientOptions = {
  name: 'websockets-client',
  room: string
}
type ConnectionOptions = WebRTCOptions | WebsocketsClientOptions

type YOptions = {
  connector: ConnectionOptions,
  db: DbOptions,
  types: Array<TypeName>,
  sourceDir: string,
  share: {[key: string]: TypeName}
}
*/

function Y (opts/* :YOptions */) /* :Promise<YConfig> */ {
  opts.types = opts.types != null ? opts.types : []
  var modules = [opts.db.name, opts.connector.name].concat(opts.types)
  for (var name in opts.share) {
    modules.push(opts.share[name])
  }
  Y.sourceDir = opts.sourceDir
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      Y.requestModules(modules).then(function () {
        if (opts == null) reject('An options object is expected! ')
        else if (opts.connector == null) reject('You must specify a connector! (missing connector property)')
        else if (opts.connector.name == null) reject('You must specify connector name! (missing connector.name property)')
        else if (opts.db == null) reject('You must specify a database! (missing db property)')
        else if (opts.connector.name == null) reject('You must specify db name! (missing db.name property)')
        else if (opts.share == null) reject('You must specify a set of shared types!')
        else {
          var yconfig = new YConfig(opts)
          yconfig.db.whenUserIdSet(function () {
            yconfig.init(function () {
              resolve(yconfig)
            })
          })
        }
      }).catch(reject)
    }, 0)
  })
}

class YConfig {
  /* ::
  db: Y.AbstractDatabase;
  connector: Y.AbstractConnector;
  share: {[key: string]: any};
  options: Object;
  */
  constructor (opts, callback) {
    this.options = opts
    this.db = new Y[opts.db.name](this, opts.db)
    this.connector = new Y[opts.connector.name](this, opts.connector)
  }
  init (callback) {
    var opts = this.options
    var share = {}
    this.share = share
    this.db.requestTransaction(function * requestTransaction () {
      // create shared object
      for (var propertyname in opts.share) {
        var typeConstructor = opts.share[propertyname].split('(')
        var typeName = typeConstructor.splice(0, 1)
        var args = []
        if (typeConstructor.length === 1) {
          try {
            args = JSON.parse('[' + typeConstructor[0].split(')')[0] + ']')
          } catch (e) {
            throw new Error('Was not able to parse type definition! (share.' + propertyname + ')')
          }
        }
        var type = Y[typeName]
        var typedef = type.typeDefinition
        var id = ['_', typedef.struct + '_' + typeName + '_' + propertyname + '_' + typeConstructor]
        share[propertyname] = yield* this.createType(type.apply(typedef, args), id)
      }
      this.store.whenTransactionsFinished()
        .then(callback)
    })
  }
  isConnected () {
    return this.connector.isSynced
  }
  disconnect () {
    return this.connector.disconnect()
  }
  reconnect () {
    return this.connector.reconnect()
  }
  destroy () {
    if (this.connector.destroy != null) {
      this.connector.destroy()
    } else {
      this.connector.disconnect()
    }
    var self = this
    this.db.requestTransaction(function * () {
      yield* self.db.destroy()
      self.connector = null
      self.db = null
    })
  }
}

if (typeof window !== 'undefined') {
  window.Y = Y
}

},{"./Connector.js":189,"./Connectors/Test.js":190,"./Database.js":191,"./Struct.js":192,"./Transaction.js":193,"./Utils.js":194}],196:[function(require,module,exports){
/**
 * Given a number, return a zero-filled string.
 * From http://stackoverflow.com/questions/1267283/
 * @param  {number} width
 * @param  {number} number
 * @return {string}
 */
module.exports = function zeroFill (width, number, pad) {
  if (number === undefined) {
    return function (number, pad) {
      return zeroFill(width, number, pad)
    }
  }
  if (pad === undefined) pad = '0'
  width -= number.toString().length
  if (width > 0) return new Array(width + (/\./.test(number) ? 2 : 1)).join(pad) + number
  return number + ''
}

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJPYWtTdHJlYW1pbmcvaW5kZXguanMiLCJleGFtcGxlX2FwcGxpY2F0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FkZHItdG8taXAtcG9ydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtcHJvdG9jb2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0dG9ycmVudC10cmFja2VyL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR0b3JyZW50LXRyYWNrZXIvbGliL2NsaWVudC90cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtdHJhY2tlci9saWIvY2xpZW50L3dlYnNvY2tldC10cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtdHJhY2tlci9saWIvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2Jsb2ItdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmxvY2stc3RyZWFtMi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLXNoaW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWlsdGluLXN0YXR1cy1jb2Rlcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NodW5rLXN0b3JlLXN0cmVhbS93cml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jbG9zZXN0LXRvL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBhY3Qyc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtdG9ycmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtdG9ycmVudC9ub2RlX21vZHVsZXMvYmVuY29kZS9iZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS10b3JyZW50L25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLXRvcnJlbnQvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2RpY3QuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLXRvcnJlbnQvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL2RlZmluZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5kLW9mLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2ZpbGVzdHJlYW0vcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9mbGF0dGVuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC1icm93c2VyLXJ0Yy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtYmluYXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1jb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9odHRwcy1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW1tZWRpYXRlLWNodW5rLXN0b3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGFkZHIuanMvbGliL2lwYWRkci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hc2NpaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZmlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy10eXBlZGFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbjMvbGliL2pzb24zLmpzIiwibm9kZV9tb2R1bGVzL2p1bmsvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFnbmV0LXVyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXJjZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZW1vcnktY2h1bmstc3RvcmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXA0LWJveC1lbmNvZGluZy9ib3hlcy5qcyIsIm5vZGVfbW9kdWxlcy9tcDQtYm94LWVuY29kaW5nL2Rlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvbXA0LWJveC1lbmNvZGluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tcDQtc3RyZWFtL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9tcDQtc3RyZWFtL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9tcDQtc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL211bHRpc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25leHQtZXZlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb25jZS9vbmNlLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLXRvcnJlbnQtZmlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS10b3JyZW50LWZpbGUvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS10b3JyZW50LWZpbGUvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS10b3JyZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlanNvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhcnNldXJpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waWVjZS1sZW5ndGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3B1bXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYW5kb20taXRlcmF0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYW5nZS1zbGljZS1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZW5kZXItbWVkaWEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVuZGVyLW1lZGlhL2xpYi9taW1lLmpzb24iLCJub2RlX21vZHVsZXMvcnVuLXBhcmFsbGVsLWxpbWl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3J1bi1wYXJhbGxlbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ydXNoYS9ydXNoYS5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1jb25jYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLWdldC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc2hhMS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS13ZWJzb2NrZXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvc3BlZWRvbWV0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL2NhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3Jlc3BvbnNlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS10by1ibG9iLXVybC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0td2l0aC1rbm93bi1sZW5ndGgtdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZzJjb21wYWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RoaXJ0eS10d28vbGliL3RoaXJ0eS10d28vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhpcnR5LXR3by9saWIvdGhpcnR5LXR3by90aGlydHktdHdvLmpzIiwibm9kZV9tb2R1bGVzL3RvLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLWFycmF5YnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvcnJlbnQtZGlzY292ZXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvcnJlbnQtcGllY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHlwZWRhcnJheS10by1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdWludDY0YmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5pcS91bmlxLmpzIiwibm9kZV9tb2R1bGVzL3Vub3JkZXJlZC1hcnJheS1yZW1vdmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dF9tZXRhZGF0YS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dF9wZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXRfcGV4L25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvdXRfcGV4L25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlkZW9zdHJlYW0vbXA0LXJlbXV4ZXIuanMiLCJub2RlX21vZHVsZXMvdmlkZW9zdHJlYW0vdmlkZW9zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2xpYi9maWxlLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2xpYi9maWxlLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvbGliL3BlZXIuanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvcmFyaXR5LW1hcC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2xpYi90b3JyZW50LmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvbGliL3dlYmNvbm4uanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvd3JhcHB5L3dyYXBweS5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJub2RlX21vZHVsZXMveHRlbmQvbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy95LWFycmF5L3NyYy9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy95LW1hcC9zcmMvTWFwLmpzIiwibm9kZV9tb2R1bGVzL3ktbWVtb3J5L3NyYy9NZW1vcnkuanMiLCJub2RlX21vZHVsZXMveS1tZW1vcnkvc3JjL1JlZEJsYWNrVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy95LXdlYnNvY2tldHMtY2xpZW50L3NyYy9XZWJzb2NrZXRzLWNsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy95ZWFzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy95anMvc3JjL0Nvbm5lY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy95anMvc3JjL0Nvbm5lY3RvcnMvVGVzdC5qcyIsIm5vZGVfbW9kdWxlcy95anMvc3JjL0RhdGFiYXNlLmpzIiwibm9kZV9tb2R1bGVzL3lqcy9zcmMvU3RydWN0LmpzIiwibm9kZV9tb2R1bGVzL3lqcy9zcmMvVHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMveWpzL3NyYy9VdGlscy5qcyIsIm5vZGVfbW9kdWxlcy95anMvc3JjL3kuanMiLCJub2RlX21vZHVsZXMvemVyby1maWxsL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcjBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNydUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25EQTs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9xREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Q0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2o2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsSUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzUzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVaQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdmxEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsSkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3prQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbnZhciBNdWx0aVN0cmVhbSA9IHJlcXVpcmUoJ211bHRpc3RyZWFtJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG4vL3ZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3N0cmVhbScpLlJlYWRhYmxlO1xyXG52YXIgcmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcclxudmFyIFZpZGVvc3RyZWFtID0gcmVxdWlyZSgndmlkZW9zdHJlYW0nKTtcclxudmFyIFdlYlRvcnJlbnQgPSByZXF1aXJlKCd3ZWJ0b3JyZW50Jyk7XHJcbnZhciBTaW1wbGVQZWVyID0gcmVxdWlyZSgnc2ltcGxlLXBlZXInKTtcclxudmFyIHV0X3BleCA9IHJlcXVpcmUoJ3V0X3BleCcpO1xyXG52YXIgcGFyc2VUb3JyZW50ID0gcmVxdWlyZSgncGFyc2UtdG9ycmVudCcpO1xyXG5cclxuXHJcbiAvKipcclxuICogQG1vZHVsZSBPYWtTdHJlYW1pbmdcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gT2FrU3RyZWFtaW5nO1xyXG5cclxuXHJcbiAvKipcclxuICogQ3JlYXRlcyBhIG5ldyBPYWtTdHJlYW1pbmcgaW5zdGFuY2Ugd2hpY2ggaGFzIHRoZSBtZXRob2RzIHN0cmVhbVZpZGVvLCBsb2FkVmlkZW8sIGFkZFBlZXIgYW5kIG9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovIFxyXG5mdW5jdGlvbiBPYWtTdHJlYW1pbmcoT2FrTmFtZSl7XHJcbiAgIHRoaXMucGVlcklkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMTAsMzAwKSArIDEpO1xyXG4gICB0aGlzLnNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXIgPSAwO1xyXG4gICB0aGlzLmNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGEgPSBbXTtcclxuICAgdGhpcy50aGVUb3JyZW50ID0gbnVsbDtcclxuICAgdGhpcy5wZWVyc1RvQWRkID0gW107XHJcbiAgIHRoaXMubm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcyA9IDA7XHJcbiAgIFxyXG4gICBjb25zb2xlLmxvZyhcIkluIE9ha1N0cmVhbWluZyBjb25zdHJ1Y3Rvci4gdGhpcy5uYW1lOiBcIiArIE9ha05hbWUpO1xyXG4gICB0aGlzLk9ha05hbWUgPSBPYWtOYW1lO1xyXG4gICAgIFxyXG4gICBcclxuICAgdGhpcy5zdHJlYW1WaWRlbyA9IHN0cmVhbVZpZGVvO1xyXG4gICB0aGlzLmxvYWRWaWRlbyA9IGxvYWRWaWRlbztcclxuICAgdGhpcy5hZGRTaW1wbGVQZWVySW5zdGFuY2UgPSBhZGRTaW1wbGVQZWVySW5zdGFuY2U7XHJcbiAgIHRoaXMub24gPSBmdW5jdGlvbigpe307XHJcbiAgIHRoaXMuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyID0gbnVsbDtcclxuICAgXHJcbiAgIC8qXHJcbiAgIHRoaXMuc3RyZWFtVmlkZW8gPSBmdW5jdGlvbihhLGIsYyxkLGUpe3N0cmVhbVZpZGVvLmNhbGwoc2VsZiwgYSwgYiwgYywgZCwgZSl9O1xyXG4gICB0aGlzLmxvYWRWaWRlbyA9IGZ1bmN0aW9uKGEsYixjKXtsb2FkVmlkZW8uY2FsbChzZWxmLCBhLCBiLCBjKX07XHJcbiAgIHRoaXMuYWRkU2ltcGxlUGVlckluc3RhbmNlID0gZnVuY3Rpb24oYSxiLGMpe2FkZFNpbXBsZVBlZXJJbnN0YW5jZS5jYWxsKHNlbGYsIGEsIGIsIGMpfTtcclxuICAgdGhpcy5vbiA9IGZ1bmN0aW9uKCl7fTtcclxuICAgdGhpcy5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgPSBmdW5jdGlvbigpe307XHJcbiAgICovXHJcbiAgIFxyXG4gICB0aGlzLmNyZWF0ZVNpZ25hbGluZ0RhdGEgPSBmdW5jdGlvbiAoY2FsbGJhY2spe1xyXG4gICAgICB2YXIgYWxyZWFkeUNhbGxlZENhbGxiYWNrID0gZmFsc2U7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiQXJjaGVtYWdlXCIpO1xyXG4gICAgICB2YXIgb2FrTnVtYmVyID0gdGhpcy5zaW1wbGVQZWVyQ3JlYXRpb25Db3VudGVyO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGEgb2FrTnVtYmVyOiBcIiArIG9ha051bWJlcik7XHJcbiAgICAgIHRoaXMuY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtvYWtOdW1iZXJdID0gbmV3IFNpbXBsZVBlZXIoe2luaXRpYXRvcjogdHJ1ZSwgdGlja2xlOiBmYWxzZX0pO1xyXG4gICAgICB0aGlzLnNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXIrKztcclxuICAgICAgXHJcbiAgICAgIHRoaXMuY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtvYWtOdW1iZXJdLm9uKCdzaWduYWwnLCBmdW5jdGlvbiAoc2lnbmFsaW5nRGF0YSl7XHJcbiAgICAgICAgIGlmKCFhbHJlYWR5Q2FsbGVkQ2FsbGJhY2spe1xyXG4gICAgICAgICAgICBhbHJlYWR5Q2FsbGVkQ2FsbGJhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICBzaWduYWxpbmdEYXRhLm9ha051bWJlciA9IG9ha051bWJlcjtcclxuICAgICAgICAgICAgY2FsbGJhY2soc2lnbmFsaW5nRGF0YSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgIH07XHJcbiAgIFxyXG4gICB0aGlzLmNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZSA9IGZ1bmN0aW9uIChzaWduYWxpbmdEYXRhLCBjYWxsYmFjayl7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiUGFsYVwiKTtcclxuICAgICAgdmFyIG9ha051bWJlciA9IHNpZ25hbGluZ0RhdGEub2FrTnVtYmVyO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZSB6dSBCZWdpbm4gb2FrTnVtYmVyOiBcIiArIG9ha051bWJlcik7XHJcbiAgICAgIGRlbGV0ZSBzaWduYWxpbmdEYXRhLm9ha051bWJlcjtcclxuICAgICAgXHJcbiAgICAgIHZhciBteVBlZXIgPSBuZXcgU2ltcGxlUGVlcih7aW5pdGlhdG9yOiBmYWxzZSwgdGlja2xlOiBmYWxzZX0pO1xyXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLnNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXI7XHJcbiAgICAgIHRoaXMuY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtpbmRleF0gPSBteVBlZXI7XHJcbiAgICAgIHRoaXMuc2ltcGxlUGVlckNyZWF0aW9uQ291bnRlcisrO1xyXG4gICAgICBcclxuICAgICAgbXlQZWVyLm9uKCdzaWduYWwnLCBmdW5jdGlvbiAoYW5zd2VyU2lnbmFsaW5nRGF0YSl7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gY3JlYXRlU2lnbmFsaW5nRGF0YVJlc3BvbnNlIG5hY2ggb25TaWduYWwgb2FrTnVtYmVyOiBcIiArIG9ha051bWJlcik7XHJcbiAgICAgICAgIGFuc3dlclNpZ25hbGluZ0RhdGEub2FrTnVtYmVyID0gb2FrTnVtYmVyO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZSAgb2JqZWN0IHRoYXQgaXMgcmV0dXJuZWQgd2l0aCBjYWxsYmFjazogXCIgKyBKU09OLnN0cmluZ2lmeShhbnN3ZXJTaWduYWxpbmdEYXRhKSk7XHJcbiAgICAgICAgIGNhbGxiYWNrKGFuc3dlclNpZ25hbGluZ0RhdGEpO1xyXG4gICAgICB9KTtcclxuICAgICAgbXlQZWVyLnNpZ25hbChzaWduYWxpbmdEYXRhKTtcclxuICAgICAgXHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgbXlQZWVyLm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKXtcclxuICAgICAgICAgc2VsZi5hZGRTaW1wbGVQZWVySW5zdGFuY2Uoc2VsZi5jb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW2luZGV4XSwge30sIGZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJhZGRTaW1wbGVQZWVySW5zdGFuY2UgZW5kZWRcIik7fSk7XHJcbiAgICAgIH0pO1xyXG4gICB9O1xyXG4gICBcclxuICAgdGhpcy5wcm9jZXNzU2lnbmFsaW5nUmVzcG9uc2UgPSBmdW5jdGlvbiAoc2lnbmFsaW5nRGF0YSwgY2FsbGJhY2spe1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkluIHByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSAgc2lnbmFsaW5nRGF0YSBwYXJhbXRlcjogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWxpbmdEYXRhKSk7XHJcbiAgICAgIHZhciBvYWtOdW1iZXIgPSBzaWduYWxpbmdEYXRhLm9ha051bWJlcjtcclxuICAgICAgZGVsZXRlIHNpZ25hbGluZ0RhdGEub2FrTnVtYmVyO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkluIHByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSAgb2FrTnVtYmVyOiBcIiArIG9ha051bWJlcik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwidGhpcy5jb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhOiBcIiArIHRoaXMuY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YSk7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgKHRoaXMuY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtvYWtOdW1iZXJdKS5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpe1xyXG4gICAgICAgICBjb25zb2xlLmxvZygnQ09OTkVDVCcpO1xyXG4gICAgICAgICBzZWxmLmFkZFNpbXBsZVBlZXJJbnN0YW5jZShzZWxmLmNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbb2FrTnVtYmVyXSk7XHJcbiAgICAgICAgIHNlbGYuY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtvYWtOdW1iZXJdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICB9KTtcclxuICAgICAgY29uc29sZS5sb2coXCJJbiBwcm9jZXNzU2lnbmFsaW5nUmVzcG9uc2UgIG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byAuc2lnbmFsKCk6IFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmFsaW5nRGF0YSkpO1xyXG4gICAgICB0aGlzLmNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbb2FrTnVtYmVyXS5zaWduYWwoc2lnbmFsaW5nRGF0YSk7XHJcbiAgIH07XHJcbn1cclxuXHJcbiBcclxuIC8qKlxyXG4gKiBAdHlwZWRlZiBTdHJlYW1JbmZvcm1hdGlvbk9iamVjdFxyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWFnbmV0VVJJIC0gTWFnbmV0IFVSSSBvZiB0aGUgdG9ycmVudC4gSWYgdGhpcyBwcm9wZXJ0eSBpcyB1bmRlZmluZWQsIG5vIHZpZGVvIGRhdGEgd2lsbCBiZSByZXF1ZXN0ZWQgZnJvbSB0aGUgV2ViVG9ycmVudCBuZXR3b3JrLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmlkZW9GaWxlU2l6ZSAtIFRoZSBzaXplIGluIGJ5dGUgb2YgdGhlIHZpZGVvIGZpbGUgdGhhdCB3YXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gWEhSUGF0aCAtIFRoZSBmaWxlIHBhdGggKGUuZy4gL2V4YW1wbGUubXA0IG9yIC92aWRlb3MvZXhhbXBsZTIubXA0KSB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIFhNTCBIVFRQIFJlcXVlc3RzIHRvIHRoZSBXZWIgc2VydmVyLiBWaWEgdGhlc2UgWE1MIEhUVFAgUmVxdWVzdHMsIHZpZGVvIGRhdGEgd2lsbCBiZSByZXF1ZXN0ZWQgZnJvbSB0aGUgV2ViIHNldmVyLiBJZiB0aGlzIHByb3BlcnR5IGlzIHVuZGVmaW5lZCwgbm8gdmlkZW8gZGF0YSB3aWxsIGJlIHJlcXVlc3RlZCBmcm9tIHRoZSBXZWIgc2VydmVyLlxyXG4gKi9cclxuIFxyXG4vKipcclxuICogQGNhbGxiYWNrIE9ha1N0cmVhbWluZ35zdHJlYW1WaWRlb0ZpbmlzaGVkXHJcbiAqIEBwYXJhbSB7U3RyZWFtSW5mb3JtYXRpb25PYmplY3R9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0IC0gQW4gb2JqZWN0IHRoYXQgb3RoZXIgY2xpZW50cy9wZWVycyBjYW4gcGFzcyBhcyBhbiBhcmd1bWVudCB0byB0aGVpciBsb2FkVmlkZW8gbWV0aG9kIHRvIGRvd25sb2FkIHRoZSB2aWRlbyBmcm9tIG90aGVyIGNsaWVudHMvcGVlcnMgYW5kL29yIHRoZSBXZWIgU2VydmVyLlxyXG4gKi8gXHJcblxyXG4vKipcclxuICogU3RyZWFtcyBhIHZpZGVvIGZpbGUgdG8gYWxsIG90aGVyIGNsaWVudHMvcGVlcnMuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB2aWRlb0ZpbGUgLSBUaGUgdmlkZW8gZmlsZSB0aGF0IHNob3VsZCBiZSBzdHJlYW1lZCB0byB0aGUgb3RoZXIgY2xpZW50cy9wZWVycy4gVGhpcyBwYXJhbXRlciBjYW4gZWl0aGVyIGJlIGEge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlfFczQyBGaWxlIG9iamVjdH0sIGEge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlTGlzdHxXM0MgRmlsZUxpc3R9LCBhIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sfE5vZGUgQnVmZmVyIG9iamVjdH0gb3IgYSB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fY2xhc3Nfc3RyZWFtX3JlYWRhYmxlfFJlYWRhYmxlIHN0cmVhbSBvYmplY3R9LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIGNyZWF0aW9uIG9mIHRoZSBTdHJlYW1JbmZvcm1hdGlvbk9iamVjdCwgdGhhdCBnZXRzIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLlhIUlBhdGggLSBUaGUgcGF0aCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIFhNTCBIVFRQIFJlcXVlc3QgKFhIUikuIElmIHRoZSBvcHRpb24gb2JqZWN0IG9yIHRoaXMgcHJvcGVydHkgb2YgdGhlIG9wdGlvbiBvYmplY3QgaXMgdW5kZWZpbmVkLCBubyB2aWRlbyBkYXRhIHdpbGwgYmUgcmVxdWVzdGVkIGZyb20gdGhlIHNlcnZlci5cclxuICogQHBhcmFtIHtPYWtTdHJlYW1pbmd+c3RyZWFtVmlkZW9GaW5pc2hlZH0gY2FsbGJhY2sgLSBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGdldHMgY2FsbGVkIHdpdGggdGhlIGdlbmVyYXRlZCBTdHJlYW1JbmZvcm1hdGlvbk9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBleGVjdXRpb24gb2Ygc3RyZWFtVmlkZW8uXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJlYW1WaWRlbyh2aWRlb0ZpbGUsIG9wdGlvbnMsIGNhbGxiYWNrLCByZXR1cm5Ub3JyZW50LCBkZXN0cm95VG9ycmVudCl7IFxyXG4gICB2YXIgd2ViVG9ycmVudENsaWVudCA9IG5ldyBXZWJUb3JyZW50KCk7XHJcbiAgIC8vLy9jb25zb2xlLmxvZyhcInN0cmVhbVZpZGVvIGlzIGV4ZWN1dGVkXCIpO1xyXG4gICAvLy8vY29uc29sZS5sb2coXCJ2aWRlb0ZpbGU6IFwiICsgdmlkZW9GaWxlKTtcclxuICAgLy8vL2NvbnNvbGUubG9nKFwib3B0aW9uczogXCIgKyBvcHRpb25zKTtcclxuICAgLy8vL2NvbnNvbGUubG9nKFwiY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xyXG4gICB2YXIgc2VsZiA9IHRoaXM7IFxyXG4gICBcclxuICAgXHJcbiAgIHZhciBzZWVkaW5nT3B0aW9uID0ge307XHJcbiAgIGlmKG9wdGlvbnMud2ViVG9ycmVudFRyYWNrZXJzKXtcclxuICAgICAgc2VlZGluZ09wdGlvbi5hbm5vdW5jZUxpc3QgPSBvcHRpb25zLndlYlRvcnJlbnRUcmFja2VycztcclxuICAgfVxyXG4gICBcclxuICAgd2ViVG9ycmVudENsaWVudC5zZWVkKHZpZGVvRmlsZSwgc2VlZGluZ09wdGlvbiwgZnVuY3Rpb24odG9ycmVudCl7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwidG9ycmVudCBmaWxlIGlzIHNlZWRlZFwiKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiSW4gbG9hZFZpZGVvICAgIFwiICsgc2VsZi5PYWtOYW1lICsgXCIuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyIGdldHMgY3JlYXRlZFwiKTtcclxuICAgICAgc2VsZi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gbG9hZFZpZGVvICAgIFwiICsgc2VsZi5PYWtOYW1lICsgXCIuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyIGdldHMgZXhlY3V0ZWRcIik7XHJcbiAgICAgICAgIGlmKHNlbGYubm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcyA8PSAwKXtcclxuICAgICAgICAgICAgc2VsZi5ub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzLS07XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja0NhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdG9ycmVudC5vbignd2lyZScsIGZ1bmN0aW9uKHdpcmUpe1xyXG4gICAgICAgICAgICAgICBpZighY2FsbGJhY2tDYWxsZWQpe1xyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFja0NhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYubm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcy0tOyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICB0b3JyZW50Lm9uKCd3aXJlJywgZnVuY3Rpb24gKHdpcmUpe1xyXG4gICAgICAgICBzZWxmLm5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMrKzsgIFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIFxyXG4gICAgICAvLy8vY29uc29sZS5sb2coXCJWaWRlbyBmaWxlIHdhcyBzZWVkZWRcIik7XHJcbiAgICAgIHZhciBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCA9IHt9O1xyXG4gICAgICAvL3N0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRvcnJlbnQgPSB0b3JyZW50O1xyXG4gICAgICBpZihvcHRpb25zLndlYlRvcnJlbnRUcmFja2Vycyl7XHJcbiAgICAgICAgIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0Lm1hZ25ldFVSSSA9IHRvcnJlbnQubWFnbmV0VVJJO1xyXG4gICAgICAgICAvLyBTaW5kIGRhbm4gamEgc2Nob24gaW0gdG9ycmVudCBmaWxlIGRyaW4gICAgICBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC53ZWJUb3JyZW50VHJhY2tlcnMgPSBvcHRpb25zLndlYlRvcnJlbnRUcmFja2VycztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuYnVmZmVyU2l6ZSA9IG9wdGlvbnMuYnVmZmVyU2l6ZTtcclxuICAgICAgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudmlkZW9GaWxlU2l6ZSA9IHRvcnJlbnQuZmlsZXNbMF0ubGVuZ3RoO1xyXG4gICAgICBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5YSFJQYXRoID0gb3B0aW9ucy5YSFJQYXRoO1xyXG4gICAgICBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZSA9IHRvcnJlbnQudG9ycmVudEZpbGU7XHJcbiAgICAgIFxyXG4gICAgICBcclxuICAgICAgLy8vLy8vY29uc29sZS5sb2coXCJDcmVhZGVkIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0OlxcblwiICsgSlNPTi5zdHJpbmdpZnkoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QpKTtcclxuICAgICAgaWYocmV0dXJuVG9ycmVudCA9PT0gXCJJdCdzIGEgdGVzdFwiKXtcclxuICAgICAgICAgaWYoZGVzdHJveVRvcnJlbnQpe1xyXG4gICAgICAgICAgICBzZWxmLm5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMgPSAwO1xyXG4gICAgICAgICAgICB0b3JyZW50LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgZGVsZXRlIHdlYlRvcnJlbnRDbGllbnQ7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe2NhbGxiYWNrKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LCB0b3JyZW50KTt9LDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Y2FsbGJhY2soc3RyZWFtSW5mb3JtYXRpb25PYmplY3QpO30sMCk7XHJcbiAgICAgIH1cclxuICAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIE9ha1N0cmVhbWluZ35sb2FkZWRWaWRlb0ZpbmlzaGVkXHJcbiAqLyBcclxuIFxyXG4vKipcclxuICogU3RyZWFtcyBhIHZpZGVvIGZpbGUgdG8gYWxsIG90aGVyIGNsaWVudHMvcGVlcnMuXHJcbiAqIEBwYXJhbSB7U3RyZWFtSW5mb3JtYXRpb25PYmplY3R9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0IC0gVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIGRhdGEgdGhhdCBpcyBuZWVkZWQgdG8gaW5pdGlhdGUgbG9hZGluZyB0aGUgdmlkZW8gZnJvbSBvdGhlciBwZWVycyBhbmQvb3IgYSBXZWIgc2VydmVyLiBTdHJlYW1JbmZvcm1hdGlvbk9iamVjdHMgY2FuIGJlIGNyZWF0ZWQgYnkgdGhlIHtAbGluayBzdHJlYW1WaWRlb3xzdHJlYW1WaWRlb30gbWV0aG9kLlxyXG4gKiBAcGFyYW0ge09ha1N0cmVhbWluZ35sb2FkZWRWaWRlb0ZpbmlzaGVkfSBjYWxsYmFjayAtIFRoaXMgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGJlZW4gbG9hZGVkIGVudGlyZWx5IGludG8gdGhlIGJ1ZmZlciBvZiB0aGUgdmlkZW8gcGxheWVyLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9hZFZpZGVvKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LCBjYWxsYmFjaywgZW5kSWZWaWRlb0xvYWRlZCl7XHJcbiAgIGNvbnNvbGUubG9nKFwiTGljaFwiKTtcclxuICAgXHJcbiAgIC8vLy8vL2NvbnNvbGUubG9nKFwiSSBlbnRlcmVkIHRoaXMubG9hZFZpZGVvXCIpO1xyXG4gICAvLy8vLy9jb25zb2xlLmxvZyhcIm9wdGlvbiBwYXJhbXRlcjpcXG5cIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0KSk7XHJcbiAgIHZhciBkZWxpdmVyeUJ5U2VydmVyID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuWEhSUGF0aCA/IHRydWUgOiBmYWxzZTtcclxuICAgdmFyIGRlbGl2ZXJ5QnlXZWJ0b3JyZW50ID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudG9ycmVudEZpbGUgPyB0cnVlIDogZmFsc2U7XHJcbiAgIHZhciB3ZWJUb3JyZW50VHJhY2tlcnMgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC53ZWJUb3JyZW50VHJhY2tlcnM7XHJcbiAgIC8vdmFyIGRlbGl2ZXJ5QnlXZWJ0b3JyZW50ID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QubWFnbmV0VVJJID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICB2YXIgTUFHTkVUX1VSSSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0Lm1hZ25ldFVSSTtcclxuICAgLy9jb25zb2xlLmxvZyhcInN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LlhIUlBhdGg6IFwiICsgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuWEhSUGF0aCk7XHJcbiAgIHZhciBQQVRIX1RPX1ZJREVPX0ZJTEUgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5YSFJQYXRoO1xyXG4gICB2YXIgU0laRV9PRl9WSURFT19GSUxFID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudmlkZW9GaWxlU2l6ZTtcclxuICAgdmFyIFRIRV9SRUNFSVZFRF9UT1JSRU5UX0ZJTEUgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZTtcclxuICAgXHJcbiAgIHZhciBWSURFT19CVUZGRVJfU0laRSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnZpZGVvQnVmZmVyU2l6ZSB8fCA1MDAwMDAwMDsgLy8gVGhpcyBpcyB0aGUgbWlub211bSBieXRlIHJhbmdlIHRoYXQgdGhlIFdlYlRvcnJlbnQgY2xpZW50IHdpbGwgZG93bmxvYWQgaW4gYWR2YW5jZSAocmVnYXJkaW5nIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uKSB3aXRoIGEgc2VxdWVudGlhbCBjaHVuayBzZWxlY3Rpb24gc3RyYXRlZ3kuIFRoaXMgbWVhbnMgdGhlIHZpZGVvIGJ1ZmZlciBzaXplIGluIGJ5dGVcclxuICAgdmFyIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmNyZWF0ZVJlYWRzdHJlYW1SZXF1ZXN0U2l6ZSB8fCA1MDAwMDAwMDsgLy8gVGhlIHNpemUgb2YgdGhlIGNyZWF0ZVJlYWRzdHJlYW0gV2ViVG9ycmVudCByZXF1ZXN0cyBpbiBieXRlcy4gXHJcbiAgIFxyXG4gICB2YXIgRE9XTkxPQURfRlJPTV9TRVJWRVJfVElNRV9SQU5HRSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmRvd25sb2FkRnJvbVNlcnZlclRpbWVSYW5nZSB8fCA1OyAvLyBpbiBzZWNvbmRzXHJcbiAgIHZhciBVUExPQURfTElNSVQgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC51cGxvYWRMaW1pdCB8fCAyOyAvLyBtdWx0aXBsaWVkIGJ5IG51bWJlciBvZiBkb3dubG9hZGVkIGJ5dGVzXHJcbiAgIHZhciBBRERJVElPTl9UT19VUExPQURfTElNSVQgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5hZGRpdGlvblRvVXBsb2FkTGltaXQgfHwgNTAwMDAwOyAvLyBhbW91bnQgb2YgYnl0ZSBhZGRlZCB0byB1cGxvYWQgbGltaXRcclxuICAgdmFyIFhIUl9SRVFVRVNUX1NJWkUgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC54aHJSZXF1ZXN0U2l6ZSB8fCA1MDAwMDsgLy8gaW4gYnl0ZVxyXG4gICB2YXIgVEhSRVNIT0xEX0ZPUl9SRVRVUk5JTkdfT0ZfQU5TV0VSX1NUUkVBTSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRocmVzaG9sZEZvclJldHVybmluZ0Fuc3dlclN0cmVhbSB8fCA1MDAwMDsgLy8gaW4gYnl0ZVxyXG5cclxuICAgdmFyIENIRUNLX0lGX0JVRkZFUl9GVUxMX0VOT1VHSF9JTlRFUlZBTCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoSW50ZXJ2YWwgfHwgMzAwOyAvLyBpbiBtaWxpc2Vjb25kc1xyXG4gICB2YXIgQ0hFQ0tfSUZfQU5TV0VSU1RSRUFNX1JFQURZX0lOVEVSVkFMID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuY2hlY2tJZkFuc3dlcnN0cmVhbVJlYWR5SW50ZXJ2YWwgfHwgMjAwOyAvLyBpbiBtaWxpc2Vjb25kc1xyXG4gICB2YXIgVVBEQVRFX0NIQVJUX0lOVEVSVkFMID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudXBkYXRlQ2hhcnRJbnRlcnZhbCB8fCAxMDAwOyAvLyBpbiBtaWxpc2Vjb25kc1xyXG4gICB2YXIgQ0hPS0VfSUZfTkVDRVNTQVJZX0lOVEVSVkFMID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuY2hva2VJZk5lY2Vzc2FyeUludGVydmFsIHx8IDUwMDsgLy8gaW4gbWlsaXNlY29uZHNcclxuICAgdmFyIENIRUNLX0lGX05FV19DUkVBVEVfUkVBRFNUUkVBTV9ORUNFU1NBUllfSU5URVJWQUwgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5jaGVja0lmTmV3Q3JlYXRlUmVhZHN0cmVhbUludGVydmFsIHx8IDUwMCA7XHJcbiAgIFxyXG4gICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgIHZhciBlbmRTdHJlYW1pbmcgPSBmYWxzZTtcclxuICAgdmFyIHdlYlRvcnJlbnRDbGllbnQgPSBudWxsO1xyXG4gICB2YXIgd2lyZXMgPSBbXTtcclxuICAgdmFyIGNvbnNvbGVDb3VudGVyID0gMDtcclxuICAgdmFyIGdsb2JhbHZpZGVvc3RyZWFtUmVxdWVzdE51bWJlciA9IDA7XHJcbiAgIHZhciBieXRlc1JlY2VpdmVkRnJvbVNlcnZlciA9IDA7XHJcbiAgIHZhciB3ZWJUb3JyZW50RmlsZTtcclxuICAgdmFyIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzID0gW107XHJcbiAgIHZhciBpbkNyaXRpY2FsID0gdHJ1ZTtcclxuICAgdmFyIHZpZGVvQ29tcGxldGVseUxvYWRlZCA9IGZhbHNlO1xyXG4gICB2YXIgYnl0ZXNUYWtlbkZyb21XZWJUb3JyZW50ID0gMDtcclxuICAgdmFyIGJ5dGVzVGFrZW5Gcm9tU2VydmVyID0gMDsgICBcclxuICAgXHJcbiAgIFxyXG4gICB2YXIgbXlWaWRlbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XHJcbiAgIG15VmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZXJyKXtcclxuICAgICAgY29uc29sZS5lcnJvcihteVZpZGVvLmVycm9yKTtcclxuICAgfSk7XHJcbiAgIFxyXG4gICBmdW5jdGlvbiBNeVJlYWRhYmxlU3RyZWFtKG9wdGlvbnMpe1xyXG4gICAgICByZWFkYWJsZVN0cmVhbS5SZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICB9XHJcbiAgIHV0aWwuaW5oZXJpdHMoTXlSZWFkYWJsZVN0cmVhbSwgcmVhZGFibGVTdHJlYW0uUmVhZGFibGUpO1xyXG4gICBNeVJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpe307XHJcbiAgIFxyXG4gIFxyXG4gICBpZihkZWxpdmVyeUJ5V2VidG9ycmVudCl7XHJcbiAgICAgIHdlYlRvcnJlbnRDbGllbnQgPSBuZXcgV2ViVG9ycmVudCgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgIC8vVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRSBcclxuICAgICBcclxuICAgICAgd2ViVG9ycmVudENsaWVudC5hZGQoTUFHTkVUX1VSSSwgZnVuY3Rpb24gKHRvcnJlbnQpeyAgICAgICAgICAgICAgXHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwid2ViVG9ycmVudENsaWVudC5hZGQgICB0b3JyZW50IG1ldGEgZGF0YSByZWFkeVwiKTsgICAgICAgICBcclxuICAgICAgICAgc2VsZi50aGVUb3JyZW50ID0gdG9ycmVudDtcclxuICAgICAgICAgXHJcbiAgICAgICAgIGZvcih2YXIgaj0wOyBqPCBzZWxmLnBlZXJzVG9BZGQubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICBzZWxmLnRoZVRvcnJlbnQuYWRkUGVlcihzZWxmLnBlZXJzVG9BZGRbal1bMF0pO1xyXG4gICAgICAgICAgICBpZihzZWxmLnBlZXJzVG9BZGRbal1bMV0pe1xyXG4gICAgICAgICAgICAgICAoc2VsZi5wZWVyc1RvQWRkW2pdWzFdKSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0gXHJcbiAgICAgICAgIFxyXG4gICAgICAgICB3ZWJUb3JyZW50RmlsZSA9IHRvcnJlbnQuZmlsZXNbMF07XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJJbiBsb2FkVmlkZW8gdHlwZW9mIHdlYlRvcnJlbnRGaWxlIGFmdGVyIGFzc2lnbm1lbnQ6IFwiICsgdHlwZW9mIHdlYlRvcnJlbnRGaWxlKTtcclxuXHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gbG9hZFZpZGVvICAgIFwiICsgc2VsZi5PYWtOYW1lICsgXCIuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyIGdldHMgY3JlYXRlZFwiKTtcclxuICAgICAgICAgc2VsZi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gbG9hZFZpZGVvICAgICBcIiArIHNlbGYuT2FrTmFtZSArIFwiLmZvclRlc3RpbmdfY29ubmVjdGVkVG9OZXdXZWJUb3JyZW50UGVlciAgIGdldHMgY2FsbGVkXCIpO1xyXG4gICAgICAgICAgICBpZihzZWxmLm5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMgPD0gMCl7XHJcbiAgICAgICAgICAgICAgIHNlbGYubm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcy0tO1xyXG4gICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tDYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHRvcnJlbnQub24oJ3dpcmUnLCBmdW5jdGlvbih3aXJlKXtcclxuICAgICAgICAgICAgICAgICAgaWYoIWNhbGxiYWNrQ2FsbGVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBzZWxmLm5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMtLTsgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9O1xyXG4gICAgICAgICBcclxuICAgICAgICAgdG9ycmVudC5vbignd2lyZScsIGZ1bmN0aW9uICh3aXJlKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0b3JyZW50Lm9uKCd3aXJlJywgLi4pIGlzIGZpcmVkXCIpO1xyXG4gICAgICAgICAgICB3aXJlcy5wdXNoKHdpcmUpO1xyXG4gICAgICAgICAgICBpZighd2luZG93LmZpcnN0V2lyZSl7XHJcbiAgICAgICAgICAgICAgIHdpbmRvdy5maXJzdFdpcmUgPSB3aXJlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYubm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcysrO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHdpcmUudXNlKHV0X3BleCgpKTtcclxuICAgICAgICAgICAgLy93aXJlLnV0X3BleC5zdGFydCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgd2lyZS51dF9wZXgub24oJ3BlZXInLCBmdW5jdGlvbiAocGVlcil7XHJcbiAgICAgICAgICAgICAgIHRoaXMudGhlVG9ycmVudC5hZGRQZWVyKHBlZXIpO1xyXG4gICAgICAgICAgICAgICAvLyBnb3QgYSBwZWVyXHJcbiAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IGFkZCBpdCB0byBwZWVyIGNvbm5lY3Rpb25zIHF1ZXVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgIGZvcih2YXIgaT0wLCBsZW5ndGg9dmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnMubGVuZ3RoOyBpPGxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIHRoaXNSZXF1ZXN0ID0gdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnNbaV07XHJcbiAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJJbiBvblRvcnJlbnQgbmFjaHRyw6RnbGljaCB3ZWJ0b3JyZW50IHN0cmVhbSBlcnpldWdlbiAgdGhpc1JlcXVlc3Quc3RhcnQ6IFwiICsgdGhpc1JlcXVlc3Quc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSW4gb25Ub3JyZW50ICB3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgd2ViVG9ycmVudEZpbGUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZhciBlbmRDcmVhdGVSZWFkU3RyZWFtO1xyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRSA+PSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1wic3RhcnRcIiA6IHRoaXNSZXF1ZXN0LnN0YXJ0LCBcImVuZFwiIDogZW5kQ3JlYXRlUmVhZFN0cmVhbX0pO1xyXG4gICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbignZW5kJywgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsICYmIHRoaXNSZXF1ZXN0LnN0YXJ0ID4gdGhpc1JlcXVlc3QubGFzdEVuZENyZWF0ZVJlYWRTdHJlYW0gJiYgdGhpc1JlcXVlc3Quc3RhcnQgPCB0aGlzUmVxdWVzdC52aWRlb0ZpbGVTaXplKXtcclxuICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFID49IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gdGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkU7XHJcbiAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5jcmVhdGVSZWFkU3RyZWFtKHtcInN0YXJ0XCIgOiB0aGlzUmVxdWVzdC5zdGFydCwgXCJlbmRcIiA6IGVuZENyZWF0ZVJlYWRTdHJlYW19KTtcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50ID0gdGhpc1JlcXVlc3Quc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0udW5waXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGlwZSh0aGlzUmVxdWVzdC5jb2xsZWN0b3JTdHJlYW1Gb3JXZWJ0b3JyZW50KTtcclxuICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBpcGUodGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgfVxyXG4gICBcclxuICAgXHJcbiAgIHZhciBmaWxlID0gZnVuY3Rpb24gKHBhdGgpe1xyXG4gICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICB9O1xyXG4gICBmaWxlLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24gKG9wdHMpe1xyXG4gICAgICBpZihvcHRzLnN0YXJ0ID4gU0laRV9PRl9WSURFT19GSUxFKXtcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm9wdHMuc3RhcnQgPiBTSVpFX09GX1ZJREVPX0ZJTEUgdGhlcmUgY2IobnVsbCxudWxsKSBldmVyeSB0aW1lXCIpO1xyXG4gICAgICAgICByZXR1cm4gKG5ldyBNdWx0aVN0cmVhbShmdW5jdGlvbiAoY2Ipe2NiKG51bGwsIG51bGwpO30pKTtcclxuICAgICAgfVxyXG4gICAgICBpbkNyaXRpY2FsID0gdHJ1ZTtcclxuICAgICAgLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgY2FsbGVkIGNyZWF0ZXJlYWRTdHJlYW0gXCIpO1xyXG4gICAgICAvL2NvbnNvbGUubG9nKGNvbnNvbGVDb3VudGVyKysgKyBcIiBvcHRzLnN0YXJ0OiBcIiArIG9wdHMuc3RhcnQpO1xyXG4gICAgICAvL2NvbnNvbGUubG9nKGNvbnNvbGVDb3VudGVyKysgKyBcIiBvcHRzLmVuZDogXCIgKyBvcHRzLmVuZCk7XHJcblxyXG4gICAgICB2YXIgdGhpc1JlcXVlc3QgPSBuZXcgVmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcigrK2dsb2JhbHZpZGVvc3RyZWFtUmVxdWVzdE51bWJlciwgb3B0cywgdGhpcyk7XHJcbiAgICAgXHJcbiAgICAgIGlmKG9wdHMuZW5kICYmICFpc05hTihvcHRzLmVuZCkpe1xyXG4gICAgICAgICB0aGlzUmVxdWVzdC5lbmQgPSBvcHRzLmVuZCArIDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgIHRoaXNSZXF1ZXN0LmVuZCA9IFNJWkVfT0ZfVklERU9fRklMRTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdmFyIE15V3JpdGVhYmxlU3RyZWFtID0gZnVuY3Rpb24oaGlnaFdhdGVyTWFyayl7XHJcbiAgICAgICAgIHJlYWRhYmxlU3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcywgaGlnaFdhdGVyTWFyayk7XHJcbiAgICAgIH07XHJcbiAgICAgIHV0aWwuaW5oZXJpdHMoTXlXcml0ZWFibGVTdHJlYW0sIHJlYWRhYmxlU3RyZWFtLldyaXRhYmxlKTtcclxuICAgICAgTXlXcml0ZWFibGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgZG9uZSl7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJNeVdyaXRlYWJsZVN0cmVhbSBfd3JpdGUgaXMgY2FsbGVkXCIpOyAgICAgICBcclxuICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQtdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50IDwgY2h1bmsubGVuZ3RoKXtcclxuICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcIk15V3JpdGVhYmxlU3RyZWFtIF93cml0ZTogcHVzaGluZyByZWNlaXZlZCBkYXRhIGluIGFuc3dlclN0cmVhbVwiKVxyXG4gICAgICAgICAgICBieXRlc1Rha2VuRnJvbVdlYlRvcnJlbnQgKz0gY2h1bmsubGVuZ3RoIC0gKHRoaXNSZXF1ZXN0LnN0YXJ0LXRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCk7XHJcbiAgICAgICAgICAgIHZhciBzdHJlYW1IYXNNZW1vcnlMZWZ0ID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2goY2h1bmsuc2xpY2UodGhpc1JlcXVlc3Quc3RhcnQtdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50LCBjaHVuay5sZW5ndGgpKTtcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQtdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHN0cmVhbUhhc01lbW9yeUxlZnQpeyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5jdXJyZW50Q0IgIT09IG51bGwgJiYgdGhpc1JlcXVlc3Quc3RhcnQgPj0gdGhpc1JlcXVlc3QuZW5kKXtcclxuICAgICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrRnVuY3Rpb24gPSB0aGlzUmVxdWVzdC5jdXJyZW50Q0I7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID0gMDtcclxuICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IDUwMDAwMDB9KTtcclxuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhbGxlZCBDQiB3aXRoIGRhdGEgb3V0IG9mIGFuc3dlclN0cmVhbSBmcm9tIHZpZGVvc3RyZWFtUmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2tGdW5jdGlvbihudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0pe1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qubm9Nb3JlRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFja0Z1bmN0aW9uID0gdGhpc1JlcXVlc3QuY3VycmVudENCO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwfSk7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgQ0Igd2l0aCBkYXRhIG91dCBvZiBhbnN3ZXJTdHJlYW0gZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrRnVuY3Rpb24obnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LnN0YXJ0ICs9IGNodW5rLmxlbmd0aCAtICh0aGlzUmVxdWVzdC5zdGFydC10aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIC8vY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkodGhpc1JlcXVlc3QpO1xyXG4gICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICBkb25lKCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQgPSBuZXcgTXlXcml0ZWFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IDUwMDAwMDAwfSk7XHJcbiAgICAgIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLnB1c2godGhpc1JlcXVlc3QpO1xyXG5cclxuICAgICAgaWYod2ViVG9ycmVudEZpbGUgJiYgc2VsZi50aGVUb3JyZW50LnVwbG9hZGVkIDw9IFVQTE9BRF9MSU1JVCAqIHNlbGYudGhlVG9ycmVudC5kb3dubG9hZGVkICsgQURESVRJT05fVE9fVVBMT0FEX0xJTUlUKXtcclxuICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcImFmdGVyIG5ldyB2aWRlb3N0cmVhbVJlcXVlc3QgY3JlYXRpbmcgYSBjb3JyZXNwb25kaW5nIHdlYnRvcnJlbnQgc3RyZWFtXCIpO1xyXG4gICAgICAgICAvLy8vY29uc29sZS5sb2coXCJvcHRzLnN0YXJ0OiBcIiArIG9wdHMuc3RhcnQpO1xyXG4gICAgICAgICAvLy8vY29uc29sZS5sb2coXCJ3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgd2ViVG9ycmVudEZpbGUubGVuZ3RoKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICB2YXIgZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPj0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTE7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtID0gd2ViVG9ycmVudEZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XCJzdGFydFwiIDogdGhpc1JlcXVlc3Quc3RhcnQsIFwiZW5kXCIgOiBlbmRDcmVhdGVSZWFkU3RyZWFtfSk7XHJcbiAgICAgICAgIHRoaXNSZXF1ZXN0Lmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtID0gZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50ID0gdGhpc1JlcXVlc3Quc3RhcnQ7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnVucGlwZSgpO1xyXG4gICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBpcGUodGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBtdWx0aSA9IG5ldyBNdWx0aVN0cmVhbShmdW5jdGlvbiAoY2Ipe1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVhZGFibGVTdHJlYW0gcmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyICsgXCIgICAgZG9lcyBhIGNiIHJlcXVlc3RcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmVuZCA+PSAwICYmIHRoaXNSZXF1ZXN0LnN0YXJ0ID49IHRoaXNSZXF1ZXN0LmVuZCl7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgY2IobnVsbCxudWxsKSBmcm9tIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7IFxyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5yZXEgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbnVsbCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgdGhpc1JlcXVlc3QuQ0JOdW1iZXIrKztcclxuICAgICAgICAgaWYoY29uc29sZUNvdW50ZXI8MjApe1xyXG4gICAgICAgICAgICAvLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgICAgXCIgKyB0aGlzUmVxdWVzdC5DQk51bWJlciArIFwiLiBjYWxsIG9mIGZ1bmN0aW9uKGNiKSBmcm9tIFwiICsgdmlkZW9zdHJlYW1SZXF1ZXN0TnVtYmVyKTtcclxuICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgICAgc3RhcnQ6IFwiICsgdGhpc1JlcXVlc3Quc3RhcnQpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiA9IGNiO1xyXG4gICAgICAgICB0aGlzUmVxdWVzdC5ub01vcmVEYXRhID0gZmFsc2U7XHJcbiAgICAgIFxyXG4gICAgICAgICBpZighY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkodGhpc1JlcXVlc3QpKXtcclxuICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucmVzdW1lKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZih3ZWJUb3JyZW50RmlsZSl7XHJcbiAgICAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJOZXcgY2IgZnVuY3Rpb24gd2FzIGNhbGxlZCBhbmQgSSBzdWJzZXF1ZW50bHkgY3JlYXRlIGEgbmV3IHRvcnJlbnRTdHJlYW0gZm9yIGl0IGJlY2F1c2Ugbm9uIGV4aXN0ZWQgYmVmb3JlIGZvciB0aGlzIHZpZGVvc3RyZWFtUmVxdWVzdFwiKTtcclxuICAgICAgICAgICAgICAgLy8vL2NvbnNvbGUubG9nKFwiQWZ0ZXIgbmV3IE11bHRpc3RyZWFtLiB0aGlzUmVxdWVzdC5zdGFydDogXCIgKyB0aGlzUmVxdWVzdC5zdGFydCk7XHJcbiAgICAgICAgICAgICAgIC8vLy9jb25zb2xlLmxvZyhcIndlYlRvcnJlbnRGaWxlLmxlbmd0aDogXCIgKyB3ZWJUb3JyZW50RmlsZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICB2YXIgZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPj0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTE7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtID0gd2ViVG9ycmVudEZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XCJzdGFydFwiIDogdGhpc1JlcXVlc3Quc3RhcnQsIFwiZW5kXCIgOiBlbmRDcmVhdGVSZWFkU3RyZWFtfSk7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtID0gZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50ID0gdGhpc1JlcXVlc3Quc3RhcnQ7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnVucGlwZSgpO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBpcGUodGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGRlbGl2ZXJ5QnlTZXJ2ZXIgJiYgaW5Dcml0aWNhbCAmJiAhdGhpc1JlcXVlc3QuWEhSQ29uZHVjdGVkKXtcclxuICAgICAgICAgICAgICAgY29uZHVjdFhIUih0aGlzUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgdGVybWluYXRlIGNyZWF0ZVJlYWRTdHJlYW1cIik7XHJcbiAgICAgIHZhciBkZXN0cm95ID0gbXVsdGkuZGVzdHJveTtcclxuICAgICAgbXVsdGkuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIGlmICh0aGlzUmVxdWVzdC5yZXEpIHtcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3QucmVxLmRlc3Ryb3koKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBkZXN0cm95LmNhbGwobXVsdGkpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXVsdGk7XHJcbiAgIH07XHJcbiAgXHJcbiAgIFxyXG4gICBcclxuICAgXHJcbiAgIHZhciBmcmVxdWVudGx5Q2hlY2tJZk5ld0NyZWF0ZVJlYWRTdHJlYW1OZWNlc3NhcnkgPSAoZnVuY3Rpb24gKCl7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigpe1xyXG4gICAgICAgICBpZih2aWRlb0NvbXBsZXRlbHlMb2FkZWQpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgIH1cclxuICAgICAgXHJcbiAgICAgICAgaWYobXlWaWRlby5kdXJhdGlvbil7XHJcbiAgICAgICAgICAgIHZhciB0aW1lUmFuZ2VzID0gbXlWaWRlby5idWZmZXJlZDtcclxuICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aW1lUmFuZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgaWYgKG15VmlkZW8uY3VycmVudFRpbWUgPj0gdGltZVJhbmdlcy5zdGFydChpKSAmJiBteVZpZGVvLmN1cnJlbnRUaW1lIDw9IHRpbWVSYW5nZXMuZW5kKGkpKzMpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHRpbWVSYW5nZXMuZW5kKGkpIC0gbXlWaWRlby5jdXJyZW50VGltZSA8PSBWSURFT19CVUZGRVJfU0laRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNSZXF1ZXN0ID0gdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5jdXJyZW50Q0IgIT09IG51bGwgJiYgdGhpc1JlcXVlc3Quc3RhcnQgPiB0aGlzUmVxdWVzdC5sYXN0RW5kQ3JlYXRlUmVhZFN0cmVhbSAmJiB0aGlzUmVxdWVzdC5zdGFydCA8IHRoaXNSZXF1ZXN0LnZpZGVvRmlsZVNpemUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPj0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1wic3RhcnRcIiA6IHRoaXNSZXF1ZXN0LnN0YXJ0LCBcImVuZFwiIDogZW5kQ3JlYXRlUmVhZFN0cmVhbX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgPSB0aGlzUmVxdWVzdC5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS51bnBpcGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5waXBlKHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0VGltZW91dChmcmVxdWVudGx5Q2hlY2tJZk5ld0NyZWF0ZVJlYWRTdHJlYW1OZWNlc3NhcnksIENIRUNLX0lGX05FV19DUkVBVEVfUkVBRFNUUkVBTV9ORUNFU1NBUllfSU5URVJWQUwpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0gICBcclxuICAgfSkoKTtcclxuICAgZnJlcXVlbnRseUNoZWNrSWZOZXdDcmVhdGVSZWFkU3RyZWFtTmVjZXNzYXJ5KCk7XHJcbiAgIFxyXG4gICBcclxuICAgZnVuY3Rpb24gY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkodGhpc1JlcXVlc3Qpe1xyXG4gICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiQXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtOiBcIiArIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0pO1xyXG4gICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiSW4gY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkgb2YgdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIgKyAgXCIuIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW06IFwiICsgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSArIFwiICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0I6IFwiICsgdGhpc1JlcXVlc3QuY3VycmVudENCKTtcclxuICAgICAgaWYgKHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiAmJiAoKHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPj0gVEhSRVNIT0xEX0ZPUl9SRVRVUk5JTkdfT0ZfQU5TV0VSX1NUUkVBTSkgfHwgKHRoaXNSZXF1ZXN0LnN0YXJ0ID49IFNJWkVfT0ZfVklERU9fRklMRSkpKXtcclxuICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcImFuc3dlclN0cmVhbSBmcm9tIHZpZGVvc3RyZWFtIFJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlciArIFwiIGFuZCBDQiBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5DQk51bWJlciArIFwiIGdldHMgcmV0dXJuZWRcIik7XHJcbiAgICAgICAgIC8vIC8vLy8vL2NvbnNvbGUubG9nKFwiUmV0dXJpbmcgYW5zd2VyU3RyZWFtIG91dCBvZiBjZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSgpXCIpO1xyXG4gICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRDQjtcclxuICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudENCID0gbnVsbDtcclxuICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgIGlmICh0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtKXtcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5wYXVzZSgpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPSAwO1xyXG4gICAgICAgICB2YXIgcmVzID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtO1xyXG4gICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0gPSBuZXcgTXlSZWFkYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogNTAwMDAwMH0pO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgfTtcclxuXHJcbiAgIHZhciBjaG9rZUlmTmVjZXNzYXJ5ID0gKGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKXtcclxuICAgICAgICAgaWYgKHNlbGYudGhlVG9ycmVudCAmJiBzZWxmLnRoZVRvcnJlbnQudXBsb2FkZWQgPj0gc2VsZi50aGVUb3JyZW50LmRvd25sb2FkZWQgKiBVUExPQURfTElNSVQgKyBBRERJVElPTl9UT19VUExPQURfTElNSVQpIHtcclxuICAgICAgICAgICAgLyogbWFjaGUgaWNoIHNjaG9uIGluIGVpbmVyIGFuZGVyZW4gZnJlcXVlbnQgbWV0aG9kZVxyXG4gICAgICAgICAgICBpZih2aWRlb0NvbXBsZXRlbHlMb2FkZWQpe1xyXG4gICAgICAgICAgICAgICBzZWxmLnRoZVRvcnJlbnQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICBkZWxldGUgd2ViVG9ycmVudENsaWVudDtcclxuICAgICAgICAgICAgICAgZW5kU3RyZWFtaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB3aXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJJIGNob2tlZCBhIHBlZXJcIik7XHJcbiAgICAgICAgICAgICAgIHdpcmVzW2ldLmNob2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICBzZXRUaW1lb3V0KGNob2tlSWZOZWNlc3NhcnksIENIT0tFX0lGX05FQ0VTU0FSWV9JTlRFUlZBTCk7XHJcbiAgICAgIH07XHJcbiAgIH0pKCk7XHJcblxyXG4gICB2YXIgdXBkYXRlQ2hhcnQgPSAoZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIGlmKGVuZFN0cmVhbWluZyl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBpZihzZWxmLnRoZVRvcnJlbnQgJiYgd2ViVG9ycmVudEZpbGUpe1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIldlYlRvcnJlbnQtcmVjZWl2ZWRcIikuaW5uZXJIVE1MID0gXCJ3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgd2ViVG9ycmVudEZpbGUubGVuZ3RoICsgXCJcXG4gdG9ycmVudC5kb3dubG9hZGVkOiBcIiArIHNlbGYudGhlVG9ycmVudC5kb3dubG9hZGVkICsgXCJcXG4gdG9ycmVudC51cGxvYWRlZDogXCIgKyBzZWxmLnRoZVRvcnJlbnQudXBsb2FkZWQgKyBcIlxcbiB0b3JyZW50LnByb2dyZXNzOiBcIiArIHNlbGYudGhlVG9ycmVudC5wcm9ncmVzcyArIFwiXFxuIEJ5dGVzIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIiArIGJ5dGVzUmVjZWl2ZWRGcm9tU2VydmVyICsgXCJcXG4gQnl0ZXMgdGFrZW4gZnJvbSBzZXJ2ZXIgZGVsaXZlcnk6IFwiICsgYnl0ZXNUYWtlbkZyb21TZXJ2ZXIgKyBcIlxcbiBCeXRlcyB0YWtlbiBmcm9tIFdlYlRvcnJlbnQgZGVsaXZlcnk6IFwiICsgYnl0ZXNUYWtlbkZyb21XZWJUb3JyZW50O1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHNldFRpbWVvdXQodXBkYXRlQ2hhcnQsIFVQREFURV9DSEFSVF9JTlRFUlZBTCk7XHJcbiAgICAgIH07XHJcbiAgIH0pKCk7XHJcbiAgICBcclxuICAgZnVuY3Rpb24gVmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcihyZWFkU3RyZWFtTnVtYmVyLCBvcHRzLCBzZWxmKSB7XHJcbiAgICAgIHRoaXMucmVhZFN0cmVhbU51bWJlciA9IHJlYWRTdHJlYW1OdW1iZXI7XHJcbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XHJcbiAgICAgIHRoaXMuc3RhcnQgPSBvcHRzLnN0YXJ0IHx8IDA7XHJcbiAgICAgIHRoaXMub2xkU3RhcnRXZWJUb3JyZW50ID0gLTQyO1xyXG4gICAgICB0aGlzLm9sZFN0YXJ0U2VydmVyID0gLTQyO1xyXG4gICAgICB0aGlzLmN1cnJlbnRDQiA9IG51bGw7XHJcbiAgICAgIHRoaXMuQ0JOdW1iZXIgPSAwO1xyXG4gICAgICB0aGlzLndlYlRvcnJlbnRTdHJlYW0gPSBudWxsO1xyXG4gICAgICB0aGlzLmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwfSk7XHJcbiAgICAgIHRoaXMuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgIHRoaXMuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuWEhSQ29uZHVjdGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuZW5kID0gLTQyO1xyXG4gICAgICB0aGlzLnNlbGYgPSBzZWxmO1xyXG4gICAgICB0aGlzLmJ5dGVzVGFrZW5Gcm9tV2ViVG9ycmVudCA9IDA7XHJcbiAgICAgIHRoaXMuYnl0ZXNUYWtlbkZyb21TZXJ2ZXIgPSAwO1xyXG4gICAgICB0aGlzLm5vTW9yZURhdGEgPSBmYWxzZTtcclxuICAgICAgdGhpcy5yZXEgPSBudWxsO1xyXG4gICAgICB0aGlzLmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtID0gLTQyO1xyXG4gICB9XHJcblxyXG4gICB2YXIgZnJlcXVlbnRseUNlY2tJZkFuc3dlclN0cmVhbVJlYWR5ID0gKGZ1bmN0aW9uICgpe1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgICAgICAgaWYodmlkZW9Db21wbGV0ZWx5TG9hZGVkKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSh2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyc1tpXSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgc2V0VGltZW91dChmcmVxdWVudGx5Q2Vja0lmQW5zd2VyU3RyZWFtUmVhZHksIENIRUNLX0lGX0FOU1dFUlNUUkVBTV9SRUFEWV9JTlRFUlZBTCk7XHJcbiAgICAgIH07XHJcbiAgIH0pKCk7XHJcblxyXG4gICB2YXIgY2hlY2tJZkJ1ZmZlckZ1bGxFbm91Z2ggPSAoZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJjaGVja0lmQnVmZmVyRnVsbEVub3VnaCBpcyBjYWxsZWRcIik7XHJcbiAgICAgICAgIGlmKHZpZGVvQ29tcGxldGVseUxvYWRlZCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgfVxyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwidmlkZW8uZHVyYXRpb246IFwiICsgbXlWaWRlby5kdXJhdGlvbik7XHJcbiAgICAgICAgIGlmKG15VmlkZW8uZHVyYXRpb24pe1xyXG4gICAgICAgICAgICB2YXIgdGltZVJhbmdlcyA9IG15VmlkZW8uYnVmZmVyZWQ7XHJcbiAgICAgICAgICAgIGlmKHRpbWVSYW5nZXMubGVuZ3RoID49IDEpe1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidGltZVJhbmdlcy5zdGFydCgwKTogXCIgKyB0aW1lUmFuZ2VzLnN0YXJ0KDApKTtcclxuICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInRpbWVSYW5nZXMuZW5kKDApOiBcIiArIHRpbWVSYW5nZXMuZW5kKDApKTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGlmKHRpbWVSYW5nZXMuc3RhcnQoMCkgPT0gMCAmJiB0aW1lUmFuZ2VzLmVuZCgwKSA9PSBteVZpZGVvLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkluIGNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoOiBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICB2aWRlb0NvbXBsZXRlbHlMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBpZihjYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKGVuZElmVmlkZW9Mb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmLnRoZVRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaWYoZW5kSWZWaWRlb0xvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHNlbGYudGhlVG9ycmVudCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudGhlVG9ycmVudC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3ZWJUb3JyZW50Q2xpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgIGVuZFN0cmVhbWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5Dcml0aWNhbCA9IHRydWU7ICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRpbWVSYW5nZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcIlRpbWUgcmFuZ2UgbnVtYmVyIFwiICsgaSArIFwiOiBzdGFydChcIiArIHRpbWVSYW5nZXMuc3RhcnQoaSkgKyBcIikgZW5kKFwiICsgdGltZVJhbmdlcy5lbmQoaSkgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgIGlmIChteVZpZGVvLmN1cnJlbnRUaW1lID49IHRpbWVSYW5nZXMuc3RhcnQoaSkgJiYgbXlWaWRlby5jdXJyZW50VGltZSA8PSB0aW1lUmFuZ2VzLmVuZChpKSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAodGltZVJhbmdlcy5lbmQoaSkgLSBteVZpZGVvLmN1cnJlbnRUaW1lID49IERPV05MT0FEX0ZST01fU0VSVkVSX1RJTUVfUkFOR0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgaW5Dcml0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiSSBzZXQgaW5Dcml0aWNhbCB0byBmYWxzZVwiKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlbGl2ZXJ5QnlTZXJ2ZXIgJiYgaW5Dcml0aWNhbCkge1xyXG4gICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuZ3RoID0gdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnMubGVuZ3RoOyBqIDwgbGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2pdLmN1cnJlbnRDQiAhPT0gbnVsbCAmJiB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyc1tqXS5YSFJDb25kdWN0ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGNvbmR1Y3RYSFIodmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnNbal0pO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHNldFRpbWVvdXQoY2hlY2tJZkJ1ZmZlckZ1bGxFbm91Z2gsIENIRUNLX0lGX0JVRkZFUl9GVUxMX0VOT1VHSF9JTlRFUlZBTCk7XHJcbiAgICAgIH1cclxuICAgfSkoKTtcclxuXHJcbiAgIGZ1bmN0aW9uIGNvbmR1Y3RYSFIodGhpc1JlcXVlc3QpIHtcclxuICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCID09PSBudWxsKXtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXNSZXF1ZXN0LlhIUkNvbmR1Y3RlZCA9IHRydWU7XHJcbiAgICAgIHZhciByZXFTdGFydCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICB2YXIgcmVxRW5kID0gcmVxU3RhcnQgKyBYSFJfUkVRVUVTVF9TSVpFO1xyXG5cclxuICAgICAgaWYgKHRoaXNSZXF1ZXN0LmVuZCA+PSAwICYmIHJlcUVuZCA+IHRoaXNSZXF1ZXN0LmVuZCkge1xyXG4gICAgICAgICByZXFFbmQgPSB0aGlzUmVxdWVzdC5lbmQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlcVN0YXJ0ID49IHJlcUVuZCkge1xyXG4gICAgICAgICB0aGlzUmVxdWVzdC5yZXEgPSBudWxsO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIGNiKG51bGwsbnVsbClcIik7XHJcbiAgICAgICAgIHJldHVybiB0aGlzUmVxdWVzdC5jdXJyZW50Q0IobnVsbCwgbnVsbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qIGdsYXViZSBpY2ggdW5uw7Z0aWdlciB1bmQvb2RlciBnZWbDpGhybGljaGVyIG3DvGxsXHJcbiAgICAgIGlmIChyZXFTdGFydCA+PSByZXFFbmQpIHtcclxuICAgICAgcmVxID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQihudWxsLCBudWxsKTtcclxuICAgICAgfVxyXG4gICAgICAqL1xyXG4gICAgICBpZiAoY29uc29sZUNvdW50ZXIgPCAxMDAwMDAwMCkge1xyXG4gICAgICAgICAvLy8vLy8vLy8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiICB2aWRlb1N0cmVhbSBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIgKyBcIiAgQ0IgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuQ0JOdW1iZXIgKyBcIiAgICByZXFTdGFydDogXCIgKyByZXFTdGFydCk7XHJcbiAgICAgICAgIC8vLy8vLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgIE11bHRpc3RyZWFtIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlciArIFwiICAgQ0IgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuQ0JOdW1iZXIgKyBcIiAgICByZXFFbmQ6IFwiICsgcmVxRW5kKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIFhIUkRhdGFIYW5kbGVyID0gZnVuY3Rpb24gKGNodW5rKXtcclxuICAgICAgICAgYnl0ZXNSZWNlaXZlZEZyb21TZXJ2ZXIgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVhZGFibGVTdHJlYW0gcmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyICsgXCIgcmVjZWl2ZWQgYSBjaHVuayBvZiBsZW5ndGggXCIgKyBjaHVuay5sZW5ndGgpO1xyXG4gICAgICAgICBpZih0aGlzUmVxdWVzdC5ub01vcmVEYXRhKXtcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0LnN0YXJ0IC0gdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgPCBjaHVuay5sZW5ndGgpeyAgICAgICAgIFxyXG4gICAgICAgICAgICBieXRlc1Rha2VuRnJvbVNlcnZlciArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQgLSB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlcik7XHJcbiAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gKz0gY2h1bmsubGVuZ3RoIC0gKHRoaXNSZXF1ZXN0LnN0YXJ0IC0gdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIpO1xyXG4gICAgICAgICAgICB2YXIgbXlCdWZmZXIgPSBjaHVuay5zbGljZSh0aGlzUmVxdWVzdC5zdGFydCAtIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0U2VydmVyLCBjaHVuay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSW4gWEhSRGF0YUhhbmRsZXIgICBteUJ1ZmZlci5sZW5ndGg6IFwiICsgbXlCdWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgdmFyIFN0cmVhbUhhc01lbW9yeUxlZnQgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChteUJ1ZmZlcik7ICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKCFTdHJlYW1IYXNNZW1vcnlMZWZ0KXtcclxuICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrRnVuY3Rpb24gPSB0aGlzUmVxdWVzdC5jdXJyZW50Q0I7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID0gMDtcclxuICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IDUwMDAwMDB9KTtcclxuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhbGxlZCBDQiB3aXRoIGRhdGEgb3V0IG9mIGFuc3dlclN0cmVhbSBmcm9tIHZpZGVvc3RyZWFtUmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2tGdW5jdGlvbihudWxsLCByZXMpOyBcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qubm9Nb3JlRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0pe1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3Quc3RhcnQgPj0gU0laRV9PRl9WSURFT19GSUxFICYmIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFja0Z1bmN0aW9uID0gdGhpc1JlcXVlc3QuY3VycmVudENCO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwfSk7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgQ0Igd2l0aCBkYXRhIG91dCBvZiBhbnN3ZXJTdHJlYW0gZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrRnVuY3Rpb24obnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5zdGFydCArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQgLSB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlcik7ICAgICAgICAgICAgXHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgWEhSRW5kID0gZnVuY3Rpb24gKCl7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJSZWFkYWJsZVN0cmVhbSByZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIgKyBcIiBYSFJFbmRcIik7XHJcbiAgICAgICAgIGlmIChjb25zb2xlQ291bnRlciA8IDEwMDAwMDAwMDAwMDApe1xyXG4gICAgICAgICAgICAvLy8vLy8vLy8vY29uc29sZS5sb2coXCJYSFJFbmQgZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYodGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA+IDAgJiYgdGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPSAwO1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtO1xyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0gPSBuZXcgTXlSZWFkYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogNTAwMDAwMH0pO1xyXG4gICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRDQjtcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudENCID0gbnVsbDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlhIUkVuZDogY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdGhpc1JlcXVlc3QuWEhSQ29uZHVjdGVkID0gZmFsc2U7XHJcbiAgICAgIH0gIFxyXG4gICAgICBcclxuICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgPSByZXFTdGFydDtcclxuICAgICAgXHJcbiAgICAgIC8vY29uc29sZS5sb2coXCJBdCBodHRvLmdldCAgIHJlcVN0YXJ0OiBcIiArIHJlcVN0YXJ0ICsgXCIgICAgIHJlcUVuZDogXCIgKyByZXFFbmQpO1xyXG5cclxuICAgICAgdGhpc1JlcXVlc3QucmVxID0gaHR0cC5nZXQoe1xyXG4gICAgICAgICAgICBwYXRoOiB0aGlzUmVxdWVzdC5zZWxmLnBhdGgsXHJcbiAgICAgICAgICAgIGhvc3RuYW1lOiAnbG9jYWxob3N0JyxcclxuICAgICAgICAgICAgcG9ydDogODA4MCxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICByYW5nZTogJ2J5dGVzPScgKyByZXFTdGFydCArICctJyArIChyZXFFbmQtMSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZXMpe1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFJhbmdlID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXTtcclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5maWxlU2l6ZSA9IHBhcnNlSW50KGNvbnRlbnRSYW5nZS5zcGxpdCgnLycpWzFdLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8vLy8vLy8vL2NvbnNvbGUubG9nKFwiSSByZXR1cm4gY3VycmVudENCIHdpdGggaHR0cCByZXNwb25zZSBzdHJlYW1cIik7XHJcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vL2NvbnNvbGUubG9nKFwiZnVuY3Rpb24ocmVzKSBpcyBleGVjdXRlZCBmcm9tIHJlYWRzdHJlYW0gbnVtYmVyIFwiICsgY3JlYXRlUmVhZFN0cmVhbUNvdW50ZXIgKyBcIiBhbmQgQ0IgbnVtYmVyIFwiICsgdGhpc0NCTnVtYmVyKTtcclxuICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCBYSFJFbmQpO1xyXG4gICAgICAgICAgICByZXMub24oJ2RhdGEnLCBYSFJEYXRhSGFuZGxlcik7XHJcbiAgICAgICAgIH1cclxuICAgICAgKTtcclxuICAgfVxyXG4gICBjaG9rZUlmTmVjZXNzYXJ5KCk7XHJcbiAgIHVwZGF0ZUNoYXJ0KCk7XHJcbiAgIGZyZXF1ZW50bHlDZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSgpO1xyXG4gICBjaGVja0lmQnVmZmVyRnVsbEVub3VnaCgpO1xyXG5cclxuICAgLy8vLy8vY29uc29sZS5sb2coXCJJIGNhbGwgVmlkZW9zdHJlYW0gY29uc3RydWN0b3JcIik7XHJcbiAgIFZpZGVvc3RyZWFtKG5ldyBmaWxlKFBBVEhfVE9fVklERU9fRklMRSksIG15VmlkZW8pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gYWRkU2ltcGxlUGVlckluc3RhbmNlKHNpbXBsZVBlZXJJbnN0YW5jZSwgb3B0aW9ucywgY2FsbGJhY2spe1xyXG4gICAvLyBUaGUgbWV0aG9kIGFkZCBhIHNpbXBsZVBlZXIgdG8gdGhlIFdlYlRvcnJlbnQgc3dhcm0gaW5zdGFuY2VcclxuICAgaWYodGhpcy50aGVUb3JyZW50KXtcclxuICAgICAgaWYodGhpcy50aGVUb3JyZW50LmluZm9IYXNoKXtcclxuICAgICAgICAgdGhpcy50aGVUb3JyZW50LmFkZFBlZXIoc2ltcGxlUGVlckluc3RhbmNlKTtcclxuICAgICAgICAgaWYoY2FsbGJhY2spe1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgIHRoaXMudGhlVG9ycmVudC5vbignaW5mb0hhc2gnLCBmdW5jdGlvbigpIHt0aGlzLnRoZVRvcnJlbnQuYWRkUGVlcihzaW1wbGVQZWVySW5zdGFuY2UpOyBpZihjYWxsYmFjayl7Y2FsbGJhY2soKX19KTtcclxuICAgICAgfVxyXG4gICB9IGVsc2Uge1xyXG4gICAgICB2YXIgcGFpciA9IFtdO1xyXG4gICAgICBwYWlyLnB1c2goc2ltcGxlUGVlckluc3RhbmNlKTtcclxuICAgICAgcGFpci5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgdGhpcy5wZWVyc1RvQWRkLnB1c2gocGFpcik7XHJcbiAgIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIG9uKHR5cGUsIGNhbGxiYWNrKXtcclxuICAgLy8gY2FsbCBjYWxsYmFjayB3aGVuIGV2ZW50IG9mIHR5cGUgXCJ0eXBlXCIgaGFwcGVuZFxyXG4gICAvLyBiaXNoZXIgbnVyIGRhcyBldmVudCBcImZvdW5kTmV3UGVlclZpYVRyYWNrZXJcIiBnZXBsYW50XHJcbn0iLCJ2YXIgWSA9IHJlcXVpcmUoXCJ5anNcIik7XHJcbnJlcXVpcmUoXCJ5LWFycmF5XCIpKFkpO1xyXG5yZXF1aXJlKFwieS1tZW1vcnlcIikoWSk7XHJcbnJlcXVpcmUoXCJ5LXdlYnNvY2tldHMtY2xpZW50XCIpKFkpO1xyXG5yZXF1aXJlKFwieS1tYXBcIikoWSk7XHJcbnZhciBPYWtTdHJlYW1pbmcgPSByZXF1aXJlKCcuL09ha1N0cmVhbWluZycpO1xyXG52YXIgbXlTdHJlYW1pbmcgPSBuZXcgT2FrU3RyZWFtaW5nKCk7XHJcblxyXG52YXIgdGhlU2hhcmVkTWFwID0gbnVsbDtcclxudmFyIHN0cmVhbVNvdXJjZSA9IGZhbHNlO1xyXG5cclxuLypcclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZm9ybScpLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGZ1bmN0aW9uIChldikge1xyXG4gIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgIG15U3RyZWFtaW5nLmxvYWRWaWRlbyhKU09OLnBhcnNlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmNvbWluZycpLnZhbHVlKSwgZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcIkFsbCB2aWRlbyBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkXCIpO30pO1xyXG59KTtcclxuKi9cclxuXHJcblkoe1xyXG4gIGRiOiB7XHJcbiAgICBuYW1lOiAnbWVtb3J5J1xyXG4gIH0sXHJcbiAgY29ubmVjdG9yOiB7XHJcbiAgICAgLy91cmwgOiBcImh0dHBzOi8veWpzLmRiaXMucnd0aC1hYWNoZW4uZGU6NTA3OFwiLFxyXG4gICAgbmFtZTogJ3dlYnNvY2tldHMtY2xpZW50JywgLy8gY2hvb3NlIHRoZSBXZWJSVEMgY29ubmVjdG9yXHJcbiAgICByb29tOiAnV2ViVG9ycmVudC1TdHJlYW1pbmcteWVhaCdcclxuICB9LFxyXG4gIHNoYXJlOiB7XHJcbiAgICAgbXlNYXAgOiAnTWFwJ1xyXG4gICAvLyB0ZXh0YXJlYTogJ1RleHQnIC8vIHkuc2hhcmUudGV4dGFyZWEgaXMgb2YgdHlwZSBZLlRleHRcclxuICB9XHJcbiAgLy8gdHlwZXM6IFsnUmljaHRleHQnLCAnQXJyYXknXSAvLyBvcHRpb25hbCBsaXN0IG9mIHR5cGVzIHlvdSB3YW50IHRvIGltcG9ydFxyXG59KS50aGVuKGZ1bmN0aW9uICh5KXtcclxuICAvLyBiaW5kIHRoZSB0ZXh0YXJlYSB0byBhIHNoYXJlZCB0ZXh0IGVsZW1lbnRcclxuICB0aGVTaGFyZWRNYXAgPSB5LnNoYXJlLm15TWFwO1xyXG4gIHkuc2hhcmUubXlNYXAub2JzZXJ2ZShmdW5jdGlvbihldmVudCl7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVGhlIGZvbGxvd2luZyBldmVudC10eXBlIHdhcyB0aHJvd246IFwiKyBldmVudC50eXBlKVxyXG4gICAgICBjb25zb2xlLmxvZyhcIlRoZSBldmVudCB3YXMgZXhlY3V0ZWQgb246IFwiKyBldmVudC5uYW1lKVxyXG4gICAgICBjb25zb2xlLmxvZyhcIlRoZSBldmVudCBvYmplY3QgaGFzIG1vcmUgaW5mb3JtYXRpb246XCIpXHJcbiAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcclxuICAgICAgaWYoIXN0cmVhbVNvdXJjZSl7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiVmlkZW8gZ2V0cyBsb2FkZWRcIik7XHJcbiAgICAgICAgIG15U3RyZWFtaW5nLmxvYWRWaWRlbyh0aGVTaGFyZWRNYXAuZ2V0KFwic3RyZWFtSW5mb3JtYXRpb25PYmplY3RcIiksIGZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJBbGwgdmlkZW8gZGF0YSBoYXMgYmVlbiByZWNlaXZlZFwiKTt9KTtcclxuICAgICAgICAgY29uc29sZS5sb2coXCJBZnRlciBteVN0cmVhbWluZy5sb2FkVmlkZW8oLi4pIGluIG15TWFwLm9ic2VydmUoLi4pXCIpO1xyXG4gICAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxud2luZG93LmhhbmRsZUZpbGVzID0gZnVuY3Rpb24oZmlsZXMpeyAgIC8vWEhSUGF0aCA6IFwiL1wiICsgZmlsZXNbMF0ubmFtZSwgXHJcbiAgIHN0cmVhbVNvdXJjZSA9IHRydWU7XHJcbiAgIG15U3RyZWFtaW5nLnN0cmVhbVZpZGVvKGZpbGVzWzBdLCB7d2ViVG9ycmVudFRyYWNrZXJzOiBbW1wid3M6Ly9sb2NhbGhvc3Q6ODA4MVwiXSxbXCJ3c3M6Ly90cmFja2VyLndlYnRvcnJlbnQuaW9cIl1dfSwgZnVuY3Rpb24oc3RyZWFtSW5mb3JtYXRpb25PYmplY3Qpe1xyXG4gICAgICBjb25zb2xlLmxvZyhcInN0cmVhbUluZm9ybWF0aW9uT2JqZWN0OlxcblwiICsgSlNPTi5zdHJpbmdpZnkoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QpKTtcclxuICAgICB0aGVTaGFyZWRNYXAuc2V0KFwic3RyZWFtSW5mb3JtYXRpb25PYmplY3RcIiwgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QpO1xyXG4gICB9KTtcclxufSIsInZhciBBRERSX1JFID0gL15cXFs/KFteXFxdXSspXFxdPzooXFxkKykkLyAvLyBpcHY0L2lwdjYvaG9zdG5hbWUgKyBwb3J0XG5cbnZhciBjYWNoZSA9IHt9XG5cbi8vIHJlc2V0IGNhY2hlIHdoZW4gaXQgZ2V0cyB0byAxMDAsMDAwIGVsZW1lbnRzICh+IDYwMEtCIG9mIGlwdjQgYWRkcmVzc2VzKVxuLy8gc28gaXQgd2lsbCBub3QgZ3JvdyB0byBjb25zdW1lIGFsbCBtZW1vcnkgaW4gbG9uZy1ydW5uaW5nIHByb2Nlc3Nlc1xudmFyIHNpemUgPSAwXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkclRvSVBQb3J0IChhZGRyKSB7XG4gIGlmIChzaXplID09PSAxMDAwMDApIG1vZHVsZS5leHBvcnRzLnJlc2V0KClcbiAgaWYgKCFjYWNoZVthZGRyXSkge1xuICAgIHZhciBtID0gQUREUl9SRS5leGVjKGFkZHIpXG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRkcjogJyArIGFkZHIpXG4gICAgY2FjaGVbYWRkcl0gPSBbIG1bMV0sIE51bWJlcihtWzJdKSBdXG4gICAgc2l6ZSArPSAxXG4gIH1cbiAgcmV0dXJuIGNhY2hlW2FkZHJdXG59XG5cbm1vZHVsZS5leHBvcnRzLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKCkge1xuICBjYWNoZSA9IHt9XG4gIHNpemUgPSAwXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG4iLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cbiIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbihjaGFycyl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcbiAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG4gICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbmZ1bmN0aW9uIGluaXQgKCkge1xuICB2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbiAgfVxuXG4gIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxuICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcbn1cblxuaW5pdCgpXG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxuXG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyoqXG4gKiBEZWNvZGVzIGJlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtICB7QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0IChvcHRpb25hbClcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kIChvcHRpb25hbClcbiAqIEBwYXJhbSAge1N0cmluZ30gZW5jb2RpbmcgKG9wdGlvbmFsKVxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fEJ1ZmZlcnxTdHJpbmd8TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWNvZGUgKGRhdGEsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwpIHtcbiAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgc3RhcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsKSB7XG4gICAgZW5jb2RpbmcgPSBlbmRcbiAgICBlbmQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gIShCdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgPyBuZXcgQnVmZmVyKGRhdGEpXG4gICAgOiBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZGVjb2RlLmJ5dGVzID0gZGVjb2RlLmRhdGEubGVuZ3RoXG5cbiAgcmV0dXJuIGRlY29kZS5uZXh0KClcbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgPSBudWxsXG5kZWNvZGUuZW5jb2RpbmcgPSBudWxsXG5cbmRlY29kZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBzd2l0Y2ggKGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0pIHtcbiAgICBjYXNlIDB4NjQ6XG4gICAgICByZXR1cm4gZGVjb2RlLmRpY3Rpb25hcnkoKVxuICAgIGNhc2UgMHg2QzpcbiAgICAgIHJldHVybiBkZWNvZGUubGlzdCgpXG4gICAgY2FzZSAweDY5OlxuICAgICAgcmV0dXJuIGRlY29kZS5pbnRlZ2VyKClcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRlY29kZS5idWZmZXIoKVxuICB9XG59XG5cbmRlY29kZS5maW5kID0gZnVuY3Rpb24gKGNocikge1xuICB2YXIgaSA9IGRlY29kZS5wb3NpdGlvblxuICB2YXIgYyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICB2YXIgZCA9IGRlY29kZS5kYXRhXG5cbiAgd2hpbGUgKGkgPCBjKSB7XG4gICAgaWYgKGRbaV0gPT09IGNocikgcmV0dXJuIGlcbiAgICBpKytcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YWxpZCBkYXRhOiBNaXNzaW5nIGRlbGltaXRlciBcIicgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoMTYpICsgJ10nXG4gIClcbn1cblxuZGVjb2RlLmRpY3Rpb25hcnkgPSBmdW5jdGlvbiAoKSB7XG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGRpY3QgPSB7fVxuXG4gIHdoaWxlIChkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1KSB7XG4gICAgZGljdFtkZWNvZGUuYnVmZmVyKCldID0gZGVjb2RlLm5leHQoKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gZGljdFxufVxuXG5kZWNvZGUubGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgbHN0ID0gW11cblxuICB3aGlsZSAoZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSkge1xuICAgIGxzdC5wdXNoKGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBsc3Rcbn1cblxuZGVjb2RlLmludGVnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmQgPSBkZWNvZGUuZmluZCgweDY1KVxuICB2YXIgbnVtYmVyID0gZGVjb2RlLmRhdGEudG9TdHJpbmcoJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uICsgMSwgZW5kKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KG51bWJlciwgMTApXG59XG5cbmRlY29kZS5idWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZXAgPSBkZWNvZGUuZmluZCgweDNBKVxuICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoZGVjb2RlLmRhdGEudG9TdHJpbmcoJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXApLCAxMClcbiAgdmFyIGVuZCA9ICsrc2VwICsgbGVuZ3RoXG5cbiAgZGVjb2RlLnBvc2l0aW9uID0gZW5kXG5cbiAgcmV0dXJuIGRlY29kZS5lbmNvZGluZ1xuICAgID8gZGVjb2RlLmRhdGEudG9TdHJpbmcoZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZClcbiAgICA6IGRlY29kZS5kYXRhLnNsaWNlKHNlcCwgZW5kKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZVxuIiwiLyoqXG4gKiBFbmNvZGVzIGRhdGEgaW4gYmVuY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE9iamVjdHxOdW1iZXJ8Qm9vbGVhbn0gZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBlbmNvZGUgKGRhdGEsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHZhciBidWZmZXJzID0gW11cbiAgdmFyIHJlc3VsdCA9IG51bGxcblxuICBlbmNvZGUuX2VuY29kZShidWZmZXJzLCBkYXRhKVxuICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpXG4gIGVuY29kZS5ieXRlcyA9IHJlc3VsdC5sZW5ndGhcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICByZXN1bHQuY29weShidWZmZXIsIG9mZnNldClcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmVuY29kZS5ieXRlcyA9IC0xXG5lbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gZmFsc2VcblxuZW5jb2RlLl9lbmNvZGUgPSBmdW5jdGlvbiAoYnVmZmVycywgZGF0YSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVyblxuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgZGF0YSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBlbmNvZGUuYnVmZmVyKGJ1ZmZlcnMsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBlbmNvZGUubnVtYmVyKGJ1ZmZlcnMsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KGJ1ZmZlcnMsIGRhdGEpXG4gICAgICAgIDogZW5jb2RlLmRpY3QoYnVmZmVycywgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBlbmNvZGUubnVtYmVyKGJ1ZmZlcnMsIGRhdGEgPyAxIDogMClcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxudmFyIGJ1ZmZFID0gbmV3IEJ1ZmZlcignZScpXG52YXIgYnVmZkQgPSBuZXcgQnVmZmVyKCdkJylcbnZhciBidWZmTCA9IG5ldyBCdWZmZXIoJ2wnKVxuXG5lbmNvZGUuYnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgKyAnOicgKyBkYXRhKSlcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uIChidWZmZXJzLCBkYXRhKSB7XG4gIHZhciBtYXhMbyA9IDB4ODAwMDAwMDBcbiAgdmFyIGhpID0gKGRhdGEgLyBtYXhMbykgPDwgMFxuICB2YXIgbG8gPSAoZGF0YSAlIG1heExvKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2gobmV3IEJ1ZmZlcignaScgKyB2YWwgKyAnZScpKVxuXG4gIGlmICh2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQpIHtcbiAgICBlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gdHJ1ZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXQVJOSU5HOiBQb3NzaWJsZSBkYXRhIGNvcnJ1cHRpb24gZGV0ZWN0ZWQgd2l0aCB2YWx1ZSBcIicgKyBkYXRhICsgJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicgKyB2YWwgKyAnXCInXG4gICAgKVxuICAgIGNvbnNvbGUudHJhY2UoKVxuICB9XG59XG5cbmVuY29kZS5kaWN0ID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgYnVmZmVycy5wdXNoKGJ1ZmZEKVxuXG4gIHZhciBqID0gMFxuICB2YXIga1xuICAvLyBmaXggZm9yIGlzc3VlICMxMyAtIHNvcnRlZCBkaWN0c1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciAoOyBqIDwga2w7IGorKykge1xuICAgIGsgPSBrZXlzW2pdXG4gICAgZW5jb2RlLmJ1ZmZlcihidWZmZXJzLCBrKVxuICAgIGVuY29kZS5fZW5jb2RlKGJ1ZmZlcnMsIGRhdGFba10pXG4gIH1cblxuICBidWZmZXJzLnB1c2goYnVmZkUpXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgdmFyIGkgPSAwXG4gIHZhciBjID0gZGF0YS5sZW5ndGhcbiAgYnVmZmVycy5wdXNoKGJ1ZmZMKVxuXG4gIGZvciAoOyBpIDwgYzsgaSsrKSB7XG4gICAgZW5jb2RlLl9lbmNvZGUoYnVmZmVycywgZGF0YVtpXSlcbiAgfVxuXG4gIGJ1ZmZlcnMucHVzaChidWZmRSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcbiIsInZhciBiZW5jb2RlID0gbW9kdWxlLmV4cG9ydHNcblxuYmVuY29kZS5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpXG5iZW5jb2RlLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJylcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBhbW91bnQgb2YgYnl0ZXNcbiAqIG5lZWRlZCB0byBlbmNvZGUgdGhlIGdpdmVuIHZhbHVlXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl8QnVmZmVyfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcn0gYnl0ZUNvdW50XG4gKi9cbmJlbmNvZGUuYnl0ZUxlbmd0aCA9IGJlbmNvZGUuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGJlbmNvZGUuZW5jb2RlKHZhbHVlKS5sZW5ndGhcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSwgY29tcGFyYXRvciwgbG93LCBoaWdoKSB7XG4gIHZhciBtaWQsIGNtcDtcblxuICBpZihsb3cgPT09IHVuZGVmaW5lZClcbiAgICBsb3cgPSAwO1xuXG4gIGVsc2Uge1xuICAgIGxvdyA9IGxvd3wwO1xuICAgIGlmKGxvdyA8IDAgfHwgbG93ID49IGhheXN0YWNrLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBsb3dlciBib3VuZFwiKTtcbiAgfVxuXG4gIGlmKGhpZ2ggPT09IHVuZGVmaW5lZClcbiAgICBoaWdoID0gaGF5c3RhY2subGVuZ3RoIC0gMTtcblxuICBlbHNlIHtcbiAgICBoaWdoID0gaGlnaHwwO1xuICAgIGlmKGhpZ2ggPCBsb3cgfHwgaGlnaCA+PSBoYXlzdGFjay5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgdXBwZXIgYm91bmRcIik7XG4gIH1cblxuICB3aGlsZShsb3cgPD0gaGlnaCkge1xuICAgIC8qIE5vdGUgdGhhdCBcIihsb3cgKyBoaWdoKSA+Pj4gMVwiIG1heSBvdmVyZmxvdywgYW5kIHJlc3VsdHMgaW4gYSB0eXBlY2FzdFxuICAgICAqIHRvIGRvdWJsZSAod2hpY2ggZ2l2ZXMgdGhlIHdyb25nIHJlc3VsdHMpLiAqL1xuICAgIG1pZCA9IGxvdyArIChoaWdoIC0gbG93ID4+IDEpO1xuICAgIGNtcCA9ICtjb21wYXJhdG9yKGhheXN0YWNrW21pZF0sIG5lZWRsZSwgbWlkLCBoYXlzdGFjayk7XG5cbiAgICAvKiBUb28gbG93LiAqL1xuICAgIGlmKGNtcCA8IDAuMClcbiAgICAgIGxvdyAgPSBtaWQgKyAxO1xuXG4gICAgLyogVG9vIGhpZ2guICovXG4gICAgZWxzZSBpZihjbXAgPiAwLjApXG4gICAgICBoaWdoID0gbWlkIC0gMTtcblxuICAgIC8qIEtleSBmb3VuZC4gKi9cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbWlkO1xuICB9XG5cbiAgLyogS2V5IG5vdCBmb3VuZC4gKi9cbiAgcmV0dXJuIH5sb3c7XG59XG4iLCJ2YXIgQ29udGFpbmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiA/IEJ1ZmZlciAvL2luIG5vZGUsIHVzZSBidWZmZXJzXHJcblx0XHQ6IHR5cGVvZiBJbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBJbnQ4QXJyYXkgLy9pbiBuZXdlciBicm93c2VycywgdXNlIHdlYmdsIGludDhhcnJheXNcclxuXHRcdDogZnVuY3Rpb24obCl7IHZhciBhID0gbmV3IEFycmF5KGwpOyBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBhW2ldPTA7IH07IC8vZWxzZSwgZG8gc29tZXRoaW5nIHNpbWlsYXJcclxuXHJcbmZ1bmN0aW9uIEJpdEZpZWxkKGRhdGEsIG9wdHMpe1xyXG5cdGlmKCEodGhpcyBpbnN0YW5jZW9mIEJpdEZpZWxkKSkge1xyXG5cdFx0cmV0dXJuIG5ldyBCaXRGaWVsZChkYXRhLCBvcHRzKTtcclxuXHR9XHJcblxyXG5cdGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDApe1xyXG5cdFx0ZGF0YSA9IDA7XHJcblx0fVxyXG5cclxuXHR0aGlzLmdyb3cgPSBvcHRzICYmIChpc0Zpbml0ZShvcHRzLmdyb3cpICYmIGdldEJ5dGVTaXplKG9wdHMuZ3JvdykgfHwgb3B0cy5ncm93KSB8fCAwO1xyXG5cclxuXHRpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCBkYXRhID09PSB1bmRlZmluZWQpe1xyXG5cdFx0ZGF0YSA9IG5ldyBDb250YWluZXIoZ2V0Qnl0ZVNpemUoZGF0YSkpO1xyXG5cdFx0aWYoZGF0YS5maWxsICYmICFkYXRhLl9pc0J1ZmZlcikgZGF0YS5maWxsKDApOyAvLyBjbGVhciBub2RlIGJ1ZmZlcnMgb2YgZ2FyYmFnZVxyXG5cdH1cclxuXHR0aGlzLmJ1ZmZlciA9IGRhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEJ5dGVTaXplKG51bSl7XHJcblx0dmFyIG91dCA9IG51bSA+PiAzO1xyXG5cdGlmKG51bSAlIDggIT09IDApIG91dCsrO1xyXG5cdHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbkJpdEZpZWxkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpKXtcclxuXHR2YXIgaiA9IGkgPj4gMztcclxuXHRyZXR1cm4gKGogPCB0aGlzLmJ1ZmZlci5sZW5ndGgpICYmXHJcblx0XHQhISh0aGlzLmJ1ZmZlcltqXSAmICgxMjggPj4gKGkgJSA4KSkpO1xyXG59O1xyXG5cclxuQml0RmllbGQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGIpe1xyXG5cdHZhciBqID0gaSA+PiAzO1xyXG5cdGlmIChiIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDEpe1xyXG5cdFx0aWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IGogKyAxKSB0aGlzLl9ncm93KE1hdGgubWF4KGogKyAxLCBNYXRoLm1pbigyICogdGhpcy5idWZmZXIubGVuZ3RoLCB0aGlzLmdyb3cpKSk7XHJcblx0XHQvLyBTZXRcclxuXHRcdHRoaXMuYnVmZmVyW2pdIHw9IDEyOCA+PiAoaSAlIDgpO1xyXG5cdH0gZWxzZSBpZiAoaiA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xyXG5cdFx0Ly8vIENsZWFyXHJcblx0XHR0aGlzLmJ1ZmZlcltqXSAmPSB+KDEyOCA+PiAoaSAlIDgpKTtcclxuXHR9XHJcbn07XHJcblxyXG5CaXRGaWVsZC5wcm90b3R5cGUuX2dyb3cgPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuXHRpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgbGVuZ3RoICYmIGxlbmd0aCA8PSB0aGlzLmdyb3cpIHtcclxuXHRcdHZhciBuZXdCdWZmZXIgPSBuZXcgQ29udGFpbmVyKGxlbmd0aCk7XHJcblx0XHRpZiAobmV3QnVmZmVyLmZpbGwpIG5ld0J1ZmZlci5maWxsKDApO1xyXG5cdFx0aWYgKHRoaXMuYnVmZmVyLmNvcHkpIHRoaXMuYnVmZmVyLmNvcHkobmV3QnVmZmVyLCAwKTtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXIubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRuZXdCdWZmZXJbaV0gPSB0aGlzLmJ1ZmZlcltpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcblx0fVxyXG59O1xyXG5cclxuaWYodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlLmV4cG9ydHMgPSBCaXRGaWVsZDtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBXaXJlXG5cbnZhciBiZW5jb2RlID0gcmVxdWlyZSgnYmVuY29kZScpXG52YXIgQml0RmllbGQgPSByZXF1aXJlKCdiaXRmaWVsZCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2JpdHRvcnJlbnQtcHJvdG9jb2wnKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBoYXQgPSByZXF1aXJlKCdoYXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNwZWVkb21ldGVyID0gcmVxdWlyZSgnc3BlZWRvbWV0ZXInKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbnZhciBCSVRGSUVMRF9HUk9XID0gNDAwMDAwXG52YXIgS0VFUF9BTElWRV9USU1FT1VUID0gNTUwMDBcblxudmFyIE1FU1NBR0VfUFJPVE9DT0wgPSBCdWZmZXIuZnJvbSgnXFx1MDAxM0JpdFRvcnJlbnQgcHJvdG9jb2wnKVxudmFyIE1FU1NBR0VfS0VFUF9BTElWRSA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweDAwLCAweDAwXSlcbnZhciBNRVNTQUdFX0NIT0tFID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDBdKVxudmFyIE1FU1NBR0VfVU5DSE9LRSA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAxXSlcbnZhciBNRVNTQUdFX0lOVEVSRVNURUQgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMl0pXG52YXIgTUVTU0FHRV9VTklOVEVSRVNURUQgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwM10pXG5cbnZhciBNRVNTQUdFX1JFU0VSVkVEID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdXG52YXIgTUVTU0FHRV9QT1JUID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIDB4MDksIDB4MDAsIDB4MDBdXG5cbmZ1bmN0aW9uIFJlcXVlc3QgKHBpZWNlLCBvZmZzZXQsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgdGhpcy5waWVjZSA9IHBpZWNlXG4gIHRoaXMub2Zmc2V0ID0gb2Zmc2V0XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xufVxuXG5pbmhlcml0cyhXaXJlLCBzdHJlYW0uRHVwbGV4KVxuXG5mdW5jdGlvbiBXaXJlICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdpcmUpKSByZXR1cm4gbmV3IFdpcmUoKVxuICBzdHJlYW0uRHVwbGV4LmNhbGwodGhpcylcblxuICB0aGlzLl9kZWJ1Z0lkID0gaGF0KDMyKVxuICB0aGlzLl9kZWJ1ZygnbmV3IHdpcmUnKVxuXG4gIHRoaXMucGVlcklkID0gbnVsbCAvLyByZW1vdGUgcGVlciBpZCAoaGV4IHN0cmluZylcbiAgdGhpcy5wZWVySWRCdWZmZXIgPSBudWxsIC8vIHJlbW90ZSBwZWVyIGlkIChidWZmZXIpXG4gIHRoaXMudHlwZSA9IG51bGwgLy8gY29ubmVjdGlvbiB0eXBlICgnd2VicnRjJywgJ3RjcEluY29taW5nJywgJ3RjcE91dGdvaW5nJywgJ3dlYlNlZWQnKVxuXG4gIHRoaXMuYW1DaG9raW5nID0gdHJ1ZSAvLyBhcmUgd2UgY2hva2luZyB0aGUgcGVlcj9cbiAgdGhpcy5hbUludGVyZXN0ZWQgPSBmYWxzZSAvLyBhcmUgd2UgaW50ZXJlc3RlZCBpbiB0aGUgcGVlcj9cblxuICB0aGlzLnBlZXJDaG9raW5nID0gdHJ1ZSAvLyBpcyB0aGUgcGVlciBjaG9raW5nIHVzP1xuICB0aGlzLnBlZXJJbnRlcmVzdGVkID0gZmFsc2UgLy8gaXMgdGhlIHBlZXIgaW50ZXJlc3RlZCBpbiB1cz9cblxuICAvLyBUaGUgbGFyZ2VzdCB0b3JyZW50IHRoYXQgSSBrbm93IG9mICh0aGUgR2VvY2l0aWVzIGFyY2hpdmUpIGlzIH42NDEgR0IgYW5kIGhhc1xuICAvLyB+NDEsMDAwIHBpZWNlcy4gVGhlcmVmb3JlLCBjYXAgYml0ZmllbGQgdG8gMTB4IGxhcmdlciAoNDAwLDAwMCBiaXRzKSB0byBzdXBwb3J0IGFsbFxuICAvLyBwb3NzaWJsZSB0b3JyZW50cyBidXQgcHJldmVudCBtYWxpY2lvdXMgcGVlcnMgZnJvbSBncm93aW5nIGJpdGZpZWxkIHRvIGZpbGwgbWVtb3J5LlxuICB0aGlzLnBlZXJQaWVjZXMgPSBuZXcgQml0RmllbGQoMCwgeyBncm93OiBCSVRGSUVMRF9HUk9XIH0pXG5cbiAgdGhpcy5wZWVyRXh0ZW5zaW9ucyA9IHt9XG5cbiAgdGhpcy5yZXF1ZXN0cyA9IFtdIC8vIG91dGdvaW5nXG4gIHRoaXMucGVlclJlcXVlc3RzID0gW10gLy8gaW5jb21pbmdcblxuICB0aGlzLmV4dGVuZGVkTWFwcGluZyA9IHt9IC8vIG51bWJlciAtPiBzdHJpbmcsIGV4OiAxIC0+ICd1dF9tZXRhZGF0YSdcbiAgdGhpcy5wZWVyRXh0ZW5kZWRNYXBwaW5nID0ge30gLy8gc3RyaW5nIC0+IG51bWJlciwgZXg6IDkgLT4gJ3V0X21ldGFkYXRhJ1xuXG4gIC8vIFRoZSBleHRlbmRlZCBoYW5kc2hha2UgdG8gc2VuZCwgbWludXMgdGhlIFwibVwiIGZpZWxkLCB3aGljaCBnZXRzIGF1dG9tYXRpY2FsbHlcbiAgLy8gZmlsbGVkIGZyb20gYHRoaXMuZXh0ZW5kZWRNYXBwaW5nYFxuICB0aGlzLmV4dGVuZGVkSGFuZHNoYWtlID0ge31cblxuICB0aGlzLnBlZXJFeHRlbmRlZEhhbmRzaGFrZSA9IHt9IC8vIHJlbW90ZSBwZWVyJ3MgZXh0ZW5kZWQgaGFuZHNoYWtlXG5cbiAgdGhpcy5fZXh0ID0ge30gIC8vIHN0cmluZyAtPiBmdW5jdGlvbiwgZXggJ3V0X21ldGFkYXRhJyAtPiB1dF9tZXRhZGF0YSgpXG4gIHRoaXMuX25leHRFeHQgPSAxXG5cbiAgdGhpcy51cGxvYWRlZCA9IDBcbiAgdGhpcy5kb3dubG9hZGVkID0gMFxuICB0aGlzLnVwbG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuICB0aGlzLmRvd25sb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG5cbiAgdGhpcy5fa2VlcEFsaXZlSW50ZXJ2YWwgPSBudWxsXG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gIHRoaXMuX3RpbWVvdXRNcyA9IDBcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlIC8vIHdhcyB0aGUgd2lyZSBlbmRlZCBieSBjYWxsaW5nIGBkZXN0cm95YD9cbiAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZVxuXG4gIHRoaXMuX3BhcnNlclNpemUgPSAwIC8vIG51bWJlciBvZiBuZWVkZWQgYnl0ZXMgdG8gcGFyc2UgbmV4dCBtZXNzYWdlIGZyb20gcmVtb3RlIHBlZXJcbiAgdGhpcy5fcGFyc2VyID0gbnVsbCAvLyBmdW5jdGlvbiB0byBjYWxsIG9uY2UgYHRoaXMuX3BhcnNlclNpemVgIGJ5dGVzIGFyZSBhdmFpbGFibGVcblxuICB0aGlzLl9idWZmZXIgPSBbXSAvLyBpbmNvbXBsZXRlIG1lc3NhZ2UgZGF0YVxuICB0aGlzLl9idWZmZXJTaXplID0gMCAvLyBjYWNoZWQgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gYHRoaXMuX2J1ZmZlcmBcblxuICB0aGlzLm9uKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaClcblxuICB0aGlzLl9wYXJzZUhhbmRzaGFrZSgpXG59XG5cbi8qKlxuICogU2V0IHdoZXRoZXIgdG8gc2VuZCBhIFwia2VlcC1hbGl2ZVwiIHBpbmcgKHNlbnQgZXZlcnkgNTVzKVxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVcbiAqL1xuV2lyZS5wcm90b3R5cGUuc2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVidWcoJ3NldEtlZXBBbGl2ZSAlcycsIGVuYWJsZSlcbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9rZWVwQWxpdmVJbnRlcnZhbClcbiAgaWYgKGVuYWJsZSA9PT0gZmFsc2UpIHJldHVyblxuICBzZWxmLl9rZWVwQWxpdmVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmtlZXBBbGl2ZSgpXG4gIH0sIEtFRVBfQUxJVkVfVElNRU9VVClcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGNvbnNpZGVyaW5nIGEgcmVxdWVzdCB0byBiZSBcInRpbWVkIG91dFwiXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVucmVmIChzaG91bGQgdGhlIHRpbWVyIGJlIHVucmVmJ2Q/IGRlZmF1bHQ6IGZhbHNlKVxuICovXG5XaXJlLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKG1zLCB1bnJlZikge1xuICB0aGlzLl9kZWJ1Zygnc2V0VGltZW91dCBtcz0lZCB1bnJlZj0lcycsIG1zLCB1bnJlZilcbiAgdGhpcy5fY2xlYXJUaW1lb3V0KClcbiAgdGhpcy5fdGltZW91dE1zID0gbXNcbiAgdGhpcy5fdGltZW91dFVucmVmID0gISF1bnJlZlxuICB0aGlzLl91cGRhdGVUaW1lb3V0KClcbn1cblxuV2lyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX2RlYnVnKCdkZXN0cm95JylcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG4gIHRoaXMuZW5kKClcbn1cblxuV2lyZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kZWJ1ZygnZW5kJylcbiAgdGhpcy5fb25VbmludGVyZXN0ZWQoKVxuICB0aGlzLl9vbkNob2tlKClcbiAgc3RyZWFtLkR1cGxleC5wcm90b3R5cGUuZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuLyoqXG4gKiBVc2UgdGhlIHNwZWNpZmllZCBwcm90b2NvbCBleHRlbnNpb24uXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gRXh0ZW5zaW9uXG4gKi9cbldpcmUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChFeHRlbnNpb24pIHtcbiAgdmFyIG5hbWUgPSBFeHRlbnNpb24ucHJvdG90eXBlLm5hbWVcbiAgaWYgKCFuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gY2xhc3MgcmVxdWlyZXMgYSBcIm5hbWVcIiBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlJylcbiAgfVxuICB0aGlzLl9kZWJ1ZygndXNlIGV4dGVuc2lvbi5uYW1lPSVzJywgbmFtZSlcblxuICB2YXIgZXh0ID0gdGhpcy5fbmV4dEV4dFxuICB2YXIgaGFuZGxlciA9IG5ldyBFeHRlbnNpb24odGhpcylcblxuICBmdW5jdGlvbiBub29wICgpIHt9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uSGFuZHNoYWtlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFuZGxlci5vbkhhbmRzaGFrZSA9IG5vb3BcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIub25FeHRlbmRlZEhhbmRzaGFrZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGhhbmRsZXIub25FeHRlbmRlZEhhbmRzaGFrZSA9IG5vb3BcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIub25NZXNzYWdlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFuZGxlci5vbk1lc3NhZ2UgPSBub29wXG4gIH1cblxuICB0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdID0gbmFtZVxuICB0aGlzLl9leHRbbmFtZV0gPSBoYW5kbGVyXG4gIHRoaXNbbmFtZV0gPSBoYW5kbGVyXG5cbiAgdGhpcy5fbmV4dEV4dCArPSAxXG59XG5cbi8vXG4vLyBPVVRHT0lORyBNRVNTQUdFU1xuLy9cblxuLyoqXG4gKiBNZXNzYWdlIFwia2VlcC1hbGl2ZVwiOiA8bGVuPTAwMDA+XG4gKi9cbldpcmUucHJvdG90eXBlLmtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ2tlZXAtYWxpdmUnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfS0VFUF9BTElWRSlcbn1cblxuLyoqXG4gKiBNZXNzYWdlOiBcImhhbmRzaGFrZVwiIDxwc3RybGVuPjxwc3RyPjxyZXNlcnZlZD48aW5mb19oYXNoPjxwZWVyX2lkPlxuICogQHBhcmFtICB7QnVmZmVyfHN0cmluZ30gaW5mb0hhc2ggKGFzIEJ1ZmZlciBvciAqaGV4KiBzdHJpbmcpXG4gKiBAcGFyYW0gIHtCdWZmZXJ8c3RyaW5nfSBwZWVySWRcbiAqIEBwYXJhbSAge09iamVjdH0gZXh0ZW5zaW9uc1xuICovXG5XaXJlLnByb3RvdHlwZS5oYW5kc2hha2UgPSBmdW5jdGlvbiAoaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucykge1xuICB2YXIgaW5mb0hhc2hCdWZmZXIsIHBlZXJJZEJ1ZmZlclxuICBpZiAodHlwZW9mIGluZm9IYXNoID09PSAnc3RyaW5nJykge1xuICAgIGluZm9IYXNoQnVmZmVyID0gQnVmZmVyLmZyb20oaW5mb0hhc2gsICdoZXgnKVxuICB9IGVsc2Uge1xuICAgIGluZm9IYXNoQnVmZmVyID0gaW5mb0hhc2hcbiAgICBpbmZvSGFzaCA9IGluZm9IYXNoQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICB9XG4gIGlmICh0eXBlb2YgcGVlcklkID09PSAnc3RyaW5nJykge1xuICAgIHBlZXJJZEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBlZXJJZCwgJ2hleCcpXG4gIH0gZWxzZSB7XG4gICAgcGVlcklkQnVmZmVyID0gcGVlcklkXG4gICAgcGVlcklkID0gcGVlcklkQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICB9XG5cbiAgaWYgKGluZm9IYXNoQnVmZmVyLmxlbmd0aCAhPT0gMjAgfHwgcGVlcklkQnVmZmVyLmxlbmd0aCAhPT0gMjApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZm9IYXNoIGFuZCBwZWVySWQgTVVTVCBoYXZlIGxlbmd0aCAyMCcpXG4gIH1cblxuICB0aGlzLl9kZWJ1ZygnaGFuZHNoYWtlIGk9JXMgcD0lcyBleHRzPSVvJywgaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucylcblxuICB2YXIgcmVzZXJ2ZWQgPSBCdWZmZXIuZnJvbShNRVNTQUdFX1JFU0VSVkVEKVxuXG4gIC8vIGVuYWJsZSBleHRlbmRlZCBtZXNzYWdlXG4gIHJlc2VydmVkWzVdIHw9IDB4MTBcblxuICBpZiAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLmRodCkgcmVzZXJ2ZWRbN10gfD0gMVxuXG4gIHRoaXMuX3B1c2goQnVmZmVyLmNvbmNhdChbTUVTU0FHRV9QUk9UT0NPTCwgcmVzZXJ2ZWQsIGluZm9IYXNoQnVmZmVyLCBwZWVySWRCdWZmZXJdKSlcbiAgdGhpcy5faGFuZHNoYWtlU2VudCA9IHRydWVcblxuICBpZiAodGhpcy5wZWVyRXh0ZW5zaW9ucy5leHRlbmRlZCAmJiAhdGhpcy5fZXh0ZW5kZWRIYW5kc2hha2VTZW50KSB7XG4gICAgLy8gUGVlcidzIGhhbmRzaGFrZSBpbmRpY2F0ZWQgc3VwcG9ydCBhbHJlYWR5XG4gICAgLy8gKGluY29taW5nIGNvbm5lY3Rpb24pXG4gICAgdGhpcy5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlKClcbiAgfVxufVxuXG4vKiBQZWVyIHN1cHBvcnRzIEJFUC0wMDEwLCBzZW5kIGV4dGVuZGVkIGhhbmRzaGFrZS5cbiAqXG4gKiBUaGlzIGNvbWVzIGFmdGVyIHRoZSAnaGFuZHNoYWtlJyBldmVudCB0byBnaXZlIHRoZSB1c2VyIGEgY2hhbmNlIHRvIHBvcHVsYXRlXG4gKiBgdGhpcy5leHRlbmRlZEhhbmRzaGFrZWAgYW5kIGB0aGlzLmV4dGVuZGVkTWFwcGluZ2AgYmVmb3JlIHRoZSBleHRlbmRlZCBoYW5kc2hha2VcbiAqIGlzIHNlbnQgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICovXG5XaXJlLnByb3RvdHlwZS5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlID0gZnVuY3Rpb24gKCkge1xuICAvLyBDcmVhdGUgZXh0ZW5kZWQgbWVzc2FnZSBvYmplY3QgZnJvbSByZWdpc3RlcmVkIGV4dGVuc2lvbnNcbiAgdmFyIG1zZyA9IGV4dGVuZCh0aGlzLmV4dGVuZGVkSGFuZHNoYWtlKVxuICBtc2cubSA9IHt9XG4gIGZvciAodmFyIGV4dCBpbiB0aGlzLmV4dGVuZGVkTWFwcGluZykge1xuICAgIHZhciBuYW1lID0gdGhpcy5leHRlbmRlZE1hcHBpbmdbZXh0XVxuICAgIG1zZy5tW25hbWVdID0gTnVtYmVyKGV4dClcbiAgfVxuXG4gIC8vIFNlbmQgZXh0ZW5kZWQgaGFuZHNoYWtlXG4gIHRoaXMuZXh0ZW5kZWQoMCwgYmVuY29kZS5lbmNvZGUobXNnKSlcbiAgdGhpcy5fZXh0ZW5kZWRIYW5kc2hha2VTZW50ID0gdHJ1ZVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJjaG9rZVwiOiA8bGVuPTAwMDE+PGlkPTA+XG4gKi9cbldpcmUucHJvdG90eXBlLmNob2tlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbUNob2tpbmcpIHJldHVyblxuICB0aGlzLmFtQ2hva2luZyA9IHRydWVcbiAgdGhpcy5fZGVidWcoJ2Nob2tlJylcbiAgdGhpcy5wZWVyUmVxdWVzdHMuc3BsaWNlKDAsIHRoaXMucGVlclJlcXVlc3RzLmxlbmd0aClcbiAgdGhpcy5fcHVzaChNRVNTQUdFX0NIT0tFKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJ1bmNob2tlXCI6IDxsZW49MDAwMT48aWQ9MT5cbiAqL1xuV2lyZS5wcm90b3R5cGUudW5jaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmFtQ2hva2luZykgcmV0dXJuXG4gIHRoaXMuYW1DaG9raW5nID0gZmFsc2VcbiAgdGhpcy5fZGVidWcoJ3VuY2hva2UnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfVU5DSE9LRSlcbn1cblxuLyoqXG4gKiBNZXNzYWdlIFwiaW50ZXJlc3RlZFwiOiA8bGVuPTAwMDE+PGlkPTI+XG4gKi9cbldpcmUucHJvdG90eXBlLmludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFtSW50ZXJlc3RlZCkgcmV0dXJuXG4gIHRoaXMuYW1JbnRlcmVzdGVkID0gdHJ1ZVxuICB0aGlzLl9kZWJ1ZygnaW50ZXJlc3RlZCcpXG4gIHRoaXMuX3B1c2goTUVTU0FHRV9JTlRFUkVTVEVEKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJ1bmludGVyZXN0ZWRcIjogPGxlbj0wMDAxPjxpZD0zPlxuICovXG5XaXJlLnByb3RvdHlwZS51bmludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5hbUludGVyZXN0ZWQpIHJldHVyblxuICB0aGlzLmFtSW50ZXJlc3RlZCA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCd1bmludGVyZXN0ZWQnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfVU5JTlRFUkVTVEVEKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJoYXZlXCI6IDxsZW49MDAwNT48aWQ9ND48cGllY2UgaW5kZXg+XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKi9cbldpcmUucHJvdG90eXBlLmhhdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdGhpcy5fZGVidWcoJ2hhdmUgJWQnLCBpbmRleClcbiAgdGhpcy5fbWVzc2FnZSg0LCBbaW5kZXhdLCBudWxsKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJiaXRmaWVsZFwiOiA8bGVuPTAwMDErWD48aWQ9NT48Yml0ZmllbGQ+XG4gKiBAcGFyYW0gIHtCaXRGaWVsZHxCdWZmZXJ9IGJpdGZpZWxkXG4gKi9cbldpcmUucHJvdG90eXBlLmJpdGZpZWxkID0gZnVuY3Rpb24gKGJpdGZpZWxkKSB7XG4gIHRoaXMuX2RlYnVnKCdiaXRmaWVsZCcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJpdGZpZWxkKSkgYml0ZmllbGQgPSBiaXRmaWVsZC5idWZmZXJcbiAgdGhpcy5fbWVzc2FnZSg1LCBbXSwgYml0ZmllbGQpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcInJlcXVlc3RcIjogPGxlbj0wMDEzPjxpZD02PjxpbmRleD48YmVnaW4+PGxlbmd0aD5cbiAqIEBwYXJhbSAge251bWJlcn0gICBpbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSAgIG9mZnNldFxuICogQHBhcmFtICB7bnVtYmVyfSAgIGxlbmd0aFxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbldpcmUucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IGZ1bmN0aW9uICgpIHt9XG4gIGlmICh0aGlzLl9maW5pc2hlZCkgcmV0dXJuIGNiKG5ldyBFcnJvcignd2lyZSBpcyBjbG9zZWQnKSlcbiAgaWYgKHRoaXMucGVlckNob2tpbmcpIHJldHVybiBjYihuZXcgRXJyb3IoJ3BlZXIgaXMgY2hva2luZycpKVxuXG4gIHRoaXMuX2RlYnVnKCdyZXF1ZXN0IGluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQnLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgdGhpcy5yZXF1ZXN0cy5wdXNoKG5ldyBSZXF1ZXN0KGluZGV4LCBvZmZzZXQsIGxlbmd0aCwgY2IpKVxuICB0aGlzLl91cGRhdGVUaW1lb3V0KClcbiAgdGhpcy5fbWVzc2FnZSg2LCBbaW5kZXgsIG9mZnNldCwgbGVuZ3RoXSwgbnVsbClcbn1cblxuLyoqXG4gKiBNZXNzYWdlIFwicGllY2VcIjogPGxlbj0wMDA5K1g+PGlkPTc+PGluZGV4PjxiZWdpbj48YmxvY2s+XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtICB7QnVmZmVyfSBidWZmZXJcbiAqL1xuV2lyZS5wcm90b3R5cGUucGllY2UgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgYnVmZmVyKSB7XG4gIHRoaXMuX2RlYnVnKCdwaWVjZSBpbmRleD0lZCBvZmZzZXQ9JWQnLCBpbmRleCwgb2Zmc2V0KVxuICB0aGlzLnVwbG9hZGVkICs9IGJ1ZmZlci5sZW5ndGhcbiAgdGhpcy51cGxvYWRTcGVlZChidWZmZXIubGVuZ3RoKVxuICB0aGlzLmVtaXQoJ3VwbG9hZCcsIGJ1ZmZlci5sZW5ndGgpXG4gIHRoaXMuX21lc3NhZ2UoNywgW2luZGV4LCBvZmZzZXRdLCBidWZmZXIpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcImNhbmNlbFwiOiA8bGVuPTAwMTM+PGlkPTg+PGluZGV4PjxiZWdpbj48bGVuZ3RoPlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSAge251bWJlcn0gbGVuZ3RoXG4gKi9cbldpcmUucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdGhpcy5fZGVidWcoJ2NhbmNlbCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuICB0aGlzLl9jYWxsYmFjayhcbiAgICBwdWxsKHRoaXMucmVxdWVzdHMsIGluZGV4LCBvZmZzZXQsIGxlbmd0aCksXG4gICAgbmV3IEVycm9yKCdyZXF1ZXN0IHdhcyBjYW5jZWxsZWQnKSxcbiAgICBudWxsXG4gIClcbiAgdGhpcy5fbWVzc2FnZSg4LCBbaW5kZXgsIG9mZnNldCwgbGVuZ3RoXSwgbnVsbClcbn1cblxuLyoqXG4gKiBNZXNzYWdlOiBcInBvcnRcIiA8bGVuPTAwMDM+PGlkPTk+PGxpc3Rlbi1wb3J0PlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcnRcbiAqL1xuV2lyZS5wcm90b3R5cGUucG9ydCA9IGZ1bmN0aW9uIChwb3J0KSB7XG4gIHRoaXMuX2RlYnVnKCdwb3J0ICVkJywgcG9ydClcbiAgdmFyIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShNRVNTQUdFX1BPUlQpXG4gIG1lc3NhZ2Uud3JpdGVVSW50MTZCRShwb3J0LCA1KVxuICB0aGlzLl9wdXNoKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogTWVzc2FnZTogXCJleHRlbmRlZFwiIDxsZW49MDAwNStYPjxpZD0yMD48ZXh0LW51bWJlcj48cGF5bG9hZD5cbiAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IGV4dFxuICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAqL1xuV2lyZS5wcm90b3R5cGUuZXh0ZW5kZWQgPSBmdW5jdGlvbiAoZXh0LCBvYmopIHtcbiAgdGhpcy5fZGVidWcoJ2V4dGVuZGVkIGV4dD0lcycsIGV4dClcbiAgaWYgKHR5cGVvZiBleHQgPT09ICdzdHJpbmcnICYmIHRoaXMucGVlckV4dGVuZGVkTWFwcGluZ1tleHRdKSB7XG4gICAgZXh0ID0gdGhpcy5wZWVyRXh0ZW5kZWRNYXBwaW5nW2V4dF1cbiAgfVxuICBpZiAodHlwZW9mIGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgZXh0SWQgPSBCdWZmZXIuZnJvbShbZXh0XSlcbiAgICB2YXIgYnVmID0gQnVmZmVyLmlzQnVmZmVyKG9iaikgPyBvYmogOiBiZW5jb2RlLmVuY29kZShvYmopXG5cbiAgICB0aGlzLl9tZXNzYWdlKDIwLCBbXSwgQnVmZmVyLmNvbmNhdChbZXh0SWQsIGJ1Zl0pKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGV4dGVuc2lvbjogJyArIGV4dClcbiAgfVxufVxuXG4vKipcbiAqIER1cGxleCBzdHJlYW0gbWV0aG9kLiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHJlbW90ZSBwZWVyIHN0cmVhbSB3YW50cyBkYXRhLiBOby1vcFxuICogc2luY2Ugd2UnbGwganVzdCBwdXNoIGRhdGEgd2hlbmV2ZXIgd2UgZ2V0IGl0LlxuICovXG5XaXJlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICovXG5XaXJlLnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uIChpZCwgbnVtYmVycywgZGF0YSkge1xuICB2YXIgZGF0YUxlbmd0aCA9IGRhdGEgPyBkYXRhLmxlbmd0aCA6IDBcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg1ICsgNCAqIG51bWJlcnMubGVuZ3RoKVxuXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGJ1ZmZlci5sZW5ndGggKyBkYXRhTGVuZ3RoIC0gNCwgMClcbiAgYnVmZmVyWzRdID0gaWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUobnVtYmVyc1tpXSwgNSArIDQgKiBpKVxuICB9XG5cbiAgdGhpcy5fcHVzaChidWZmZXIpXG4gIGlmIChkYXRhKSB0aGlzLl9wdXNoKGRhdGEpXG59XG5cbldpcmUucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgaWYgKHRoaXMuX2ZpbmlzaGVkKSByZXR1cm5cbiAgcmV0dXJuIHRoaXMucHVzaChkYXRhKVxufVxuXG4vL1xuLy8gSU5DT01JTkcgTUVTU0FHRVNcbi8vXG5cbldpcmUucHJvdG90eXBlLl9vbktlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBrZWVwLWFsaXZlJylcbiAgdGhpcy5lbWl0KCdrZWVwLWFsaXZlJylcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGluZm9IYXNoQnVmZmVyLCBwZWVySWRCdWZmZXIsIGV4dGVuc2lvbnMpIHtcbiAgdmFyIGluZm9IYXNoID0gaW5mb0hhc2hCdWZmZXIudG9TdHJpbmcoJ2hleCcpXG4gIHZhciBwZWVySWQgPSBwZWVySWRCdWZmZXIudG9TdHJpbmcoJ2hleCcpXG5cbiAgdGhpcy5fZGVidWcoJ2dvdCBoYW5kc2hha2UgaT0lcyBwPSVzIGV4dHM9JW8nLCBpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKVxuXG4gIHRoaXMucGVlcklkID0gcGVlcklkXG4gIHRoaXMucGVlcklkQnVmZmVyID0gcGVlcklkQnVmZmVyXG4gIHRoaXMucGVlckV4dGVuc2lvbnMgPSBleHRlbnNpb25zXG5cbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKVxuXG4gIHZhciBuYW1lXG4gIGZvciAobmFtZSBpbiB0aGlzLl9leHQpIHtcbiAgICB0aGlzLl9leHRbbmFtZV0ub25IYW5kc2hha2UoaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucylcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLmV4dGVuZGVkICYmIHRoaXMuX2hhbmRzaGFrZVNlbnQgJiZcbiAgICAgICF0aGlzLl9leHRlbmRlZEhhbmRzaGFrZVNlbnQpIHtcbiAgICAvLyBvdXRnb2luZyBjb25uZWN0aW9uXG4gICAgdGhpcy5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlKClcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25DaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVyQ2hva2luZyA9IHRydWVcbiAgdGhpcy5fZGVidWcoJ2dvdCBjaG9rZScpXG4gIHRoaXMuZW1pdCgnY2hva2UnKVxuICB3aGlsZSAodGhpcy5yZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLnJlcXVlc3RzLnNoaWZ0KCksIG5ldyBFcnJvcigncGVlciBpcyBjaG9raW5nJyksIG51bGwpXG4gIH1cbn1cblxuV2lyZS5wcm90b3R5cGUuX29uVW5jaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVyQ2hva2luZyA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCdnb3QgdW5jaG9rZScpXG4gIHRoaXMuZW1pdCgndW5jaG9rZScpXG59XG5cbldpcmUucHJvdG90eXBlLl9vbkludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGVlckludGVyZXN0ZWQgPSB0cnVlXG4gIHRoaXMuX2RlYnVnKCdnb3QgaW50ZXJlc3RlZCcpXG4gIHRoaXMuZW1pdCgnaW50ZXJlc3RlZCcpXG59XG5cbldpcmUucHJvdG90eXBlLl9vblVuaW50ZXJlc3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVySW50ZXJlc3RlZCA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCdnb3QgdW5pbnRlcmVzdGVkJylcbiAgdGhpcy5lbWl0KCd1bmludGVyZXN0ZWQnKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25IYXZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIGlmICh0aGlzLnBlZXJQaWVjZXMuZ2V0KGluZGV4KSkgcmV0dXJuXG4gIHRoaXMuX2RlYnVnKCdnb3QgaGF2ZSAlZCcsIGluZGV4KVxuXG4gIHRoaXMucGVlclBpZWNlcy5zZXQoaW5kZXgsIHRydWUpXG4gIHRoaXMuZW1pdCgnaGF2ZScsIGluZGV4KVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25CaXRGaWVsZCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdGhpcy5wZWVyUGllY2VzID0gbmV3IEJpdEZpZWxkKGJ1ZmZlcilcbiAgdGhpcy5fZGVidWcoJ2dvdCBiaXRmaWVsZCcpXG4gIHRoaXMuZW1pdCgnYml0ZmllbGQnLCB0aGlzLnBlZXJQaWVjZXMpXG59XG5cbldpcmUucHJvdG90eXBlLl9vblJlcXVlc3QgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5hbUNob2tpbmcpIHJldHVyblxuICBzZWxmLl9kZWJ1ZygnZ290IHJlcXVlc3QgaW5kZXg9JWQgb2Zmc2V0PSVkIGxlbmd0aD0lZCcsIGluZGV4LCBvZmZzZXQsIGxlbmd0aClcblxuICB2YXIgcmVzcG9uZCA9IGZ1bmN0aW9uIChlcnIsIGJ1ZmZlcikge1xuICAgIGlmIChyZXF1ZXN0ICE9PSBwdWxsKHNlbGYucGVlclJlcXVlc3RzLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpKSByZXR1cm5cbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5fZGVidWcoJ2Vycm9yIHNhdGlzZnlpbmcgcmVxdWVzdCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkICglcyknLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGVyci5tZXNzYWdlKVxuICAgIHNlbGYucGllY2UoaW5kZXgsIG9mZnNldCwgYnVmZmVyKVxuICB9XG5cbiAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIHJlc3BvbmQpXG4gIHNlbGYucGVlclJlcXVlc3RzLnB1c2gocmVxdWVzdClcbiAgc2VsZi5lbWl0KCdyZXF1ZXN0JywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoLCByZXNwb25kKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25QaWVjZSA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBidWZmZXIpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBwaWVjZSBpbmRleD0lZCBvZmZzZXQ9JWQnLCBpbmRleCwgb2Zmc2V0KVxuICB0aGlzLl9jYWxsYmFjayhwdWxsKHRoaXMucmVxdWVzdHMsIGluZGV4LCBvZmZzZXQsIGJ1ZmZlci5sZW5ndGgpLCBudWxsLCBidWZmZXIpXG4gIHRoaXMuZG93bmxvYWRlZCArPSBidWZmZXIubGVuZ3RoXG4gIHRoaXMuZG93bmxvYWRTcGVlZChidWZmZXIubGVuZ3RoKVxuICB0aGlzLmVtaXQoJ2Rvd25sb2FkJywgYnVmZmVyLmxlbmd0aClcbiAgdGhpcy5lbWl0KCdwaWVjZScsIGluZGV4LCBvZmZzZXQsIGJ1ZmZlcilcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gZnVuY3Rpb24gKGluZGV4LCBvZmZzZXQsIGxlbmd0aCkge1xuICB0aGlzLl9kZWJ1ZygnZ290IGNhbmNlbCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuICBwdWxsKHRoaXMucGVlclJlcXVlc3RzLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG4gIHRoaXMuZW1pdCgnY2FuY2VsJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25Qb3J0ID0gZnVuY3Rpb24gKHBvcnQpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBwb3J0ICVkJywgcG9ydClcbiAgdGhpcy5lbWl0KCdwb3J0JywgcG9ydClcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uRXh0ZW5kZWQgPSBmdW5jdGlvbiAoZXh0LCBidWYpIHtcbiAgaWYgKGV4dCA9PT0gMCkge1xuICAgIHZhciBpbmZvXG4gICAgdHJ5IHtcbiAgICAgIGluZm8gPSBiZW5jb2RlLmRlY29kZShidWYpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnaWdub3JpbmcgaW52YWxpZCBleHRlbmRlZCBoYW5kc2hha2U6ICVzJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICAgIH1cblxuICAgIGlmICghaW5mbykgcmV0dXJuXG4gICAgdGhpcy5wZWVyRXh0ZW5kZWRIYW5kc2hha2UgPSBpbmZvXG5cbiAgICB2YXIgbmFtZVxuICAgIGlmICh0eXBlb2YgaW5mby5tID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChuYW1lIGluIGluZm8ubSkge1xuICAgICAgICB0aGlzLnBlZXJFeHRlbmRlZE1hcHBpbmdbbmFtZV0gPSBOdW1iZXIoaW5mby5tW25hbWVdLnRvU3RyaW5nKCkpXG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiB0aGlzLl9leHQpIHtcbiAgICAgIGlmICh0aGlzLnBlZXJFeHRlbmRlZE1hcHBpbmdbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5fZXh0W25hbWVdLm9uRXh0ZW5kZWRIYW5kc2hha2UodGhpcy5wZWVyRXh0ZW5kZWRIYW5kc2hha2UpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RlYnVnKCdnb3QgZXh0ZW5kZWQgaGFuZHNoYWtlJylcbiAgICB0aGlzLmVtaXQoJ2V4dGVuZGVkJywgJ2hhbmRzaGFrZScsIHRoaXMucGVlckV4dGVuZGVkSGFuZHNoYWtlKVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdKSB7XG4gICAgICBleHQgPSB0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdIC8vIGZyaWVuZGx5IG5hbWUgZm9yIGV4dGVuc2lvblxuICAgICAgaWYgKHRoaXMuX2V4dFtleHRdKSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIGFuIHJlZ2lzdGVyZWQgZXh0ZW5zaW9uIGhhbmRsZXIsIHNvIGNhbGwgaXRcbiAgICAgICAgdGhpcy5fZXh0W2V4dF0ub25NZXNzYWdlKGJ1ZilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGVidWcoJ2dvdCBleHRlbmRlZCBtZXNzYWdlIGV4dD0lcycsIGV4dClcbiAgICB0aGlzLmVtaXQoJ2V4dGVuZGVkJywgZXh0LCBidWYpXG4gIH1cbn1cblxuV2lyZS5wcm90b3R5cGUuX29uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ3JlcXVlc3QgdGltZWQgb3V0JylcbiAgdGhpcy5fY2FsbGJhY2sodGhpcy5yZXF1ZXN0cy5zaGlmdCgpLCBuZXcgRXJyb3IoJ3JlcXVlc3QgaGFzIHRpbWVkIG91dCcpLCBudWxsKVxuICB0aGlzLmVtaXQoJ3RpbWVvdXQnKVxufVxuXG4vKipcbiAqIER1cGxleCBzdHJlYW0gbWV0aG9kLiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHJlbW90ZSBwZWVyIGhhcyBkYXRhIGZvciB1cy4gRGF0YSB0aGF0IHRoZVxuICogcmVtb3RlIHBlZXIgc2VuZHMgZ2V0cyBidWZmZXJlZCAoaS5lLiBub3QgYWN0dWFsbHkgcHJvY2Vzc2VkKSB1bnRpbCB0aGUgcmlnaHQgbnVtYmVyXG4gKiBvZiBieXRlcyBoYXZlIGFycml2ZWQsIGRldGVybWluZWQgYnkgdGhlIGxhc3QgY2FsbCB0byBgdGhpcy5fcGFyc2UobnVtYmVyLCBjYWxsYmFjaylgLlxuICogT25jZSBlbm91Z2ggYnl0ZXMgaGF2ZSBhcnJpdmVkIHRvIHByb2Nlc3MgdGhlIG1lc3NhZ2UsIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICogKGkuZS4gYHRoaXMuX3BhcnNlcmApIGdldHMgY2FsbGVkIHdpdGggdGhlIGZ1bGwgYnVmZmVyIG9mIGRhdGEuXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGRhdGFcbiAqIEBwYXJhbSAge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICovXG5XaXJlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuX2J1ZmZlclNpemUgKz0gZGF0YS5sZW5ndGhcbiAgdGhpcy5fYnVmZmVyLnB1c2goZGF0YSlcblxuICB3aGlsZSAodGhpcy5fYnVmZmVyU2l6ZSA+PSB0aGlzLl9wYXJzZXJTaXplKSB7XG4gICAgdmFyIGJ1ZmZlciA9ICh0aGlzLl9idWZmZXIubGVuZ3RoID09PSAxKVxuICAgICAgPyB0aGlzLl9idWZmZXJbMF1cbiAgICAgIDogQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXIpXG4gICAgdGhpcy5fYnVmZmVyU2l6ZSAtPSB0aGlzLl9wYXJzZXJTaXplXG4gICAgdGhpcy5fYnVmZmVyID0gdGhpcy5fYnVmZmVyU2l6ZVxuICAgICAgPyBbYnVmZmVyLnNsaWNlKHRoaXMuX3BhcnNlclNpemUpXVxuICAgICAgOiBbXVxuICAgIHRoaXMuX3BhcnNlcihidWZmZXIuc2xpY2UoMCwgdGhpcy5fcGFyc2VyU2l6ZSkpXG4gIH1cblxuICBjYihudWxsKSAvLyBTaWduYWwgdGhhdCB3ZSdyZSByZWFkeSBmb3IgbW9yZSBkYXRhXG59XG5cbldpcmUucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBlcnIsIGJ1ZmZlcikge1xuICBpZiAoIXJlcXVlc3QpIHJldHVyblxuXG4gIHRoaXMuX2NsZWFyVGltZW91dCgpXG5cbiAgaWYgKCF0aGlzLnBlZXJDaG9raW5nICYmICF0aGlzLl9maW5pc2hlZCkgdGhpcy5fdXBkYXRlVGltZW91dCgpXG4gIHJlcXVlc3QuY2FsbGJhY2soZXJyLCBidWZmZXIpXG59XG5cbldpcmUucHJvdG90eXBlLl9jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fdGltZW91dCkgcmV0dXJuXG5cbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsXG59XG5cbldpcmUucHJvdG90eXBlLl91cGRhdGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl90aW1lb3V0TXMgfHwgIXNlbGYucmVxdWVzdHMubGVuZ3RoIHx8IHNlbGYuX3RpbWVvdXQpIHJldHVyblxuXG4gIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vblRpbWVvdXQoKVxuICB9LCBzZWxmLl90aW1lb3V0TXMpXG4gIGlmIChzZWxmLl90aW1lb3V0VW5yZWYgJiYgc2VsZi5fdGltZW91dC51bnJlZikgc2VsZi5fdGltZW91dC51bnJlZigpXG59XG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2YgYnl0ZXMgdGhhdCB0aGUgbG9jYWwgcGVlciBpcyB3YWl0aW5nIHRvIHJlY2VpdmUgZnJvbSB0aGUgcmVtb3RlIHBlZXJcbiAqIGluIG9yZGVyIHRvIHBhcnNlIGEgY29tcGxldGUgbWVzc2FnZSwgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgZW5vdWdoXG4gKiBieXRlcyBoYXZlIGFycml2ZWQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHNpemVcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBwYXJzZXJcbiAqL1xuV2lyZS5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24gKHNpemUsIHBhcnNlcikge1xuICB0aGlzLl9wYXJzZXJTaXplID0gc2l6ZVxuICB0aGlzLl9wYXJzZXIgPSBwYXJzZXJcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgYSBtZXNzYWdlLCB0byBkZXRlcm1pbmUgdGhlIGxlbmd0aCBvZiBieXRlcyB0aGF0IG11c3QgYmVcbiAqIHdhaXRlZCBmb3IgaW4gb3JkZXIgdG8gaGF2ZSB0aGUgd2hvbGUgbWVzc2FnZS5cbiAqIEBwYXJhbSAge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbldpcmUucHJvdG90eXBlLl9vbk1lc3NhZ2VMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBidWZmZXIucmVhZFVJbnQzMkJFKDApXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fcGFyc2UobGVuZ3RoLCB0aGlzLl9vbk1lc3NhZ2UpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb25LZWVwQWxpdmUoKVxuICAgIHRoaXMuX3BhcnNlKDQsIHRoaXMuX29uTWVzc2FnZUxlbmd0aClcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBhIG1lc3NhZ2UgZnJvbSB0aGUgcmVtb3RlIHBlZXIuXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGJ1ZmZlclxuICovXG5XaXJlLnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB0aGlzLl9wYXJzZSg0LCB0aGlzLl9vbk1lc3NhZ2VMZW5ndGgpXG4gIHN3aXRjaCAoYnVmZmVyWzBdKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHRoaXMuX29uQ2hva2UoKVxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB0aGlzLl9vblVuY2hva2UoKVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB0aGlzLl9vbkludGVyZXN0ZWQoKVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB0aGlzLl9vblVuaW50ZXJlc3RlZCgpXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIHRoaXMuX29uSGF2ZShidWZmZXIucmVhZFVJbnQzMkJFKDEpKVxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiB0aGlzLl9vbkJpdEZpZWxkKGJ1ZmZlci5zbGljZSgxKSlcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gdGhpcy5fb25SZXF1ZXN0KGJ1ZmZlci5yZWFkVUludDMyQkUoMSksXG4gICAgICAgICAgYnVmZmVyLnJlYWRVSW50MzJCRSg1KSwgYnVmZmVyLnJlYWRVSW50MzJCRSg5KSlcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QaWVjZShidWZmZXIucmVhZFVJbnQzMkJFKDEpLFxuICAgICAgICAgIGJ1ZmZlci5yZWFkVUludDMyQkUoNSksIGJ1ZmZlci5zbGljZSg5KSlcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gdGhpcy5fb25DYW5jZWwoYnVmZmVyLnJlYWRVSW50MzJCRSgxKSxcbiAgICAgICAgICBidWZmZXIucmVhZFVJbnQzMkJFKDUpLCBidWZmZXIucmVhZFVJbnQzMkJFKDkpKVxuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiB0aGlzLl9vblBvcnQoYnVmZmVyLnJlYWRVSW50MTZCRSgxKSlcbiAgICBjYXNlIDIwOlxuICAgICAgcmV0dXJuIHRoaXMuX29uRXh0ZW5kZWQoYnVmZmVyLnJlYWRVSW50OCgxKSwgYnVmZmVyLnNsaWNlKDIpKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLl9kZWJ1ZygnZ290IHVua25vd24gbWVzc2FnZScpXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCd1bmtub3dubWVzc2FnZScsIGJ1ZmZlcilcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fcGFyc2VIYW5kc2hha2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9wYXJzZSgxLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgdmFyIHBzdHJsZW4gPSBidWZmZXIucmVhZFVJbnQ4KDApXG4gICAgc2VsZi5fcGFyc2UocHN0cmxlbiArIDQ4LCBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSBoYW5kc2hha2Uuc2xpY2UoMCwgcHN0cmxlbilcbiAgICAgIGlmIChwcm90b2NvbC50b1N0cmluZygpICE9PSAnQml0VG9ycmVudCBwcm90b2NvbCcpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ0Vycm9yOiB3aXJlIG5vdCBzcGVha2luZyBCaXRUb3JyZW50IHByb3RvY29sICglcyknLCBwcm90b2NvbC50b1N0cmluZygpKVxuICAgICAgICBzZWxmLmVuZCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaGFuZHNoYWtlID0gaGFuZHNoYWtlLnNsaWNlKHBzdHJsZW4pXG4gICAgICBzZWxmLl9vbkhhbmRzaGFrZShoYW5kc2hha2Uuc2xpY2UoOCwgMjgpLCBoYW5kc2hha2Uuc2xpY2UoMjgsIDQ4KSwge1xuICAgICAgICBkaHQ6ICEhKGhhbmRzaGFrZVs3XSAmIDB4MDEpLCAvLyBzZWUgYmVwXzAwMDVcbiAgICAgICAgZXh0ZW5kZWQ6ICEhKGhhbmRzaGFrZVs1XSAmIDB4MTApIC8vIHNlZSBiZXBfMDAxMFxuICAgICAgfSlcbiAgICAgIHNlbGYuX3BhcnNlKDQsIHNlbGYuX29uTWVzc2FnZUxlbmd0aClcbiAgICB9KVxuICB9KVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZVxuXG4gIHRoaXMucHVzaChudWxsKSAvLyBzdHJlYW0gY2Fubm90IGJlIGhhbGYgb3Blbiwgc28gc2lnbmFsIHRoZSBlbmQgb2YgaXRcbiAgd2hpbGUgKHRoaXMucmVhZCgpKSB7fSAvLyBjb25zdW1lIGFuZCBkaXNjYXJkIHRoZSByZXN0IG9mIHRoZSBzdHJlYW0gZGF0YVxuXG4gIGNsZWFySW50ZXJ2YWwodGhpcy5fa2VlcEFsaXZlSW50ZXJ2YWwpXG4gIHRoaXMuX3BhcnNlKE51bWJlci5NQVhfVkFMVUUsIGZ1bmN0aW9uICgpIHt9KVxuICB0aGlzLnBlZXJSZXF1ZXN0cyA9IFtdXG4gIHdoaWxlICh0aGlzLnJlcXVlc3RzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMucmVxdWVzdHMuc2hpZnQoKSwgbmV3IEVycm9yKCd3aXJlIHdhcyBjbG9zZWQnKSwgbnVsbClcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIGFyZ3NbMF0gPSAnWycgKyB0aGlzLl9kZWJ1Z0lkICsgJ10gJyArIGFyZ3NbMF1cbiAgZGVidWcuYXBwbHkobnVsbCwgYXJncylcbn1cblxuZnVuY3Rpb24gcHVsbCAocmVxdWVzdHMsIHBpZWNlLCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlcSA9IHJlcXVlc3RzW2ldXG4gICAgaWYgKHJlcS5waWVjZSAhPT0gcGllY2UgfHwgcmVxLm9mZnNldCAhPT0gb2Zmc2V0IHx8IHJlcS5sZW5ndGggIT09IGxlbmd0aCkgY29udGludWVcblxuICAgIGlmIChpID09PSAwKSByZXF1ZXN0cy5zaGlmdCgpXG4gICAgZWxzZSByZXF1ZXN0cy5zcGxpY2UoaSwgMSlcblxuICAgIHJldHVybiByZXFcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBDbGllbnRcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdiaXR0b3JyZW50LXRyYWNrZXInKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgcGFyYWxsZWwgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwnKVxudmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG52YXIgdW5pcSA9IHJlcXVpcmUoJ3VuaXEnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2xpYi9jb21tb24nKVxudmFyIEhUVFBUcmFja2VyID0gcmVxdWlyZSgnLi9saWIvY2xpZW50L2h0dHAtdHJhY2tlcicpIC8vIGVtcHR5IG9iamVjdCBpbiBicm93c2VyXG52YXIgVURQVHJhY2tlciA9IHJlcXVpcmUoJy4vbGliL2NsaWVudC91ZHAtdHJhY2tlcicpIC8vIGVtcHR5IG9iamVjdCBpbiBicm93c2VyXG52YXIgV2ViU29ja2V0VHJhY2tlciA9IHJlcXVpcmUoJy4vbGliL2NsaWVudC93ZWJzb2NrZXQtdHJhY2tlcicpXG5cbmluaGVyaXRzKENsaWVudCwgRXZlbnRFbWl0dGVyKVxuXG4vKipcbiAqIEJpdFRvcnJlbnQgdHJhY2tlciBjbGllbnQuXG4gKlxuICogRmluZCB0b3JyZW50IHBlZXJzLCB0byBoZWxwIGEgdG9ycmVudCBjbGllbnQgcGFydGljaXBhdGUgaW4gYSB0b3JyZW50IHN3YXJtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBvcHRzLmluZm9IYXNoICAgICAgICAgIHRvcnJlbnQgaW5mbyBoYXNoXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IG9wdHMucGVlcklkICAgICAgICAgICAgcGVlciBpZFxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IG9wdHMuYW5ub3VuY2UgIGFubm91bmNlXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5wb3J0ICAgICAgICAgICAgICAgICAgICAgdG9ycmVudCBjbGllbnQgbGlzdGVuaW5nIHBvcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdHMuZ2V0QW5ub3VuY2VPcHRzICAgICAgICBjYWxsYmFjayB0byBwcm92aWRlIGRhdGEgdG8gdHJhY2tlclxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucnRjQ29uZmlnICAgICAgICAgICAgICAgIFJUQ1BlZXJDb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy53cnRjICAgICAgICAgICAgICAgICAgICAgY3VzdG9tIHdlYnJ0YyBpbXBsICh1c2VmdWwgaW4gbm9kZS5qcylcbiAqL1xuZnVuY3Rpb24gQ2xpZW50IChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgQ2xpZW50KSkgcmV0dXJuIG5ldyBDbGllbnQob3B0cylcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBpZiAoIW9wdHMucGVlcklkKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgcGVlcklkYCBpcyByZXF1aXJlZCcpXG4gIGlmICghb3B0cy5pbmZvSGFzaCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGluZm9IYXNoYCBpcyByZXF1aXJlZCcpXG4gIGlmICghb3B0cy5hbm5vdW5jZSkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGFubm91bmNlYCBpcyByZXF1aXJlZCcpXG4gIGlmICghcHJvY2Vzcy5icm93c2VyICYmICFvcHRzLnBvcnQpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBwb3J0YCBpcyByZXF1aXJlZCcpXG5cbiAgLy8gcmVxdWlyZWRcbiAgc2VsZi5wZWVySWQgPSB0eXBlb2Ygb3B0cy5wZWVySWQgPT09ICdzdHJpbmcnXG4gICAgPyBvcHRzLnBlZXJJZFxuICAgIDogb3B0cy5wZWVySWQudG9TdHJpbmcoJ2hleCcpXG4gIHNlbGYuX3BlZXJJZEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNlbGYucGVlcklkLCAnaGV4JylcbiAgc2VsZi5fcGVlcklkQmluYXJ5ID0gc2VsZi5fcGVlcklkQnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknKVxuXG4gIHNlbGYuaW5mb0hhc2ggPSB0eXBlb2Ygb3B0cy5pbmZvSGFzaCA9PT0gJ3N0cmluZydcbiAgICA/IG9wdHMuaW5mb0hhc2hcbiAgICA6IG9wdHMuaW5mb0hhc2gudG9TdHJpbmcoJ2hleCcpXG4gIHNlbGYuX2luZm9IYXNoQnVmZmVyID0gQnVmZmVyLmZyb20oc2VsZi5pbmZvSGFzaCwgJ2hleCcpXG4gIHNlbGYuX2luZm9IYXNoQmluYXJ5ID0gc2VsZi5faW5mb0hhc2hCdWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpXG5cbiAgc2VsZi5fcG9ydCA9IG9wdHMucG9ydFxuXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcblxuICBzZWxmLl9ydGNDb25maWcgPSBvcHRzLnJ0Y0NvbmZpZ1xuICBzZWxmLl93cnRjID0gb3B0cy53cnRjXG4gIHNlbGYuX2dldEFubm91bmNlT3B0cyA9IG9wdHMuZ2V0QW5ub3VuY2VPcHRzXG5cbiAgZGVidWcoJ25ldyBjbGllbnQgJXMnLCBzZWxmLmluZm9IYXNoKVxuXG4gIHZhciB3ZWJydGNTdXBwb3J0ID0gc2VsZi5fd3J0YyAhPT0gZmFsc2UgJiYgKCEhc2VsZi5fd3J0YyB8fCBQZWVyLldFQlJUQ19TVVBQT1JUKVxuXG4gIHZhciBhbm5vdW5jZSA9ICh0eXBlb2Ygb3B0cy5hbm5vdW5jZSA9PT0gJ3N0cmluZycpXG4gICAgPyBbIG9wdHMuYW5ub3VuY2UgXVxuICAgIDogb3B0cy5hbm5vdW5jZSA9PSBudWxsXG4gICAgICA/IFtdXG4gICAgICA6IG9wdHMuYW5ub3VuY2VcblxuICBhbm5vdW5jZSA9IGFubm91bmNlLm1hcChmdW5jdGlvbiAoYW5ub3VuY2VVcmwpIHtcbiAgICBhbm5vdW5jZVVybCA9IGFubm91bmNlVXJsLnRvU3RyaW5nKClcbiAgICBpZiAoYW5ub3VuY2VVcmxbYW5ub3VuY2VVcmwubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGZyb20gdHJhY2tlcnMgdG8gY2F0Y2ggZHVwbGljYXRlc1xuICAgICAgYW5ub3VuY2VVcmwgPSBhbm5vdW5jZVVybC5zdWJzdHJpbmcoMCwgYW5ub3VuY2VVcmwubGVuZ3RoIC0gMSlcbiAgICB9XG4gICAgcmV0dXJuIGFubm91bmNlVXJsXG4gIH0pXG5cbiAgYW5ub3VuY2UgPSB1bmlxKGFubm91bmNlKVxuXG4gIHNlbGYuX3RyYWNrZXJzID0gYW5ub3VuY2VcbiAgICAubWFwKGZ1bmN0aW9uIChhbm5vdW5jZVVybCkge1xuICAgICAgdmFyIHByb3RvY29sID0gdXJsLnBhcnNlKGFubm91bmNlVXJsKS5wcm90b2NvbFxuICAgICAgaWYgKChwcm90b2NvbCA9PT0gJ2h0dHA6JyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzOicpICYmXG4gICAgICAgICAgdHlwZW9mIEhUVFBUcmFja2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSFRUUFRyYWNrZXIoc2VsZiwgYW5ub3VuY2VVcmwpXG4gICAgICB9IGVsc2UgaWYgKHByb3RvY29sID09PSAndWRwOicgJiYgdHlwZW9mIFVEUFRyYWNrZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVRFBUcmFja2VyKHNlbGYsIGFubm91bmNlVXJsKVxuICAgICAgfSBlbHNlIGlmICgocHJvdG9jb2wgPT09ICd3czonIHx8IHByb3RvY29sID09PSAnd3NzOicpICYmIHdlYnJ0Y1N1cHBvcnQpIHtcbiAgICAgICAgLy8gU2tpcCB3czovLyB0cmFja2VycyBvbiBodHRwczovLyBzaXRlcyBiZWNhdXNlIHRoZXkgdGhyb3cgU2VjdXJpdHlFcnJvclxuICAgICAgICBpZiAocHJvdG9jb2wgPT09ICd3czonICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgbmV4dFRpY2tXYXJuKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHJhY2tlciBwcm90b2NvbDogJyArIGFubm91bmNlVXJsKSlcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2ViU29ja2V0VHJhY2tlcihzZWxmLCBhbm5vdW5jZVVybClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRUaWNrV2FybihuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRyYWNrZXIgcHJvdG9jb2w6ICcgKyBhbm5vdW5jZVVybCkpXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tXYXJuIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNjcmFwZSBhIHRyYWNrZXIgZm9yIGFuIGluZm8gaGFzaCB3aXRob3V0IG5lZWRpbmcgdG9cbiAqIGNyZWF0ZSBhIENsaWVudCwgcGFzcyBpdCBhIHBhcnNlZCB0b3JyZW50LCBldGMuIFN1cHBvcnQgc2NyYXBpbmcgYSB0cmFja2VyIGZvciBtdWx0aXBsZVxuICogdG9ycmVudHMgYXQgdGhlIHNhbWUgdGltZS5cbiAqIEBwYXJhbXMge09iamVjdH0gb3B0c1xuICogQHBhcmFtICB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBvcHRzLmluZm9IYXNoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG9wdHMuYW5ub3VuY2VcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICovXG5DbGllbnQuc2NyYXBlID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIGNiID0gb25jZShjYilcblxuICBpZiAoIW9wdHMuaW5mb0hhc2gpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBpbmZvSGFzaGAgaXMgcmVxdWlyZWQnKVxuICBpZiAoIW9wdHMuYW5ub3VuY2UpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBhbm5vdW5jZWAgaXMgcmVxdWlyZWQnKVxuXG4gIHZhciBjbGllbnRPcHRzID0gZXh0ZW5kKG9wdHMsIHtcbiAgICBpbmZvSGFzaDogQXJyYXkuaXNBcnJheShvcHRzLmluZm9IYXNoKSA/IG9wdHMuaW5mb0hhc2hbMF0gOiBvcHRzLmluZm9IYXNoLFxuICAgIHBlZXJJZDogQnVmZmVyLmZyb20oJzAxMjM0NTY3ODkwMTIzNDU2Nzg5JyksIC8vIGR1bW15IHZhbHVlXG4gICAgcG9ydDogNjg4MSAvLyBkdW1teSB2YWx1ZVxuICB9KVxuXG4gIHZhciBjbGllbnQgPSBuZXcgQ2xpZW50KGNsaWVudE9wdHMpXG4gIGNsaWVudC5vbmNlKCdlcnJvcicsIGNiKVxuXG4gIHZhciBsZW4gPSBBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpID8gb3B0cy5pbmZvSGFzaC5sZW5ndGggOiAxXG4gIHZhciByZXN1bHRzID0ge31cbiAgY2xpZW50Lm9uKCdzY3JhcGUnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGxlbiAtPSAxXG4gICAgcmVzdWx0c1tkYXRhLmluZm9IYXNoXSA9IGRhdGFcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBjbGllbnQuZGVzdHJveSgpXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlc3VsdHMpXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2IobnVsbCwgcmVzdWx0c1trZXlzWzBdXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG51bGwsIHJlc3VsdHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIG9wdHMuaW5mb0hhc2ggPSBBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpXG4gICAgPyBvcHRzLmluZm9IYXNoLm1hcChmdW5jdGlvbiAoaW5mb0hhc2gpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbmZvSGFzaCwgJ2hleCcpXG4gICAgfSlcbiAgICA6IEJ1ZmZlci5mcm9tKG9wdHMuaW5mb0hhc2gsICdoZXgnKVxuICBjbGllbnQuc2NyYXBlKHsgaW5mb0hhc2g6IG9wdHMuaW5mb0hhc2ggfSlcbiAgcmV0dXJuIGNsaWVudFxufVxuXG4vKipcbiAqIFNlbmQgYSBgc3RhcnRgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubGVmdCAoaWYgbm90IHNldCwgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5KVxuICovXG5DbGllbnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKCdzZW5kIGBzdGFydGAnKVxuICBvcHRzID0gc2VsZi5fZGVmYXVsdEFubm91bmNlT3B0cyhvcHRzKVxuICBvcHRzLmV2ZW50ID0gJ3N0YXJ0ZWQnXG4gIHNlbGYuX2Fubm91bmNlKG9wdHMpXG5cbiAgLy8gc3RhcnQgYW5ub3VuY2luZyBvbiBpbnRlcnZhbHNcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHRyYWNrZXIuc2V0SW50ZXJ2YWwoKVxuICB9KVxufVxuXG4vKipcbiAqIFNlbmQgYSBgc3RvcGAgYW5ub3VuY2UgdG8gdGhlIHRyYWNrZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy51cGxvYWRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmRvd25sb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5udW13YW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubGVmdCAoaWYgbm90IHNldCwgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5KVxuICovXG5DbGllbnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NlbmQgYHN0b3BgJylcbiAgb3B0cyA9IHNlbGYuX2RlZmF1bHRBbm5vdW5jZU9wdHMob3B0cylcbiAgb3B0cy5ldmVudCA9ICdzdG9wcGVkJ1xuICBzZWxmLl9hbm5vdW5jZShvcHRzKVxufVxuXG4vKipcbiAqIFNlbmQgYSBgY29tcGxldGVgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubnVtd2FudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmxlZnQgKGlmIG5vdCBzZXQsIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSlcbiAqL1xuQ2xpZW50LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2VuZCBgY29tcGxldGVgJylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cyA9IHNlbGYuX2RlZmF1bHRBbm5vdW5jZU9wdHMob3B0cylcbiAgb3B0cy5ldmVudCA9ICdjb21wbGV0ZWQnXG4gIHNlbGYuX2Fubm91bmNlKG9wdHMpXG59XG5cbi8qKlxuICogU2VuZCBhIGB1cGRhdGVgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubnVtd2FudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmxlZnQgKGlmIG5vdCBzZXQsIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSlcbiAqL1xuQ2xpZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NlbmQgYHVwZGF0ZWAnKVxuICBvcHRzID0gc2VsZi5fZGVmYXVsdEFubm91bmNlT3B0cyhvcHRzKVxuICBpZiAob3B0cy5ldmVudCkgZGVsZXRlIG9wdHMuZXZlbnRcbiAgc2VsZi5fYW5ub3VuY2Uob3B0cylcbn1cblxuQ2xpZW50LnByb3RvdHlwZS5fYW5ub3VuY2UgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIC8vIHRyYWNrZXIgc2hvdWxkIG5vdCBtb2RpZnkgYG9wdHNgIG9iamVjdCwgaXQncyBwYXNzZWQgdG8gYWxsIHRyYWNrZXJzXG4gICAgdHJhY2tlci5hbm5vdW5jZShvcHRzKVxuICB9KVxufVxuXG4vKipcbiAqIFNlbmQgYSBzY3JhcGUgcmVxdWVzdCB0byB0aGUgdHJhY2tlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5DbGllbnQucHJvdG90eXBlLnNjcmFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2VuZCBgc2NyYXBlYCcpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHNlbGYuX3RyYWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrZXIpIHtcbiAgICAvLyB0cmFja2VyIHNob3VsZCBub3QgbW9kaWZ5IGBvcHRzYCBvYmplY3QsIGl0J3MgcGFzc2VkIHRvIGFsbCB0cmFja2Vyc1xuICAgIHRyYWNrZXIuc2NyYXBlKG9wdHMpXG4gIH0pXG59XG5cbkNsaWVudC5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWxNcykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NldEludGVydmFsICVkJywgaW50ZXJ2YWxNcylcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHRyYWNrZXIuc2V0SW50ZXJ2YWwoaW50ZXJ2YWxNcylcbiAgfSlcbn1cblxuQ2xpZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcbiAgZGVidWcoJ2Rlc3Ryb3knKVxuXG4gIHZhciB0YXNrcyA9IHNlbGYuX3RyYWNrZXJzLm1hcChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHRyYWNrZXIuZGVzdHJveShjYilcbiAgICB9XG4gIH0pXG5cbiAgcGFyYWxsZWwodGFza3MsIGNiKVxuXG4gIHNlbGYuX3RyYWNrZXJzID0gW11cbiAgc2VsZi5fZ2V0QW5ub3VuY2VPcHRzID0gbnVsbFxufVxuXG5DbGllbnQucHJvdG90eXBlLl9kZWZhdWx0QW5ub3VuY2VPcHRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgaWYgKG9wdHMubnVtd2FudCA9PSBudWxsKSBvcHRzLm51bXdhbnQgPSBjb21tb24uREVGQVVMVF9BTk5PVU5DRV9QRUVSU1xuXG4gIGlmIChvcHRzLnVwbG9hZGVkID09IG51bGwpIG9wdHMudXBsb2FkZWQgPSAwXG4gIGlmIChvcHRzLmRvd25sb2FkZWQgPT0gbnVsbCkgb3B0cy5kb3dubG9hZGVkID0gMFxuXG4gIGlmIChzZWxmLl9nZXRBbm5vdW5jZU9wdHMpIG9wdHMgPSBleHRlbmQob3B0cywgc2VsZi5fZ2V0QW5ub3VuY2VPcHRzKCkpXG4gIHJldHVybiBvcHRzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFRyYWNrZXJcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5pbmhlcml0cyhUcmFja2VyLCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIFRyYWNrZXIgKGNsaWVudCwgYW5ub3VuY2VVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG4gIHNlbGYuY2xpZW50ID0gY2xpZW50XG4gIHNlbGYuYW5ub3VuY2VVcmwgPSBhbm5vdW5jZVVybFxuXG4gIHNlbGYuaW50ZXJ2YWwgPSBudWxsXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuVHJhY2tlci5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWxNcykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKGludGVydmFsTXMgPT0gbnVsbCkgaW50ZXJ2YWxNcyA9IHNlbGYuREVGQVVMVF9BTk5PVU5DRV9JTlRFUlZBTFxuXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5pbnRlcnZhbClcblxuICBpZiAoaW50ZXJ2YWxNcykge1xuICAgIHNlbGYuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmFubm91bmNlKHNlbGYuY2xpZW50Ll9kZWZhdWx0QW5ub3VuY2VPcHRzKCkpXG4gICAgfSwgaW50ZXJ2YWxNcylcbiAgICBpZiAoc2VsZi5pbnRlcnZhbC51bnJlZikgc2VsZi5pbnRlcnZhbC51bnJlZigpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhY2tlclxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdiaXR0b3JyZW50LXRyYWNrZXI6d2Vic29ja2V0LXRyYWNrZXInKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBoYXQgPSByZXF1aXJlKCdoYXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG52YXIgU29ja2V0ID0gcmVxdWlyZSgnc2ltcGxlLXdlYnNvY2tldCcpXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKVxudmFyIFRyYWNrZXIgPSByZXF1aXJlKCcuL3RyYWNrZXInKVxuXG4vLyBVc2UgYSBzb2NrZXQgcG9vbCwgc28gdHJhY2tlciBjbGllbnRzIHNoYXJlIFdlYlNvY2tldCBvYmplY3RzIGZvciB0aGUgc2FtZSBzZXJ2ZXIuXG4vLyBJbiBwcmFjdGljZSwgV2ViU29ja2V0cyBhcmUgcHJldHR5IHNsb3cgdG8gZXN0YWJsaXNoLCBzbyB0aGlzIGdpdmVzIGEgbmljZSBwZXJmb3JtYW5jZVxuLy8gYm9vc3QsIGFuZCBzYXZlcyBicm93c2VyIHJlc291cmNlcy5cbnZhciBzb2NrZXRQb29sID0ge31cblxudmFyIFJFQ09OTkVDVF9NSU5JTVVNID0gMTUgKiAxMDAwXG52YXIgUkVDT05ORUNUX01BWElNVU0gPSAzMCAqIDYwICogMTAwMFxudmFyIFJFQ09OTkVDVF9WQVJJQU5DRSA9IDMwICogMTAwMFxudmFyIE9GRkVSX1RJTUVPVVQgPSA1MCAqIDEwMDBcblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhY2tlciwgVHJhY2tlcilcblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhY2tlciAoY2xpZW50LCBhbm5vdW5jZVVybCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgVHJhY2tlci5jYWxsKHNlbGYsIGNsaWVudCwgYW5ub3VuY2VVcmwpXG4gIGRlYnVnKCduZXcgd2Vic29ja2V0IHRyYWNrZXIgJXMnLCBhbm5vdW5jZVVybClcblxuICBzZWxmLnBlZXJzID0ge30gLy8gcGVlcnMgKG9mZmVyIGlkIC0+IHBlZXIpXG4gIHNlbGYuc29ja2V0ID0gbnVsbFxuXG4gIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2VcbiAgc2VsZi5yZXRyaWVzID0gMFxuICBzZWxmLnJlY29ubmVjdFRpbWVyID0gbnVsbFxuXG4gIHNlbGYuX29wZW5Tb2NrZXQoKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5ERUZBVUxUX0FOTk9VTkNFX0lOVEVSVkFMID0gMzAgKiAxMDAwIC8vIDMwIHNlY29uZHNcblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuYW5ub3VuY2UgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkIHx8IHNlbGYucmVjb25uZWN0aW5nKSByZXR1cm5cbiAgaWYgKCFzZWxmLnNvY2tldC5jb25uZWN0ZWQpIHtcbiAgICBzZWxmLnNvY2tldC5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5hbm5vdW5jZShvcHRzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcGFyYW1zID0gZXh0ZW5kKG9wdHMsIHtcbiAgICBhY3Rpb246ICdhbm5vdW5jZScsXG4gICAgaW5mb19oYXNoOiBzZWxmLmNsaWVudC5faW5mb0hhc2hCaW5hcnksXG4gICAgcGVlcl9pZDogc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeVxuICB9KVxuICBpZiAoc2VsZi5fdHJhY2tlcklkKSBwYXJhbXMudHJhY2tlcmlkID0gc2VsZi5fdHJhY2tlcklkXG5cbiAgaWYgKG9wdHMuZXZlbnQgPT09ICdzdG9wcGVkJykge1xuICAgIC8vIERvbid0IGluY2x1ZGUgb2ZmZXJzIHdpdGggJ3N0b3BwZWQnIGV2ZW50XG4gICAgc2VsZi5fc2VuZChwYXJhbXMpXG4gIH0gZWxzZSB7XG4gICAgLy8gTGltaXQgdGhlIG51bWJlciBvZiBvZmZlcnMgdGhhdCBhcmUgZ2VuZXJhdGVkLCBzaW5jZSBpdCBjYW4gYmUgc2xvd1xuICAgIHZhciBudW13YW50ID0gTWF0aC5taW4ob3B0cy5udW13YW50LCA1KVxuXG4gICAgc2VsZi5fZ2VuZXJhdGVPZmZlcnMobnVtd2FudCwgZnVuY3Rpb24gKG9mZmVycykge1xuICAgICAgcGFyYW1zLm51bXdhbnQgPSBudW13YW50XG4gICAgICBwYXJhbXMub2ZmZXJzID0gb2ZmZXJzXG4gICAgICBzZWxmLl9zZW5kKHBhcmFtcylcbiAgICB9KVxuICB9XG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLnNjcmFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQgfHwgc2VsZi5yZWNvbm5lY3RpbmcpIHJldHVyblxuICBpZiAoIXNlbGYuc29ja2V0LmNvbm5lY3RlZCkge1xuICAgIHNlbGYuc29ja2V0Lm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNjcmFwZShvcHRzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgaW5mb0hhc2hlcyA9IChBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpICYmIG9wdHMuaW5mb0hhc2gubGVuZ3RoID4gMClcbiAgICA/IG9wdHMuaW5mb0hhc2gubWFwKGZ1bmN0aW9uIChpbmZvSGFzaCkge1xuICAgICAgcmV0dXJuIGluZm9IYXNoLnRvU3RyaW5nKCdiaW5hcnknKVxuICAgIH0pXG4gICAgOiAob3B0cy5pbmZvSGFzaCAmJiBvcHRzLmluZm9IYXNoLnRvU3RyaW5nKCdiaW5hcnknKSkgfHwgc2VsZi5jbGllbnQuX2luZm9IYXNoQmluYXJ5XG4gIHZhciBwYXJhbXMgPSB7XG4gICAgYWN0aW9uOiAnc2NyYXBlJyxcbiAgICBpbmZvX2hhc2g6IGluZm9IYXNoZXNcbiAgfVxuXG4gIHNlbGYuX3NlbmQocGFyYW1zKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobnVsbClcblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuICBjbGVhckludGVydmFsKHNlbGYuaW50ZXJ2YWwpXG4gIGNsZWFyVGltZW91dChzZWxmLnJlY29ubmVjdFRpbWVyKVxuXG4gIGlmIChzZWxmLnNvY2tldCkge1xuICAgIHNlbGYuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0Jywgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQpXG4gICAgc2VsZi5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzZWxmLl9vblNvY2tldERhdGFCb3VuZClcbiAgICBzZWxmLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzZWxmLl9vblNvY2tldENsb3NlQm91bmQpXG4gICAgc2VsZi5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fb25Tb2NrZXRFcnJvckJvdW5kKVxuICB9XG5cbiAgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQgPSBudWxsXG4gIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZCA9IG51bGxcbiAgc2VsZi5fb25Tb2NrZXREYXRhQm91bmQgPSBudWxsXG4gIHNlbGYuX29uU29ja2V0Q2xvc2VCb3VuZCA9IG51bGxcblxuICAvLyBEZXN0cm95IHBlZXJzXG4gIGZvciAodmFyIHBlZXJJZCBpbiBzZWxmLnBlZXJzKSB7XG4gICAgdmFyIHBlZXIgPSBzZWxmLnBlZXJzW3BlZXJJZF1cbiAgICBjbGVhclRpbWVvdXQocGVlci50cmFja2VyVGltZW91dClcbiAgICBwZWVyLmRlc3Ryb3koKVxuICB9XG4gIHNlbGYucGVlcnMgPSBudWxsXG5cbiAgaWYgKHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0pIHtcbiAgICBzb2NrZXRQb29sW3NlbGYuYW5ub3VuY2VVcmxdLmNvbnN1bWVycyAtPSAxXG4gIH1cblxuICBpZiAoc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXS5jb25zdW1lcnMgPT09IDApIHtcbiAgICBkZWxldGUgc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXVxuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuc29ja2V0Lm9uKCdlcnJvcicsIG5vb3ApIC8vIGlnbm9yZSBhbGwgZnV0dXJlIGVycm9yc1xuICAgICAgc2VsZi5zb2NrZXQuZGVzdHJveShjYilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBzZWxmLnNvY2tldCA9IG51bGxcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29wZW5Tb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgaWYgKCFzZWxmLnBlZXJzKSBzZWxmLnBlZXJzID0ge31cblxuICBzZWxmLl9vblNvY2tldENvbm5lY3RCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vblNvY2tldENvbm5lY3QoKVxuICB9XG4gIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9vblNvY2tldEVycm9yKGVycilcbiAgfVxuICBzZWxmLl9vblNvY2tldERhdGFCb3VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5fb25Tb2NrZXREYXRhKGRhdGEpXG4gIH1cbiAgc2VsZi5fb25Tb2NrZXRDbG9zZUJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uU29ja2V0Q2xvc2UoKVxuICB9XG5cbiAgc2VsZi5zb2NrZXQgPSBzb2NrZXRQb29sW3NlbGYuYW5ub3VuY2VVcmxdXG4gIGlmIChzZWxmLnNvY2tldCkge1xuICAgIHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0uY29uc3VtZXJzICs9IDFcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNvY2tldCA9IHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0gPSBuZXcgU29ja2V0KHNlbGYuYW5ub3VuY2VVcmwpXG4gICAgc2VsZi5zb2NrZXQuY29uc3VtZXJzID0gMVxuICAgIHNlbGYuc29ja2V0Lm9uKCdjb25uZWN0Jywgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQpXG4gIH1cblxuICBzZWxmLnNvY2tldC5vbignZGF0YScsIHNlbGYuX29uU29ja2V0RGF0YUJvdW5kKVxuICBzZWxmLnNvY2tldC5vbignY2xvc2UnLCBzZWxmLl9vblNvY2tldENsb3NlQm91bmQpXG4gIHNlbGYuc29ja2V0Lm9uKCdlcnJvcicsIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZClcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0Q29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgaWYgKHNlbGYucmVjb25uZWN0aW5nKSB7XG4gICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHNlbGYucmV0cmllcyA9IDBcbiAgICBzZWxmLmFubm91bmNlKHNlbGYuY2xpZW50Ll9kZWZhdWx0QW5ub3VuY2VPcHRzKCkpXG4gIH1cbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHRyeSB7XG4gICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc2VsZi5jbGllbnQuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignSW52YWxpZCB0cmFja2VyIHJlc3BvbnNlJykpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZGF0YS5hY3Rpb24gPT09ICdhbm5vdW5jZScpIHtcbiAgICBzZWxmLl9vbkFubm91bmNlUmVzcG9uc2UoZGF0YSlcbiAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbiA9PT0gJ3NjcmFwZScpIHtcbiAgICBzZWxmLl9vblNjcmFwZVJlc3BvbnNlKGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fb25Tb2NrZXRFcnJvcihuZXcgRXJyb3IoJ2ludmFsaWQgYWN0aW9uIGluIFdTIHJlc3BvbnNlOiAnICsgZGF0YS5hY3Rpb24pKVxuICB9XG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLl9vbkFubm91bmNlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoZGF0YS5pbmZvX2hhc2ggIT09IHNlbGYuY2xpZW50Ll9pbmZvSGFzaEJpbmFyeSkge1xuICAgIGRlYnVnKFxuICAgICAgJ2lnbm9yaW5nIHdlYnNvY2tldCBkYXRhIGZyb20gJXMgZm9yICVzIChsb29raW5nIGZvciAlczogcmV1c2VkIHNvY2tldCknLFxuICAgICAgc2VsZi5hbm5vdW5jZVVybCwgY29tbW9uLmJpbmFyeVRvSGV4KGRhdGEuaW5mb19oYXNoKSwgc2VsZi5jbGllbnQuaW5mb0hhc2hcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZGF0YS5wZWVyX2lkICYmIGRhdGEucGVlcl9pZCA9PT0gc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeSkge1xuICAgIC8vIGlnbm9yZSBvZmZlcnMvYW5zd2VycyBmcm9tIHRoaXMgY2xpZW50XG4gICAgcmV0dXJuXG4gIH1cblxuICBkZWJ1ZyhcbiAgICAncmVjZWl2ZWQgJXMgZnJvbSAlcyBmb3IgJXMnLFxuICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpLCBzZWxmLmFubm91bmNlVXJsLCBzZWxmLmNsaWVudC5pbmZvSGFzaFxuICApXG5cbiAgdmFyIGZhaWx1cmUgPSBkYXRhWydmYWlsdXJlIHJlYXNvbiddXG4gIGlmIChmYWlsdXJlKSByZXR1cm4gc2VsZi5jbGllbnQuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcihmYWlsdXJlKSlcblxuICB2YXIgd2FybmluZyA9IGRhdGFbJ3dhcm5pbmcgbWVzc2FnZSddXG4gIGlmICh3YXJuaW5nKSBzZWxmLmNsaWVudC5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKHdhcm5pbmcpKVxuXG4gIHZhciBpbnRlcnZhbCA9IGRhdGEuaW50ZXJ2YWwgfHwgZGF0YVsnbWluIGludGVydmFsJ11cbiAgaWYgKGludGVydmFsKSBzZWxmLnNldEludGVydmFsKGludGVydmFsICogMTAwMClcblxuICB2YXIgdHJhY2tlcklkID0gZGF0YVsndHJhY2tlciBpZCddXG4gIGlmICh0cmFja2VySWQpIHtcbiAgICAvLyBJZiBhYnNlbnQsIGRvIG5vdCBkaXNjYXJkIHByZXZpb3VzIHRyYWNrZXJJZCB2YWx1ZVxuICAgIHNlbGYuX3RyYWNrZXJJZCA9IHRyYWNrZXJJZFxuICB9XG5cbiAgaWYgKGRhdGEuY29tcGxldGUgIT0gbnVsbCkge1xuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3VwZGF0ZScsIHtcbiAgICAgIGFubm91bmNlOiBzZWxmLmFubm91bmNlVXJsLFxuICAgICAgY29tcGxldGU6IGRhdGEuY29tcGxldGUsXG4gICAgICBpbmNvbXBsZXRlOiBkYXRhLmluY29tcGxldGVcbiAgICB9KVxuICB9XG5cbiAgdmFyIHBlZXJcbiAgaWYgKGRhdGEub2ZmZXIgJiYgZGF0YS5wZWVyX2lkKSB7XG4gICAgZGVidWcoJ2NyZWF0aW5nIHBlZXIgKGZyb20gcmVtb3RlIG9mZmVyKScpXG4gICAgcGVlciA9IG5ldyBQZWVyKHtcbiAgICAgIHRyaWNrbGU6IGZhbHNlLFxuICAgICAgY29uZmlnOiBzZWxmLmNsaWVudC5fcnRjQ29uZmlnLFxuICAgICAgd3J0Yzogc2VsZi5jbGllbnQuX3dydGNcbiAgICB9KVxuICAgIHBlZXIuaWQgPSBjb21tb24uYmluYXJ5VG9IZXgoZGF0YS5wZWVyX2lkKVxuICAgIHBlZXIub25jZSgnc2lnbmFsJywgZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgYWN0aW9uOiAnYW5ub3VuY2UnLFxuICAgICAgICBpbmZvX2hhc2g6IHNlbGYuY2xpZW50Ll9pbmZvSGFzaEJpbmFyeSxcbiAgICAgICAgcGVlcl9pZDogc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeSxcbiAgICAgICAgdG9fcGVlcl9pZDogZGF0YS5wZWVyX2lkLFxuICAgICAgICBhbnN3ZXI6IGFuc3dlcixcbiAgICAgICAgb2ZmZXJfaWQ6IGRhdGEub2ZmZXJfaWRcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLl90cmFja2VySWQpIHBhcmFtcy50cmFja2VyaWQgPSBzZWxmLl90cmFja2VySWRcbiAgICAgIHNlbGYuX3NlbmQocGFyYW1zKVxuICAgIH0pXG4gICAgcGVlci5zaWduYWwoZGF0YS5vZmZlcilcbiAgICBzZWxmLmNsaWVudC5lbWl0KCdwZWVyJywgcGVlcilcbiAgfVxuXG4gIGlmIChkYXRhLmFuc3dlciAmJiBkYXRhLnBlZXJfaWQpIHtcbiAgICB2YXIgb2ZmZXJJZCA9IGNvbW1vbi5iaW5hcnlUb0hleChkYXRhLm9mZmVyX2lkKVxuICAgIHBlZXIgPSBzZWxmLnBlZXJzW29mZmVySWRdXG4gICAgaWYgKHBlZXIpIHtcbiAgICAgIHBlZXIuaWQgPSBjb21tb24uYmluYXJ5VG9IZXgoZGF0YS5wZWVyX2lkKVxuICAgICAgcGVlci5zaWduYWwoZGF0YS5hbnN3ZXIpXG4gICAgICBzZWxmLmNsaWVudC5lbWl0KCdwZWVyJywgcGVlcilcblxuICAgICAgY2xlYXJUaW1lb3V0KHBlZXIudHJhY2tlclRpbWVvdXQpXG4gICAgICBwZWVyLnRyYWNrZXJUaW1lb3V0ID0gbnVsbFxuICAgICAgZGVsZXRlIHNlbGYucGVlcnNbb2ZmZXJJZF1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2dvdCB1bmV4cGVjdGVkIGFuc3dlcjogJyArIEpTT04uc3RyaW5naWZ5KGRhdGEuYW5zd2VyKSlcbiAgICB9XG4gIH1cbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU2NyYXBlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGF0YSA9IGRhdGEuZmlsZXMgfHwge31cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ2ludmFsaWQgc2NyYXBlIHJlc3BvbnNlJykpXG4gICAgcmV0dXJuXG4gIH1cblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGluZm9IYXNoKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gZGF0YVtpbmZvSGFzaF1cbiAgICAvLyBUT0RPOiBvcHRpb25hbGx5IGhhbmRsZSBkYXRhLmZsYWdzLm1pbl9yZXF1ZXN0X2ludGVydmFsXG4gICAgLy8gKHNlcGFyYXRlIGZyb20gYW5ub3VuY2UgaW50ZXJ2YWwpXG4gICAgc2VsZi5jbGllbnQuZW1pdCgnc2NyYXBlJywge1xuICAgICAgYW5ub3VuY2U6IHNlbGYuYW5ub3VuY2VVcmwsXG4gICAgICBpbmZvSGFzaDogY29tbW9uLmJpbmFyeVRvSGV4KGluZm9IYXNoKSxcbiAgICAgIGNvbXBsZXRlOiByZXNwb25zZS5jb21wbGV0ZSxcbiAgICAgIGluY29tcGxldGU6IHJlc3BvbnNlLmluY29tcGxldGUsXG4gICAgICBkb3dubG9hZGVkOiByZXNwb25zZS5kb3dubG9hZGVkXG4gICAgfSlcbiAgfSlcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3koKVxuICBzZWxmLl9zdGFydFJlY29ubmVjdFRpbWVyKClcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3koKVxuICAvLyBlcnJvcnMgd2lsbCBvZnRlbiBoYXBwZW4gaWYgYSB0cmFja2VyIGlzIG9mZmxpbmUsIHNvIGRvbid0IHRyZWF0IGl0IGFzIGZhdGFsXG4gIHNlbGYuY2xpZW50LmVtaXQoJ3dhcm5pbmcnLCBlcnIpXG4gIHNlbGYuX3N0YXJ0UmVjb25uZWN0VGltZXIoKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fc3RhcnRSZWNvbm5lY3RUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBtcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFJFQ09OTkVDVF9WQVJJQU5DRSkgKyBNYXRoLm1pbihNYXRoLnBvdygyLCBzZWxmLnJldHJpZXMpICogUkVDT05ORUNUX01JTklNVU0sIFJFQ09OTkVDVF9NQVhJTVVNKVxuXG4gIHNlbGYucmVjb25uZWN0aW5nID0gdHJ1ZVxuICBjbGVhclRpbWVvdXQoc2VsZi5yZWNvbm5lY3RUaW1lcilcbiAgc2VsZi5yZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYucmV0cmllcysrXG4gICAgc2VsZi5fb3BlblNvY2tldCgpXG4gIH0sIG1zKVxuICBpZiAoc2VsZi5yZWNvbm5lY3RUaW1lci51bnJlZikgc2VsZi5yZWNvbm5lY3RUaW1lci51bnJlZigpXG5cbiAgZGVidWcoJ3JlY29ubmVjdGluZyBzb2NrZXQgaW4gJXMgbXMnLCBtcylcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHZhciBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKVxuICBkZWJ1Zygnc2VuZCAlcycsIG1lc3NhZ2UpXG4gIHNlbGYuc29ja2V0LnNlbmQobWVzc2FnZSlcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX2dlbmVyYXRlT2ZmZXJzID0gZnVuY3Rpb24gKG51bXdhbnQsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgb2ZmZXJzID0gW11cbiAgZGVidWcoJ2dlbmVyYXRpbmcgJXMgb2ZmZXJzJywgbnVtd2FudClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bXdhbnQ7ICsraSkge1xuICAgIGdlbmVyYXRlT2ZmZXIoKVxuICB9XG4gIGNoZWNrRG9uZSgpXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVPZmZlciAoKSB7XG4gICAgdmFyIG9mZmVySWQgPSBoYXQoMTYwKVxuICAgIGRlYnVnKCdjcmVhdGluZyBwZWVyIChmcm9tIF9nZW5lcmF0ZU9mZmVycyknKVxuICAgIHZhciBwZWVyID0gc2VsZi5wZWVyc1tvZmZlcklkXSA9IG5ldyBQZWVyKHtcbiAgICAgIGluaXRpYXRvcjogdHJ1ZSxcbiAgICAgIHRyaWNrbGU6IGZhbHNlLFxuICAgICAgY29uZmlnOiBzZWxmLmNsaWVudC5fcnRjQ29uZmlnLFxuICAgICAgd3J0Yzogc2VsZi5jbGllbnQuX3dydGNcbiAgICB9KVxuICAgIHBlZXIub25jZSgnc2lnbmFsJywgZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICBvZmZlcnMucHVzaCh7XG4gICAgICAgIG9mZmVyOiBvZmZlcixcbiAgICAgICAgb2ZmZXJfaWQ6IGNvbW1vbi5oZXhUb0JpbmFyeShvZmZlcklkKVxuICAgICAgfSlcbiAgICAgIGNoZWNrRG9uZSgpXG4gICAgfSlcbiAgICBwZWVyLnRyYWNrZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygndHJhY2tlciB0aW1lb3V0OiBkZXN0cm95aW5nIHBlZXInKVxuICAgICAgcGVlci50cmFja2VyVGltZW91dCA9IG51bGxcbiAgICAgIGRlbGV0ZSBzZWxmLnBlZXJzW29mZmVySWRdXG4gICAgICBwZWVyLmRlc3Ryb3koKVxuICAgIH0sIE9GRkVSX1RJTUVPVVQpXG4gICAgaWYgKHBlZXIudHJhY2tlclRpbWVvdXQudW5yZWYpIHBlZXIudHJhY2tlclRpbWVvdXQudW5yZWYoKVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEb25lICgpIHtcbiAgICBpZiAob2ZmZXJzLmxlbmd0aCA9PT0gbnVtd2FudCkge1xuICAgICAgZGVidWcoJ2dlbmVyYXRlZCAlcyBvZmZlcnMnLCBudW13YW50KVxuICAgICAgY2Iob2ZmZXJzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iLCIvKipcbiAqIEZ1bmN0aW9ucy9jb25zdGFudHMgbmVlZGVkIGJ5IGJvdGggdGhlIGNsaWVudCBhbmQgc2VydmVyLlxuICovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kL211dGFibGUnKVxuXG5leHBvcnRzLkRFRkFVTFRfQU5OT1VOQ0VfUEVFUlMgPSA1MFxuZXhwb3J0cy5NQVhfQU5OT1VOQ0VfUEVFUlMgPSA4MlxuXG5leHBvcnRzLmJpbmFyeVRvSGV4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKVxuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICdiaW5hcnknKS50b1N0cmluZygnaGV4Jylcbn1cblxuZXhwb3J0cy5oZXhUb0JpbmFyeSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cilcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAnaGV4JykudG9TdHJpbmcoJ2JpbmFyeScpXG59XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbW1vbi1ub2RlJylcbmV4dGVuZChleHBvcnRzLCBjb25maWcpXG4iLCIvKiBnbG9iYWwgQmxvYiwgRmlsZVJlYWRlciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2JUb0J1ZmZlciAoYmxvYiwgY2IpIHtcbiAgaWYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyB8fCAhKGJsb2IgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIEJsb2InKVxuICB9XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG5cbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICBmdW5jdGlvbiBvbkxvYWRFbmQgKGUpIHtcbiAgICByZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG9uTG9hZEVuZCwgZmFsc2UpXG4gICAgaWYgKGUuZXJyb3IpIGNiKGUuZXJyb3IpXG4gICAgZWxzZSBjYihudWxsLCBuZXcgQnVmZmVyKHJlYWRlci5yZXN1bHQpKVxuICB9XG5cbiAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBvbkxvYWRFbmQsIGZhbHNlKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbn1cbiIsIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm07XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJ2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbG9jaztcbmluaGVyaXRzKEJsb2NrLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBCbG9jayAoc2l6ZSwgb3B0cykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCbG9jaykpIHJldHVybiBuZXcgQmxvY2soc2l6ZSwgb3B0cyk7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcyk7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0gc2l6ZTtcbiAgICAgICAgc2l6ZSA9IG9wdHMuc2l6ZTtcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZSB8fCA1MTI7XG4gICAgXG4gICAgaWYgKG9wdHMubm9wYWQpIHRoaXMuX3plcm9QYWRkaW5nID0gZmFsc2U7XG4gICAgZWxzZSB0aGlzLl96ZXJvUGFkZGluZyA9IGRlZmluZWQob3B0cy56ZXJvUGFkZGluZywgdHJ1ZSk7XG4gICAgXG4gICAgdGhpcy5fYnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbn1cblxuQmxvY2sucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoYnVmLCBlbmMsIG5leHQpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVyZWQucHVzaChidWYpO1xuICAgIFxuICAgIHdoaWxlICh0aGlzLl9idWZmZXJlZEJ5dGVzID49IHRoaXMuc2l6ZSkge1xuICAgICAgICB2YXIgYiA9IEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmZmVyZWQpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHRoaXMuc2l6ZTtcbiAgICAgICAgdGhpcy5wdXNoKGIuc2xpY2UoMCwgdGhpcy5zaXplKSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkID0gWyBiLnNsaWNlKHRoaXMuc2l6ZSwgYi5sZW5ndGgpIF07XG4gICAgfVxuICAgIG5leHQoKTtcbn07XG5cbkJsb2NrLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgJiYgdGhpcy5femVyb1BhZGRpbmcpIHtcbiAgICAgICAgdmFyIHplcm9lcyA9IG5ldyBCdWZmZXIodGhpcy5zaXplIC0gdGhpcy5fYnVmZmVyZWRCeXRlcyk7XG4gICAgICAgIHplcm9lcy5maWxsKDApO1xuICAgICAgICB0aGlzLl9idWZmZXJlZC5wdXNoKHplcm9lcyk7XG4gICAgICAgIHRoaXMucHVzaChCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZmZlcmVkKSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcykge1xuICAgICAgICB0aGlzLnB1c2goQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXJlZCkpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucHVzaChudWxsKTtcbn07XG4iLCIiLCIndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyO1xudmFyIFNsb3dCdWZmZXIgPSBidWZmZXIuU2xvd0J1ZmZlcjtcbnZhciBNQVhfTEVOID0gYnVmZmVyLmtNYXhMZW5ndGggfHwgMjE0NzQ4MzY0NztcbmV4cG9ydHMuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBub3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHZhciBlbmMgPSBlbmNvZGluZztcbiAgdmFyIF9maWxsID0gZmlsbDtcbiAgaWYgKF9maWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmMgPSB1bmRlZmluZWQ7XG4gICAgX2ZpbGwgPSAwO1xuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICBpZiAodHlwZW9mIF9maWxsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBmaWxsQnVmID0gbmV3IEJ1ZmZlcihfZmlsbCwgZW5jKTtcbiAgICB2YXIgZmxlbiA9IGZpbGxCdWYubGVuZ3RoO1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IHNpemUpIHtcbiAgICAgIGJ1ZltpXSA9IGZpbGxCdWZbaSAlIGZsZW5dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbChfZmlsbCk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG59XG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiAoIWdsb2JhbC5VaW50OEFycmF5IHx8IFVpbnQ4QXJyYXkuZnJvbSAhPT0gQnVmZmVyLmZyb20pKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBvZmZzZXQgPSBlbmNvZGluZ09yT2Zmc2V0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGxlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPj0gdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChsZW4gPiB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgdmFsdWUuY29weShvdXQsIDAsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsICcgKyAnQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKTtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gYWxsb2NVbnNhZmVTbG93KHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3coc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID49IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc2l6ZSk7XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgZm91bmRJbmRleCA9IC0xXG4gIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlYWQoYXJyLCBieXRlT2Zmc2V0ICsgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIChieXRlT2Zmc2V0ICsgZm91bmRJbmRleCkgKiBpbmRleFNpemVcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZylcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgaSsrKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCIxMDBcIjogXCJDb250aW51ZVwiLFxuICBcIjEwMVwiOiBcIlN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgXCIxMDJcIjogXCJQcm9jZXNzaW5nXCIsXG4gIFwiMjAwXCI6IFwiT0tcIixcbiAgXCIyMDFcIjogXCJDcmVhdGVkXCIsXG4gIFwiMjAyXCI6IFwiQWNjZXB0ZWRcIixcbiAgXCIyMDNcIjogXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLFxuICBcIjIwNFwiOiBcIk5vIENvbnRlbnRcIixcbiAgXCIyMDVcIjogXCJSZXNldCBDb250ZW50XCIsXG4gIFwiMjA2XCI6IFwiUGFydGlhbCBDb250ZW50XCIsXG4gIFwiMjA3XCI6IFwiTXVsdGktU3RhdHVzXCIsXG4gIFwiMjA4XCI6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICBcIjIyNlwiOiBcIklNIFVzZWRcIixcbiAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gIFwiMzAxXCI6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgXCIzMDJcIjogXCJGb3VuZFwiLFxuICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICBcIjMwNFwiOiBcIk5vdCBNb2RpZmllZFwiLFxuICBcIjMwNVwiOiBcIlVzZSBQcm94eVwiLFxuICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICBcIjMwOFwiOiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICBcIjQwMFwiOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gIFwiNDAyXCI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICBcIjQwM1wiOiBcIkZvcmJpZGRlblwiLFxuICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICBcIjQwNVwiOiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICBcIjQwNlwiOiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MDhcIjogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgXCI0MDlcIjogXCJDb25mbGljdFwiLFxuICBcIjQxMFwiOiBcIkdvbmVcIixcbiAgXCI0MTFcIjogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgXCI0MTJcIjogXCJQcmVjb25kaXRpb24gRmFpbGVkXCIsXG4gIFwiNDEzXCI6IFwiUGF5bG9hZCBUb28gTGFyZ2VcIixcbiAgXCI0MTRcIjogXCJVUkkgVG9vIExvbmdcIixcbiAgXCI0MTVcIjogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gIFwiNDE2XCI6IFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gIFwiNDE3XCI6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gIFwiNDE4XCI6IFwiSSdtIGEgdGVhcG90XCIsXG4gIFwiNDIxXCI6IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiLFxuICBcIjQyMlwiOiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXG4gIFwiNDIzXCI6IFwiTG9ja2VkXCIsXG4gIFwiNDI0XCI6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgXCI0MjVcIjogXCJVbm9yZGVyZWQgQ29sbGVjdGlvblwiLFxuICBcIjQyNlwiOiBcIlVwZ3JhZGUgUmVxdWlyZWRcIixcbiAgXCI0MjhcIjogXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MjlcIjogXCJUb28gTWFueSBSZXF1ZXN0c1wiLFxuICBcIjQzMVwiOiBcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcIixcbiAgXCI1MDBcIjogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgXCI1MDFcIjogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgXCI1MDJcIjogXCJCYWQgR2F0ZXdheVwiLFxuICBcIjUwM1wiOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgXCI1MDRcIjogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICBcIjUwNlwiOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gIFwiNTA3XCI6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgXCI1MDhcIjogXCJMb29wIERldGVjdGVkXCIsXG4gIFwiNTA5XCI6IFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXCIsXG4gIFwiNTEwXCI6IFwiTm90IEV4dGVuZGVkXCIsXG4gIFwiNTExXCI6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IENodW5rU3RvcmVXcml0ZVN0cmVhbVxuXG52YXIgQmxvY2tTdHJlYW0gPSByZXF1aXJlKCdibG9jay1zdHJlYW0yJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG5pbmhlcml0cyhDaHVua1N0b3JlV3JpdGVTdHJlYW0sIHN0cmVhbS5Xcml0YWJsZSlcblxuZnVuY3Rpb24gQ2h1bmtTdG9yZVdyaXRlU3RyZWFtIChzdG9yZSwgY2h1bmtMZW5ndGgsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBDaHVua1N0b3JlV3JpdGVTdHJlYW0pKSB7XG4gICAgcmV0dXJuIG5ldyBDaHVua1N0b3JlV3JpdGVTdHJlYW0oc3RvcmUsIGNodW5rTGVuZ3RoLCBvcHRzKVxuICB9XG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYsIG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgaWYgKCFzdG9yZSB8fCAhc3RvcmUucHV0IHx8ICFzdG9yZS5nZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gYWJzdHJhY3QtY2h1bmstc3RvcmUgY29tcGxpYW50IHN0b3JlJylcbiAgfVxuICBjaHVua0xlbmd0aCA9IE51bWJlcihjaHVua0xlbmd0aClcbiAgaWYgKCFjaHVua0xlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGNodW5rIGxlbmd0aCcpXG5cbiAgc2VsZi5fYmxvY2tzdHJlYW0gPSBuZXcgQmxvY2tTdHJlYW0oY2h1bmtMZW5ndGgsIHsgemVyb1BhZGRpbmc6IGZhbHNlIH0pXG5cbiAgc2VsZi5fYmxvY2tzdHJlYW1cbiAgICAub24oJ2RhdGEnLCBvbkRhdGEpXG4gICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5kZXN0cm95KGVycikgfSlcblxuICB2YXIgaW5kZXggPSAwXG4gIGZ1bmN0aW9uIG9uRGF0YSAoY2h1bmspIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHN0b3JlLnB1dChpbmRleCwgY2h1bmspXG4gICAgaW5kZXggKz0gMVxuICB9XG5cbiAgc2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkgeyB0aGlzLl9ibG9ja3N0cmVhbS5lbmQoKSB9KVxufVxuXG5DaHVua1N0b3JlV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX2Jsb2Nrc3RyZWFtLndyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spXG59XG5cbkNodW5rU3RvcmVXcml0ZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgbnVtYmVycykge1xuICB2YXIgY2xvc2VzdCA9IEluZmluaXR5XG4gIHZhciBkaWZmZXJlbmNlID0gMFxuICB2YXIgd2lubmVyID0gbnVsbFxuXG4gIG51bWJlcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiXG4gIH0pXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBudW1iZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyAgXG4gICAgZGlmZmVyZW5jZSA9IE1hdGguYWJzKHRhcmdldCAtIG51bWJlcnNbaV0pXG4gICAgaWYgKGRpZmZlcmVuY2UgPj0gY2xvc2VzdCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2xvc2VzdCA9IGRpZmZlcmVuY2VcbiAgICB3aW5uZXIgPSBudW1iZXJzW2ldXG4gIH1cblxuICByZXR1cm4gd2lubmVyXG59XG4iLCJ2YXIgaXBhZGRyID0gcmVxdWlyZSgnaXBhZGRyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFjdDJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHN3aXRjaChidWYubGVuZ3RoKSB7XG4gIGNhc2UgNjpcbiAgICByZXR1cm4gYnVmWzBdICsgXCIuXCIgKyBidWZbMV0gKyBcIi5cIiArIGJ1ZlsyXSArIFwiLlwiICsgYnVmWzNdICsgXCI6XCIgKyBidWYucmVhZFVJbnQxNkJFKDQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDE4OlxuICAgIHZhciBoZXhHcm91cHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBoZXhHcm91cHMucHVzaChidWYucmVhZFVJbnQxNkJFKGkgKiAyKS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICB2YXIgaG9zdCA9IGlwYWRkci5wYXJzZShoZXhHcm91cHMuam9pbihcIjpcIikpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIFwiW1wiICsgaG9zdCArIFwiXTpcIiArIGJ1Zi5yZWFkVUludDE2QkUoMTYpO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQ29tcGFjdCBJUC9QT1JULCBJdCBzaG91bGQgY29udGFpbiA2IG9yIDE4IGJ5dGVzXCIpO1xuICB9XG59O1xuXG5jb21wYWN0MnN0cmluZy5tdWx0aSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYoYnVmLmxlbmd0aCAlIDYgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmIGxlbmd0aCBpc24ndCBtdWx0aXBsZSBvZiBjb21wYWN0IElQL1BPUlRzICg2IGJ5dGVzKVwiKTtcblxuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGJ1Zi5sZW5ndGggLSAxOyBpID0gaSArIDYpIHtcbiAgICBvdXRwdXQucHVzaChjb21wYWN0MnN0cmluZyhidWYuc2xpY2UoaSwgaSArIDYpKSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29tcGFjdDJzdHJpbmcubXVsdGk2ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZihidWYubGVuZ3RoICUgMTggIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmIGxlbmd0aCBpc24ndCBtdWx0aXBsZSBvZiBjb21wYWN0IElQNi9QT1JUcyAoMTggYnl0ZXMpXCIpO1xuXG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYnVmLmxlbmd0aCAtIDE7IGkgPSBpICsgMTgpIHtcbiAgICBvdXRwdXQucHVzaChjb21wYWN0MnN0cmluZyhidWYuc2xpY2UoaSwgaSArIDE4KSkpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG4iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUb3JyZW50XG5tb2R1bGUuZXhwb3J0cy5wYXJzZUlucHV0ID0gcGFyc2VJbnB1dFxuXG5tb2R1bGUuZXhwb3J0cy5hbm5vdW5jZUxpc3QgPSBbXG4gIFsgJ3VkcDovL3RyYWNrZXIub3BlbmJpdHRvcnJlbnQuY29tOjgwJyBdLFxuICBbICd1ZHA6Ly90cmFja2VyLmludGVybmV0d2FycmlvcnMubmV0OjEzMzcnIF0sXG4gIFsgJ3VkcDovL3RyYWNrZXIubGVlY2hlcnMtcGFyYWRpc2Uub3JnOjY5NjknIF0sXG4gIFsgJ3VkcDovL3RyYWNrZXIuY29wcGVyc3VyZmVyLnRrOjY5NjknIF0sXG4gIFsgJ3VkcDovL2V4b2R1cy5kZXN5bmMuY29tOjY5NjknIF0sXG4gIFsgJ3dzczovL3RyYWNrZXIud2VidG9ycmVudC5pbycgXSxcbiAgWyAnd3NzOi8vdHJhY2tlci5idG9ycmVudC54eXonIF0sXG4gIFsgJ3dzczovL3RyYWNrZXIub3BlbndlYnRvcnJlbnQuY29tJyBdLFxuICBbICd3c3M6Ly90cmFja2VyLmZhc3RjYXN0Lm56JyBdXG5dXG5cbnZhciBiZW5jb2RlID0gcmVxdWlyZSgnYmVuY29kZScpXG52YXIgQmxvY2tTdHJlYW0gPSByZXF1aXJlKCdibG9jay1zdHJlYW0yJylcbnZhciBjYWxjUGllY2VMZW5ndGggPSByZXF1aXJlKCdwaWVjZS1sZW5ndGgnKVxudmFyIGNvcmVQYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIEZpbGVSZWFkU3RyZWFtID0gcmVxdWlyZSgnZmlsZXN0cmVhbS9yZWFkJylcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnZmxhdHRlbicpXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgaXNGaWxlID0gcmVxdWlyZSgnaXMtZmlsZScpXG52YXIganVuayA9IHJlcXVpcmUoJ2p1bmsnKVxudmFyIE11bHRpU3RyZWFtID0gcmVxdWlyZSgnbXVsdGlzdHJlYW0nKVxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbnZhciBwYXJhbGxlbCA9IHJlcXVpcmUoJ3J1bi1wYXJhbGxlbCcpXG52YXIgc2hhMSA9IHJlcXVpcmUoJ3NpbXBsZS1zaGExJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG4vKipcbiAqIENyZWF0ZSBhIHRvcnJlbnQuXG4gKiBAcGFyYW0gIHtzdHJpbmd8RmlsZXxGaWxlTGlzdHxCdWZmZXJ8U3RyZWFtfEFycmF5LjxzdHJpbmd8RmlsZXxCdWZmZXJ8U3RyZWFtPn0gaW5wdXRcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0c1xuICogQHBhcmFtICB7c3RyaW5nPX0gb3B0cy5uYW1lXG4gKiBAcGFyYW0gIHtEYXRlPX0gb3B0cy5jcmVhdGlvbkRhdGVcbiAqIEBwYXJhbSAge3N0cmluZz19IG9wdHMuY29tbWVudFxuICogQHBhcmFtICB7c3RyaW5nPX0gb3B0cy5jcmVhdGVkQnlcbiAqIEBwYXJhbSAge2Jvb2xlYW58bnVtYmVyPX0gb3B0cy5wcml2YXRlXG4gKiBAcGFyYW0gIHtudW1iZXI9fSBvcHRzLnBpZWNlTGVuZ3RoXG4gKiBAcGFyYW0gIHtBcnJheS48QXJyYXkuPHN0cmluZz4+PX0gb3B0cy5hbm5vdW5jZUxpc3RcbiAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+PX0gb3B0cy51cmxMaXN0XG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2JcbiAqIEByZXR1cm4ge0J1ZmZlcn0gYnVmZmVyIG9mIC50b3JyZW50IGZpbGUgZGF0YVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb3JyZW50IChpbnB1dCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gY3JlYXRlVG9ycmVudChpbnB1dCwgbnVsbCwgb3B0cylcbiAgb3B0cyA9IG9wdHMgPyBleHRlbmQob3B0cykgOiB7fVxuXG4gIF9wYXJzZUlucHV0KGlucHV0LCBvcHRzLCBmdW5jdGlvbiAoZXJyLCBmaWxlcywgc2luZ2xlRmlsZVRvcnJlbnQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIG9wdHMuc2luZ2xlRmlsZVRvcnJlbnQgPSBzaW5nbGVGaWxlVG9ycmVudFxuICAgIG9uRmlsZXMoZmlsZXMsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUlucHV0IChpbnB1dCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gcGFyc2VJbnB1dChpbnB1dCwgbnVsbCwgb3B0cylcbiAgb3B0cyA9IG9wdHMgPyBleHRlbmQob3B0cykgOiB7fVxuICBfcGFyc2VJbnB1dChpbnB1dCwgb3B0cywgY2IpXG59XG5cbi8qKlxuICogUGFyc2UgaW5wdXQgZmlsZSBhbmQgcmV0dXJuIGZpbGUgaW5mb3JtYXRpb24uXG4gKi9cbmZ1bmN0aW9uIF9wYXJzZUlucHV0IChpbnB1dCwgb3B0cywgY2IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHR5cGUnKVxuXG4gIGlmIChpc0ZpbGVMaXN0KGlucHV0KSkgaW5wdXQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbnB1dClcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkgaW5wdXQgPSBbIGlucHV0IF1cblxuICAvLyBJbiBFbGVjdHJvbiwgdXNlIHRoZSB0cnVlIGZpbGUgcGF0aFxuICBpbnB1dCA9IGlucHV0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpc0Jsb2IoaXRlbSkgJiYgdHlwZW9mIGl0ZW0ucGF0aCA9PT0gJ3N0cmluZycpIHJldHVybiBpdGVtLnBhdGhcbiAgICByZXR1cm4gaXRlbVxuICB9KVxuXG4gIC8vIElmIHRoZXJlJ3MganVzdCBvbmUgZmlsZSwgYWxsb3cgdGhlIG5hbWUgdG8gYmUgc2V0IGJ5IGBvcHRzLm5hbWVgXG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJyAmJiAhaW5wdXRbMF0ubmFtZSkgaW5wdXRbMF0ubmFtZSA9IG9wdHMubmFtZVxuXG4gIHZhciBjb21tb25QcmVmaXggPSBudWxsXG4gIGlucHV0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IGl0ZW0uZnVsbFBhdGggfHwgaXRlbS5uYW1lXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBwYXRoID0gJ1Vua25vd24gRmlsZSAnICsgKGkgKyAxKVxuICAgICAgaXRlbS51bmtub3duTmFtZSA9IHRydWVcbiAgICB9XG5cbiAgICBpdGVtLnBhdGggPSBwYXRoLnNwbGl0KCcvJylcblxuICAgIC8vIFJlbW92ZSBpbml0aWFsIHNsYXNoXG4gICAgaWYgKCFpdGVtLnBhdGhbMF0pIHtcbiAgICAgIGl0ZW0ucGF0aC5zaGlmdCgpXG4gICAgfVxuXG4gICAgaWYgKGl0ZW0ucGF0aC5sZW5ndGggPCAyKSB7IC8vIE5vIHJlYWwgcHJlZml4XG4gICAgICBjb21tb25QcmVmaXggPSBudWxsXG4gICAgfSBlbHNlIGlmIChpID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEpIHsgLy8gVGhlIGZpcnN0IGZpbGUgaGFzIGEgcHJlZml4XG4gICAgICBjb21tb25QcmVmaXggPSBpdGVtLnBhdGhbMF1cbiAgICB9IGVsc2UgaWYgKGl0ZW0ucGF0aFswXSAhPT0gY29tbW9uUHJlZml4KSB7IC8vIFRoZSBwcmVmaXggZG9lc24ndCBtYXRjaFxuICAgICAgY29tbW9uUHJlZml4ID0gbnVsbFxuICAgIH1cbiAgfSlcblxuICAvLyByZW1vdmUganVuayBmaWxlc1xuICBpbnB1dCA9IGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHZhciBmaWxlbmFtZSA9IGl0ZW0ucGF0aFtpdGVtLnBhdGgubGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gbm90SGlkZGVuKGZpbGVuYW1lKSAmJiBqdW5rLm5vdChmaWxlbmFtZSlcbiAgfSlcblxuICBpZiAoY29tbW9uUHJlZml4KSB7XG4gICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHBhdGhsZXNzID0gKEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSB8fCBpc1JlYWRhYmxlKGl0ZW0pKSAmJiAhaXRlbS5wYXRoXG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnIHx8IHBhdGhsZXNzKSByZXR1cm5cbiAgICAgIGl0ZW0ucGF0aC5zaGlmdCgpXG4gICAgfSlcbiAgfVxuXG4gIGlmICghb3B0cy5uYW1lICYmIGNvbW1vblByZWZpeCkge1xuICAgIG9wdHMubmFtZSA9IGNvbW1vblByZWZpeFxuICB9XG5cbiAgaWYgKCFvcHRzLm5hbWUpIHtcbiAgICAvLyB1c2UgZmlyc3QgdXNlci1zZXQgZmlsZSBuYW1lXG4gICAgaW5wdXQuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRzLm5hbWUgPSBjb3JlUGF0aC5iYXNlbmFtZShpdGVtKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICghaXRlbS51bmtub3duTmFtZSkge1xuICAgICAgICBvcHRzLm5hbWUgPSBpdGVtLnBhdGhbaXRlbS5wYXRoLmxlbmd0aCAtIDFdXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlmICghb3B0cy5uYW1lKSB7XG4gICAgb3B0cy5uYW1lID0gJ1VubmFtZWQgVG9ycmVudCAnICsgRGF0ZS5ub3coKVxuICB9XG5cbiAgdmFyIG51bVBhdGhzID0gaW5wdXQucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGl0ZW0pIHtcbiAgICByZXR1cm4gc3VtICsgTnVtYmVyKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJylcbiAgfSwgMClcblxuICB2YXIgaXNTaW5nbGVGaWxlVG9ycmVudCA9IChpbnB1dC5sZW5ndGggPT09IDEpXG5cbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgaW5wdXRbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBmcy5zdGF0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVzeXN0ZW0gcGF0aHMgZG8gbm90IHdvcmsgaW4gdGhlIGJyb3dzZXInKVxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIGEgc2luZ2xlIHBhdGgsIHZlcmlmeSBpdCdzIGEgZmlsZSBiZWZvcmUgZGVjaWRpbmcgdGhpcyBpcyBhIHNpbmdsZVxuICAgIC8vIGZpbGUgdG9ycmVudFxuICAgIGlzRmlsZShpbnB1dFswXSwgZnVuY3Rpb24gKGVyciwgcGF0aElzRmlsZSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlzU2luZ2xlRmlsZVRvcnJlbnQgPSBwYXRoSXNGaWxlXG4gICAgICBwcm9jZXNzSW5wdXQoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzSW5wdXQoKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSW5wdXQgKCkge1xuICAgIHBhcmFsbGVsKGlucHV0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgZmlsZSA9IHt9XG5cbiAgICAgICAgaWYgKGlzQmxvYihpdGVtKSkge1xuICAgICAgICAgIGZpbGUuZ2V0U3RyZWFtID0gZ2V0QmxvYlN0cmVhbShpdGVtKVxuICAgICAgICAgIGZpbGUubGVuZ3RoID0gaXRlbS5zaXplXG4gICAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSB7XG4gICAgICAgICAgZmlsZS5nZXRTdHJlYW0gPSBnZXRCdWZmZXJTdHJlYW0oaXRlbSlcbiAgICAgICAgICBmaWxlLmxlbmd0aCA9IGl0ZW0ubGVuZ3RoXG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWFkYWJsZShpdGVtKSkge1xuICAgICAgICAgIGZpbGUuZ2V0U3RyZWFtID0gZ2V0U3RyZWFtU3RyZWFtKGl0ZW0sIGZpbGUpXG4gICAgICAgICAgZmlsZS5sZW5ndGggPSAwXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmcy5zdGF0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVzeXN0ZW0gcGF0aHMgZG8gbm90IHdvcmsgaW4gdGhlIGJyb3dzZXInKVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIga2VlcFJvb3QgPSBudW1QYXRocyA+IDEgfHwgaXNTaW5nbGVGaWxlVG9ycmVudFxuICAgICAgICAgIGdldEZpbGVzKGl0ZW0sIGtlZXBSb290LCBjYilcbiAgICAgICAgICByZXR1cm4gLy8gZWFybHkgcmV0dXJuIVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICBmaWxlLnBhdGggPSBpdGVtLnBhdGhcbiAgICAgICAgY2IobnVsbCwgZmlsZSlcbiAgICAgIH1cbiAgICB9KSwgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBmaWxlcyA9IGZsYXR0ZW4oZmlsZXMpXG4gICAgICBjYihudWxsLCBmaWxlcywgaXNTaW5nbGVGaWxlVG9ycmVudClcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVzIChwYXRoLCBrZWVwUm9vdCwgY2IpIHtcbiAgdHJhdmVyc2VQYXRoKHBhdGgsIGdldEZpbGVJbmZvLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxlcykpIGZpbGVzID0gZmxhdHRlbihmaWxlcylcbiAgICBlbHNlIGZpbGVzID0gWyBmaWxlcyBdXG5cbiAgICBwYXRoID0gY29yZVBhdGgubm9ybWFsaXplKHBhdGgpXG4gICAgaWYgKGtlZXBSb290KSB7XG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBwYXRoLmxhc3RJbmRleE9mKGNvcmVQYXRoLnNlcCkgKyAxKVxuICAgIH1cbiAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdICE9PSBjb3JlUGF0aC5zZXApIHBhdGggKz0gY29yZVBhdGguc2VwXG5cbiAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICBmaWxlLmdldFN0cmVhbSA9IGdldEZpbGVQYXRoU3RyZWFtKGZpbGUucGF0aClcbiAgICAgIGZpbGUucGF0aCA9IGZpbGUucGF0aC5yZXBsYWNlKHBhdGgsICcnKS5zcGxpdChjb3JlUGF0aC5zZXApXG4gICAgfSlcbiAgICBjYihudWxsLCBmaWxlcylcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZUluZm8gKHBhdGgsIGNiKSB7XG4gIGNiID0gb25jZShjYilcbiAgZnMuc3RhdChwYXRoLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIGxlbmd0aDogc3RhdC5zaXplLFxuICAgICAgcGF0aDogcGF0aFxuICAgIH1cbiAgICBjYihudWxsLCBpbmZvKVxuICB9KVxufVxuXG5mdW5jdGlvbiB0cmF2ZXJzZVBhdGggKHBhdGgsIGZuLCBjYikge1xuICBmcy5yZWFkZGlyKHBhdGgsIGZ1bmN0aW9uIChlcnIsIGVudHJpZXMpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRU5PVERJUicpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBmaWxlXG4gICAgICBmbihwYXRoLCBjYilcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgLy8gcmVhbCBlcnJvclxuICAgICAgY2IoZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIGEgZm9sZGVyXG4gICAgICBwYXJhbGxlbChlbnRyaWVzLmZpbHRlcihub3RIaWRkZW4pLmZpbHRlcihqdW5rLm5vdCkubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdHJhdmVyc2VQYXRoKGNvcmVQYXRoLmpvaW4ocGF0aCwgZW50cnkpLCBmbiwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pLCBjYilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5vdEhpZGRlbiAoZmlsZSkge1xuICByZXR1cm4gZmlsZVswXSAhPT0gJy4nXG59XG5cbmZ1bmN0aW9uIGdldFBpZWNlTGlzdCAoZmlsZXMsIHBpZWNlTGVuZ3RoLCBjYikge1xuICBjYiA9IG9uY2UoY2IpXG4gIHZhciBwaWVjZXMgPSBbXVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIHZhciBzdHJlYW1zID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgcmV0dXJuIGZpbGUuZ2V0U3RyZWFtXG4gIH0pXG5cbiAgdmFyIHJlbWFpbmluZ0hhc2hlcyA9IDBcbiAgdmFyIHBpZWNlTnVtID0gMFxuICB2YXIgZW5kZWQgPSBmYWxzZVxuXG4gIHZhciBtdWx0aXN0cmVhbSA9IG5ldyBNdWx0aVN0cmVhbShzdHJlYW1zKVxuICB2YXIgYmxvY2tzdHJlYW0gPSBuZXcgQmxvY2tTdHJlYW0ocGllY2VMZW5ndGgsIHsgemVyb1BhZGRpbmc6IGZhbHNlIH0pXG5cbiAgbXVsdGlzdHJlYW0ub24oJ2Vycm9yJywgb25FcnJvcilcblxuICBtdWx0aXN0cmVhbVxuICAgIC5waXBlKGJsb2Nrc3RyZWFtKVxuICAgIC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAub24oJ2VuZCcsIG9uRW5kKVxuICAgIC5vbignZXJyb3InLCBvbkVycm9yKVxuXG4gIGZ1bmN0aW9uIG9uRGF0YSAoY2h1bmspIHtcbiAgICBsZW5ndGggKz0gY2h1bmsubGVuZ3RoXG5cbiAgICB2YXIgaSA9IHBpZWNlTnVtXG4gICAgc2hhMShjaHVuaywgZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHBpZWNlc1tpXSA9IGhhc2hcbiAgICAgIHJlbWFpbmluZ0hhc2hlcyAtPSAxXG4gICAgICBtYXliZURvbmUoKVxuICAgIH0pXG4gICAgcmVtYWluaW5nSGFzaGVzICs9IDFcbiAgICBwaWVjZU51bSArPSAxXG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZCAoKSB7XG4gICAgZW5kZWQgPSB0cnVlXG4gICAgbWF5YmVEb25lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IgKGVycikge1xuICAgIGNsZWFudXAoKVxuICAgIGNiKGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIG11bHRpc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgYmxvY2tzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpXG4gICAgYmxvY2tzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKVxuICAgIGJsb2Nrc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gIH1cblxuICBmdW5jdGlvbiBtYXliZURvbmUgKCkge1xuICAgIGlmIChlbmRlZCAmJiByZW1haW5pbmdIYXNoZXMgPT09IDApIHtcbiAgICAgIGNsZWFudXAoKVxuICAgICAgY2IobnVsbCwgbmV3IEJ1ZmZlcihwaWVjZXMuam9pbignJyksICdoZXgnKSwgbGVuZ3RoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkZpbGVzIChmaWxlcywgb3B0cywgY2IpIHtcbiAgdmFyIGFubm91bmNlTGlzdCA9IG9wdHMuYW5ub3VuY2VMaXN0XG5cbiAgaWYgKCFhbm5vdW5jZUxpc3QpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMuYW5ub3VuY2UgPT09ICdzdHJpbmcnKSBhbm5vdW5jZUxpc3QgPSBbIFsgb3B0cy5hbm5vdW5jZSBdIF1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdHMuYW5ub3VuY2UpKSB7XG4gICAgICBhbm5vdW5jZUxpc3QgPSBvcHRzLmFubm91bmNlLm1hcChmdW5jdGlvbiAodSkgeyByZXR1cm4gWyB1IF0gfSlcbiAgICB9XG4gIH1cblxuICBpZiAoIWFubm91bmNlTGlzdCkgYW5ub3VuY2VMaXN0ID0gW11cblxuICBpZiAoZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5XRUJUT1JSRU5UX0FOTk9VTkNFID09PSAnc3RyaW5nJykge1xuICAgICAgYW5ub3VuY2VMaXN0LnB1c2goWyBbIGdsb2JhbC5XRUJUT1JSRU5UX0FOTk9VTkNFIF0gXSlcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UpKSB7XG4gICAgICBhbm5vdW5jZUxpc3QgPSBhbm5vdW5jZUxpc3QuY29uY2F0KGdsb2JhbC5XRUJUT1JSRU5UX0FOTk9VTkNFLm1hcChmdW5jdGlvbiAodSkge1xuICAgICAgICByZXR1cm4gWyB1IF1cbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIC8vIFdoZW4gbm8gdHJhY2tlcnMgc3BlY2lmaWVkLCB1c2Ugc29tZSByZWFzb25hYmxlIGRlZmF1bHRzXG4gIGlmIChvcHRzLmFubm91bmNlID09PSB1bmRlZmluZWQgJiYgb3B0cy5hbm5vdW5jZUxpc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGFubm91bmNlTGlzdCA9IGFubm91bmNlTGlzdC5jb25jYXQobW9kdWxlLmV4cG9ydHMuYW5ub3VuY2VMaXN0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzLnVybExpc3QgPT09ICdzdHJpbmcnKSBvcHRzLnVybExpc3QgPSBbIG9wdHMudXJsTGlzdCBdXG5cbiAgdmFyIHRvcnJlbnQgPSB7XG4gICAgaW5mbzoge1xuICAgICAgbmFtZTogb3B0cy5uYW1lXG4gICAgfSxcbiAgICAnY3JlYXRpb24gZGF0ZSc6IE1hdGguY2VpbCgoTnVtYmVyKG9wdHMuY3JlYXRpb25EYXRlKSB8fCBEYXRlLm5vdygpKSAvIDEwMDApLFxuICAgIGVuY29kaW5nOiAnVVRGLTgnXG4gIH1cblxuICBpZiAoYW5ub3VuY2VMaXN0Lmxlbmd0aCAhPT0gMCkge1xuICAgIHRvcnJlbnQuYW5ub3VuY2UgPSBhbm5vdW5jZUxpc3RbMF1bMF1cbiAgICB0b3JyZW50Wydhbm5vdW5jZS1saXN0J10gPSBhbm5vdW5jZUxpc3RcbiAgfVxuXG4gIGlmIChvcHRzLmNvbW1lbnQgIT09IHVuZGVmaW5lZCkgdG9ycmVudC5jb21tZW50ID0gb3B0cy5jb21tZW50XG5cbiAgaWYgKG9wdHMuY3JlYXRlZEJ5ICE9PSB1bmRlZmluZWQpIHRvcnJlbnRbJ2NyZWF0ZWQgYnknXSA9IG9wdHMuY3JlYXRlZEJ5XG5cbiAgaWYgKG9wdHMucHJpdmF0ZSAhPT0gdW5kZWZpbmVkKSB0b3JyZW50LmluZm8ucHJpdmF0ZSA9IE51bWJlcihvcHRzLnByaXZhdGUpXG5cbiAgLy8gXCJzc2wtY2VydFwiIGtleSBpcyBmb3IgU1NMIHRvcnJlbnRzLCBzZWU6XG4gIC8vICAgLSBodHRwOi8vYmxvZy5saWJ0b3JyZW50Lm9yZy8yMDEyLzAxL2JpdHRvcnJlbnQtb3Zlci1zc2wvXG4gIC8vICAgLSBodHRwOi8vd3d3LmxpYnRvcnJlbnQub3JnL21hbnVhbC1yZWYuaHRtbCNzc2wtdG9ycmVudHNcbiAgLy8gICAtIGh0dHA6Ly93d3cubGlidG9ycmVudC5vcmcvcmVmZXJlbmNlLUNyZWF0ZV9Ub3JyZW50cy5odG1sXG4gIGlmIChvcHRzLnNzbENlcnQgIT09IHVuZGVmaW5lZCkgdG9ycmVudC5pbmZvWydzc2wtY2VydCddID0gb3B0cy5zc2xDZXJ0XG5cbiAgaWYgKG9wdHMudXJsTGlzdCAhPT0gdW5kZWZpbmVkKSB0b3JyZW50Wyd1cmwtbGlzdCddID0gb3B0cy51cmxMaXN0XG5cbiAgdmFyIHBpZWNlTGVuZ3RoID0gb3B0cy5waWVjZUxlbmd0aCB8fCBjYWxjUGllY2VMZW5ndGgoZmlsZXMucmVkdWNlKHN1bUxlbmd0aCwgMCkpXG4gIHRvcnJlbnQuaW5mb1sncGllY2UgbGVuZ3RoJ10gPSBwaWVjZUxlbmd0aFxuXG4gIGdldFBpZWNlTGlzdChmaWxlcywgcGllY2VMZW5ndGgsIGZ1bmN0aW9uIChlcnIsIHBpZWNlcywgdG9ycmVudExlbmd0aCkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgdG9ycmVudC5pbmZvLnBpZWNlcyA9IHBpZWNlc1xuXG4gICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgZGVsZXRlIGZpbGUuZ2V0U3RyZWFtXG4gICAgfSlcblxuICAgIGlmIChvcHRzLnNpbmdsZUZpbGVUb3JyZW50KSB7XG4gICAgICB0b3JyZW50LmluZm8ubGVuZ3RoID0gdG9ycmVudExlbmd0aFxuICAgIH0gZWxzZSB7XG4gICAgICB0b3JyZW50LmluZm8uZmlsZXMgPSBmaWxlc1xuICAgIH1cblxuICAgIGNiKG51bGwsIGJlbmNvZGUuZW5jb2RlKHRvcnJlbnQpKVxuICB9KVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdG9yIHRvIHN1bSBmaWxlIGxlbmd0aHNcbiAqIEBwYXJhbSAge251bWJlcn0gc3VtXG4gKiBAcGFyYW0gIHtPYmplY3R9IGZpbGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc3VtTGVuZ3RoIChzdW0sIGZpbGUpIHtcbiAgcmV0dXJuIHN1bSArIGZpbGUubGVuZ3RoXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBXM0MgYEJsb2JgIG9iamVjdCAod2hpY2ggYEZpbGVgIGluaGVyaXRzIGZyb20pXG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQmxvYiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgQmxvYlxufVxuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVzNDIGBGaWxlTGlzdGAgb2JqZWN0XG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmlsZUxpc3QgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIEZpbGVMaXN0ID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEZpbGVMaXN0XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBub2RlIFJlYWRhYmxlIHN0cmVhbVxuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBgRmlsZWAgdG8gYSBsYXp5IHJlYWRhYmxlIHN0cmVhbS5cbiAqIEBwYXJhbSAge0ZpbGV8QmxvYn0gZmlsZVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEJsb2JTdHJlYW0gKGZpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEZpbGVSZWFkU3RyZWFtKGZpbGUpXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgYEJ1ZmZlcmAgdG8gYSBsYXp5IHJlYWRhYmxlIHN0cmVhbS5cbiAqIEBwYXJhbSAge0J1ZmZlcn0gYnVmZmVyXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0QnVmZmVyU3RyZWFtIChidWZmZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IG5ldyBzdHJlYW0uUGFzc1Rocm91Z2goKVxuICAgIHMuZW5kKGJ1ZmZlcilcbiAgICByZXR1cm4gc1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIGZpbGUgcGF0aCB0byBhIGxhenkgcmVhZGFibGUgc3RyZWFtLlxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0RmlsZVBhdGhTdHJlYW0gKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoKVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIHJlYWRhYmxlIHN0cmVhbSB0byBhIGxhenkgcmVhZGFibGUgc3RyZWFtLiBBZGRzIGluc3RydW1lbnRhdGlvbiB0byB0cmFja1xuICogdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGUgc3RyZWFtIGFuZCBzZXQgYGZpbGUubGVuZ3RoYC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJlYW19IHN0cmVhbVxuICogQHBhcmFtICB7T2JqZWN0fSBmaWxlXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyZWFtU3RyZWFtIChyZWFkYWJsZSwgZmlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb3VudGVyID0gbmV3IHN0cmVhbS5UcmFuc2Zvcm0oKVxuICAgIGNvdW50ZXIuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChidWYsIGVuYywgZG9uZSkge1xuICAgICAgZmlsZS5sZW5ndGggKz0gYnVmLmxlbmd0aFxuICAgICAgdGhpcy5wdXNoKGJ1ZilcbiAgICAgIGRvbmUoKVxuICAgIH1cbiAgICByZWFkYWJsZS5waXBlKGNvdW50ZXIpXG4gICAgcmV0dXJuIGNvdW50ZXJcbiAgfVxufVxuIiwidmFyIGJlbmNvZGUgPSBtb2R1bGUuZXhwb3J0c1xuXG5iZW5jb2RlLmVuY29kZSA9IHJlcXVpcmUoICcuL2xpYi9lbmNvZGUnIClcbmJlbmNvZGUuZGVjb2RlID0gcmVxdWlyZSggJy4vbGliL2RlY29kZScgKVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGFtb3VudCBvZiBieXRlc1xuICogbmVlZGVkIHRvIGVuY29kZSB0aGUgZ2l2ZW4gdmFsdWVcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcnxCb29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfSBieXRlQ291bnRcbiAqL1xuYmVuY29kZS5ieXRlTGVuZ3RoID0gYmVuY29kZS5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgcmV0dXJuIGJlbmNvZGUuZW5jb2RlKCB2YWx1ZSApLmxlbmd0aFxufVxuIiwidmFyIERpY3QgPSByZXF1aXJlKFwiLi9kaWN0XCIpXG5cbi8qKlxuICogRGVjb2RlcyBiZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcn0gZGF0YVxuICogQHBhcmFtICB7TnVtYmVyfSBzdGFydCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGVuY29kaW5nIChvcHRpb25hbClcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKCBkYXRhLCBzdGFydCwgZW5kLCBlbmNvZGluZyApIHtcbiAgXG4gIGlmKCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBzdGFydFxuICAgIHN0YXJ0ID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGlmKCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gZW5kXG4gICAgZW5kID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gISggQnVmZmVyLmlzQnVmZmVyKGRhdGEpIClcbiAgICA/IG5ldyBCdWZmZXIoIGRhdGEgKVxuICAgIDogZGF0YS5zbGljZSggc3RhcnQsIGVuZCApXG4gIFxuICBkZWNvZGUuYnl0ZXMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgXG4gIHJldHVybiBkZWNvZGUubmV4dCgpXG5cbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgICAgID0gbnVsbFxuZGVjb2RlLmVuY29kaW5nID0gbnVsbFxuXG5kZWNvZGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gIHN3aXRjaCggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSApIHtcbiAgICBjYXNlIDB4NjQ6IHJldHVybiBkZWNvZGUuZGljdGlvbmFyeSgpOyBicmVha1xuICAgIGNhc2UgMHg2QzogcmV0dXJuIGRlY29kZS5saXN0KCk7IGJyZWFrXG4gICAgY2FzZSAweDY5OiByZXR1cm4gZGVjb2RlLmludGVnZXIoKTsgYnJlYWtcbiAgICBkZWZhdWx0OiAgIHJldHVybiBkZWNvZGUuYnVmZmVyKCk7IGJyZWFrXG4gIH1cblxufVxuXG5kZWNvZGUuZmluZCA9IGZ1bmN0aW9uKCBjaHIgKSB7XG5cbiAgdmFyIGkgPSBkZWNvZGUucG9zaXRpb25cbiAgdmFyIGMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgdmFyIGQgPSBkZWNvZGUuZGF0YVxuXG4gIHdoaWxlKCBpIDwgYyApIHtcbiAgICBpZiggZFtpXSA9PT0gY2hyIClcbiAgICAgIHJldHVybiBpXG4gICAgaSsrXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ0ludmFsaWQgZGF0YTogTWlzc2luZyBkZWxpbWl0ZXIgXCInICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjaHIgKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoIDE2ICkgKyAnXSdcbiAgKVxuXG59XG5cbmRlY29kZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgZGljdCA9IG5ldyBEaWN0KClcblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBkaWN0LmJpbmFyeVNldChkZWNvZGUuYnVmZmVyKCksIGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBkaWN0XG5cbn1cblxuZGVjb2RlLmxpc3QgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBsc3QgPSBbXVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGxzdC5wdXNoKCBkZWNvZGUubmV4dCgpIClcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGxzdFxuXG59XG5cbmRlY29kZS5pbnRlZ2VyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGVuZCAgICA9IGRlY29kZS5maW5kKCAweDY1IClcbiAgdmFyIG51bWJlciA9IGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24gKyAxLCBlbmQgKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KCBudW1iZXIsIDEwIClcblxufVxuXG5kZWNvZGUuYnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNlcCAgICA9IGRlY29kZS5maW5kKCAweDNBIClcbiAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KCBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXAgKSwgMTAgKVxuICB2YXIgZW5kICAgID0gKytzZXAgKyBsZW5ndGhcblxuICBkZWNvZGUucG9zaXRpb24gPSBlbmRcblxuICByZXR1cm4gZGVjb2RlLmVuY29kaW5nXG4gICAgPyBkZWNvZGUuZGF0YS50b1N0cmluZyggZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZCApXG4gICAgOiBkZWNvZGUuZGF0YS5zbGljZSggc2VwLCBlbmQgKVxuXG59XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlXG4iLCJ2YXIgRGljdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRGljdCgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tleXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBbXSxcbiAgfSlcbn1cblxuRGljdC5wcm90b3R5cGUuYmluYXJ5S2V5cyA9IGZ1bmN0aW9uIGJpbmFyeUtleXMoKSB7XG4gIHJldHVybiB0aGlzLl9rZXlzLnNsaWNlKClcbn1cblxuRGljdC5wcm90b3R5cGUuYmluYXJ5U2V0ID0gZnVuY3Rpb24gYmluYXJ5U2V0KGtleSwgdmFsdWUpIHtcbiAgdGhpcy5fa2V5cy5wdXNoKGtleSlcblxuICB0aGlzW2tleV0gPSB2YWx1ZVxufVxuIiwiLyoqXG4gKiBFbmNvZGVzIGRhdGEgaW4gYmVuY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE9iamVjdHxOdW1iZXJ8Qm9vbGVhbn0gZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBlbmNvZGUoIGRhdGEsIGJ1ZmZlciwgb2Zmc2V0ICkge1xuICBcbiAgdmFyIGJ1ZmZlcnMgPSBbXVxuICB2YXIgcmVzdWx0ID0gbnVsbFxuICBcbiAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGEgKVxuICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KCBidWZmZXJzIClcbiAgZW5jb2RlLmJ5dGVzID0gcmVzdWx0Lmxlbmd0aFxuICBcbiAgaWYoIEJ1ZmZlci5pc0J1ZmZlciggYnVmZmVyICkgKSB7XG4gICAgcmVzdWx0LmNvcHkoIGJ1ZmZlciwgb2Zmc2V0IClcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRcbiAgXG59XG5cbmVuY29kZS5ieXRlcyA9IC0xXG5lbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gZmFsc2VcblxuZW5jb2RlLl9lbmNvZGUgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBpZiggQnVmZmVyLmlzQnVmZmVyKGRhdGEpICkge1xuICAgIGJ1ZmZlcnMucHVzaChuZXcgQnVmZmVyKGRhdGEubGVuZ3RoICsgJzonKSlcbiAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2goIHR5cGVvZiBkYXRhICkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBkYXRhIClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlcbiAgICAgICAgPyBlbmNvZGUubGlzdCggYnVmZmVycywgZGF0YSApXG4gICAgICAgIDogZW5jb2RlLmRpY3QoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgPyAxIDogMCApXG4gICAgICBicmVha1xuICB9XG5cbn1cblxudmFyIGJ1ZmZfZSA9IG5ldyBCdWZmZXIoJ2UnKVxuICAsIGJ1ZmZfZCA9IG5ldyBCdWZmZXIoJ2QnKVxuICAsIGJ1ZmZfbCA9IG5ldyBCdWZmZXIoJ2wnKVxuXG5lbmNvZGUuYnVmZmVyID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKEJ1ZmZlci5ieXRlTGVuZ3RoKCBkYXRhICkgKyAnOicgKyBkYXRhKSApXG59XG5cbmVuY29kZS5udW1iZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcbiAgdmFyIG1heExvID0gMHg4MDAwMDAwMFxuICB2YXIgaGkgPSAoIGRhdGEgLyBtYXhMbyApIDw8IDBcbiAgdmFyIGxvID0gKCBkYXRhICUgbWF4TG8gICkgPDwgMFxuICB2YXIgdmFsID0gaGkgKiBtYXhMbyArIGxvXG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKCAnaScgKyB2YWwgKyAnZScgKSlcblxuICBpZiggdmFsICE9PSBkYXRhICYmICFlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkICkge1xuICAgIGVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSB0cnVlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dBUk5JTkc6IFBvc3NpYmxlIGRhdGEgY29ycnVwdGlvbiBkZXRlY3RlZCB3aXRoIHZhbHVlIFwiJytkYXRhKydcIjonLFxuICAgICAgJ0JlbmNvZGluZyBvbmx5IGRlZmluZXMgc3VwcG9ydCBmb3IgaW50ZWdlcnMsIHZhbHVlIHdhcyBjb252ZXJ0ZWQgdG8gXCInK3ZhbCsnXCInXG4gICAgKVxuICAgIGNvbnNvbGUudHJhY2UoKVxuICB9XG5cbn1cblxuZW5jb2RlLmRpY3QgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZCApXG5cbiAgdmFyIGogPSAwXG4gIHZhciBrXG4gIC8vIGZpeCBmb3IgaXNzdWUgIzEzIC0gc29ydGVkIGRpY3RzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGRhdGEgKS5zb3J0KClcbiAgdmFyIGtsID0ga2V5cy5sZW5ndGhcblxuICBmb3IoIDsgaiA8IGtsIDsgaisrKSB7XG4gICAgaz1rZXlzW2pdXG4gICAgZW5jb2RlLmJ1ZmZlciggYnVmZmVycywgayApXG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFba10gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxufVxuXG5lbmNvZGUubGlzdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIHZhciBpID0gMCwgaiA9IDFcbiAgdmFyIGMgPSBkYXRhLmxlbmd0aFxuICBidWZmZXJzLnB1c2goIGJ1ZmZfbCApXG5cbiAgZm9yKCA7IGkgPCBjOyBpKysgKSB7XG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFbaV0gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxuXG59XG5cbi8vIEV4cG9zZVxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbn07XG4iLCJ2YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDaGlsZFByb2Nlc3MgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zdGRpbyAmJiBBcnJheS5pc0FycmF5KHN0cmVhbS5zdGRpbykgJiYgc3RyZWFtLnN0ZGlvLmxlbmd0aCA9PT0gM1xufTtcblxudmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG5cdGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG5cdGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcblxuXHR2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cdHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblx0dmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCAob3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlKTtcblx0dmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCAob3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlKTtcblxuXHR2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcblx0fTtcblxuXHR2YXIgb25maW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHR3cml0YWJsZSA9IGZhbHNlO1xuXHRcdGlmICghcmVhZGFibGUpIGNhbGxiYWNrKCk7XG5cdH07XG5cblx0dmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVhZGFibGUgPSBmYWxzZTtcblx0XHRpZiAoIXdyaXRhYmxlKSBjYWxsYmFjaygpO1xuXHR9O1xuXG5cdHZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkge1xuXHRcdGNhbGxiYWNrKGV4aXRDb2RlID8gbmV3IEVycm9yKCdleGl0ZWQgd2l0aCBlcnJvciBjb2RlOiAnICsgZXhpdENvZGUpIDogbnVsbCk7XG5cdH07XG5cblx0dmFyIG9uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAocmVhZGFibGUgJiYgIShycyAmJiBycy5lbmRlZCkpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcblx0XHRpZiAod3JpdGFibGUgJiYgISh3cyAmJiB3cy5lbmRlZCkpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcblx0fTtcblxuXHR2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0c3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHR9O1xuXG5cdGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuXHRcdHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuXHRcdGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtcblx0XHRlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG5cdH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXdzKSB7IC8vIGxlZ2FjeSBzdHJlYW1zXG5cdFx0c3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcblx0fVxuXG5cdGlmIChpc0NoaWxkUHJvY2VzcyhzdHJlYW0pKSBzdHJlYW0ub24oJ2V4aXQnLCBvbmV4aXQpO1xuXG5cdHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuXHRzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0aWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuXHRzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uZXhpdCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNhbGxiYWNrKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCJcbm1vZHVsZS5leHBvcnRzID0gIHJlcXVpcmUoJy4vbGliLycpO1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBOb29wIGZ1bmN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCh1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmUgOlxuICAgIChnbG9iYWwubG9jYXRpb24gJiYgJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnQgP1xuICAgICAgIGxvY2F0aW9uLnBvcnQgOlxuICAgICAgICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgZm9yY2VKU09OUDogdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIHBmeDogdGhpcy5wZngsXG4gICAga2V5OiB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogdGhpcy5jZXJ0LFxuICAgIGNhOiB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnNcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpe1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG4gICAgLCBmYWlsZWQgPSBmYWxzZVxuICAgICwgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PSBtc2cudHlwZSAmJiAncHJvYmUnID09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pe1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwKCl7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YSxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIGlmIChmbikgdGhpcy5vbmNlKCdmbHVzaCcsIGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG4gICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nKG9wdHMpe1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIENhbGxiYWNrcyBjb3VudC5cbiAqL1xuXG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfVxuICBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIFxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrIHNlbGYuaWZyYW1lSWQgKydcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2goZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG4iLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG9wdHMpe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbihkYXRhLCBmbil7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG9wdHMpe1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oZnJvbUVycm9yKXtcbiAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKS5zcGxpdCgnOycpWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciB1aThBcnIgPSBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSk7XG4gICAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IHVpOEFyci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKHVpOEFycltpZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIFJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG4gIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcbiAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKG9uUGF1c2Upe1xuICB2YXIgcGVuZGluZyA9IDA7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UoKXtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UoKXtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbnZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICB0cnkge1xuICAgIFdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG5cbiAgdGhpcy53cyA9IEJyb3dzZXJXZWJTb2NrZXQgPyBuZXcgV2ViU29ja2V0KHVyaSkgOiBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdidWZmZXInO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpe1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgb25EYXRhYCB0byB1c2UgYSB0aW1lciBvbiBpT1MuXG4gKiBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21sb3VnaHJhbi8yMDUyMDA2XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3JcbiAgJiYgL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gIFdTLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcbiAgICB9LCAwKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG4gICAgKGZ1bmN0aW9uKHBhY2tldCkge1xuICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCFCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEgPyBnbG9iYWwuQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9Tb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lKCl7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKXtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpXG4gICAgfHwgKCd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG4iLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2goZSkgeyB9XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgndXRmOCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnXG4gICAgLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmICgnOicgIT0gY2hyKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJycgPT0gbGVuZ3RoIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgaSArPSBuO1xuICAgICAgbGVuZ3RoID0gJyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCAhPSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcblxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgbnVtYmVyVG9vTG9uZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGlmKG51bWJlclRvb0xvbmcpIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG4iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuIiwiXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIGlmIChvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJ2YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgcmVFeHRlbnNpb24gPSAvXi4qXFwuKFxcdyspJC87XG52YXIgdG9CdWZmZXIgPSByZXF1aXJlKCd0eXBlZGFycmF5LXRvLWJ1ZmZlcicpO1xuXG5mdW5jdGlvbiBGaWxlUmVhZFN0cmVhbShmaWxlLCBvcHRzKSB7XG4gIHZhciByZWFkU3RyZWFtID0gdGhpcztcbiAgaWYgKCEgKHRoaXMgaW5zdGFuY2VvZiBGaWxlUmVhZFN0cmVhbSkpIHtcbiAgICByZXR1cm4gbmV3IEZpbGVSZWFkU3RyZWFtKGZpbGUsIG9wdHMpO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIC8vIGluaGVyaXQgcmVhZGFibGVcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAvLyBzYXZlIHRoZSByZWFkIG9mZnNldFxuICB0aGlzLl9vZmZzZXQgPSAwO1xuICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICB0aGlzLl9maWxlID0gZmlsZTtcbiAgdGhpcy5fc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgdGhpcy5fY2h1bmtTaXplID0gb3B0cy5jaHVua1NpemUgfHwgTWF0aC5tYXgodGhpcy5fc2l6ZSAvIDEwMDAsIDIwMCAqIDEwMjQpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgcmVhZGVyXG4gIHRoaXMucmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAvLyBnZW5lcmF0ZSB0aGUgaGVhZGVyIGJsb2NrcyB0aGF0IHdlIHdpbGwgc2VuZCBhcyBwYXJ0IG9mIHRoZSBpbml0aWFsIHBheWxvYWRcbiAgdGhpcy5fZ2VuZXJhdGVIZWFkZXJCbG9ja3MoZmlsZSwgb3B0cywgZnVuY3Rpb24oZXJyLCBibG9ja3MpIHtcbiAgICAvLyBpZiB3ZSBlbmNvdW50ZXJlZCBhbiBlcnJvciwgZW1pdCBpdFxuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiByZWFkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG5cbiAgICAvLyBwdXNoIHRoZSBoZWFkZXIgYmxvY2tzIG91dCB0byB0aGUgc3RyZWFtXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2tzKSkge1xuICAgICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHJlYWRTdHJlYW0ucHVzaChibG9jayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZWFkU3RyZWFtLl9yZWFkeSA9IHRydWU7XG4gICAgcmVhZFN0cmVhbS5lbWl0KCdfcmVhZHknKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEZpbGVSZWFkU3RyZWFtLCBSZWFkYWJsZSk7XG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVSZWFkU3RyZWFtO1xuXG5GaWxlUmVhZFN0cmVhbS5wcm90b3R5cGUuX2dlbmVyYXRlSGVhZGVyQmxvY2tzID0gZnVuY3Rpb24oZmlsZSwgb3B0cywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgW10pO1xufTtcblxuRmlsZVJlYWRTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmVhZHkpIHtcbiAgICB0aGlzLm9uY2UoJ19yZWFkeScsIHRoaXMuX3JlYWQuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWFkU3RyZWFtID0gdGhpcztcbiAgdmFyIHJlYWRlciA9IHRoaXMucmVhZGVyO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgdmFyIGVuZE9mZnNldCA9IHRoaXMuX29mZnNldCArIHRoaXMuX2NodW5rU2l6ZTtcbiAgaWYgKGVuZE9mZnNldCA+IHRoaXMuX3NpemUpIGVuZE9mZnNldCA9IHRoaXMuX3NpemU7XG5cbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSB0aGlzLl9zaXplKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5wdXNoKG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cGRhdGUgdGhlIHN0cmVhbSBvZmZzZXRcbiAgICByZWFkU3RyZWFtLl9vZmZzZXQgPSBlbmRPZmZzZXQ7XG5cbiAgICAvLyBnZXQgdGhlIGRhdGEgY2h1bmtcbiAgICByZWFkU3RyZWFtLnB1c2godG9CdWZmZXIocmVhZGVyLnJlc3VsdCkpO1xuICB9XG4gIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmVhZFN0cmVhbS5lbWl0KCdlcnJvcicsIHJlYWRlci5lcnJvcik7XG4gIH1cblxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIodGhpcy5fZmlsZS5zbGljZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSk7XG59O1xuXG5GaWxlUmVhZFN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9maWxlID0gbnVsbDtcbiAgaWYgKHRoaXMucmVhZGVyKSB7XG4gICAgdGhpcy5yZWFkZXIub25sb2FkID0gbnVsbDtcbiAgICB0aGlzLnJlYWRlci5vbmVycm9yID0gbnVsbDtcbiAgICB0cnkgeyB0aGlzLnJlYWRlci5hYm9ydCgpOyB9IGNhdGNoIChlKSB7fTtcbiAgfVxuICB0aGlzLnJlYWRlciA9IG51bGw7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsYXR0ZW4obGlzdCwgZGVwdGgpIHtcbiAgZGVwdGggPSAodHlwZW9mIGRlcHRoID09ICdudW1iZXInKSA/IGRlcHRoIDogSW5maW5pdHk7XG5cbiAgaWYgKCFkZXB0aCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgICByZXR1cm4gbGlzdC5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmV0dXJuIF9mbGF0dGVuKGxpc3QsIDEpO1xuXG4gIGZ1bmN0aW9uIF9mbGF0dGVuKGxpc3QsIGQpIHtcbiAgICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaXRlbSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgJiYgZCA8IGRlcHRoKSB7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KF9mbGF0dGVuKGl0ZW0sIGQgKyAxKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoaXRlbSk7XG4gICAgICB9XG4gICAgfSwgW10pO1xuICB9XG59O1xuIiwiLy8gb3JpZ2luYWxseSBwdWxsZWQgb3V0IG9mIHNpbXBsZS1wZWVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QnJvd3NlclJUQyAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGxcbiAgdmFyIHdydGMgPSB7XG4gICAgUlRDUGVlckNvbm5lY3Rpb246IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbixcbiAgICBSVENTZXNzaW9uRGVzY3JpcHRpb246IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gfHxcbiAgICAgIHdpbmRvdy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgd2luZG93LndlYmtpdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbixcbiAgICBSVENJY2VDYW5kaWRhdGU6IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93Lm1velJUQ0ljZUNhbmRpZGF0ZSB8fFxuICAgICAgd2luZG93LndlYmtpdFJUQ0ljZUNhbmRpZGF0ZVxuICB9XG4gIGlmICghd3J0Yy5SVENQZWVyQ29ubmVjdGlvbikgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHdydGNcbn1cbiIsIlxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgICAgIGlmIChvYmoudG9KU09OICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuIiwidmFyIGhhdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdHMsIGJhc2UpIHtcbiAgICBpZiAoIWJhc2UpIGJhc2UgPSAxNjtcbiAgICBpZiAoYml0cyA9PT0gdW5kZWZpbmVkKSBiaXRzID0gMTI4O1xuICAgIGlmIChiaXRzIDw9IDApIHJldHVybiAnMCc7XG4gICAgXG4gICAgdmFyIGRpZ2l0cyA9IE1hdGgubG9nKE1hdGgucG93KDIsIGJpdHMpKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgIGZvciAodmFyIGkgPSAyOyBkaWdpdHMgPT09IEluZmluaXR5OyBpICo9IDIpIHtcbiAgICAgICAgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cyAvIGkpKSAvIE1hdGgubG9nKGJhc2UpICogaTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlbSA9IGRpZ2l0cyAtIE1hdGguZmxvb3IoZGlnaXRzKTtcbiAgICBcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLmZsb29yKGRpZ2l0cyk7IGkrKykge1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICByZXMgPSB4ICsgcmVzO1xuICAgIH1cbiAgICBcbiAgICBpZiAocmVtKSB7XG4gICAgICAgIHZhciBiID0gTWF0aC5wb3coYmFzZSwgcmVtKTtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBiKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgcmVzID0geCArIHJlcztcbiAgICB9XG4gICAgXG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHJlcywgYmFzZSk7XG4gICAgaWYgKHBhcnNlZCAhPT0gSW5maW5pdHkgJiYgcGFyc2VkID49IE1hdGgucG93KDIsIGJpdHMpKSB7XG4gICAgICAgIHJldHVybiBoYXQoYml0cywgYmFzZSlcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gcmVzO1xufTtcblxuaGF0LnJhY2sgPSBmdW5jdGlvbiAoYml0cywgYmFzZSwgZXhwYW5kQnkpIHtcbiAgICB2YXIgZm4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgaXRlcnMgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoaXRlcnMgKysgPiAxMCkge1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRCeSkgYml0cyArPSBleHBhbmRCeTtcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgSUQgY29sbGlzaW9ucywgdXNlIG1vcmUgYml0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpZCA9IGhhdChiaXRzLCBiYXNlKTtcbiAgICAgICAgfSB3aGlsZSAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoaGF0cywgaWQpKTtcbiAgICAgICAgXG4gICAgICAgIGhhdHNbaWRdID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG4gICAgdmFyIGhhdHMgPSBmbi5oYXRzID0ge307XG4gICAgXG4gICAgZm4uZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBmbi5oYXRzW2lkXTtcbiAgICB9O1xuICAgIFxuICAgIGZuLnNldCA9IGZ1bmN0aW9uIChpZCwgdmFsdWUpIHtcbiAgICAgICAgZm4uaGF0c1tpZF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgXG4gICAgZm4uYml0cyA9IGJpdHMgfHwgMTI4O1xuICAgIGZuLmJhc2UgPSBiYXNlIHx8IDE2O1xuICAgIHJldHVybiBmbjtcbn07XG4iLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHM7XG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gICAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XTtcbn07XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBwYXJhbXMuc2NoZW1lID0gJ2h0dHBzJztcbiAgICBwYXJhbXMucHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYik7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gSW1tZWRpYXRlU3RvcmVcblxuZnVuY3Rpb24gSW1tZWRpYXRlU3RvcmUgKHN0b3JlKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbW1lZGlhdGVTdG9yZSkpIHJldHVybiBuZXcgSW1tZWRpYXRlU3RvcmUoc3RvcmUpXG5cbiAgdGhpcy5zdG9yZSA9IHN0b3JlXG4gIHRoaXMuY2h1bmtMZW5ndGggPSBzdG9yZS5jaHVua0xlbmd0aFxuXG4gIGlmICghdGhpcy5zdG9yZSB8fCAhdGhpcy5zdG9yZS5nZXQgfHwgIXRoaXMuc3RvcmUucHV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFic3RyYWN0LWNodW5rLXN0b3JlIGNvbXBsaWFudCcpXG4gIH1cblxuICB0aGlzLm1lbSA9IFtdXG59XG5cbkltbWVkaWF0ZVN0b3JlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoaW5kZXgsIGJ1ZiwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYubWVtW2luZGV4XSA9IGJ1ZlxuICBzZWxmLnN0b3JlLnB1dChpbmRleCwgYnVmLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5tZW1baW5kZXhdID0gbnVsbFxuICAgIGlmIChjYikgY2IoZXJyKVxuICB9KVxufVxuXG5JbW1lZGlhdGVTdG9yZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmdldChpbmRleCwgbnVsbCwgb3B0cylcblxuICB2YXIgc3RhcnQgPSAob3B0cyAmJiBvcHRzLm9mZnNldCkgfHwgMFxuICB2YXIgZW5kID0gb3B0cyAmJiBvcHRzLmxlbmd0aCAmJiAoc3RhcnQgKyBvcHRzLmxlbmd0aClcblxuICB2YXIgYnVmID0gdGhpcy5tZW1baW5kZXhdXG4gIGlmIChidWYpIHJldHVybiBuZXh0VGljayhjYiwgbnVsbCwgb3B0cyA/IGJ1Zi5zbGljZShzdGFydCwgZW5kKSA6IGJ1ZilcblxuICB0aGlzLnN0b3JlLmdldChpbmRleCwgb3B0cywgY2IpXG59XG5cbkltbWVkaWF0ZVN0b3JlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYikge1xuICB0aGlzLnN0b3JlLmNsb3NlKGNiKVxufVxuXG5JbW1lZGlhdGVTdG9yZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICB0aGlzLnN0b3JlLmRlc3Ryb3koY2IpXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgZXJyLCB2YWwpIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSBjYihlcnIsIHZhbClcbiAgfSlcbn1cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGV4cGFuZElQdjYsIGlwYWRkciwgaXB2NFBhcnQsIGlwdjRSZWdleGVzLCBpcHY2UGFydCwgaXB2NlJlZ2V4ZXMsIG1hdGNoQ0lEUiwgcm9vdDtcblxuICBpcGFkZHIgPSB7fTtcblxuICByb290ID0gdGhpcztcblxuICBpZiAoKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaXBhZGRyO1xuICB9IGVsc2Uge1xuICAgIHJvb3RbJ2lwYWRkciddID0gaXBhZGRyO1xuICB9XG5cbiAgbWF0Y2hDSURSID0gZnVuY3Rpb24oZmlyc3QsIHNlY29uZCwgcGFydFNpemUsIGNpZHJCaXRzKSB7XG4gICAgdmFyIHBhcnQsIHNoaWZ0O1xuICAgIGlmIChmaXJzdC5sZW5ndGggIT09IHNlY29uZC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogY2Fubm90IG1hdGNoIENJRFIgZm9yIG9iamVjdHMgd2l0aCBkaWZmZXJlbnQgbGVuZ3Roc1wiKTtcbiAgICB9XG4gICAgcGFydCA9IDA7XG4gICAgd2hpbGUgKGNpZHJCaXRzID4gMCkge1xuICAgICAgc2hpZnQgPSBwYXJ0U2l6ZSAtIGNpZHJCaXRzO1xuICAgICAgaWYgKHNoaWZ0IDwgMCkge1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RbcGFydF0gPj4gc2hpZnQgIT09IHNlY29uZFtwYXJ0XSA+PiBzaGlmdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaWRyQml0cyAtPSBwYXJ0U2l6ZTtcbiAgICAgIHBhcnQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgaXBhZGRyLnN1Ym5ldE1hdGNoID0gZnVuY3Rpb24oYWRkcmVzcywgcmFuZ2VMaXN0LCBkZWZhdWx0TmFtZSkge1xuICAgIHZhciByYW5nZU5hbWUsIHJhbmdlU3VibmV0cywgc3VibmV0LCBfaSwgX2xlbjtcbiAgICBpZiAoZGVmYXVsdE5hbWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdE5hbWUgPSAndW5pY2FzdCc7XG4gICAgfVxuICAgIGZvciAocmFuZ2VOYW1lIGluIHJhbmdlTGlzdCkge1xuICAgICAgcmFuZ2VTdWJuZXRzID0gcmFuZ2VMaXN0W3JhbmdlTmFtZV07XG4gICAgICBpZiAocmFuZ2VTdWJuZXRzWzBdICYmICEocmFuZ2VTdWJuZXRzWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHJhbmdlU3VibmV0cyA9IFtyYW5nZVN1Ym5ldHNdO1xuICAgICAgfVxuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSByYW5nZVN1Ym5ldHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgc3VibmV0ID0gcmFuZ2VTdWJuZXRzW19pXTtcbiAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2guYXBwbHkoYWRkcmVzcywgc3VibmV0KSkge1xuICAgICAgICAgIHJldHVybiByYW5nZU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHROYW1lO1xuICB9O1xuXG4gIGlwYWRkci5JUHY0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElQdjQob2N0ZXRzKSB7XG4gICAgICB2YXIgb2N0ZXQsIF9pLCBfbGVuO1xuICAgICAgaWYgKG9jdGV0cy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBpcHY0IG9jdGV0IGNvdW50IHNob3VsZCBiZSA0XCIpO1xuICAgICAgfVxuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvY3RldHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb2N0ZXQgPSBvY3RldHNbX2ldO1xuICAgICAgICBpZiAoISgoMCA8PSBvY3RldCAmJiBvY3RldCA8PSAyNTUpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogaXB2NCBvY3RldCBzaG91bGQgZml0IGluIDggYml0c1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vY3RldHMgPSBvY3RldHM7XG4gICAgfVxuXG4gICAgSVB2NC5wcm90b3R5cGUua2luZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdpcHY0JztcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9jdGV0cy5qb2luKFwiLlwiKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9jdGV0cy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgY2lkclJhbmdlKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGlmIChjaWRyUmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgICBfcmVmID0gb3RoZXIsIG90aGVyID0gX3JlZlswXSwgY2lkclJhbmdlID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlci5raW5kKCkgIT09ICdpcHY0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGNhbm5vdCBtYXRjaCBpcHY0IGFkZHJlc3Mgd2l0aCBub24taXB2NCBvbmVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hDSURSKHRoaXMub2N0ZXRzLCBvdGhlci5vY3RldHMsIDgsIGNpZHJSYW5nZSk7XG4gICAgfTtcblxuICAgIElQdjQucHJvdG90eXBlLlNwZWNpYWxSYW5nZXMgPSB7XG4gICAgICB1bnNwZWNpZmllZDogW1tuZXcgSVB2NChbMCwgMCwgMCwgMF0pLCA4XV0sXG4gICAgICBicm9hZGNhc3Q6IFtbbmV3IElQdjQoWzI1NSwgMjU1LCAyNTUsIDI1NV0pLCAzMl1dLFxuICAgICAgbXVsdGljYXN0OiBbW25ldyBJUHY0KFsyMjQsIDAsIDAsIDBdKSwgNF1dLFxuICAgICAgbGlua0xvY2FsOiBbW25ldyBJUHY0KFsxNjksIDI1NCwgMCwgMF0pLCAxNl1dLFxuICAgICAgbG9vcGJhY2s6IFtbbmV3IElQdjQoWzEyNywgMCwgMCwgMF0pLCA4XV0sXG4gICAgICBcInByaXZhdGVcIjogW1tuZXcgSVB2NChbMTAsIDAsIDAsIDBdKSwgOF0sIFtuZXcgSVB2NChbMTcyLCAxNiwgMCwgMF0pLCAxMl0sIFtuZXcgSVB2NChbMTkyLCAxNjgsIDAsIDBdKSwgMTZdXSxcbiAgICAgIHJlc2VydmVkOiBbW25ldyBJUHY0KFsxOTIsIDAsIDAsIDBdKSwgMjRdLCBbbmV3IElQdjQoWzE5MiwgMCwgMiwgMF0pLCAyNF0sIFtuZXcgSVB2NChbMTkyLCA4OCwgOTksIDBdKSwgMjRdLCBbbmV3IElQdjQoWzE5OCwgNTEsIDEwMCwgMF0pLCAyNF0sIFtuZXcgSVB2NChbMjAzLCAwLCAxMTMsIDBdKSwgMjRdLCBbbmV3IElQdjQoWzI0MCwgMCwgMCwgMF0pLCA0XV1cbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpcGFkZHIuc3VibmV0TWF0Y2godGhpcywgdGhpcy5TcGVjaWFsUmFuZ2VzKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUudG9JUHY0TWFwcGVkQWRkcmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LnBhcnNlKFwiOjpmZmZmOlwiICsgKHRoaXMudG9TdHJpbmcoKSkpO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS5wcmVmaXhMZW5ndGhGcm9tU3VibmV0TWFzayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNpZHIsIGksIG9jdGV0LCBzdG9wLCB6ZXJvcywgemVyb3RhYmxlLCBfaTtcbiAgICAgIHplcm90YWJsZSA9IHtcbiAgICAgICAgMDogOCxcbiAgICAgICAgMTI4OiA3LFxuICAgICAgICAxOTI6IDYsXG4gICAgICAgIDIyNDogNSxcbiAgICAgICAgMjQwOiA0LFxuICAgICAgICAyNDg6IDMsXG4gICAgICAgIDI1MjogMixcbiAgICAgICAgMjU0OiAxLFxuICAgICAgICAyNTU6IDBcbiAgICAgIH07XG4gICAgICBjaWRyID0gMDtcbiAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IF9pID0gMzsgX2kgPj0gMDsgaSA9IF9pICs9IC0xKSB7XG4gICAgICAgIG9jdGV0ID0gdGhpcy5vY3RldHNbaV07XG4gICAgICAgIGlmIChvY3RldCBpbiB6ZXJvdGFibGUpIHtcbiAgICAgICAgICB6ZXJvcyA9IHplcm90YWJsZVtvY3RldF07XG4gICAgICAgICAgaWYgKHN0b3AgJiYgemVyb3MgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoemVyb3MgIT09IDgpIHtcbiAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaWRyICs9IHplcm9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMzIgLSBjaWRyO1xuICAgIH07XG5cbiAgICByZXR1cm4gSVB2NDtcblxuICB9KSgpO1xuXG4gIGlwdjRQYXJ0ID0gXCIoMD9cXFxcZCt8MHhbYS1mMC05XSspXCI7XG5cbiAgaXB2NFJlZ2V4ZXMgPSB7XG4gICAgZm91ck9jdGV0OiBuZXcgUmVnRXhwKFwiXlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIiRcIiwgJ2knKSxcbiAgICBsb25nVmFsdWU6IG5ldyBSZWdFeHAoXCJeXCIgKyBpcHY0UGFydCArIFwiJFwiLCAnaScpXG4gIH07XG5cbiAgaXBhZGRyLklQdjQucGFyc2VyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoLCBwYXJzZUludEF1dG8sIHBhcnQsIHNoaWZ0LCB2YWx1ZTtcbiAgICBwYXJzZUludEF1dG8gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmdbMF0gPT09IFwiMFwiICYmIHN0cmluZ1sxXSAhPT0gXCJ4XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY0UmVnZXhlcy5mb3VyT2N0ZXQpKSB7XG4gICAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gbWF0Y2guc2xpY2UoMSwgNik7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHBhcnQgPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnNlSW50QXV0byhwYXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjRSZWdleGVzLmxvbmdWYWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VJbnRBdXRvKG1hdGNoWzFdKTtcbiAgICAgIGlmICh2YWx1ZSA+IDB4ZmZmZmZmZmYgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogYWRkcmVzcyBvdXRzaWRlIGRlZmluZWQgcmFuZ2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChzaGlmdCA9IF9pID0gMDsgX2kgPD0gMjQ7IHNoaWZ0ID0gX2kgKz0gOCkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goKHZhbHVlID4+IHNoaWZ0KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpLnJldmVyc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5JUHY2ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElQdjYocGFydHMpIHtcbiAgICAgIHZhciBpLCBwYXJ0LCBfaSwgX2osIF9sZW4sIF9yZWY7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxNikge1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPD0gMTQ7IGkgPSBfaSArPSAyKSB7XG4gICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKChwYXJ0c1tpXSA8PCA4KSB8IHBhcnRzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogaXB2NiBwYXJ0IGNvdW50IHNob3VsZCBiZSA4IG9yIDE2XCIpO1xuICAgICAgfVxuICAgICAgX3JlZiA9IHRoaXMucGFydHM7XG4gICAgICBmb3IgKF9qID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaiA8IF9sZW47IF9qKyspIHtcbiAgICAgICAgcGFydCA9IF9yZWZbX2pdO1xuICAgICAgICBpZiAoISgoMCA8PSBwYXJ0ICYmIHBhcnQgPD0gMHhmZmZmKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGlwdjYgcGFydCBzaG91bGQgZml0IGluIDE2IGJpdHNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBJUHY2LnByb3RvdHlwZS5raW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ2lwdjYnO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbXBhY3RTdHJpbmdQYXJ0cywgcGFydCwgcHVzaFBhcnQsIHN0YXRlLCBzdHJpbmdQYXJ0cywgX2ksIF9sZW47XG4gICAgICBzdHJpbmdQYXJ0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMucGFydHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHBhcnQgPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnQudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgY29tcGFjdFN0cmluZ1BhcnRzID0gW107XG4gICAgICBwdXNoUGFydCA9IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhY3RTdHJpbmdQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgfTtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc3RyaW5nUGFydHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFydCA9IHN0cmluZ1BhcnRzW19pXTtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgcHVzaFBhcnQoJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHVzaFBhcnQocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2hQYXJ0KHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKHBhcnQgIT09ICcwJykge1xuICAgICAgICAgICAgICBwdXNoUGFydCgnJyk7XG4gICAgICAgICAgICAgIHB1c2hQYXJ0KHBhcnQpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBwdXNoUGFydChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAyKSB7XG4gICAgICAgIHB1c2hQYXJ0KCcnKTtcbiAgICAgICAgcHVzaFBhcnQoJycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbXBhY3RTdHJpbmdQYXJ0cy5qb2luKFwiOlwiKTtcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBieXRlcywgcGFydCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBieXRlcyA9IFtdO1xuICAgICAgX3JlZiA9IHRoaXMucGFydHM7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFydCA9IF9yZWZbX2ldO1xuICAgICAgICBieXRlcy5wdXNoKHBhcnQgPj4gOCk7XG4gICAgICAgIGJ5dGVzLnB1c2gocGFydCAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b05vcm1hbGl6ZWRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJ0O1xuICAgICAgcmV0dXJuICgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLnBhcnRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwYXJ0ID0gX3JlZltfaV07XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChwYXJ0LnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSkuam9pbihcIjpcIik7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ob3RoZXIsIGNpZHJSYW5nZSkge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICBpZiAoY2lkclJhbmdlID09PSB2b2lkIDApIHtcbiAgICAgICAgX3JlZiA9IG90aGVyLCBvdGhlciA9IF9yZWZbMF0sIGNpZHJSYW5nZSA9IF9yZWZbMV07XG4gICAgICB9XG4gICAgICBpZiAob3RoZXIua2luZCgpICE9PSAnaXB2NicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBjYW5ub3QgbWF0Y2ggaXB2NiBhZGRyZXNzIHdpdGggbm9uLWlwdjYgb25lXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoQ0lEUih0aGlzLnBhcnRzLCBvdGhlci5wYXJ0cywgMTYsIGNpZHJSYW5nZSk7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLlNwZWNpYWxSYW5nZXMgPSB7XG4gICAgICB1bnNwZWNpZmllZDogW25ldyBJUHY2KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDEyOF0sXG4gICAgICBsaW5rTG9jYWw6IFtuZXcgSVB2NihbMHhmZTgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDEwXSxcbiAgICAgIG11bHRpY2FzdDogW25ldyBJUHY2KFsweGZmMDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgOF0sXG4gICAgICBsb29wYmFjazogW25ldyBJUHY2KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAxXSksIDEyOF0sXG4gICAgICB1bmlxdWVMb2NhbDogW25ldyBJUHY2KFsweGZjMDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgN10sXG4gICAgICBpcHY0TWFwcGVkOiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDAsIDB4ZmZmZiwgMCwgMF0pLCA5Nl0sXG4gICAgICByZmM2MTQ1OiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDB4ZmZmZiwgMCwgMCwgMF0pLCA5Nl0sXG4gICAgICByZmM2MDUyOiBbbmV3IElQdjYoWzB4NjQsIDB4ZmY5YiwgMCwgMCwgMCwgMCwgMCwgMF0pLCA5Nl0sXG4gICAgICAnNnRvNCc6IFtuZXcgSVB2NihbMHgyMDAyLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDE2XSxcbiAgICAgIHRlcmVkbzogW25ldyBJUHY2KFsweDIwMDEsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMzJdLFxuICAgICAgcmVzZXJ2ZWQ6IFtbbmV3IElQdjYoWzB4MjAwMSwgMHhkYjgsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMzJdXVxuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlwYWRkci5zdWJuZXRNYXRjaCh0aGlzLCB0aGlzLlNwZWNpYWxSYW5nZXMpO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS5pc0lQdjRNYXBwZWRBZGRyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZSgpID09PSAnaXB2NE1hcHBlZCc7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvSVB2NEFkZHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoaWdoLCBsb3csIF9yZWY7XG4gICAgICBpZiAoIXRoaXMuaXNJUHY0TWFwcGVkQWRkcmVzcygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogdHJ5aW5nIHRvIGNvbnZlcnQgYSBnZW5lcmljIGlwdjYgYWRkcmVzcyB0byBpcHY0XCIpO1xuICAgICAgfVxuICAgICAgX3JlZiA9IHRoaXMucGFydHMuc2xpY2UoLTIpLCBoaWdoID0gX3JlZlswXSwgbG93ID0gX3JlZlsxXTtcbiAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjQoW2hpZ2ggPj4gOCwgaGlnaCAmIDB4ZmYsIGxvdyA+PiA4LCBsb3cgJiAweGZmXSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJUHY2O1xuXG4gIH0pKCk7XG5cbiAgaXB2NlBhcnQgPSBcIig/OlswLTlhLWZdKzo6PykrXCI7XG5cbiAgaXB2NlJlZ2V4ZXMgPSB7XG4gICAgXCJuYXRpdmVcIjogbmV3IFJlZ0V4cChcIl4oOjopPyhcIiArIGlwdjZQYXJ0ICsgXCIpPyhbMC05YS1mXSspPyg6Oik/JFwiLCAnaScpLFxuICAgIHRyYW5zaXRpb25hbDogbmV3IFJlZ0V4cCgoXCJeKCg/OlwiICsgaXB2NlBhcnQgKyBcIil8KD86OjopKD86XCIgKyBpcHY2UGFydCArIFwiKT8pXCIpICsgKFwiXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiJFwiKSwgJ2knKVxuICB9O1xuXG4gIGV4cGFuZElQdjYgPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7XG4gICAgdmFyIGNvbG9uQ291bnQsIGxhc3RDb2xvbiwgcGFydCwgcmVwbGFjZW1lbnQsIHJlcGxhY2VtZW50Q291bnQ7XG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCc6OicpICE9PSBzdHJpbmcubGFzdEluZGV4T2YoJzo6JykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb2xvbkNvdW50ID0gMDtcbiAgICBsYXN0Q29sb24gPSAtMTtcbiAgICB3aGlsZSAoKGxhc3RDb2xvbiA9IHN0cmluZy5pbmRleE9mKCc6JywgbGFzdENvbG9uICsgMSkpID49IDApIHtcbiAgICAgIGNvbG9uQ291bnQrKztcbiAgICB9XG4gICAgaWYgKHN0cmluZy5zdWJzdHIoMCwgMikgPT09ICc6OicpIHtcbiAgICAgIGNvbG9uQ291bnQtLTtcbiAgICB9XG4gICAgaWYgKHN0cmluZy5zdWJzdHIoLTIsIDIpID09PSAnOjonKSB7XG4gICAgICBjb2xvbkNvdW50LS07XG4gICAgfVxuICAgIGlmIChjb2xvbkNvdW50ID4gcGFydHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXBsYWNlbWVudENvdW50ID0gcGFydHMgLSBjb2xvbkNvdW50O1xuICAgIHJlcGxhY2VtZW50ID0gJzonO1xuICAgIHdoaWxlIChyZXBsYWNlbWVudENvdW50LS0pIHtcbiAgICAgIHJlcGxhY2VtZW50ICs9ICcwOic7XG4gICAgfVxuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKCc6OicsIHJlcGxhY2VtZW50KTtcbiAgICBpZiAoc3RyaW5nWzBdID09PSAnOicpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKTtcbiAgICB9XG4gICAgaWYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICc6Jykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVmID0gc3RyaW5nLnNwbGl0KFwiOlwiKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFydCA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkoKTtcbiAgfTtcblxuICBpcGFkZHIuSVB2Ni5wYXJzZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2gsIG9jdGV0LCBvY3RldHMsIHBhcnRzLCBfaSwgX2xlbjtcbiAgICBpZiAoc3RyaW5nLm1hdGNoKGlwdjZSZWdleGVzWyduYXRpdmUnXSkpIHtcbiAgICAgIHJldHVybiBleHBhbmRJUHY2KHN0cmluZywgOCk7XG4gICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY2UmVnZXhlc1sndHJhbnNpdGlvbmFsJ10pKSB7XG4gICAgICBwYXJ0cyA9IGV4cGFuZElQdjYobWF0Y2hbMV0uc2xpY2UoMCwgLTEpLCA2KTtcbiAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICBvY3RldHMgPSBbcGFyc2VJbnQobWF0Y2hbMl0pLCBwYXJzZUludChtYXRjaFszXSksIHBhcnNlSW50KG1hdGNoWzRdKSwgcGFyc2VJbnQobWF0Y2hbNV0pXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvY3RldHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBvY3RldCA9IG9jdGV0c1tfaV07XG4gICAgICAgICAgaWYgKCEoKDAgPD0gb2N0ZXQgJiYgb2N0ZXQgPD0gMjU1KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKG9jdGV0c1swXSA8PCA4IHwgb2N0ZXRzWzFdKTtcbiAgICAgICAgcGFydHMucHVzaChvY3RldHNbMl0gPDwgOCB8IG9jdGV0c1szXSk7XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgaXBhZGRyLklQdjQuaXNJUHY0ID0gaXBhZGRyLklQdjYuaXNJUHY2ID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VyKHN0cmluZykgIT09IG51bGw7XG4gIH07XG5cbiAgaXBhZGRyLklQdjQuaXNWYWxpZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBlO1xuICAgIHRyeSB7XG4gICAgICBuZXcgdGhpcyh0aGlzLnBhcnNlcihzdHJpbmcpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLklQdjYuaXNWYWxpZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBlO1xuICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSBcInN0cmluZ1wiICYmIHN0cmluZy5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyB0aGlzKHRoaXMucGFyc2VyKHN0cmluZykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuSVB2NC5wYXJzZSA9IGlwYWRkci5JUHY2LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHBhcnRzO1xuICAgIHBhcnRzID0gdGhpcy5wYXJzZXIoc3RyaW5nKTtcbiAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBpcCBhZGRyZXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMocGFydHMpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY0LnBhcnNlQ0lEUiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBtYXNrTGVuZ3RoLCBtYXRjaDtcbiAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oLispXFwvKFxcZCspJC8pKSB7XG4gICAgICBtYXNrTGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgaWYgKG1hc2tMZW5ndGggPj0gMCAmJiBtYXNrTGVuZ3RoIDw9IDMyKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5wYXJzZShtYXRjaFsxXSksIG1hc2tMZW5ndGhdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHN0cmluZyBpcyBub3QgZm9ybWF0dGVkIGxpa2UgYW4gSVB2NCBDSURSIHJhbmdlXCIpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY2LnBhcnNlQ0lEUiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBtYXNrTGVuZ3RoLCBtYXRjaDtcbiAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oLispXFwvKFxcZCspJC8pKSB7XG4gICAgICBtYXNrTGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgaWYgKG1hc2tMZW5ndGggPj0gMCAmJiBtYXNrTGVuZ3RoIDw9IDEyOCkge1xuICAgICAgICByZXR1cm4gW3RoaXMucGFyc2UobWF0Y2hbMV0pLCBtYXNrTGVuZ3RoXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBzdHJpbmcgaXMgbm90IGZvcm1hdHRlZCBsaWtlIGFuIElQdjYgQ0lEUiByYW5nZVwiKTtcbiAgfTtcblxuICBpcGFkZHIuaXNWYWxpZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBpcGFkZHIuSVB2Ni5pc1ZhbGlkKHN0cmluZykgfHwgaXBhZGRyLklQdjQuaXNWYWxpZChzdHJpbmcpO1xuICB9O1xuXG4gIGlwYWRkci5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmIChpcGFkZHIuSVB2Ni5pc1ZhbGlkKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBpcGFkZHIuSVB2Ni5wYXJzZShzdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXBhZGRyLklQdjQuaXNWYWxpZChzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gaXBhZGRyLklQdjQucGFyc2Uoc3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiB0aGUgYWRkcmVzcyBoYXMgbmVpdGhlciBJUHY2IG5vciBJUHY0IGZvcm1hdFwiKTtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLnBhcnNlQ0lEUiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaXBhZGRyLklQdjYucGFyc2VDSURSKHN0cmluZyk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlwYWRkci5JUHY0LnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogdGhlIGFkZHJlc3MgaGFzIG5laXRoZXIgSVB2NiBub3IgSVB2NCBDSURSIGZvcm1hdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLmZyb21CeXRlQXJyYXkgPSBmdW5jdGlvbihieXRlcykge1xuICAgIHZhciBsZW5ndGg7XG4gICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjQoYnl0ZXMpO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSAxNikge1xuICAgICAgcmV0dXJuIG5ldyBpcGFkZHIuSVB2NihieXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogdGhlIGJpbmFyeSBpbnB1dCBpcyBuZWl0aGVyIGFuIElQdjYgbm9yIElQdjQgYWRkcmVzc1wiKTtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLnByb2Nlc3MgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgYWRkcjtcbiAgICBhZGRyID0gdGhpcy5wYXJzZShzdHJpbmcpO1xuICAgIGlmIChhZGRyLmtpbmQoKSA9PT0gJ2lwdjYnICYmIGFkZHIuaXNJUHY0TWFwcGVkQWRkcmVzcygpKSB7XG4gICAgICByZXR1cm4gYWRkci50b0lQdjRBZGRyZXNzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhZGRyO1xuICAgIH1cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qIChjKSAyMDE2IEFyaSBQb3JhZCAoQGFyaXBvcmFkKSA8aHR0cDovL2FyaXBvcmFkLmNvbT4uIExpY2Vuc2U6IGFyaXBvcmFkLm1pdC1saWNlbnNlLm9yZyAqL1xuXG4vLyBQYXJ0aWFsbHkgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85NDA0OS8xOTI4NDg0LCBhbmQgZnJvbSBhbm90aGVyIFNPIGFuc3dlciwgd2hpY2ggdG9sZCBtZSB0aGF0IHRoZSBoaWdoZXN0XG4vLyBjaGFyIGNvZGUgdGhhdCdzIGFzY2lpIGlzIDEyNywgYnV0IEkgY2FuJ3QgZmluZCB0aGUgbGluayBmb3IuIFNvcnJ5LlxuXG52YXIgTUFYX0FTQ0lJX0NIQVJfQ09ERSA9IDEyNztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FzY2lpKHN0cikge1xuICBmb3IgKHZhciBpID0gMCwgc3RyTGVuID0gc3RyLmxlbmd0aDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpID4gTUFYX0FTQ0lJX0NIQVJfQ09ERSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBCdWZmZXJcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgaXMtYnVmZmVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiZcbiAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgKSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ZpbGUocGF0aCwgY2Ipe1xuICBpZighY2IpcmV0dXJuIGlzRmlsZVN5bmMocGF0aCk7XG5cbiAgZnMuc3RhdChwYXRoLCBmdW5jdGlvbihlcnIsIHN0YXRzKXtcbiAgICBpZihlcnIpcmV0dXJuIGNiKGVycik7XG4gICAgcmV0dXJuIGNiKG51bGwsIHN0YXRzLmlzRmlsZSgpKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gaXNGaWxlU3luYztcblxuZnVuY3Rpb24gaXNGaWxlU3luYyhwYXRoKXtcbiAgcmV0dXJuIGZzLmV4aXN0c1N5bmMocGF0aCkgJiYgZnMuc3RhdFN5bmMocGF0aCkuaXNGaWxlKCk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyAgICAgID0gaXNUeXBlZEFycmF5XG5pc1R5cGVkQXJyYXkuc3RyaWN0ID0gaXNTdHJpY3RUeXBlZEFycmF5XG5pc1R5cGVkQXJyYXkubG9vc2UgID0gaXNMb29zZVR5cGVkQXJyYXlcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIG5hbWVzID0ge1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgSW50MTZBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgSW50MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDhBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgICAgaXNTdHJpY3RUeXBlZEFycmF5KGFycilcbiAgICB8fCBpc0xvb3NlVHlwZWRBcnJheShhcnIpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gKFxuICAgICAgIGFyciBpbnN0YW5jZW9mIEludDhBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEludDE2QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBJbnQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDE2QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuICApXG59XG5cbmZ1bmN0aW9uIGlzTG9vc2VUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gbmFtZXNbdG9TdHJpbmcuY2FsbChhcnIpXVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC8vIEFsbFxuLy8gL15ucG0tZGVidWdcXC5sb2ckLywgICAvLyBucG0gZXJyb3IgbG9nXG4vLyAvXlxcLi4qXFwuc3dwJC8sICAgICAgICAvLyB2aW0gc3RhdGVcbi8vIC8vIE9TIFhcbi8vIC9eXFwuRFNfU3RvcmUkLywgICAgICAgLy8gc3RvcmVzIGN1c3RvbSBmb2xkZXIgYXR0cmlidXRlc1xuLy8gL15cXC5BcHBsZURvdWJsZSQvLCAgICAvLyBzdG9yZXMgYWRkaXRpb25hbCBmaWxlIHJlc291cmNlc1xuLy8gL15cXC5MU092ZXJyaWRlJC8sICAgICAvLyBjb250YWlucyB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgYXBwIHRvIGJlIHVzZWRcbi8vIC9eSWNvbltcXHJcXD9dPy8sICAgICAgIC8vIGN1c3RvbSBGaW5kZXIgaWNvblxuLy8gL15cXC5fLiovLCAgICAgICAgICAgICAvLyB0aHVtYm5haWxcbi8vIC9eXFwuU3BvdGxpZ2h0LVYxMDAkLywgIC8vIGZpbGUgdGhhdCBtaWdodCBhcHBlYXIgb24gZXh0ZXJuYWwgZGlza1xuLy8gL1xcLlRyYXNoZXMvLCAgICAgICAgICAvLyBmaWxlIHRoYXQgbWlnaHQgYXBwZWFyIG9uIGV4dGVybmFsIGRpc2tcbi8vIC9eX19NQUNPU1gkLywgICAgICAgICAvLyByZXNvdXJjZSBmb3JrXG4vLyAvLyBMaW51eFxuLy8gL34kLywgICAgICAgICAgICAgICAgIC8vIGJhY2t1cCBmaWxlXG4vLyAvLyBXaW5kb3dzXG4vLyAvXlRodW1ic1xcLmRiJC8sICAgICAgIC8vIGltYWdlIGZpbGUgY2FjaGVcbi8vIC9eZWh0aHVtYnNcXC5kYiQvLCAgICAgLy8gZm9sZGVyIGNvbmZpZyBmaWxlXG4vLyAvXkRlc2t0b3BcXC5pbmkkLyAgICAgIC8vIHN0b3JlcyBjdXN0b20gZm9sZGVyIGF0dHJpYnV0ZXNcblxuZXhwb3J0cy5yZSA9IC9ebnBtLWRlYnVnXFwubG9nJHxeXFwuLipcXC5zd3AkfF5cXC5EU19TdG9yZSR8XlxcLkFwcGxlRG91YmxlJHxeXFwuTFNPdmVycmlkZSR8Xkljb25bXFxyXFw/XT98XlxcLl8uKnxeXFwuU3BvdGxpZ2h0LVYxMDAkfFxcLlRyYXNoZXN8Xl9fTUFDT1NYJHx+JHxeVGh1bWJzXFwuZGIkfF5laHRodW1ic1xcLmRiJHxeRGVza3RvcFxcLmluaSQvO1xuXG5leHBvcnRzLmlzID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG5cdHJldHVybiBleHBvcnRzLnJlLnRlc3QoZmlsZW5hbWUpO1xufTtcblxuZXhwb3J0cy5ub3QgPSBleHBvcnRzLmlzbnQgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcblx0cmV0dXJuICFleHBvcnRzLmlzKGZpbGVuYW1lKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG1hZ25ldFVSSURlY29kZVxubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gbWFnbmV0VVJJRGVjb2RlXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSBtYWduZXRVUklFbmNvZGVcblxudmFyIGJhc2UzMiA9IHJlcXVpcmUoJ3RoaXJ0eS10d28nKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciB1bmlxID0gcmVxdWlyZSgndW5pcScpXG5cbi8qKlxuICogUGFyc2UgYSBtYWduZXQgVVJJIGFuZCByZXR1cm4gYW4gb2JqZWN0IG9mIGtleXMvdmFsdWVzXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmlcbiAqIEByZXR1cm4ge09iamVjdH0gcGFyc2VkIHVyaVxuICovXG5mdW5jdGlvbiBtYWduZXRVUklEZWNvZGUgKHVyaSkge1xuICB2YXIgcmVzdWx0ID0ge31cbiAgdmFyIGRhdGEgPSB1cmkuc3BsaXQoJ21hZ25ldDo/JylbMV1cblxuICB2YXIgcGFyYW1zID0gKGRhdGEgJiYgZGF0YS5sZW5ndGggPj0gMClcbiAgICA/IGRhdGEuc3BsaXQoJyYnKVxuICAgIDogW11cblxuICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIga2V5dmFsID0gcGFyYW0uc3BsaXQoJz0nKVxuXG4gICAgLy8gVGhpcyBrZXl2YWwgaXMgaW52YWxpZCwgc2tpcCBpdFxuICAgIGlmIChrZXl2YWwubGVuZ3RoICE9PSAyKSByZXR1cm5cblxuICAgIHZhciBrZXkgPSBrZXl2YWxbMF1cbiAgICB2YXIgdmFsID0ga2V5dmFsWzFdXG5cbiAgICAvLyBDbGVhbiB1cCB0b3JyZW50IG5hbWVcbiAgICBpZiAoa2V5ID09PSAnZG4nKSB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQodmFsKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuXG4gICAgLy8gQWRkcmVzcyB0cmFja2VyICh0ciksIGV4YWN0IHNvdXJjZSAoeHMpLCBhbmQgYWNjZXB0YWJsZSBzb3VyY2UgKGFzKSBhcmUgZW5jb2RlZFxuICAgIC8vIFVSSXMsIHNvIGRlY29kZSB0aGVtXG4gICAgaWYgKGtleSA9PT0gJ3RyJyB8fCBrZXkgPT09ICd4cycgfHwga2V5ID09PSAnYXMnIHx8IGtleSA9PT0gJ3dzJykge1xuICAgICAgdmFsID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbClcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4ga2V5d29yZHMgYXMgYW4gYXJyYXlcbiAgICBpZiAoa2V5ID09PSAna3QnKSB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQodmFsKS5zcGxpdCgnKycpXG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgcmVwZWF0ZWQgcGFyYW1ldGVycywgcmV0dXJuIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgIGlmIChyZXN1bHRba2V5XSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9sZCA9IHJlc3VsdFtrZXldXG4gICAgICAgIHJlc3VsdFtrZXldID0gW29sZCwgdmFsXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbFxuICAgIH1cbiAgfSlcblxuICAvLyBDb252ZW5pZW5jZSBwcm9wZXJ0aWVzIGZvciBwYXJpdHkgd2l0aCBgcGFyc2UtdG9ycmVudC1maWxlYCBtb2R1bGVcbiAgdmFyIG1cbiAgaWYgKHJlc3VsdC54dCkge1xuICAgIHZhciB4dHMgPSBBcnJheS5pc0FycmF5KHJlc3VsdC54dCkgPyByZXN1bHQueHQgOiBbIHJlc3VsdC54dCBdXG4gICAgeHRzLmZvckVhY2goZnVuY3Rpb24gKHh0KSB7XG4gICAgICBpZiAoKG0gPSB4dC5tYXRjaCgvXnVybjpidGloOiguezQwfSkvKSkpIHtcbiAgICAgICAgcmVzdWx0LmluZm9IYXNoID0gbVsxXS50b0xvd2VyQ2FzZSgpXG4gICAgICB9IGVsc2UgaWYgKChtID0geHQubWF0Y2goL151cm46YnRpaDooLnszMn0pLykpKSB7XG4gICAgICAgIHZhciBkZWNvZGVkU3RyID0gYmFzZTMyLmRlY29kZShtWzFdKVxuICAgICAgICByZXN1bHQuaW5mb0hhc2ggPSBuZXcgQnVmZmVyKGRlY29kZWRTdHIsICdiaW5hcnknKS50b1N0cmluZygnaGV4JylcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGlmIChyZXN1bHQuaW5mb0hhc2gpIHJlc3VsdC5pbmZvSGFzaEJ1ZmZlciA9IG5ldyBCdWZmZXIocmVzdWx0LmluZm9IYXNoLCAnaGV4JylcblxuICBpZiAocmVzdWx0LmRuKSByZXN1bHQubmFtZSA9IHJlc3VsdC5kblxuICBpZiAocmVzdWx0Lmt0KSByZXN1bHQua2V5d29yZHMgPSByZXN1bHQua3RcblxuICBpZiAodHlwZW9mIHJlc3VsdC50ciA9PT0gJ3N0cmluZycpIHJlc3VsdC5hbm5vdW5jZSA9IFsgcmVzdWx0LnRyIF1cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQudHIpKSByZXN1bHQuYW5ub3VuY2UgPSByZXN1bHQudHJcbiAgZWxzZSByZXN1bHQuYW5ub3VuY2UgPSBbXVxuXG4gIHJlc3VsdC51cmxMaXN0ID0gW11cbiAgaWYgKHR5cGVvZiByZXN1bHQuYXMgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkocmVzdWx0LmFzKSkge1xuICAgIHJlc3VsdC51cmxMaXN0ID0gcmVzdWx0LnVybExpc3QuY29uY2F0KHJlc3VsdC5hcylcbiAgfVxuICBpZiAodHlwZW9mIHJlc3VsdC53cyA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQud3MpKSB7XG4gICAgcmVzdWx0LnVybExpc3QgPSByZXN1bHQudXJsTGlzdC5jb25jYXQocmVzdWx0LndzKVxuICB9XG5cbiAgdW5pcShyZXN1bHQuYW5ub3VuY2UpXG4gIHVuaXEocmVzdWx0LnVybExpc3QpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBtYWduZXRVUklFbmNvZGUgKG9iaikge1xuICBvYmogPSBleHRlbmQob2JqKSAvLyBjbG9uZSBvYmosIHNvIHdlIGNhbiBtdXRhdGUgaXRcblxuICAvLyBzdXBwb3J0IHVzaW5nIGNvbnZlbmllbmNlIG5hbWVzLCBpbiBhZGRpdGlvbiB0byBzcGVjIG5hbWVzXG4gIC8vIChleGFtcGxlOiBgaW5mb0hhc2hgIGZvciBgeHRgLCBgbmFtZWAgZm9yIGBkbmApXG4gIGlmIChvYmouaW5mb0hhc2hCdWZmZXIpIG9iai54dCA9ICd1cm46YnRpaDonICsgb2JqLmluZm9IYXNoQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICBpZiAob2JqLmluZm9IYXNoKSBvYmoueHQgPSAndXJuOmJ0aWg6JyArIG9iai5pbmZvSGFzaFxuICBpZiAob2JqLm5hbWUpIG9iai5kbiA9IG9iai5uYW1lXG4gIGlmIChvYmoua2V5d29yZHMpIG9iai5rdCA9IG9iai5rZXl3b3Jkc1xuICBpZiAob2JqLmFubm91bmNlKSBvYmoudHIgPSBvYmouYW5ub3VuY2VcbiAgaWYgKG9iai51cmxMaXN0KSB7XG4gICAgb2JqLndzID0gb2JqLnVybExpc3RcbiAgICBkZWxldGUgb2JqLmFzXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJ21hZ25ldDo/J1xuICBPYmplY3Qua2V5cyhvYmopXG4gICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMlxuICAgIH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgdmFyIHZhbHVlcyA9IEFycmF5LmlzQXJyYXkob2JqW2tleV0pID8gb2JqW2tleV0gOiBbIG9ialtrZXldIF1cbiAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGopIHtcbiAgICAgICAgaWYgKChpID4gMCB8fCBqID4gMCkgJiYgKGtleSAhPT0gJ2t0JyB8fCBqID09PSAwKSkgcmVzdWx0ICs9ICcmJ1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdkbicpIHZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLnJlcGxhY2UoLyUyMC9nLCAnKycpXG4gICAgICAgIGlmIChrZXkgPT09ICd0cicgfHwga2V5ID09PSAneHMnIHx8IGtleSA9PT0gJ2FzJyB8fCBrZXkgPT09ICd3cycpIHtcbiAgICAgICAgICB2YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsKVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdrdCcpIHZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpXG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2t0JyAmJiBqID4gMCkgcmVzdWx0ICs9ICcrJyArIHZhbFxuICAgICAgICBlbHNlIHJlc3VsdCArPSBrZXkgKyAnPScgKyB2YWxcbiAgICAgIH0pXG4gICAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE1lZGlhRWxlbWVudFdyYXBwZXJcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgdG9BcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ3RvLWFycmF5YnVmZmVyJylcblxudmFyIE1lZGlhU291cmNlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1lZGlhU291cmNlXG5cbnZhciBERUZBVUxUX0JVRkZFUl9EVVJBVElPTiA9IDYwIC8vIHNlY29uZHNcblxuZnVuY3Rpb24gTWVkaWFFbGVtZW50V3JhcHBlciAoZWxlbSwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIE1lZGlhRWxlbWVudFdyYXBwZXIpKSByZXR1cm4gbmV3IE1lZGlhRWxlbWVudFdyYXBwZXIoZWxlbSwgb3B0cylcblxuICBpZiAoIU1lZGlhU291cmNlKSB0aHJvdyBuZXcgRXJyb3IoJ3dlYiBicm93c2VyIGxhY2tzIE1lZGlhU291cmNlIHN1cHBvcnQnKVxuXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHNlbGYuX2J1ZmZlckR1cmF0aW9uID0gb3B0cy5idWZmZXJEdXJhdGlvbiB8fCBERUZBVUxUX0JVRkZFUl9EVVJBVElPTlxuICBzZWxmLl9lbGVtID0gZWxlbVxuICBzZWxmLl9tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpXG4gIHNlbGYuX3N0cmVhbXMgPSBbXVxuICBzZWxmLmRldGFpbGVkRXJyb3IgPSBudWxsXG5cbiAgc2VsZi5fZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2VsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckhhbmRsZXIpXG4gICAgdmFyIHN0cmVhbXMgPSBzZWxmLl9zdHJlYW1zLnNsaWNlKClcbiAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmRlc3Ryb3koc2VsZi5fZWxlbS5lcnJvcilcbiAgICB9KVxuICB9XG4gIHNlbGYuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckhhbmRsZXIpXG5cbiAgc2VsZi5fZWxlbS5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzZWxmLl9tZWRpYVNvdXJjZSlcbn1cblxuLypcbiAqIGBvYmpgIGNhbiBiZSBhIHByZXZpb3VzIHZhbHVlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb25cbiAqIG9yIGEgc3RyaW5nXG4gKi9cbk1lZGlhRWxlbWVudFdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZVdyaXRlU3RyZWFtID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICByZXR1cm4gbmV3IE1lZGlhU291cmNlU3RyZWFtKHNlbGYsIG9iailcbn1cblxuLypcbiAqIFVzZSB0byB0cmlnZ2VyIGFuIGVycm9yIG9uIHRoZSB1bmRlcmx5aW5nIG1lZGlhIGVsZW1lbnRcbiAqL1xuTWVkaWFFbGVtZW50V3JhcHBlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIC8vIGJlIGNhcmVmdWwgbm90IHRvIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgZGV0YWlsZWRFcnJvciB2YWx1ZXNcbiAgaWYgKCFzZWxmLmRldGFpbGVkRXJyb3IpIHtcbiAgICBzZWxmLmRldGFpbGVkRXJyb3IgPSBlcnJcbiAgfVxuICB0cnkge1xuICAgIHNlbGYuX21lZGlhU291cmNlLmVuZE9mU3RyZWFtKCdkZWNvZGUnKVxuICB9IGNhdGNoIChlcnIpIHt9XG59XG5cbmluaGVyaXRzKE1lZGlhU291cmNlU3RyZWFtLCBzdHJlYW0uV3JpdGFibGUpXG5cbmZ1bmN0aW9uIE1lZGlhU291cmNlU3RyZWFtICh3cmFwcGVyLCBvYmopIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cbiAgc2VsZi5fd3JhcHBlciA9IHdyYXBwZXJcbiAgc2VsZi5fZWxlbSA9IHdyYXBwZXIuX2VsZW1cbiAgc2VsZi5fbWVkaWFTb3VyY2UgPSB3cmFwcGVyLl9tZWRpYVNvdXJjZVxuICBzZWxmLl9hbGxTdHJlYW1zID0gd3JhcHBlci5fc3RyZWFtc1xuICBzZWxmLl9hbGxTdHJlYW1zLnB1c2goc2VsZilcbiAgc2VsZi5fYnVmZmVyRHVyYXRpb24gPSB3cmFwcGVyLl9idWZmZXJEdXJhdGlvblxuICBzZWxmLl9zb3VyY2VCdWZmZXIgPSBudWxsXG5cbiAgc2VsZi5fb3BlbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25Tb3VyY2VPcGVuKClcbiAgfVxuICBzZWxmLl9mbG93SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9mbG93KClcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHNlbGYuX3R5cGUgPSBvYmpcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBzb3VyY2VCdWZmZXJcbiAgICBpZiAoc2VsZi5fbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICBzZWxmLl9jcmVhdGVTb3VyY2VCdWZmZXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2VsZi5fb3BlbkhhbmRsZXIpXG4gICAgfVxuICB9IGVsc2UgaWYgKG9iai5fc291cmNlQnVmZmVyID09PSBudWxsKSB7XG4gICAgb2JqLmRlc3Ryb3koKVxuICAgIHNlbGYuX3R5cGUgPSBvYmouX3R5cGUgLy8gVGhlIG9sZCBzdHJlYW0gd2FzIGNyZWF0ZWQgYnV0IGhhc24ndCBmaW5pc2hlZCBpbml0aWFsaXppbmdcbiAgICBzZWxmLl9tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2VsZi5fb3BlbkhhbmRsZXIpXG4gIH0gZWxzZSBpZiAob2JqLl9zb3VyY2VCdWZmZXIpIHtcbiAgICBvYmouZGVzdHJveSgpXG4gICAgc2VsZi5fdHlwZSA9IG9iai5fdHlwZVxuICAgIHNlbGYuX3NvdXJjZUJ1ZmZlciA9IG9iai5fc291cmNlQnVmZmVyIC8vIENvcHkgb3ZlciB0aGUgb2xkIHNvdXJjZUJ1ZmZlclxuICAgIHNlbGYuX3NvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCBzZWxmLl9mbG93SGFuZGxlcilcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhcmd1bWVudCB0byBNZWRpYUVsZW1lbnRXcmFwcGVyLmNyZWF0ZVdyaXRlU3RyZWFtIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBwcmV2aW91cyBzdHJlYW0gcmV0dXJuZWQgZnJvbSB0aGF0IGZ1bmN0aW9uJylcbiAgfVxuXG4gIHNlbGYuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHNlbGYuX2Zsb3dIYW5kbGVyKVxuXG4gIHNlbGYub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX3dyYXBwZXIuZXJyb3IoZXJyKVxuICB9KVxuXG4gIHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHNlbGYuX2ZpbmlzaGVkID0gdHJ1ZVxuICAgIGlmIChzZWxmLl9hbGxTdHJlYW1zLmV2ZXJ5KGZ1bmN0aW9uIChvdGhlcikgeyByZXR1cm4gb3RoZXIuX2ZpbmlzaGVkIH0pKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLl9tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgfVxuICB9KVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuX29uU291cmNlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHNlbGYuX29wZW5IYW5kbGVyKVxuICBzZWxmLl9jcmVhdGVTb3VyY2VCdWZmZXIoKVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIC8vIFJlbW92ZSBmcm9tIGFsbFN0cmVhbXNcbiAgc2VsZi5fYWxsU3RyZWFtcy5zcGxpY2Uoc2VsZi5fYWxsU3RyZWFtcy5pbmRleE9mKHNlbGYpLCAxKVxuXG4gIHNlbGYuX21lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCBzZWxmLl9vcGVuSGFuZGxlcilcbiAgc2VsZi5fZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gIGlmIChzZWxmLl9zb3VyY2VCdWZmZXIpIHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gICAgaWYgKHNlbGYuX21lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgc2VsZi5fc291cmNlQnVmZmVyLmFib3J0KClcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICBzZWxmLmVtaXQoJ2Nsb3NlJylcbn1cblxuTWVkaWFTb3VyY2VTdHJlYW0ucHJvdG90eXBlLl9jcmVhdGVTb3VyY2VCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIGlmIChNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoc2VsZi5fdHlwZSkpIHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIgPSBzZWxmLl9tZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIoc2VsZi5fdHlwZSlcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gICAgaWYgKHNlbGYuX2NiKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSBudWxsXG4gICAgICBjYigpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgfVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmICghc2VsZi5fc291cmNlQnVmZmVyKSB7XG4gICAgc2VsZi5fY2IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgc2VsZi5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYilcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZi5fc291cmNlQnVmZmVyLnVwZGF0aW5nKSB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ2Fubm90IGFwcGVuZCBidWZmZXIgd2hpbGUgc291cmNlIGJ1ZmZlciB1cGRhdGluZycpKVxuICB9XG5cbiAgdHJ5IHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIuYXBwZW5kQnVmZmVyKHRvQXJyYXlCdWZmZXIoY2h1bmspKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBhcHBlbmRCdWZmZXIgY2FuIHRocm93IGZvciBhIG51bWJlciBvZiByZWFzb25zLCBtb3N0IG5vdGFibHkgd2hlbiB0aGUgZGF0YVxuICAgIC8vIGJlaW5nIGFwcGVuZGVkIGlzIGludmFsaWQgb3IgaWYgYXBwZW5kQnVmZmVyIGlzIGNhbGxlZCBhZnRlciBhbm90aGVyIGVycm9yXG4gICAgLy8gYWxyZWFkeSBvY2N1cnJlZCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gSW4gQ2hyb21lLCB0aGVyZSBtYXkgYmUgdXNlZnVsIGRlYnVnZ2luZ1xuICAgIC8vIGluZm8gaW4gY2hyb21lOi8vbWVkaWEtaW50ZXJuYWxzXG4gICAgc2VsZi5kZXN0cm95KGVycilcbiAgICByZXR1cm5cbiAgfVxuICBzZWxmLl9jYiA9IGNiXG59XG5cbk1lZGlhU291cmNlU3RyZWFtLnByb3RvdHlwZS5fZmxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYuZGVzdHJveWVkIHx8ICFzZWxmLl9zb3VyY2VCdWZmZXIgfHwgc2VsZi5fc291cmNlQnVmZmVyLnVwZGF0aW5nKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZi5fbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgLy8gY2hlY2sgYnVmZmVyIHNpemVcbiAgICBpZiAoc2VsZi5fZ2V0QnVmZmVyRHVyYXRpb24oKSA+IHNlbGYuX2J1ZmZlckR1cmF0aW9uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5fY2IpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgIHNlbGYuX2NiID0gbnVsbFxuICAgIGNiKClcbiAgfVxufVxuXG4vLyBUT0RPOiBpZiB6ZXJvIGFjdHVhbGx5IHdvcmtzIGluIGFsbCBicm93c2VycywgcmVtb3ZlIHRoZSBsb2dpYyBhc3NvY2lhdGVkIHdpdGggdGhpcyBiZWxvd1xudmFyIEVQU0lMT04gPSAwXG5cbk1lZGlhU291cmNlU3RyZWFtLnByb3RvdHlwZS5fZ2V0QnVmZmVyRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBidWZmZXJlZCA9IHNlbGYuX3NvdXJjZUJ1ZmZlci5idWZmZXJlZFxuICB2YXIgY3VycmVudFRpbWUgPSBzZWxmLl9lbGVtLmN1cnJlbnRUaW1lXG4gIHZhciBidWZmZXJFbmQgPSAtMSAvLyBlbmQgb2YgdGhlIGJ1ZmZlclxuICAvLyBUaGlzIGlzIGEgbGl0dGxlIG92ZXIgY29tcGxleCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgc2VlbSB0byBzZXBhcmF0ZSB0aGVcbiAgLy8gYnVmZmVyZWQgcmVnaW9uIGludG8gbXVsdGlwbGUgc2VjdGlvbnMgd2l0aCBzbGlnaHQgZ2Fwcy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpXG4gICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKSArIEVQU0lMT05cblxuICAgIGlmIChzdGFydCA+IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBSZWFjaGVkIHBhc3QgdGhlIGpvaW5lZCBidWZmZXJcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChidWZmZXJFbmQgPj0gMCB8fCBjdXJyZW50VGltZSA8PSBlbmQpIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBzdGFydC9jb250aW51YXRpb24gb2YgdGhlIGpvaW5lZCBidWZmZXJcbiAgICAgIGJ1ZmZlckVuZCA9IGVuZFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXJlZFRpbWUgPSBidWZmZXJFbmQgLSBjdXJyZW50VGltZVxuICBpZiAoYnVmZmVyZWRUaW1lIDwgMCkge1xuICAgIGJ1ZmZlcmVkVGltZSA9IDBcbiAgfVxuXG4gIHJldHVybiBidWZmZXJlZFRpbWVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gU3RvcmFnZVxuXG5mdW5jdGlvbiBTdG9yYWdlIChjaHVua0xlbmd0aCwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RvcmFnZSkpIHJldHVybiBuZXcgU3RvcmFnZShjaHVua0xlbmd0aCwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB0aGlzLmNodW5rTGVuZ3RoID0gTnVtYmVyKGNodW5rTGVuZ3RoKVxuICBpZiAoIXRoaXMuY2h1bmtMZW5ndGgpIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNodW5rIGxlbmd0aCcpXG5cbiAgdGhpcy5jaHVua3MgPSBbXVxuICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gIHRoaXMubGVuZ3RoID0gTnVtYmVyKG9wdHMubGVuZ3RoKSB8fCBJbmZpbml0eVxuXG4gIGlmICh0aGlzLmxlbmd0aCAhPT0gSW5maW5pdHkpIHtcbiAgICB0aGlzLmxhc3RDaHVua0xlbmd0aCA9ICh0aGlzLmxlbmd0aCAlIHRoaXMuY2h1bmtMZW5ndGgpIHx8IHRoaXMuY2h1bmtMZW5ndGhcbiAgICB0aGlzLmxhc3RDaHVua0luZGV4ID0gTWF0aC5jZWlsKHRoaXMubGVuZ3RoIC8gdGhpcy5jaHVua0xlbmd0aCkgLSAxXG4gIH1cbn1cblxuU3RvcmFnZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGluZGV4LCBidWYsIGNiKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuIG5leHRUaWNrKGNiLCBuZXcgRXJyb3IoJ1N0b3JhZ2UgaXMgY2xvc2VkJykpXG5cbiAgdmFyIGlzTGFzdENodW5rID0gKGluZGV4ID09PSB0aGlzLmxhc3RDaHVua0luZGV4KVxuICBpZiAoaXNMYXN0Q2h1bmsgJiYgYnVmLmxlbmd0aCAhPT0gdGhpcy5sYXN0Q2h1bmtMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignTGFzdCBjaHVuayBsZW5ndGggbXVzdCBiZSAnICsgdGhpcy5sYXN0Q2h1bmtMZW5ndGgpKVxuICB9XG4gIGlmICghaXNMYXN0Q2h1bmsgJiYgYnVmLmxlbmd0aCAhPT0gdGhpcy5jaHVua0xlbmd0aCkge1xuICAgIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdDaHVuayBsZW5ndGggbXVzdCBiZSAnICsgdGhpcy5jaHVua0xlbmd0aCkpXG4gIH1cbiAgdGhpcy5jaHVua3NbaW5kZXhdID0gYnVmXG4gIG5leHRUaWNrKGNiLCBudWxsKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZ2V0KGluZGV4LCBudWxsLCBvcHRzKVxuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdTdG9yYWdlIGlzIGNsb3NlZCcpKVxuICB2YXIgYnVmID0gdGhpcy5jaHVua3NbaW5kZXhdXG4gIGlmICghYnVmKSByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignQ2h1bmsgbm90IGZvdW5kJykpXG4gIGlmICghb3B0cykgcmV0dXJuIG5leHRUaWNrKGNiLCBudWxsLCBidWYpXG4gIHZhciBvZmZzZXQgPSBvcHRzLm9mZnNldCB8fCAwXG4gIHZhciBsZW4gPSBvcHRzLmxlbmd0aCB8fCAoYnVmLmxlbmd0aCAtIG9mZnNldClcbiAgbmV4dFRpY2soY2IsIG51bGwsIGJ1Zi5zbGljZShvZmZzZXQsIGxlbiArIG9mZnNldCkpXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLmNsb3NlID0gU3RvcmFnZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdTdG9yYWdlIGlzIGNsb3NlZCcpKVxuICB0aGlzLmNsb3NlZCA9IHRydWVcbiAgdGhpcy5jaHVua3MgPSBudWxsXG4gIG5leHRUaWNrKGNiLCBudWxsKVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGVyciwgdmFsKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikgY2IoZXJyLCB2YWwpXG4gIH0pXG59XG4iLCIvLyBUaGlzIGlzIGFuIGludGVudGlvbmFsbHkgcmVjdXJzaXZlIHJlcXVpcmUuIEkgZG9uJ3QgbGlrZSBpdCBlaXRoZXIuXG52YXIgQm94ID0gcmVxdWlyZSgnLi9pbmRleCcpXG52YXIgRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vZGVzY3JpcHRvcicpXG5cbnZhciBUSU1FX09GRlNFVCA9IDIwODI4NDQ4MDAwMDBcblxuLypcblRPRE86XG50ZXN0IHRoZXNlXG5hZGQgbmV3IGJveCB2ZXJzaW9uc1xuKi9cblxuLy8gVGhlc2UgaGF2ZSAndmVyc2lvbicgYW5kICdmbGFncycgZmllbGRzIGluIHRoZSBoZWFkZXJzXG5leHBvcnRzLmZ1bGxCb3hlcyA9IHt9XG52YXIgZnVsbEJveGVzID0gW1xuICAnbXZoZCcsXG4gICd0a2hkJyxcbiAgJ21kaGQnLFxuICAndm1oZCcsXG4gICdzbWhkJyxcbiAgJ3N0c2QnLFxuICAnZXNkcycsXG4gICdzdHN6JyxcbiAgJ3N0Y28nLFxuICAnc3RzcycsXG4gICdzdHRzJyxcbiAgJ2N0dHMnLFxuICAnc3RzYycsXG4gICdkcmVmJyxcbiAgJ2Vsc3QnLFxuICAnaGRscicsXG4gICdtZWhkJyxcbiAgJ3RyZXgnLFxuICAnbWZoZCcsXG4gICd0ZmhkJyxcbiAgJ3RmZHQnLFxuICAndHJ1bidcbl1cbmZ1bGxCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIGV4cG9ydHMuZnVsbEJveGVzW3R5cGVdID0gdHJ1ZVxufSlcblxuZXhwb3J0cy5mdHlwID0ge31cbmV4cG9ydHMuZnR5cC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5mdHlwLmVuY29kaW5nTGVuZ3RoKGJveCkpXG4gIHZhciBicmFuZHMgPSBib3guY29tcGF0aWJsZUJyYW5kcyB8fCBbXVxuICBidWYud3JpdGUoYm94LmJyYW5kLCAwLCA0LCAnYXNjaWknKVxuICBidWYud3JpdGVVSW50MzJCRShib3guYnJhbmRWZXJzaW9uLCA0KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJyYW5kcy5sZW5ndGg7IGkrKykgYnVmLndyaXRlKGJyYW5kc1tpXSwgOCArIChpICogNCksIDQsICdhc2NpaScpXG4gIGV4cG9ydHMuZnR5cC5lbmNvZGUuYnl0ZXMgPSA4ICsgYnJhbmRzLmxlbmd0aCAqIDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5mdHlwLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgYnJhbmQgPSBidWYudG9TdHJpbmcoJ2FzY2lpJywgMCwgNClcbiAgdmFyIHZlcnNpb24gPSBidWYucmVhZFVJbnQzMkJFKDQpXG4gIHZhciBjb21wYXRpYmxlQnJhbmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDg7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIGNvbXBhdGlibGVCcmFuZHMucHVzaChidWYudG9TdHJpbmcoJ2FzY2lpJywgaSwgaSArIDQpKVxuICByZXR1cm4ge1xuICAgIGJyYW5kOiBicmFuZCxcbiAgICBicmFuZFZlcnNpb246IHZlcnNpb24sXG4gICAgY29tcGF0aWJsZUJyYW5kczogY29tcGF0aWJsZUJyYW5kc1xuICB9XG59XG5leHBvcnRzLmZ0eXAuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA4ICsgKGJveC5jb21wYXRpYmxlQnJhbmRzIHx8IFtdKS5sZW5ndGggKiA0XG59XG5cbmV4cG9ydHMubXZoZCA9IHt9XG5leHBvcnRzLm12aGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDk2KVxuICB3cml0ZURhdGUoYm94LmN0aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgMClcbiAgd3JpdGVEYXRlKGJveC5tdGltZSB8fCBuZXcgRGF0ZSgpLCBidWYsIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50aW1lU2NhbGUgfHwgMCwgOClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmR1cmF0aW9uIHx8IDAsIDEyKVxuICB3cml0ZUZpeGVkMzIoYm94LnByZWZlcnJlZFJhdGUgfHwgMCwgYnVmLCAxNilcbiAgd3JpdGVGaXhlZDE2KGJveC5wcmVmZXJyZWRWb2x1bWUgfHwgMCwgYnVmLCAyMClcbiAgd3JpdGVSZXNlcnZlZChidWYsIDIyLCAzMilcbiAgd3JpdGVNYXRyaXgoYm94Lm1hdHJpeCwgYnVmLCAzMilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnByZXZpZXdUaW1lIHx8IDAsIDY4KVxuICBidWYud3JpdGVVSW50MzJCRShib3gucHJldmlld0R1cmF0aW9uIHx8IDAsIDcyKVxuICBidWYud3JpdGVVSW50MzJCRShib3gucG9zdGVyVGltZSB8fCAwLCA3NilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnNlbGVjdGlvblRpbWUgfHwgMCwgODApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zZWxlY3Rpb25EdXJhdGlvbiB8fCAwLCA4NClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmN1cnJlbnRUaW1lIHx8IDAsIDg4KVxuICBidWYud3JpdGVVSW50MzJCRShib3gubmV4dFRyYWNrSWQgfHwgMCwgOTIpXG4gIGV4cG9ydHMubXZoZC5lbmNvZGUuYnl0ZXMgPSA5NlxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm12aGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgY3RpbWU6IHJlYWREYXRlKGJ1ZiwgMCksXG4gICAgbXRpbWU6IHJlYWREYXRlKGJ1ZiwgNCksXG4gICAgdGltZVNjYWxlOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDEyKSxcbiAgICBwcmVmZXJyZWRSYXRlOiByZWFkRml4ZWQzMihidWYsIDE2KSxcbiAgICBwcmVmZXJyZWRWb2x1bWU6IHJlYWRGaXhlZDE2KGJ1ZiwgMjApLFxuICAgIG1hdHJpeDogcmVhZE1hdHJpeChidWYuc2xpY2UoMzIsIDY4KSksXG4gICAgcHJldmlld1RpbWU6IGJ1Zi5yZWFkVUludDMyQkUoNjgpLFxuICAgIHByZXZpZXdEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSg3MiksXG4gICAgcG9zdGVyVGltZTogYnVmLnJlYWRVSW50MzJCRSg3NiksXG4gICAgc2VsZWN0aW9uVGltZTogYnVmLnJlYWRVSW50MzJCRSg4MCksXG4gICAgc2VsZWN0aW9uRHVyYXRpb246IGJ1Zi5yZWFkVUludDMyQkUoODQpLFxuICAgIGN1cnJlbnRUaW1lOiBidWYucmVhZFVJbnQzMkJFKDg4KSxcbiAgICBuZXh0VHJhY2tJZDogYnVmLnJlYWRVSW50MzJCRSg5MilcbiAgfVxufVxuZXhwb3J0cy5tdmhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gOTZcbn1cblxuZXhwb3J0cy50a2hkID0ge31cbmV4cG9ydHMudGtoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoODApXG4gIHdyaXRlRGF0ZShib3guY3RpbWUgfHwgbmV3IERhdGUoKSwgYnVmLCAwKVxuICB3cml0ZURhdGUoYm94Lm10aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgNClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRyYWNrSWQgfHwgMCwgOClcbiAgd3JpdGVSZXNlcnZlZChidWYsIDEyLCAxNilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmR1cmF0aW9uIHx8IDAsIDE2KVxuICB3cml0ZVJlc2VydmVkKGJ1ZiwgMjAsIDI4KVxuICBidWYud3JpdGVVSW50MTZCRShib3gubGF5ZXIgfHwgMCwgMjgpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5hbHRlcm5hdGVHcm91cCB8fCAwLCAzMClcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LnZvbHVtZSB8fCAwLCAzMilcbiAgd3JpdGVNYXRyaXgoYm94Lm1hdHJpeCwgYnVmLCAzNilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRyYWNrV2lkdGggfHwgMCwgNzIpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50cmFja0hlaWdodCB8fCAwLCA3NilcbiAgZXhwb3J0cy50a2hkLmVuY29kZS5ieXRlcyA9IDgwXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMudGtoZC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgcmV0dXJuIHtcbiAgICBjdGltZTogcmVhZERhdGUoYnVmLCAwKSxcbiAgICBtdGltZTogcmVhZERhdGUoYnVmLCA0KSxcbiAgICB0cmFja0lkOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDE2KSxcbiAgICBsYXllcjogYnVmLnJlYWRVSW50MTZCRSgyOCksXG4gICAgYWx0ZXJuYXRlR3JvdXA6IGJ1Zi5yZWFkVUludDE2QkUoMzApLFxuICAgIHZvbHVtZTogYnVmLnJlYWRVSW50MTZCRSgzMiksXG4gICAgbWF0cml4OiByZWFkTWF0cml4KGJ1Zi5zbGljZSgzNiwgNzIpKSxcbiAgICB0cmFja1dpZHRoOiBidWYucmVhZFVJbnQzMkJFKDcyKSxcbiAgICB0cmFja0hlaWdodDogYnVmLnJlYWRVSW50MzJCRSg3NilcbiAgfVxufVxuZXhwb3J0cy50a2hkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gODBcbn1cblxuZXhwb3J0cy5tZGhkID0ge31cbmV4cG9ydHMubWRoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoMjApXG4gIHdyaXRlRGF0ZShib3guY3RpbWUgfHwgbmV3IERhdGUoKSwgYnVmLCAwKVxuICB3cml0ZURhdGUoYm94Lm10aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgNClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRpbWVTY2FsZSB8fCAwLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShib3guZHVyYXRpb24gfHwgMCwgMTIpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5sYW5ndWFnZSB8fCAwLCAxNilcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LnF1YWxpdHkgfHwgMCwgMTgpXG4gIGV4cG9ydHMubWRoZC5lbmNvZGUuYnl0ZXMgPSAyMFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1kaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgY3RpbWU6IHJlYWREYXRlKGJ1ZiwgMCksXG4gICAgbXRpbWU6IHJlYWREYXRlKGJ1ZiwgNCksXG4gICAgdGltZVNjYWxlOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDEyKSxcbiAgICBsYW5ndWFnZTogYnVmLnJlYWRVSW50MTZCRSgxNiksXG4gICAgcXVhbGl0eTogYnVmLnJlYWRVSW50MTZCRSgxOClcbiAgfVxufVxuZXhwb3J0cy5tZGhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gMjBcbn1cblxuZXhwb3J0cy52bWhkID0ge31cbmV4cG9ydHMudm1oZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoOClcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LmdyYXBoaWNzTW9kZSB8fCAwLCAwKVxuICB2YXIgb3Bjb2xvciA9IGJveC5vcGNvbG9yIHx8IFswLCAwLCAwXVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzBdLCAyKVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzFdLCA0KVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzJdLCA2KVxuICBleHBvcnRzLnZtaGQuZW5jb2RlLmJ5dGVzID0gOFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnZtaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgZ3JhcGhpY3NNb2RlOiBidWYucmVhZFVJbnQxNkJFKDApLFxuICAgIG9wY29sb3I6IFtidWYucmVhZFVJbnQxNkJFKDIpLCBidWYucmVhZFVJbnQxNkJFKDQpLCBidWYucmVhZFVJbnQxNkJFKDYpXVxuICB9XG59XG5leHBvcnRzLnZtaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA4XG59XG5cbmV4cG9ydHMuc21oZCA9IHt9XG5leHBvcnRzLnNtaGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDQpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5iYWxhbmNlIHx8IDAsIDApXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAyLCA0KVxuICBleHBvcnRzLnNtaGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnNtaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgYmFsYW5jZTogYnVmLnJlYWRVSW50MTZCRSgwKVxuICB9XG59XG5leHBvcnRzLnNtaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMuc3RzZCA9IHt9XG5leHBvcnRzLnN0c2QuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuc3RzZC5lbmNvZGluZ0xlbmd0aChib3gpKVxuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgdmFyIHB0ciA9IDRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXVxuICAgIEJveC5lbmNvZGUoZW50cnksIGJ1ZiwgcHRyKVxuICAgIHB0ciArPSBCb3guZW5jb2RlLmJ5dGVzXG4gIH1cblxuICBleHBvcnRzLnN0c2QuZW5jb2RlLmJ5dGVzID0gcHRyXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3RzZC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG4gIHZhciBwdHIgPSA0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBlbnRyeSA9IEJveC5kZWNvZGUoYnVmLCBwdHIsIGVuZClcbiAgICBlbnRyaWVzW2ldID0gZW50cnlcbiAgICBwdHIgKz0gZW50cnkubGVuZ3RoXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHNkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICB2YXIgdG90YWxTaXplID0gNFxuICBpZiAoIWJveC5lbnRyaWVzKSByZXR1cm4gdG90YWxTaXplXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm94LmVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbFNpemUgKz0gQm94LmVuY29kaW5nTGVuZ3RoKGJveC5lbnRyaWVzW2ldKVxuICB9XG4gIHJldHVybiB0b3RhbFNpemVcbn1cblxuZXhwb3J0cy5hdmMxID0gZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeSA9IHt9XG5leHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcihleHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgd3JpdGVSZXNlcnZlZChidWYsIDAsIDYpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5kYXRhUmVmZXJlbmNlSW5kZXggfHwgMCwgNilcbiAgd3JpdGVSZXNlcnZlZChidWYsIDgsIDI0KVxuICBidWYud3JpdGVVSW50MTZCRShib3gud2lkdGggfHwgMCwgMjQpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5oZWlnaHQgfHwgMCwgMjYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5oUmVzb2x1dGlvbiB8fCAweDQ4MDAwMCwgMjgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC52UmVzb2x1dGlvbiB8fCAweDQ4MDAwMCwgMzIpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAzNiwgNDApXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5mcmFtZUNvdW50IHx8IDEsIDQwKVxuICB2YXIgY29tcHJlc3Nvck5hbWUgPSBib3guY29tcHJlc3Nvck5hbWUgfHwgJydcbiAgdmFyIG5hbWVMZW4gPSBNYXRoLm1pbihjb21wcmVzc29yTmFtZS5sZW5ndGgsIDMxKVxuICBidWYud3JpdGVVSW50OChuYW1lTGVuLCA0MilcbiAgYnVmLndyaXRlKGNvbXByZXNzb3JOYW1lLCA0MywgbmFtZUxlbiwgJ3V0ZjgnKVxuICBidWYud3JpdGVVSW50MTZCRShib3guZGVwdGggfHwgMHgxOCwgNzQpXG4gIGJ1Zi53cml0ZUludDE2QkUoLTEsIDc2KVxuXG4gIHZhciBwdHIgPSA3OFxuICB2YXIgY2hpbGRyZW4gPSBib3guY2hpbGRyZW4gfHwgW11cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBCb3guZW5jb2RlKGNoaWxkLCBidWYsIHB0cilcbiAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICB9KVxuICBleHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kZS5ieXRlcyA9IHB0clxufVxuZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0XG4gIHZhciBuYW1lTGVuID0gTWF0aC5taW4oYnVmLnJlYWRVSW50OCg0MiksIDMxKVxuICB2YXIgYm94ID0ge1xuICAgIGRhdGFSZWZlcmVuY2VJbmRleDogYnVmLnJlYWRVSW50MTZCRSg2KSxcbiAgICB3aWR0aDogYnVmLnJlYWRVSW50MTZCRSgyNCksXG4gICAgaGVpZ2h0OiBidWYucmVhZFVJbnQxNkJFKDI2KSxcbiAgICBoUmVzb2x1dGlvbjogYnVmLnJlYWRVSW50MzJCRSgyOCksXG4gICAgdlJlc29sdXRpb246IGJ1Zi5yZWFkVUludDMyQkUoMzIpLFxuICAgIGZyYW1lQ291bnQ6IGJ1Zi5yZWFkVUludDE2QkUoNDApLFxuICAgIGNvbXByZXNzb3JOYW1lOiBidWYudG9TdHJpbmcoJ3V0ZjgnLCA0MywgNDMgKyBuYW1lTGVuKSxcbiAgICBkZXB0aDogYnVmLnJlYWRVSW50MTZCRSg3NCksXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cblxuICB2YXIgcHRyID0gNzhcbiAgd2hpbGUgKGxlbmd0aCAtIHB0ciA+PSA4KSB7XG4gICAgdmFyIGNoaWxkID0gQm94LmRlY29kZShidWYsIHB0ciwgbGVuZ3RoKVxuICAgIGJveC5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIGJveFtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgcHRyICs9IGNoaWxkLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIGJveFxufVxuZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgdmFyIGxlbiA9IDc4XG4gIHZhciBjaGlsZHJlbiA9IGJveC5jaGlsZHJlbiB8fCBbXVxuICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGxlbiArPSBCb3guZW5jb2RpbmdMZW5ndGgoY2hpbGQpXG4gIH0pXG4gIHJldHVybiBsZW5cbn1cblxuZXhwb3J0cy5hdmNDID0ge31cbmV4cG9ydHMuYXZjQy5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IEJ1ZmZlcihib3guYnVmZmVyLmxlbmd0aClcblxuICBib3guYnVmZmVyLmNvcHkoYnVmKVxuICBleHBvcnRzLmF2Y0MuZW5jb2RlLmJ5dGVzID0gYm94LmJ1ZmZlci5sZW5ndGhcbn1cbmV4cG9ydHMuYXZjQy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0LCBlbmQpXG5cbiAgcmV0dXJuIHtcbiAgICBtaW1lQ29kZWM6IGJ1Zi50b1N0cmluZygnaGV4JywgMSwgNCksXG4gICAgYnVmZmVyOiBuZXcgQnVmZmVyKGJ1ZilcbiAgfVxufVxuZXhwb3J0cy5hdmNDLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gYm94LmJ1ZmZlci5sZW5ndGhcbn1cblxuZXhwb3J0cy5tcDRhID0gZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5ID0ge31cbmV4cG9ydHMuQXVkaW9TYW1wbGVFbnRyeS5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgd3JpdGVSZXNlcnZlZChidWYsIDAsIDYpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5kYXRhUmVmZXJlbmNlSW5kZXggfHwgMCwgNilcbiAgd3JpdGVSZXNlcnZlZChidWYsIDgsIDE2KVxuICBidWYud3JpdGVVSW50MTZCRShib3guY2hhbm5lbENvdW50IHx8IDIsIDE2KVxuICBidWYud3JpdGVVSW50MTZCRShib3guc2FtcGxlU2l6ZSB8fCAxNiwgMTgpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAyMCwgMjQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zYW1wbGVSYXRlIHx8IDAsIDI0KVxuXG4gIHZhciBwdHIgPSAyOFxuICB2YXIgY2hpbGRyZW4gPSBib3guY2hpbGRyZW4gfHwgW11cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBCb3guZW5jb2RlKGNoaWxkLCBidWYsIHB0cilcbiAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICB9KVxuICBleHBvcnRzLkF1ZGlvU2FtcGxlRW50cnkuZW5jb2RlLmJ5dGVzID0gcHRyXG59XG5leHBvcnRzLkF1ZGlvU2FtcGxlRW50cnkuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldCwgZW5kKVxuICB2YXIgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0XG4gIHZhciBib3ggPSB7XG4gICAgZGF0YVJlZmVyZW5jZUluZGV4OiBidWYucmVhZFVJbnQxNkJFKDYpLFxuICAgIGNoYW5uZWxDb3VudDogYnVmLnJlYWRVSW50MTZCRSgxNiksXG4gICAgc2FtcGxlU2l6ZTogYnVmLnJlYWRVSW50MTZCRSgxOCksXG4gICAgc2FtcGxlUmF0ZTogYnVmLnJlYWRVSW50MzJCRSgyNCksXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cblxuICB2YXIgcHRyID0gMjhcbiAgd2hpbGUgKGxlbmd0aCAtIHB0ciA+PSA4KSB7XG4gICAgdmFyIGNoaWxkID0gQm94LmRlY29kZShidWYsIHB0ciwgbGVuZ3RoKVxuICAgIGJveC5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIGJveFtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgcHRyICs9IGNoaWxkLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIGJveFxufVxuZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICB2YXIgbGVuID0gMjhcbiAgdmFyIGNoaWxkcmVuID0gYm94LmNoaWxkcmVuIHx8IFtdXG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgbGVuICs9IEJveC5lbmNvZGluZ0xlbmd0aChjaGlsZClcbiAgfSlcbiAgcmV0dXJuIGxlblxufVxuXG5leHBvcnRzLmVzZHMgPSB7fVxuZXhwb3J0cy5lc2RzLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogQnVmZmVyKGJveC5idWZmZXIubGVuZ3RoKVxuXG4gIGJveC5idWZmZXIuY29weShidWYsIDApXG4gIGV4cG9ydHMuZXNkcy5lbmNvZGUuYnl0ZXMgPSBib3guYnVmZmVyLmxlbmd0aFxufVxuZXhwb3J0cy5lc2RzLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgZW5kKSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQsIGVuZClcblxuICB2YXIgZGVzYyA9IERlc2NyaXB0b3IuRGVzY3JpcHRvci5kZWNvZGUoYnVmLCAwLCBidWYubGVuZ3RoKVxuICB2YXIgZXNkID0gKGRlc2MudGFnTmFtZSA9PT0gJ0VTRGVzY3JpcHRvcicpID8gZGVzYyA6IHt9XG4gIHZhciBkY2QgPSBlc2QuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IgfHwge31cbiAgdmFyIG90aSA9IGRjZC5vdGkgfHwgMFxuICB2YXIgZHNpID0gZGNkLkRlY29kZXJTcGVjaWZpY0luZm9cbiAgdmFyIGF1ZGlvQ29uZmlnID0gZHNpID8gKGRzaS5idWZmZXIucmVhZFVJbnQ4KDApICYgMHhmOCkgPj4gMyA6IDBcblxuICB2YXIgbWltZUNvZGVjID0gbnVsbFxuICBpZiAob3RpKSB7XG4gICAgbWltZUNvZGVjID0gb3RpLnRvU3RyaW5nKDE2KVxuICAgIGlmIChhdWRpb0NvbmZpZykge1xuICAgICAgbWltZUNvZGVjICs9ICcuJyArIGF1ZGlvQ29uZmlnXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW1lQ29kZWM6IG1pbWVDb2RlYyxcbiAgICBidWZmZXI6IG5ldyBCdWZmZXIoYnVmLnNsaWNlKDApKVxuICB9XG59XG5leHBvcnRzLmVzZHMuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiBib3guYnVmZmVyLmxlbmd0aFxufVxuXG4vLyBUT0RPOiBpbnRlZ3JhdGUgdGhlIHR3byB2ZXJzaW9ucyBpbiBhIHNhbmVyIHdheVxuZXhwb3J0cy5zdHN6ID0ge31cbmV4cG9ydHMuc3Rzei5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogQnVmZmVyKGV4cG9ydHMuc3Rzei5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKDAsIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCA0KVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0sIGkgKiA0ICsgOClcbiAgfVxuXG4gIGV4cG9ydHMuc3Rzei5lbmNvZGUuYnl0ZXMgPSA4ICsgZW50cmllcy5sZW5ndGggKiA0XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3Rzei5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIHNpemUgPSBidWYucmVhZFVJbnQzMkJFKDApXG4gIHZhciBudW0gPSBidWYucmVhZFVJbnQzMkJFKDQpXG4gIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KG51bSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIGVudHJpZXNbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0ICsgOClcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cmllc1tpXSA9IHNpemVcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHN6LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gOCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDRcbn1cblxuZXhwb3J0cy5zdHNzID1cbmV4cG9ydHMuc3RjbyA9IHt9XG5leHBvcnRzLnN0Y28uZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5zdGNvLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXSwgaSAqIDQgKyA0KVxuICB9XG5cbiAgZXhwb3J0cy5zdGNvLmVuY29kZS5ieXRlcyA9IDQgKyBlbnRyaWVzLmxlbmd0aCAqIDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdGNvLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGVudHJpZXNbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50cmllczogZW50cmllc1xuICB9XG59XG5leHBvcnRzLnN0Y28uZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0ICsgYm94LmVudHJpZXMubGVuZ3RoICogNFxufVxuXG5leHBvcnRzLnN0dHMgPSB7fVxuZXhwb3J0cy5zdHRzLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBlbnRyaWVzID0gYm94LmVudHJpZXMgfHwgW11cbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuc3R0cy5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogOCArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmNvdW50IHx8IDAsIHB0cilcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmR1cmF0aW9uIHx8IDAsIHB0ciArIDQpXG4gIH1cblxuICBleHBvcnRzLnN0dHMuZW5jb2RlLmJ5dGVzID0gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDhcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdHRzLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogOCArIDRcbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgY291bnQ6IGJ1Zi5yZWFkVUludDMyQkUocHRyKSxcbiAgICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKHB0ciArIDQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuc3R0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDQgKyBib3guZW50cmllcy5sZW5ndGggKiA4XG59XG5cbmV4cG9ydHMuY3R0cyA9IHt9XG5leHBvcnRzLmN0dHMuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5jdHRzLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiA4ICsgNFxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uY291bnQgfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uY29tcG9zaXRpb25PZmZzZXQgfHwgMCwgcHRyICsgNClcbiAgfVxuXG4gIGV4cG9ydHMuY3R0cy5lbmNvZGUuYnl0ZXMgPSA0ICsgZW50cmllcy5sZW5ndGggKiA4XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuY3R0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgcHRyID0gaSAqIDggKyA0XG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIGNvdW50OiBidWYucmVhZFVJbnQzMkJFKHB0ciksXG4gICAgICBjb21wb3NpdGlvbk9mZnNldDogYnVmLnJlYWRJbnQzMkJFKHB0ciArIDQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuY3R0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDQgKyBib3guZW50cmllcy5sZW5ndGggKiA4XG59XG5cbmV4cG9ydHMuc3RzYyA9IHt9XG5leHBvcnRzLnN0c2MuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5zdHNjLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmZpcnN0Q2h1bmsgfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uc2FtcGxlc1BlckNodW5rIHx8IDAsIHB0ciArIDQpXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXS5zYW1wbGVEZXNjcmlwdGlvbklkIHx8IDAsIHB0ciArIDgpXG4gIH1cblxuICBleHBvcnRzLnN0c2MuZW5jb2RlLmJ5dGVzID0gNCArIGVudHJpZXMubGVuZ3RoICogMTJcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdHNjLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogMTIgKyA0XG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIGZpcnN0Q2h1bms6IGJ1Zi5yZWFkVUludDMyQkUocHRyKSxcbiAgICAgIHNhbXBsZXNQZXJDaHVuazogYnVmLnJlYWRVSW50MzJCRShwdHIgKyA0KSxcbiAgICAgIHNhbXBsZURlc2NyaXB0aW9uSWQ6IGJ1Zi5yZWFkVUludDMyQkUocHRyICsgOClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHNjLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDEyXG59XG5cbmV4cG9ydHMuZHJlZiA9IHt9XG5leHBvcnRzLmRyZWYuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuZHJlZi5lbmNvZGluZ0xlbmd0aChib3gpKVxuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgdmFyIHB0ciA9IDRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXVxuICAgIHZhciBzaXplID0gKGVudHJ5LmJ1ZiA/IGVudHJ5LmJ1Zi5sZW5ndGggOiAwKSArIDQgKyA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShzaXplLCBwdHIpXG4gICAgcHRyICs9IDRcblxuICAgIGJ1Zi53cml0ZShlbnRyeS50eXBlLCBwdHIsIDQsICdhc2NpaScpXG4gICAgcHRyICs9IDRcblxuICAgIGlmIChlbnRyeS5idWYpIHtcbiAgICAgIGVudHJ5LmJ1Zi5jb3B5KGJ1ZiwgcHRyKVxuICAgICAgcHRyICs9IGVudHJ5LmJ1Zi5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmRyZWYuZW5jb2RlLmJ5dGVzID0gcHRyXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuZHJlZi5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuICB2YXIgcHRyID0gNFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgc2l6ZSA9IGJ1Zi5yZWFkVUludDMyQkUocHRyKVxuICAgIHZhciB0eXBlID0gYnVmLnRvU3RyaW5nKCdhc2NpaScsIHB0ciArIDQsIHB0ciArIDgpXG4gICAgdmFyIHRtcCA9IGJ1Zi5zbGljZShwdHIgKyA4LCBwdHIgKyBzaXplKVxuICAgIHB0ciArPSBzaXplXG5cbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGJ1ZjogdG1wXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuZHJlZi5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgdmFyIHRvdGFsU2l6ZSA9IDRcbiAgaWYgKCFib3guZW50cmllcykgcmV0dXJuIHRvdGFsU2l6ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveC5lbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGJveC5lbnRyaWVzW2ldLmJ1ZlxuICAgIHRvdGFsU2l6ZSArPSAoYnVmID8gYnVmLmxlbmd0aCA6IDApICsgNCArIDRcbiAgfVxuICByZXR1cm4gdG90YWxTaXplXG59XG5cbmV4cG9ydHMuZWxzdCA9IHt9XG5leHBvcnRzLmVsc3QuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5lbHN0LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLnRyYWNrRHVyYXRpb24gfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0ubWVkaWFUaW1lIHx8IDAsIHB0ciArIDQpXG4gICAgd3JpdGVGaXhlZDMyKGVudHJpZXNbaV0ubWVkaWFSYXRlIHx8IDAsIGJ1ZiwgcHRyICsgOClcbiAgfVxuXG4gIGV4cG9ydHMuZWxzdC5lbmNvZGUuYnl0ZXMgPSA0ICsgZW50cmllcy5sZW5ndGggKiAxMlxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLmVsc3QuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHZhciBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApXG4gIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KG51bSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgdHJhY2tEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRShwdHIpLFxuICAgICAgbWVkaWFUaW1lOiBidWYucmVhZEludDMyQkUocHRyICsgNCksXG4gICAgICBtZWRpYVJhdGU6IHJlYWRGaXhlZDMyKGJ1ZiwgcHRyICsgOClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5lbHN0LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDEyXG59XG5cbmV4cG9ydHMuaGRsciA9IHt9XG5leHBvcnRzLmhkbHIuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuaGRsci5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIHZhciBsZW4gPSAyMSArIChib3gubmFtZSB8fCAnJykubGVuZ3RoXG4gIGJ1Zi5maWxsKDAsIDAsIGxlbilcblxuICBidWYud3JpdGUoYm94LmhhbmRsZXJUeXBlIHx8ICcnLCA0LCA0LCAnYXNjaWknKVxuICB3cml0ZVN0cmluZyhib3gubmFtZSB8fCAnJywgYnVmLCAyMClcblxuICBleHBvcnRzLmhkbHIuZW5jb2RlLmJ5dGVzID0gbGVuXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuaGRsci5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICByZXR1cm4ge1xuICAgIGhhbmRsZXJUeXBlOiBidWYudG9TdHJpbmcoJ2FzY2lpJywgNCwgOCksXG4gICAgbmFtZTogcmVhZFN0cmluZyhidWYsIDIwLCBlbmQpXG4gIH1cbn1cbmV4cG9ydHMuaGRsci5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDIxICsgKGJveC5uYW1lIHx8ICcnKS5sZW5ndGhcbn1cblxuZXhwb3J0cy5tZWhkID0ge31cbmV4cG9ydHMubWVoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoNClcblxuICBidWYud3JpdGVVSW50MzJCRShib3guZnJhZ21lbnREdXJhdGlvbiB8fCAwLCAwKVxuICBleHBvcnRzLm1laGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1laGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgZnJhZ21lbnREdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSgwKVxuICB9XG59XG5leHBvcnRzLm1laGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudHJleCA9IHt9XG5leHBvcnRzLnRyZXguZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDIwKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50cmFja0lkIHx8IDAsIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleCB8fCAwLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShib3guZGVmYXVsdFNhbXBsZUR1cmF0aW9uIHx8IDAsIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kZWZhdWx0U2FtcGxlU2l6ZSB8fCAwLCAxMilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmRlZmF1bHRTYW1wbGVGbGFncyB8fCAwLCAxNilcbiAgZXhwb3J0cy50cmV4LmVuY29kZS5ieXRlcyA9IDIwXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMudHJleC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgcmV0dXJuIHtcbiAgICB0cmFja0lkOiBidWYucmVhZFVJbnQzMkJFKDApLFxuICAgIGRlZmF1bHRTYW1wbGVEZXNjcmlwdGlvbkluZGV4OiBidWYucmVhZFVJbnQzMkJFKDQpLFxuICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBkZWZhdWx0U2FtcGxlU2l6ZTogYnVmLnJlYWRVSW50MzJCRSgxMiksXG4gICAgZGVmYXVsdFNhbXBsZUZsYWdzOiBidWYucmVhZFVJbnQzMkJFKDE2KVxuICB9XG59XG5leHBvcnRzLnRyZXguZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiAyMFxufVxuXG5leHBvcnRzLm1maGQgPSB7fVxuZXhwb3J0cy5tZmhkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig0KVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zZXF1ZW5jZU51bWJlciB8fCAwLCAwKVxuICBleHBvcnRzLm1maGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1maGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIHJldHVybiB7XG4gICAgc2VxdWVuY2VOdW1iZXI6IGJ1Zi5yZWFkVWludDMyQkUoMClcbiAgfVxufVxuZXhwb3J0cy5tZmhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNFxufVxuXG5leHBvcnRzLnRmaGQgPSB7fVxuZXhwb3J0cy50ZmhkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig0KVxuICBidWYud3JpdGVVSW50MzJCRShib3gudHJhY2tJZCwgMClcbiAgZXhwb3J0cy50ZmhkLmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy50ZmhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAvLyBUT0RPOiB0aGlzXG59XG5leHBvcnRzLnRmaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIC8vIFRPRE86IHRoaXMgaXMgd3JvbmchXG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudGZkdCA9IHt9XG5leHBvcnRzLnRmZHQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDQpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmJhc2VNZWRpYURlY29kZVRpbWUgfHwgMCwgMClcbiAgZXhwb3J0cy50ZmR0LmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy50ZmR0LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAvLyBUT0RPOiB0aGlzXG59XG5leHBvcnRzLnRmZHQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudHJ1biA9IHt9XG5leHBvcnRzLnRydW4uZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDggKyBib3guZW50cmllcy5sZW5ndGggKiAxNilcblxuICAvLyBUT0RPOiB0aGlzIGlzIHdyb25nXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5lbnRyaWVzLmxlbmd0aCwgMClcbiAgYnVmLndyaXRlSW50MzJCRShib3guZGF0YU9mZnNldCwgNClcbiAgdmFyIHB0ciA9IDhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3guZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbnRyeSA9IGJveC5lbnRyaWVzW2ldXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cnkuc2FtcGxlRHVyYXRpb24sIHB0cilcbiAgICBwdHIgKz0gNFxuXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cnkuc2FtcGxlU2l6ZSwgcHRyKVxuICAgIHB0ciArPSA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyeS5zYW1wbGVGbGFncywgcHRyKVxuICAgIHB0ciArPSA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyeS5zYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQsIHB0cilcbiAgICBwdHIgKz0gNFxuICB9XG4gIGV4cG9ydHMudHJ1bi5lbmNvZGUuYnl0ZXMgPSBwdHJcbn1cbmV4cG9ydHMudHJ1bi5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgLy8gVE9ETzogdGhpc1xufVxuZXhwb3J0cy50cnVuLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICAvLyBUT0RPOiB0aGlzIGlzIHdyb25nXG4gIHJldHVybiA4ICsgYm94LmVudHJpZXMubGVuZ3RoICogMTZcbn1cblxuZXhwb3J0cy5tZGF0ID0ge31cbmV4cG9ydHMubWRhdC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBpZiAoYm94LmJ1ZmZlcikge1xuICAgIGJveC5idWZmZXIuY29weShidWYsIG9mZnNldClcbiAgICBleHBvcnRzLm1kYXQuZW5jb2RlLmJ5dGVzID0gYm94LmJ1ZmZlci5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLm1kYXQuZW5jb2RlLmJ5dGVzID0gZXhwb3J0cy5tZGF0LmVuY29kaW5nTGVuZ3RoKGJveClcbiAgfVxufVxuZXhwb3J0cy5tZGF0LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHtcbiAgICBidWZmZXI6IG5ldyBCdWZmZXIoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5leHBvcnRzLm1kYXQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiBib3guYnVmZmVyID8gYm94LmJ1ZmZlci5sZW5ndGggOiBib3guY29udGVudExlbmd0aFxufVxuXG5mdW5jdGlvbiB3cml0ZVJlc2VydmVkIChidWYsIG9mZnNldCwgZW5kKSB7XG4gIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykgYnVmW2ldID0gMFxufVxuXG5mdW5jdGlvbiB3cml0ZURhdGUgKGRhdGUsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1Zi53cml0ZVVJbnQzMkJFKE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpICsgVElNRV9PRkZTRVQpIC8gMTAwMCksIG9mZnNldClcbn1cblxuLy8gVE9ETzogdGhpbmsgc29tZXRoaW5nIGlzIHdyb25nIGhlcmVcbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMiAobnVtLCBidWYsIG9mZnNldCkge1xuICBidWYud3JpdGVVSW50MTZCRShNYXRoLmZsb29yKG51bSkgJSAoMjU2ICogMjU2KSwgb2Zmc2V0KVxuICBidWYud3JpdGVVSW50MTZCRShNYXRoLmZsb29yKG51bSAqIDI1NiAqIDI1NikgJSAoMjU2ICogMjU2KSwgb2Zmc2V0ICsgMilcbn1cblxuZnVuY3Rpb24gd3JpdGVGaXhlZDE2IChudW0sIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZltvZmZzZXRdID0gTWF0aC5mbG9vcihudW0pICUgMjU2XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IE1hdGguZmxvb3IobnVtICogMjU2KSAlIDI1NlxufVxuXG5mdW5jdGlvbiB3cml0ZU1hdHJpeCAobGlzdCwgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKCFsaXN0KSBsaXN0ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlRml4ZWQzMihsaXN0W2ldLCBidWYsIG9mZnNldCArIGkgKiA0KVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nIChzdHIsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBzdHJCdWZmZXIgPSBuZXcgQnVmZmVyKHN0ciwgJ3V0ZjgnKVxuICBzdHJCdWZmZXIuY29weShidWYsIG9mZnNldClcbiAgYnVmW29mZnNldCArIHN0ckJ1ZmZlci5sZW5ndGhdID0gMFxufVxuXG5mdW5jdGlvbiByZWFkTWF0cml4IChidWYpIHtcbiAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoYnVmLmxlbmd0aCAvIDQpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgbGlzdFtpXSA9IHJlYWRGaXhlZDMyKGJ1ZiwgaSAqIDQpXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHJlYWREYXRlIChidWYsIG9mZnNldCkge1xuICByZXR1cm4gbmV3IERhdGUoYnVmLnJlYWRVSW50MzJCRShvZmZzZXQpICogMTAwMCAtIFRJTUVfT0ZGU0VUKVxufVxuXG5mdW5jdGlvbiByZWFkRml4ZWQzMiAoYnVmLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0KSArIGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0ICsgMikgLyAoMjU2ICogMjU2KVxufVxuXG5mdW5jdGlvbiByZWFkRml4ZWQxNiAoYnVmLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1ZltvZmZzZXRdICsgYnVmW29mZnNldCArIDFdIC8gMjU2XG59XG5cbmZ1bmN0aW9uIHJlYWRTdHJpbmcgKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltvZmZzZXQgKyBpXSA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIG9mZnNldCwgb2Zmc2V0ICsgaSlcbn1cbiIsInZhciB0YWdUb05hbWUgPSB7XG4gIDB4MDM6ICdFU0Rlc2NyaXB0b3InLFxuICAweDA0OiAnRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3InLFxuICAweDA1OiAnRGVjb2RlclNwZWNpZmljSW5mbycsXG4gIDB4MDY6ICdTTENvbmZpZ0Rlc2NyaXB0b3InXG59XG5cbmV4cG9ydHMuRGVzY3JpcHRvciA9IHt9XG5leHBvcnRzLkRlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgdGFnID0gYnVmLnJlYWRVSW50OChzdGFydClcbiAgdmFyIHB0ciA9IHN0YXJ0ICsgMVxuICB2YXIgbGVuQnl0ZVxuICB2YXIgbGVuID0gMFxuICBkbyB7XG4gICAgbGVuQnl0ZSA9IGJ1Zi5yZWFkVUludDgocHRyKyspXG4gICAgbGVuID0gKGxlbiA8PCA3KSB8IChsZW5CeXRlICYgMHg3ZilcbiAgfSB3aGlsZSAobGVuQnl0ZSAmIDB4ODApXG5cbiAgdmFyIG9ialxuICB2YXIgdGFnTmFtZSA9IHRhZ1RvTmFtZVt0YWddIC8vIE1heSBiZSB1bmRlZmluZWQ7IHRoYXQncyBva1xuICBpZiAoZXhwb3J0c1t0YWdOYW1lXSkge1xuICAgIG9iaiA9IGV4cG9ydHNbdGFnTmFtZV0uZGVjb2RlKGJ1ZiwgcHRyLCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgb2JqID0ge1xuICAgICAgYnVmZmVyOiBuZXcgQnVmZmVyKGJ1Zi5zbGljZShwdHIsIHB0ciArIGxlbikpXG4gICAgfVxuICB9XG5cbiAgb2JqLnRhZyA9IHRhZ1xuICBvYmoudGFnTmFtZSA9IHRhZ05hbWVcbiAgb2JqLmxlbmd0aCA9IChwdHIgLSBzdGFydCkgKyBsZW5cbiAgb2JqLmNvbnRlbnRzTGVuID0gbGVuXG4gIHJldHVybiBvYmpcbn1cblxuZXhwb3J0cy5EZXNjcmlwdG9yQXJyYXkgPSB7fVxuZXhwb3J0cy5EZXNjcmlwdG9yQXJyYXkuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcHRyID0gc3RhcnRcbiAgdmFyIG9iaiA9IHt9XG4gIHdoaWxlIChwdHIgKyAyIDw9IGVuZCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yLmRlY29kZShidWYsIHB0ciwgZW5kKVxuICAgIHB0ciArPSBkZXNjcmlwdG9yLmxlbmd0aFxuICAgIHZhciB0YWdOYW1lID0gdGFnVG9OYW1lW2Rlc2NyaXB0b3IudGFnXSB8fCAoJ0Rlc2NyaXB0b3InICsgZGVzY3JpcHRvci50YWcpXG4gICAgb2JqW3RhZ05hbWVdID0gZGVzY3JpcHRvclxuICB9XG4gIHJldHVybiBvYmpcbn1cblxuZXhwb3J0cy5FU0Rlc2NyaXB0b3IgPSB7fVxuZXhwb3J0cy5FU0Rlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgZmxhZ3MgPSBidWYucmVhZFVJbnQ4KHN0YXJ0ICsgMilcbiAgdmFyIHB0ciA9IHN0YXJ0ICsgM1xuICBpZiAoZmxhZ3MgJiAweDgwKSB7XG4gICAgcHRyICs9IDJcbiAgfVxuICBpZiAoZmxhZ3MgJiAweDQwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5yZWFkVUludDgocHRyKVxuICAgIHB0ciArPSBsZW4gKyAxXG4gIH1cbiAgaWYgKGZsYWdzICYgMHgyMCkge1xuICAgIHB0ciArPSAyXG4gIH1cbiAgcmV0dXJuIGV4cG9ydHMuRGVzY3JpcHRvckFycmF5LmRlY29kZShidWYsIHB0ciwgZW5kKVxufVxuXG5leHBvcnRzLkRlY29kZXJDb25maWdEZXNjcmlwdG9yID0ge31cbmV4cG9ydHMuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgb3RpID0gYnVmLnJlYWRVSW50OChzdGFydClcbiAgdmFyIG9iaiA9IGV4cG9ydHMuRGVzY3JpcHRvckFycmF5LmRlY29kZShidWYsIHN0YXJ0ICsgMTMsIGVuZClcbiAgb2JqLm90aSA9IG90aVxuICByZXR1cm4gb2JqXG59XG4iLCIvLyB2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciB1aW50NjRiZSA9IHJlcXVpcmUoJ3VpbnQ2NGJlJylcblxudmFyIGJveGVzID0gcmVxdWlyZSgnLi9ib3hlcycpXG5cbnZhciBVSU5UMzJfTUFYID0gNDI5NDk2NzI5NVxuXG52YXIgQm94ID0gZXhwb3J0c1xuXG4vKlxuICogTGlzdHMgdGhlIHByb3BlciBvcmRlciBmb3IgYm94ZXMgaW5zaWRlIGNvbnRhaW5lcnMuXG4gKiBGaXZlLWNoYXJhY3RlciBuYW1lcyBlbmRpbmcgaW4gJ3MnIGluZGljYXRlIGFycmF5cyBpbnN0ZWFkIG9mIHNpbmdsZSBlbGVtZW50cy5cbiAqL1xudmFyIGNvbnRhaW5lcnMgPSBleHBvcnRzLmNvbnRhaW5lcnMgPSB7XG4gICdtb292JzogWydtdmhkJywgJ21ldGEnLCAndHJha3MnLCAnbXZleCddLFxuICAndHJhayc6IFsndGtoZCcsICd0cmVmJywgJ3RyZ3InLCAnZWR0cycsICdtZXRhJywgJ21kaWEnLCAndWR0YSddLFxuICAnZWR0cyc6IFsnZWxzdCddLFxuICAnbWRpYSc6IFsnbWRoZCcsICdoZGxyJywgJ2VsbmcnLCAnbWluZiddLFxuICAnbWluZic6IFsndm1oZCcsICdzbWhkJywgJ2htaGQnLCAnc3RoZCcsICdubWhkJywgJ2RpbmYnLCAnc3RibCddLFxuICAnZGluZic6IFsnZHJlZiddLFxuICAnc3RibCc6IFsnc3RzZCcsICdzdHRzJywgJ2N0dHMnLCAnY3NsZycsICdzdHNjJywgJ3N0c3onLCAnc3R6MicsICdzdGNvJywgJ2NvNjQnLCAnc3RzcycsICdzdHNoJywgJ3BhZGInLCAnc3RkcCcsICdzZHRwJywgJ3NiZ3BzJywgJ3NncGRzJywgJ3N1YnNzJywgJ3NhaXpzJywgJ3NhaW9zJ10sXG4gICdtdmV4JzogWydtZWhkJywgJ3RyZXhzJywgJ2xldmEnXSxcbiAgJ21vb2YnOiBbJ21maGQnLCAnbWV0YScsICd0cmFmcyddLFxuICAndHJhZic6IFsndGZoZCcsICd0cnVuJywgJ3NiZ3BzJywgJ3NncGRzJywgJ3N1YnNzJywgJ3NhaXpzJywgJ3NhaW9zJywgJ3RmZHQnLCAnbWV0YSddXG59XG5cbkJveC5lbmNvZGUgPSBmdW5jdGlvbiAob2JqLCBidWZmZXIsIG9mZnNldCkge1xuICBCb3guZW5jb2RpbmdMZW5ndGgob2JqKSAvLyBzZXRzIGV2ZXJ5IGxldmVsIGFwcHJvcHJpYXRlbHlcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBCdWZmZXIob2JqLmxlbmd0aClcbiAgcmV0dXJuIEJveC5fZW5jb2RlKG9iaiwgYnVmZmVyLCBvZmZzZXQpXG59XG5cbkJveC5fZW5jb2RlID0gZnVuY3Rpb24gKG9iaiwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgdmFyIHR5cGUgPSBvYmoudHlwZVxuICB2YXIgbGVuID0gb2JqLmxlbmd0aFxuICBpZiAobGVuID4gVUlOVDMyX01BWCkge1xuICAgIGxlbiA9IDFcbiAgfVxuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldClcbiAgYnVmZmVyLndyaXRlKG9iai50eXBlLCBvZmZzZXQgKyA0LCA0LCAnYXNjaWknKVxuICB2YXIgcHRyID0gb2Zmc2V0ICsgOFxuICBpZiAobGVuID09PSAxKSB7XG4gICAgdWludDY0YmUuZW5jb2RlKG9iai5sZW5ndGgsIGJ1ZmZlciwgcHRyKVxuICAgIHB0ciArPSA4XG4gIH1cbiAgaWYgKGJveGVzLmZ1bGxCb3hlc1t0eXBlXSkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9iai5mbGFncyB8fCAwLCBwdHIpXG4gICAgYnVmZmVyLndyaXRlVUludDgob2JqLnZlcnNpb24gfHwgMCwgcHRyKVxuICAgIHB0ciArPSA0XG4gIH1cblxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIHZhciBjb250ZW50cyA9IGNvbnRhaW5lcnNbdHlwZV1cbiAgICBjb250ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFR5cGUpIHtcbiAgICAgIGlmIChjaGlsZFR5cGUubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGNoaWxkVHlwZSA9IGNoaWxkVHlwZS5zdWJzdHIoMCwgNClcbiAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBCb3guX2VuY29kZShjaGlsZCwgYnVmZmVyLCBwdHIpXG4gICAgICAgICAgcHRyICs9IEJveC5lbmNvZGUuYnl0ZXNcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAob2JqW2NoaWxkVHlwZV0pIHtcbiAgICAgICAgQm94Ll9lbmNvZGUob2JqW2NoaWxkVHlwZV0sIGJ1ZmZlciwgcHRyKVxuICAgICAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKG9iai5vdGhlckJveGVzKSB7XG4gICAgICBvYmoub3RoZXJCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBCb3guX2VuY29kZShjaGlsZCwgYnVmZmVyLCBwdHIpXG4gICAgICAgIHB0ciArPSBCb3guZW5jb2RlLmJ5dGVzXG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIGlmIChib3hlc1t0eXBlXSkge1xuICAgIHZhciBlbmNvZGUgPSBib3hlc1t0eXBlXS5lbmNvZGVcbiAgICBlbmNvZGUob2JqLCBidWZmZXIsIHB0cilcbiAgICBwdHIgKz0gZW5jb2RlLmJ5dGVzXG4gIH0gZWxzZSBpZiAob2JqLmJ1ZmZlcikge1xuICAgIHZhciBidWYgPSBvYmouYnVmZmVyXG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwdHIpXG4gICAgcHRyICs9IG9iai5idWZmZXIubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgYHR5cGVgIG11c3QgYmUgc2V0IHRvIGEga25vd24gdHlwZSAobm90XFwnJyArIHR5cGUgKyAnXFwnKSBvciBgYnVmZmVyYCBtdXN0IGJlIHNldCcpXG4gIH1cblxuICBCb3guZW5jb2RlLmJ5dGVzID0gcHRyIC0gb2Zmc2V0XG4gIC8vIGFzc2VydC5lcXVhbChwdHIgLSBvZmZzZXQsIG9iai5sZW5ndGgsICdFcnJvciBlbmNvZGluZyBcXCcnICsgdHlwZSArICdcXCc6IHdyb3RlICcgKyBwdHIgLSBvZmZzZXQgKyAnIGJ5dGVzLCBleHBlY3RpbmcgJyArIG9iai5sZW5ndGgpXG4gIHJldHVybiBidWZmZXJcbn1cblxuLypcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHR5cGVgIGFuZCBgc2l6ZWAgZmllbGRzLFxuICogb3IgaWYgdGhlcmUgaXNuJ3QgZW5vdWdoIGRhdGEsIHJldHVybnMgdGhlIHRvdGFsXG4gKiBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIHJlYWQgdGhlIGhlYWRlcnNcbiAqL1xuQm94LnJlYWRIZWFkZXJzID0gZnVuY3Rpb24gKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgZW5kID0gZW5kIHx8IGJ1ZmZlci5sZW5ndGhcbiAgaWYgKGVuZCAtIHN0YXJ0IDwgOCkge1xuICAgIHJldHVybiA4XG4gIH1cblxuICB2YXIgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShzdGFydClcbiAgdmFyIHR5cGUgPSBidWZmZXIudG9TdHJpbmcoJ2FzY2lpJywgc3RhcnQgKyA0LCBzdGFydCArIDgpXG4gIHZhciBwdHIgPSBzdGFydCArIDhcblxuICBpZiAobGVuID09PSAxKSB7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDwgMTYpIHtcbiAgICAgIHJldHVybiAxNlxuICAgIH1cblxuICAgIGxlbiA9IHVpbnQ2NGJlLmRlY29kZShidWZmZXIsIHB0cilcbiAgICBwdHIgKz0gOFxuICB9XG5cbiAgdmFyIHZlcnNpb25cbiAgdmFyIGZsYWdzXG4gIGlmIChib3hlcy5mdWxsQm94ZXNbdHlwZV0pIHtcbiAgICB2ZXJzaW9uID0gYnVmZmVyLnJlYWRVSW50OChwdHIpXG4gICAgZmxhZ3MgPSBidWZmZXIucmVhZFVJbnQzMkJFKHB0cikgJiAweGZmZmZmZlxuICAgIHB0ciArPSA0XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogbGVuLFxuICAgIGhlYWRlcnNMZW46IHB0ciAtIHN0YXJ0LFxuICAgIGNvbnRlbnRMZW46IGxlbiAtIChwdHIgLSBzdGFydCksXG4gICAgdHlwZTogdHlwZSxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGZsYWdzOiBmbGFnc1xuICB9XG59XG5cbkJveC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBlbmQgPSBlbmQgfHwgYnVmZmVyLmxlbmd0aFxuICB2YXIgaGVhZGVycyA9IEJveC5yZWFkSGVhZGVycyhidWZmZXIsIHN0YXJ0LCBlbmQpXG4gIGlmICghaGVhZGVycyB8fCBoZWFkZXJzLmxlbmd0aCA+IGVuZCAtIHN0YXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIHRvbyBzaG9ydCcpXG4gIH1cblxuICByZXR1cm4gQm94LmRlY29kZVdpdGhvdXRIZWFkZXJzKGhlYWRlcnMsIGJ1ZmZlciwgc3RhcnQgKyBoZWFkZXJzLmhlYWRlcnNMZW4sIHN0YXJ0ICsgaGVhZGVycy5sZW5ndGgpXG59XG5cbkJveC5kZWNvZGVXaXRob3V0SGVhZGVycyA9IGZ1bmN0aW9uIChoZWFkZXJzLCBidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IGVuZCB8fCBidWZmZXIubGVuZ3RoXG4gIHZhciB0eXBlID0gaGVhZGVycy50eXBlXG4gIHZhciBvYmogPSB7fVxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIG9iai5vdGhlckJveGVzID0gW11cbiAgICB2YXIgY29udGVudHMgPSBjb250YWluZXJzW3R5cGVdXG4gICAgdmFyIHB0ciA9IHN0YXJ0XG4gICAgd2hpbGUgKGVuZCAtIHB0ciA+PSA4KSB7XG4gICAgICB2YXIgY2hpbGQgPSBCb3guZGVjb2RlKGJ1ZmZlciwgcHRyLCBlbmQpXG4gICAgICBwdHIgKz0gY2hpbGQubGVuZ3RoXG4gICAgICBpZiAoY29udGVudHMuaW5kZXhPZihjaGlsZC50eXBlKSA+PSAwKSB7XG4gICAgICAgIG9ialtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnRzLmluZGV4T2YoY2hpbGQudHlwZSArICdzJykgPj0gMCkge1xuICAgICAgICB2YXIgY2hpbGRUeXBlID0gY2hpbGQudHlwZSArICdzJ1xuICAgICAgICB2YXIgZW50cnkgPSBvYmpbY2hpbGRUeXBlXSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGVudHJ5LnB1c2goY2hpbGQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmoub3RoZXJCb3hlcy5wdXNoKGNoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChib3hlc1t0eXBlXSkge1xuICAgIHZhciBkZWNvZGUgPSBib3hlc1t0eXBlXS5kZWNvZGVcbiAgICBvYmogPSBkZWNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIG9iai5idWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxuXG4gIG9iai5sZW5ndGggPSBoZWFkZXJzLmxlbmd0aFxuICBvYmouY29udGVudExlbiA9IGhlYWRlcnMuY29udGVudExlblxuICBvYmoudHlwZSA9IGhlYWRlcnMudHlwZVxuICBvYmoudmVyc2lvbiA9IGhlYWRlcnMudmVyc2lvblxuICBvYmouZmxhZ3MgPSBoZWFkZXJzLmZsYWdzXG4gIHJldHVybiBvYmpcbn1cblxuQm94LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgdHlwZSA9IG9iai50eXBlXG5cbiAgdmFyIGxlbiA9IDhcbiAgaWYgKGJveGVzLmZ1bGxCb3hlc1t0eXBlXSkge1xuICAgIGxlbiArPSA0XG4gIH1cblxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIHZhciBjb250ZW50cyA9IGNvbnRhaW5lcnNbdHlwZV1cbiAgICBjb250ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFR5cGUpIHtcbiAgICAgIGlmIChjaGlsZFR5cGUubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGNoaWxkVHlwZSA9IGNoaWxkVHlwZS5zdWJzdHIoMCwgNClcbiAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBjaGlsZC50eXBlID0gY2hpbGRUeXBlXG4gICAgICAgICAgbGVuICs9IEJveC5lbmNvZGluZ0xlbmd0aChjaGlsZClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAob2JqW2NoaWxkVHlwZV0pIHtcbiAgICAgICAgdmFyIGNoaWxkID0gb2JqW2NoaWxkVHlwZV1cbiAgICAgICAgY2hpbGQudHlwZSA9IGNoaWxkVHlwZVxuICAgICAgICBsZW4gKz0gQm94LmVuY29kaW5nTGVuZ3RoKGNoaWxkKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKG9iai5vdGhlckJveGVzKSB7XG4gICAgICBvYmoub3RoZXJCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBsZW4gKz0gQm94LmVuY29kaW5nTGVuZ3RoKGNoaWxkKVxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm94ZXNbdHlwZV0pIHtcbiAgICBsZW4gKz0gYm94ZXNbdHlwZV0uZW5jb2RpbmdMZW5ndGgob2JqKVxuICB9IGVsc2UgaWYgKG9iai5idWZmZXIpIHtcbiAgICBsZW4gKz0gb2JqLmJ1ZmZlci5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBgdHlwZWAgbXVzdCBiZSBzZXQgdG8gYSBrbm93biB0eXBlIChub3RcXCcnICsgdHlwZSArICdcXCcpIG9yIGBidWZmZXJgIG11c3QgYmUgc2V0JylcbiAgfVxuXG4gIGlmIChsZW4gPiBVSU5UMzJfTUFYKSB7XG4gICAgbGVuICs9IDhcbiAgfVxuXG4gIG9iai5sZW5ndGggPSBsZW5cbiAgcmV0dXJuIGxlblxufVxuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbmV4dEV2ZW50ID0gcmVxdWlyZSgnbmV4dC1ldmVudCcpXG52YXIgQm94ID0gcmVxdWlyZSgnbXA0LWJveC1lbmNvZGluZycpXG5cbnZhciBFTVBUWSA9IG5ldyBCdWZmZXIoMClcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvZGVyXG5cbmZ1bmN0aW9uIERlY29kZXIgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVjb2RlcikpIHJldHVybiBuZXcgRGVjb2RlcigpXG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIHRoaXMuX3BlbmRpbmcgPSAwXG4gIHRoaXMuX21pc3NpbmcgPSAwXG4gIHRoaXMuX2J1ZiA9IG51bGxcbiAgdGhpcy5fc3RyID0gbnVsbFxuICB0aGlzLl9jYiA9IG51bGxcbiAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgdGhpcy5fd3JpdGVCdWZmZXIgPSBudWxsXG4gIHRoaXMuX3dyaXRlQ2IgPSBudWxsXG5cbiAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgdGhpcy5fa2ljaygpXG59XG5cbmluaGVyaXRzKERlY29kZXIsIHN0cmVhbS5Xcml0YWJsZSlcblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jLCBuZXh0KSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBkcmFpbmVkID0gIXRoaXMuX3N0ciB8fCAhdGhpcy5fc3RyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpblxuXG4gIHdoaWxlIChkYXRhLmxlbmd0aCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAoIXRoaXMuX21pc3NpbmcpIHtcbiAgICAgIHRoaXMuX3dyaXRlQnVmZmVyID0gZGF0YVxuICAgICAgdGhpcy5fd3JpdGVDYiA9IG5leHRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjb25zdW1lZCA9IGRhdGEubGVuZ3RoIDwgdGhpcy5fbWlzc2luZyA/IGRhdGEubGVuZ3RoIDogdGhpcy5fbWlzc2luZ1xuICAgIGlmICh0aGlzLl9idWYpIGRhdGEuY29weSh0aGlzLl9idWYsIHRoaXMuX2J1Zi5sZW5ndGggLSB0aGlzLl9taXNzaW5nKVxuICAgIGVsc2UgaWYgKHRoaXMuX3N0cikgZHJhaW5lZCA9IHRoaXMuX3N0ci53cml0ZShjb25zdW1lZCA9PT0gZGF0YS5sZW5ndGggPyBkYXRhIDogZGF0YS5zbGljZSgwLCBjb25zdW1lZCkpXG5cbiAgICB0aGlzLl9taXNzaW5nIC09IGNvbnN1bWVkXG5cbiAgICBpZiAoIXRoaXMuX21pc3NpbmcpIHtcbiAgICAgIHZhciBidWYgPSB0aGlzLl9idWZcbiAgICAgIHZhciBjYiA9IHRoaXMuX2NiXG4gICAgICB2YXIgc3RyZWFtID0gdGhpcy5fc3RyXG5cbiAgICAgIHRoaXMuX2J1ZiA9IHRoaXMuX2NiID0gdGhpcy5fc3RyID0gdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgICAgIGRyYWluZWQgPSB0cnVlXG5cbiAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS5lbmQoKVxuICAgICAgaWYgKGNiKSBjYihidWYpXG4gICAgfVxuXG4gICAgZGF0YSA9IGNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCA/IEVNUFRZIDogZGF0YS5zbGljZShjb25zdW1lZClcbiAgfVxuXG4gIGlmICh0aGlzLl9wZW5kaW5nICYmICF0aGlzLl9taXNzaW5nKSB7XG4gICAgdGhpcy5fd3JpdGVCdWZmZXIgPSBkYXRhXG4gICAgdGhpcy5fd3JpdGVDYiA9IG5leHRcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChkcmFpbmVkKSBuZXh0KClcbiAgZWxzZSB0aGlzLl9vbmRyYWluKG5leHQpXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9idWZmZXIgPSBmdW5jdGlvbiAoc2l6ZSwgY2IpIHtcbiAgdGhpcy5fbWlzc2luZyA9IHNpemVcbiAgdGhpcy5fYnVmID0gbmV3IEJ1ZmZlcihzaXplKVxuICB0aGlzLl9jYiA9IGNiXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9zdHJlYW0gPSBmdW5jdGlvbiAoc2l6ZSwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX21pc3NpbmcgPSBzaXplXG4gIHRoaXMuX3N0ciA9IG5ldyBNZWRpYURhdGEodGhpcylcbiAgdGhpcy5fb25kcmFpbiA9IG5leHRFdmVudCh0aGlzLl9zdHIsICdkcmFpbicpXG4gIHRoaXMuX3BlbmRpbmcrK1xuICB0aGlzLl9zdHIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9wZW5kaW5nLS1cbiAgICBzZWxmLl9raWNrKClcbiAgfSlcbiAgdGhpcy5fY2IgPSBjYlxuICByZXR1cm4gdGhpcy5fc3RyXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9yZWFkQm94ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgYnVmZmVySGVhZGVycyg4KVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckhlYWRlcnMgKGxlbiwgYnVmKSB7XG4gICAgc2VsZi5fYnVmZmVyKGxlbiwgZnVuY3Rpb24gKGFkZGl0aW9uYWxCdWYpIHtcbiAgICAgIGlmIChidWYpIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChidWYsIGFkZGl0aW9uYWxCdWYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBhZGRpdGlvbmFsQnVmXG4gICAgICB9XG4gICAgICB2YXIgaGVhZGVycyA9IEJveC5yZWFkSGVhZGVycyhidWYpXG4gICAgICBpZiAodHlwZW9mIGhlYWRlcnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ1ZmZlckhlYWRlcnMoaGVhZGVycyAtIGJ1Zi5sZW5ndGgsIGJ1ZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3BlbmRpbmcrK1xuICAgICAgICBzZWxmLl9oZWFkZXJzID0gaGVhZGVyc1xuICAgICAgICBzZWxmLmVtaXQoJ2JveCcsIGhlYWRlcnMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuX2hlYWRlcnMpIHRocm93IG5ldyBFcnJvcigndGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgb25jZSBhZnRlciBcXCdib3hcXCcgaXMgZW1pdHRlZCcpXG4gIHZhciBoZWFkZXJzID0gc2VsZi5faGVhZGVyc1xuICBzZWxmLl9oZWFkZXJzID0gbnVsbFxuXG4gIHJldHVybiBzZWxmLl9zdHJlYW0oaGVhZGVycy5jb250ZW50TGVuLCBudWxsKVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5faGVhZGVycykgdGhyb3cgbmV3IEVycm9yKCd0aGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlIGFmdGVyIFxcJ2JveFxcJyBpcyBlbWl0dGVkJylcbiAgdmFyIGhlYWRlcnMgPSBzZWxmLl9oZWFkZXJzXG4gIHNlbGYuX2hlYWRlcnMgPSBudWxsXG5cbiAgc2VsZi5fYnVmZmVyKGhlYWRlcnMuY29udGVudExlbiwgZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBib3ggPSBCb3guZGVjb2RlV2l0aG91dEhlYWRlcnMoaGVhZGVycywgYnVmKVxuICAgIGNiKGJveClcbiAgICBzZWxmLl9wZW5kaW5nLS1cbiAgICBzZWxmLl9raWNrKClcbiAgfSlcbn1cblxuRGVjb2Rlci5wcm90b3R5cGUuaWdub3JlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl9oZWFkZXJzKSB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UgYWZ0ZXIgXFwnYm94XFwnIGlzIGVtaXR0ZWQnKVxuICB2YXIgaGVhZGVycyA9IHNlbGYuX2hlYWRlcnNcbiAgc2VsZi5faGVhZGVycyA9IG51bGxcblxuICB0aGlzLl9taXNzaW5nID0gaGVhZGVycy5jb250ZW50TGVuXG4gIHRoaXMuX2NiID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3BlbmRpbmctLVxuICAgIHNlbGYuX2tpY2soKVxuICB9XG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9raWNrID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcGVuZGluZykgcmV0dXJuXG4gIGlmICghdGhpcy5fYnVmICYmICF0aGlzLl9zdHIpIHRoaXMuX3JlYWRCb3goKVxuICBpZiAodGhpcy5fd3JpdGVCdWZmZXIpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX3dyaXRlQ2JcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fd3JpdGVCdWZmZXJcbiAgICB0aGlzLl93cml0ZUJ1ZmZlciA9IG51bGxcbiAgICB0aGlzLl93cml0ZUNiID0gbnVsbFxuICAgIHRoaXMuX3dyaXRlKGJ1ZmZlciwgbnVsbCwgbmV4dClcbiAgfVxufVxuXG5mdW5jdGlvbiBNZWRpYURhdGEgKHBhcmVudCkge1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICBzdHJlYW0uUGFzc1Rocm91Z2guY2FsbCh0aGlzKVxufVxuXG5pbmhlcml0cyhNZWRpYURhdGEsIHN0cmVhbS5QYXNzVGhyb3VnaClcblxuTWVkaWFEYXRhLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgdGhpcy5fcGFyZW50LmRlc3Ryb3koZXJyKVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEJveCA9IHJlcXVpcmUoJ21wNC1ib3gtZW5jb2RpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuY29kZXJcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBFbmNvZGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVuY29kZXIpKSByZXR1cm4gbmV3IEVuY29kZXIoKVxuICBzdHJlYW0uUmVhZGFibGUuY2FsbCh0aGlzKVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICB0aGlzLl9yZWFkaW5nID0gZmFsc2VcbiAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICB0aGlzLl9kcmFpbiA9IG51bGxcbiAgdGhpcy5fd2FudCA9IGZhbHNlXG4gIHRoaXMuX29ucmVhZGFibGUgPSBvbnJlYWRhYmxlXG4gIHRoaXMuX29uZW5kID0gb25lbmRcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBvbnJlYWRhYmxlICgpIHtcbiAgICBpZiAoIXNlbGYuX3dhbnQpIHJldHVyblxuICAgIHNlbGYuX3dhbnQgPSBmYWxzZVxuICAgIHNlbGYuX3JlYWQoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQgKCkge1xuICAgIHNlbGYuX3N0cmVhbSA9IG51bGxcbiAgfVxufVxuXG5pbmhlcml0cyhFbmNvZGVyLCBzdHJlYW0uUmVhZGFibGUpXG5cbkVuY29kZXIucHJvdG90eXBlLm1lZGlhRGF0YSA9XG5FbmNvZGVyLnByb3RvdHlwZS5tZGF0ID0gZnVuY3Rpb24gKHNpemUsIGNiKSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgTWVkaWFEYXRhKHRoaXMpXG4gIHRoaXMuYm94KHt0eXBlOiAnbWRhdCcsIGNvbnRlbnRMZW5ndGg6IHNpemUsIGVuY29kZUJ1ZmZlckxlbjogOCwgc3RyZWFtOiBzdHJlYW19LCBjYilcbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5FbmNvZGVyLnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbiAoYm94LCBjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gY2IobmV3IEVycm9yKCdFbmNvZGVyIGlzIGRlc3Ryb3llZCcpKVxuXG4gIHZhciBidWZcbiAgaWYgKGJveC5lbmNvZGVCdWZmZXJMZW4pIHtcbiAgICBidWYgPSBuZXcgQnVmZmVyKGJveC5lbmNvZGVCdWZmZXJMZW4pXG4gIH1cbiAgaWYgKGJveC5zdHJlYW0pIHtcbiAgICBib3guYnVmZmVyID0gbnVsbFxuICAgIGJ1ZiA9IEJveC5lbmNvZGUoYm94LCBidWYpXG4gICAgdGhpcy5wdXNoKGJ1ZilcbiAgICB0aGlzLl9zdHJlYW0gPSBib3guc3RyZWFtXG4gICAgdGhpcy5fc3RyZWFtLm9uKCdyZWFkYWJsZScsIHRoaXMuX29ucmVhZGFibGUpXG4gICAgdGhpcy5fc3RyZWFtLm9uKCdlbmQnLCB0aGlzLl9vbmVuZClcbiAgICB0aGlzLl9zdHJlYW0ub24oJ2VuZCcsIGNiKVxuICAgIHRoaXMuX2ZvcndhcmQoKVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJveC5lbmNvZGUoYm94LCBidWYpXG4gICAgdmFyIGRyYWluZWQgPSB0aGlzLnB1c2goYnVmKVxuICAgIGlmIChkcmFpbmVkKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB0aGlzLl9kcmFpbiA9IGNiXG4gIH1cbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIGlmICh0aGlzLl9zdHJlYW0gJiYgdGhpcy5fc3RyZWFtLmRlc3Ryb3kpIHRoaXMuX3N0cmVhbS5kZXN0cm95KClcbiAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICBpZiAodGhpcy5fZHJhaW4pIHtcbiAgICB2YXIgY2IgPSB0aGlzLl9kcmFpblxuICAgIHRoaXMuX2RyYWluID0gbnVsbFxuICAgIGNiKGVycilcbiAgfVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucHVzaChudWxsKVxufVxuXG5FbmNvZGVyLnByb3RvdHlwZS5fZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9zdHJlYW0pIHJldHVyblxuXG4gIHdoaWxlICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICB2YXIgYnVmID0gdGhpcy5fc3RyZWFtLnJlYWQoKVxuXG4gICAgaWYgKCFidWYpIHtcbiAgICAgIHRoaXMuX3dhbnQgPSAhIXRoaXMuX3N0cmVhbVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnB1c2goYnVmKSkgcmV0dXJuXG4gIH1cbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9yZWFkaW5nIHx8IHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fcmVhZGluZyA9IHRydWVcblxuICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9mb3J3YXJkKClcbiAgaWYgKHRoaXMuX2RyYWluKSB7XG4gICAgdmFyIGRyYWluID0gdGhpcy5fZHJhaW5cbiAgICB0aGlzLl9kcmFpbiA9IG51bGxcbiAgICBkcmFpbigpXG4gIH1cblxuICB0aGlzLl9yZWFkaW5nID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gTWVkaWFEYXRhIChwYXJlbnQpIHtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgc3RyZWFtLlBhc3NUaHJvdWdoLmNhbGwodGhpcylcbn1cblxuaW5oZXJpdHMoTWVkaWFEYXRhLCBzdHJlYW0uUGFzc1Rocm91Z2gpXG5cbk1lZGlhRGF0YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX3BhcmVudC5kZXN0cm95KGVycilcbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG4iLCJleHBvcnRzLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJylcbmV4cG9ydHMuZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGUnKVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBNdWx0aVN0cmVhbVxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxuaW5oZXJpdHMoTXVsdGlTdHJlYW0sIHN0cmVhbS5SZWFkYWJsZSlcblxuZnVuY3Rpb24gTXVsdGlTdHJlYW0gKHN0cmVhbXMsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE11bHRpU3RyZWFtKSkgcmV0dXJuIG5ldyBNdWx0aVN0cmVhbShzdHJlYW1zLCBvcHRzKVxuICBzdHJlYW0uUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRzKVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICB0aGlzLl9kcmFpbmVkID0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG4gIHRoaXMuX2N1cnJlbnQgPSBudWxsXG4gIHRoaXMuX3F1ZXVlID0gKHR5cGVvZiBzdHJlYW1zID09PSAnZnVuY3Rpb24nID8gc3RyZWFtcyA6IHN0cmVhbXMubWFwKHRvU3RyZWFtczIpKVxuXG4gIHRoaXMuX25leHQoKVxufVxuXG5NdWx0aVN0cmVhbS5vYmogPSBmdW5jdGlvbiAoc3RyZWFtcykge1xuICByZXR1cm4gbmV3IE11bHRpU3RyZWFtKHN0cmVhbXMsIHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogMTYgfSlcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kcmFpbmVkID0gdHJ1ZVxuICB0aGlzLl9mb3J3YXJkKClcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9mb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZm9yd2FyZGluZyB8fCAhdGhpcy5fZHJhaW5lZCB8fCAhdGhpcy5fY3VycmVudCkgcmV0dXJuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSB0cnVlXG5cbiAgdmFyIGNodW5rXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jdXJyZW50LnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICB0aGlzLl9kcmFpbmVkID0gdGhpcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG59XG5cbk11bHRpU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcblxuICBpZiAodGhpcy5fY3VycmVudCAmJiB0aGlzLl9jdXJyZW50LmRlc3Ryb3kpIHRoaXMuX2N1cnJlbnQuZGVzdHJveSgpXG4gIGlmICh0eXBlb2YgdGhpcy5fcXVldWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9xdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIGlmIChzdHJlYW0uZGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koKVxuICAgIH0pXG4gIH1cblxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fY3VycmVudCA9IG51bGxcblxuICBpZiAodHlwZW9mIHNlbGYuX3F1ZXVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5fcXVldWUoZnVuY3Rpb24gKGVyciwgc3RyZWFtKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcbiAgICAgIHNlbGYuX2dvdE5leHRTdHJlYW0odG9TdHJlYW1zMihzdHJlYW0pKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmVhbSA9IHNlbGYuX3F1ZXVlLnNoaWZ0KClcbiAgICBpZiAodHlwZW9mIHN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykgc3RyZWFtID0gdG9TdHJlYW1zMihzdHJlYW0oKSlcbiAgICBzZWxmLl9nb3ROZXh0U3RyZWFtKHN0cmVhbSlcbiAgfVxufVxuXG5NdWx0aVN0cmVhbS5wcm90b3R5cGUuX2dvdE5leHRTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICghc3RyZWFtKSB7XG4gICAgc2VsZi5wdXNoKG51bGwpXG4gICAgc2VsZi5kZXN0cm95KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNlbGYuX2N1cnJlbnQgPSBzdHJlYW1cbiAgc2VsZi5fZm9yd2FyZCgpXG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUpXG4gIHN0cmVhbS5vbignZW5kJywgb25FbmQpXG4gIHN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25DbG9zZSlcblxuICBmdW5jdGlvbiBvblJlYWRhYmxlICgpIHtcbiAgICBzZWxmLl9mb3J3YXJkKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xvc2UgKCkge1xuICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICBzZWxmLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kICgpIHtcbiAgICBzZWxmLl9jdXJyZW50ID0gbnVsbFxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBvblJlYWRhYmxlKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG4gICAgc2VsZi5fbmV4dCgpXG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yIChlcnIpIHtcbiAgICBzZWxmLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3RyZWFtczIgKHMpIHtcbiAgaWYgKCFzIHx8IHR5cGVvZiBzID09PSAnZnVuY3Rpb24nIHx8IHMuX3JlYWRhYmxlU3RhdGUpIHJldHVybiBzXG5cbiAgdmFyIHdyYXAgPSBuZXcgc3RyZWFtLlJlYWRhYmxlKCkud3JhcChzKVxuICBpZiAocy5kZXN0cm95KSB7XG4gICAgd3JhcC5kZXN0cm95ID0gcy5kZXN0cm95LmJpbmQocylcbiAgfVxuICByZXR1cm4gd3JhcFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBuZXh0RXZlbnRcblxuZnVuY3Rpb24gbmV4dEV2ZW50IChlbWl0dGVyLCBuYW1lKSB7XG4gIHZhciBuZXh0ID0gbnVsbFxuICBlbWl0dGVyLm9uKG5hbWUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCFuZXh0KSByZXR1cm5cbiAgICB2YXIgZm4gPSBuZXh0XG4gICAgbmV4dCA9IG51bGxcbiAgICBmbihkYXRhKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAob25jZSkge1xuICAgIG5leHQgPSBvbmNlXG4gIH1cbn1cbiIsInZhciB3cmFwcHkgPSByZXF1aXJlKCd3cmFwcHknKVxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkob25jZSlcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZGVjb2RlVG9ycmVudEZpbGVcbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IGRlY29kZVRvcnJlbnRGaWxlXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVUb3JyZW50RmlsZVxuXG52YXIgYmVuY29kZSA9IHJlcXVpcmUoJ2JlbmNvZGUnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcblxuLyoqXG4gKiBQYXJzZSBhIHRvcnJlbnQuIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHRvcnJlbnQgaXMgbWlzc2luZyByZXF1aXJlZCBmaWVsZHMuXG4gKiBAcGFyYW0gIHtCdWZmZXJ8T2JqZWN0fSB0b3JyZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBwYXJzZWQgdG9ycmVudFxuICovXG5mdW5jdGlvbiBkZWNvZGVUb3JyZW50RmlsZSAodG9ycmVudCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcnJlbnQpKSB7XG4gICAgdG9ycmVudCA9IGJlbmNvZGUuZGVjb2RlKHRvcnJlbnQpXG4gIH1cblxuICAvLyBzYW5pdHkgY2hlY2tcbiAgZW5zdXJlKHRvcnJlbnQuaW5mbywgJ2luZm8nKVxuICBlbnN1cmUodG9ycmVudC5pbmZvWyduYW1lLnV0Zi04J10gfHwgdG9ycmVudC5pbmZvLm5hbWUsICdpbmZvLm5hbWUnKVxuICBlbnN1cmUodG9ycmVudC5pbmZvWydwaWVjZSBsZW5ndGgnXSwgJ2luZm9bXFwncGllY2UgbGVuZ3RoXFwnXScpXG4gIGVuc3VyZSh0b3JyZW50LmluZm8ucGllY2VzLCAnaW5mby5waWVjZXMnKVxuXG4gIGlmICh0b3JyZW50LmluZm8uZmlsZXMpIHtcbiAgICB0b3JyZW50LmluZm8uZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgZW5zdXJlKHR5cGVvZiBmaWxlLmxlbmd0aCA9PT0gJ251bWJlcicsICdpbmZvLmZpbGVzWzBdLmxlbmd0aCcpXG4gICAgICBlbnN1cmUoZmlsZVsncGF0aC51dGYtOCddIHx8IGZpbGUucGF0aCwgJ2luZm8uZmlsZXNbMF0ucGF0aCcpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBlbnN1cmUodHlwZW9mIHRvcnJlbnQuaW5mby5sZW5ndGggPT09ICdudW1iZXInLCAnaW5mby5sZW5ndGgnKVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG4gIHJlc3VsdC5pbmZvID0gdG9ycmVudC5pbmZvXG4gIHJlc3VsdC5pbmZvQnVmZmVyID0gYmVuY29kZS5lbmNvZGUodG9ycmVudC5pbmZvKVxuICByZXN1bHQuaW5mb0hhc2ggPSBzaGExLnN5bmMocmVzdWx0LmluZm9CdWZmZXIpXG4gIHJlc3VsdC5pbmZvSGFzaEJ1ZmZlciA9IG5ldyBCdWZmZXIocmVzdWx0LmluZm9IYXNoLCAnaGV4JylcblxuICByZXN1bHQubmFtZSA9ICh0b3JyZW50LmluZm9bJ25hbWUudXRmLTgnXSB8fCB0b3JyZW50LmluZm8ubmFtZSkudG9TdHJpbmcoKVxuXG4gIGlmICh0b3JyZW50LmluZm8ucHJpdmF0ZSAhPT0gdW5kZWZpbmVkKSByZXN1bHQucHJpdmF0ZSA9ICEhdG9ycmVudC5pbmZvLnByaXZhdGVcblxuICBpZiAodG9ycmVudFsnY3JlYXRpb24gZGF0ZSddKSByZXN1bHQuY3JlYXRlZCA9IG5ldyBEYXRlKHRvcnJlbnRbJ2NyZWF0aW9uIGRhdGUnXSAqIDEwMDApXG4gIGlmICh0b3JyZW50WydjcmVhdGVkIGJ5J10pIHJlc3VsdC5jcmVhdGVkQnkgPSB0b3JyZW50WydjcmVhdGVkIGJ5J10udG9TdHJpbmcoKVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodG9ycmVudC5jb21tZW50KSkgcmVzdWx0LmNvbW1lbnQgPSB0b3JyZW50LmNvbW1lbnQudG9TdHJpbmcoKVxuXG4gIC8vIGFubm91bmNlIGFuZCBhbm5vdW5jZS1saXN0IHdpbGwgYmUgbWlzc2luZyBpZiBtZXRhZGF0YSBmZXRjaGVkIHZpYSB1dF9tZXRhZGF0YVxuICByZXN1bHQuYW5ub3VuY2UgPSBbXVxuICBpZiAodG9ycmVudFsnYW5ub3VuY2UtbGlzdCddICYmIHRvcnJlbnRbJ2Fubm91bmNlLWxpc3QnXS5sZW5ndGgpIHtcbiAgICB0b3JyZW50Wydhbm5vdW5jZS1saXN0J10uZm9yRWFjaChmdW5jdGlvbiAodXJscykge1xuICAgICAgdXJscy5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmVzdWx0LmFubm91bmNlLnB1c2godXJsLnRvU3RyaW5nKCkpXG4gICAgICB9KVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodG9ycmVudC5hbm5vdW5jZSkge1xuICAgIHJlc3VsdC5hbm5vdW5jZS5wdXNoKHRvcnJlbnQuYW5ub3VuY2UudG9TdHJpbmcoKSlcbiAgfVxuXG4gIC8vIGhhbmRsZSB1cmwtbGlzdCAoQkVQMTkgLyB3ZWIgc2VlZGluZylcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3JyZW50Wyd1cmwtbGlzdCddKSkge1xuICAgIC8vIHNvbWUgY2xpZW50cyBzZXQgdXJsLWxpc3QgdG8gZW1wdHkgc3RyaW5nXG4gICAgdG9ycmVudFsndXJsLWxpc3QnXSA9IHRvcnJlbnRbJ3VybC1saXN0J10ubGVuZ3RoID4gMFxuICAgICAgPyBbIHRvcnJlbnRbJ3VybC1saXN0J10gXVxuICAgICAgOiBbXVxuICB9XG4gIHJlc3VsdC51cmxMaXN0ID0gKHRvcnJlbnRbJ3VybC1saXN0J10gfHwgW10pLm1hcChmdW5jdGlvbiAodXJsKSB7XG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpXG4gIH0pXG5cbiAgdW5pcShyZXN1bHQuYW5ub3VuY2UpXG4gIHVuaXEocmVzdWx0LnVybExpc3QpXG5cbiAgdmFyIGZpbGVzID0gdG9ycmVudC5pbmZvLmZpbGVzIHx8IFsgdG9ycmVudC5pbmZvIF1cbiAgcmVzdWx0LmZpbGVzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlLCBpKSB7XG4gICAgdmFyIHBhcnRzID0gW10uY29uY2F0KHJlc3VsdC5uYW1lLCBmaWxlWydwYXRoLnV0Zi04J10gfHwgZmlsZS5wYXRoIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwLnRvU3RyaW5nKClcbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLmpvaW4uYXBwbHkobnVsbCwgW3BhdGguc2VwXS5jb25jYXQocGFydHMpKS5zbGljZSgxKSxcbiAgICAgIG5hbWU6IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLFxuICAgICAgbGVuZ3RoOiBmaWxlLmxlbmd0aCxcbiAgICAgIG9mZnNldDogZmlsZXMuc2xpY2UoMCwgaSkucmVkdWNlKHN1bUxlbmd0aCwgMClcbiAgICB9XG4gIH0pXG5cbiAgcmVzdWx0Lmxlbmd0aCA9IGZpbGVzLnJlZHVjZShzdW1MZW5ndGgsIDApXG5cbiAgdmFyIGxhc3RGaWxlID0gcmVzdWx0LmZpbGVzW3Jlc3VsdC5maWxlcy5sZW5ndGggLSAxXVxuXG4gIHJlc3VsdC5waWVjZUxlbmd0aCA9IHRvcnJlbnQuaW5mb1sncGllY2UgbGVuZ3RoJ11cbiAgcmVzdWx0Lmxhc3RQaWVjZUxlbmd0aCA9ICgobGFzdEZpbGUub2Zmc2V0ICsgbGFzdEZpbGUubGVuZ3RoKSAlIHJlc3VsdC5waWVjZUxlbmd0aCkgfHwgcmVzdWx0LnBpZWNlTGVuZ3RoXG4gIHJlc3VsdC5waWVjZXMgPSBzcGxpdFBpZWNlcyh0b3JyZW50LmluZm8ucGllY2VzKVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcGFyc2VkIHRvcnJlbnQgb2JqZWN0IGJhY2sgaW50byBhIC50b3JyZW50IGZpbGUgYnVmZmVyLlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJzZWQgcGFyc2VkIHRvcnJlbnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVG9ycmVudEZpbGUgKHBhcnNlZCkge1xuICB2YXIgdG9ycmVudCA9IHtcbiAgICBpbmZvOiBwYXJzZWQuaW5mb1xuICB9XG5cbiAgdG9ycmVudFsnYW5ub3VuY2UtbGlzdCddID0gKHBhcnNlZC5hbm5vdW5jZSB8fCBbXSkubWFwKGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoIXRvcnJlbnQuYW5ub3VuY2UpIHRvcnJlbnQuYW5ub3VuY2UgPSB1cmxcbiAgICB1cmwgPSBuZXcgQnVmZmVyKHVybCwgJ3V0ZjgnKVxuICAgIHJldHVybiBbIHVybCBdXG4gIH0pXG5cbiAgdG9ycmVudFsndXJsLWxpc3QnXSA9IHBhcnNlZC51cmxMaXN0IHx8IFtdXG5cbiAgaWYgKHBhcnNlZC5jcmVhdGVkKSB7XG4gICAgdG9ycmVudFsnY3JlYXRpb24gZGF0ZSddID0gKHBhcnNlZC5jcmVhdGVkLmdldFRpbWUoKSAvIDEwMDApIHwgMFxuICB9XG5cbiAgaWYgKHBhcnNlZC5jcmVhdGVkQnkpIHtcbiAgICB0b3JyZW50WydjcmVhdGVkIGJ5J10gPSBwYXJzZWQuY3JlYXRlZEJ5XG4gIH1cblxuICBpZiAocGFyc2VkLmNvbW1lbnQpIHtcbiAgICB0b3JyZW50LmNvbW1lbnQgPSBwYXJzZWQuY29tbWVudFxuICB9XG5cbiAgcmV0dXJuIGJlbmNvZGUuZW5jb2RlKHRvcnJlbnQpXG59XG5cbmZ1bmN0aW9uIHN1bUxlbmd0aCAoc3VtLCBmaWxlKSB7XG4gIHJldHVybiBzdW0gKyBmaWxlLmxlbmd0aFxufVxuXG5mdW5jdGlvbiBzcGxpdFBpZWNlcyAoYnVmKSB7XG4gIHZhciBwaWVjZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMjApIHtcbiAgICBwaWVjZXMucHVzaChidWYuc2xpY2UoaSwgaSArIDIwKS50b1N0cmluZygnaGV4JykpXG4gIH1cbiAgcmV0dXJuIHBpZWNlc1xufVxuXG5mdW5jdGlvbiBlbnN1cmUgKGJvb2wsIGZpZWxkTmFtZSkge1xuICBpZiAoIWJvb2wpIHRocm93IG5ldyBFcnJvcignVG9ycmVudCBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiAnICsgZmllbGROYW1lKVxufVxuIiwidmFyIERpY3QgPSByZXF1aXJlKFwiLi9kaWN0XCIpXG5cbi8qKlxuICogRGVjb2RlcyBiZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcn0gZGF0YVxuICogQHBhcmFtICB7TnVtYmVyfSBzdGFydCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGVuY29kaW5nIChvcHRpb25hbClcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKCBkYXRhLCBzdGFydCwgZW5kLCBlbmNvZGluZyApIHtcbiAgXG4gIGlmKCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBzdGFydFxuICAgIHN0YXJ0ID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGlmKCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gZW5kXG4gICAgZW5kID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gISggQnVmZmVyLmlzQnVmZmVyKGRhdGEpIClcbiAgICA/IG5ldyBCdWZmZXIoIGRhdGEgKVxuICAgIDogZGF0YS5zbGljZSggc3RhcnQsIGVuZCApXG4gIFxuICBkZWNvZGUuYnl0ZXMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgXG4gIHJldHVybiBkZWNvZGUubmV4dCgpXG5cbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgICAgID0gbnVsbFxuZGVjb2RlLmVuY29kaW5nID0gbnVsbFxuXG5kZWNvZGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gIHN3aXRjaCggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSApIHtcbiAgICBjYXNlIDB4NjQ6IHJldHVybiBkZWNvZGUuZGljdGlvbmFyeSgpOyBicmVha1xuICAgIGNhc2UgMHg2QzogcmV0dXJuIGRlY29kZS5saXN0KCk7IGJyZWFrXG4gICAgY2FzZSAweDY5OiByZXR1cm4gZGVjb2RlLmludGVnZXIoKTsgYnJlYWtcbiAgICBkZWZhdWx0OiAgIHJldHVybiBkZWNvZGUuYnVmZmVyKCk7IGJyZWFrXG4gIH1cblxufVxuXG5kZWNvZGUuZmluZCA9IGZ1bmN0aW9uKCBjaHIgKSB7XG5cbiAgdmFyIGkgPSBkZWNvZGUucG9zaXRpb25cbiAgdmFyIGMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgdmFyIGQgPSBkZWNvZGUuZGF0YVxuXG4gIHdoaWxlKCBpIDwgYyApIHtcbiAgICBpZiggZFtpXSA9PT0gY2hyIClcbiAgICAgIHJldHVybiBpXG4gICAgaSsrXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ0ludmFsaWQgZGF0YTogTWlzc2luZyBkZWxpbWl0ZXIgXCInICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjaHIgKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoIDE2ICkgKyAnXSdcbiAgKVxuXG59XG5cbmRlY29kZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgZGljdCA9IG5ldyBEaWN0KClcblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBkaWN0LmJpbmFyeVNldChkZWNvZGUuYnVmZmVyKCksIGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBkaWN0XG5cbn1cblxuZGVjb2RlLmxpc3QgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBsc3QgPSBbXVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGxzdC5wdXNoKCBkZWNvZGUubmV4dCgpIClcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGxzdFxuXG59XG5cbmRlY29kZS5pbnRlZ2VyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGVuZCAgICA9IGRlY29kZS5maW5kKCAweDY1IClcbiAgdmFyIG51bWJlciA9IGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24gKyAxLCBlbmQgKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KCBudW1iZXIsIDEwIClcblxufVxuXG5kZWNvZGUuYnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNlcCAgICA9IGRlY29kZS5maW5kKCAweDNBIClcbiAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KCBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXAgKSwgMTAgKVxuICB2YXIgZW5kICAgID0gKytzZXAgKyBsZW5ndGhcblxuICBkZWNvZGUucG9zaXRpb24gPSBlbmRcblxuICByZXR1cm4gZGVjb2RlLmVuY29kaW5nXG4gICAgPyBkZWNvZGUuZGF0YS50b1N0cmluZyggZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZCApXG4gICAgOiBkZWNvZGUuZGF0YS5zbGljZSggc2VwLCBlbmQgKVxuXG59XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlXG4iLCIvKipcbiAqIEVuY29kZXMgZGF0YSBpbiBiZW5jb2RlLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcnxBcnJheXxTdHJpbmd8T2JqZWN0fE51bWJlcnxCb29sZWFufSBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZSggZGF0YSwgYnVmZmVyLCBvZmZzZXQgKSB7XG4gIFxuICB2YXIgYnVmZmVycyA9IFtdXG4gIHZhciByZXN1bHQgPSBudWxsXG4gIFxuICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YSApXG4gIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoIGJ1ZmZlcnMgKVxuICBlbmNvZGUuYnl0ZXMgPSByZXN1bHQubGVuZ3RoXG4gIFxuICBpZiggQnVmZmVyLmlzQnVmZmVyKCBidWZmZXIgKSApIHtcbiAgICByZXN1bHQuY29weSggYnVmZmVyLCBvZmZzZXQgKVxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdFxuICBcbn1cblxuZW5jb2RlLmJ5dGVzID0gLTFcbmVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSBmYWxzZVxuXG5lbmNvZGUuX2VuY29kZSA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGlmKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCggdHlwZW9mIGRhdGEgKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGVuY29kZS5idWZmZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KCBidWZmZXJzLCBkYXRhIClcbiAgICAgICAgOiBlbmNvZGUuZGljdCggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSA/IDEgOiAwIClcbiAgICAgIGJyZWFrXG4gIH1cblxufVxuXG52YXIgYnVmZl9lID0gbmV3IEJ1ZmZlcignZScpXG4gICwgYnVmZl9kID0gbmV3IEJ1ZmZlcignZCcpXG4gICwgYnVmZl9sID0gbmV3IEJ1ZmZlcignbCcpXG5cbmVuY29kZS5idWZmZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoIGRhdGEgKSArICc6JyArIGRhdGEpIClcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuICB2YXIgbWF4TG8gPSAweDgwMDAwMDAwXG4gIHZhciBoaSA9ICggZGF0YSAvIG1heExvICkgPDwgMFxuICB2YXIgbG8gPSAoIGRhdGEgJSBtYXhMbyAgKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoICdpJyArIHZhbCArICdlJyApKVxuXG4gIGlmKCB2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgKSB7XG4gICAgZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCA9IHRydWVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV0FSTklORzogUG9zc2libGUgZGF0YSBjb3JydXB0aW9uIGRldGVjdGVkIHdpdGggdmFsdWUgXCInK2RhdGErJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicrdmFsKydcIidcbiAgICApXG4gICAgY29uc29sZS50cmFjZSgpXG4gIH1cblxufVxuXG5lbmNvZGUuZGljdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9kIClcblxuICB2YXIgaiA9IDBcbiAgdmFyIGtcbiAgLy8gZml4IGZvciBpc3N1ZSAjMTMgLSBzb3J0ZWQgZGljdHNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZGF0YSApLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciggOyBqIDwga2wgOyBqKyspIHtcbiAgICBrPWtleXNbal1cbiAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBrIClcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtrXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgdmFyIGkgPSAwLCBqID0gMVxuICB2YXIgYyA9IGRhdGEubGVuZ3RoXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9sIClcblxuICBmb3IoIDsgaSA8IGM7IGkrKyApIHtcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtpXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG5cbn1cblxuLy8gRXhwb3NlXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuIiwiLyogZ2xvYmFsIEJsb2IgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVRvcnJlbnRcbm1vZHVsZS5leHBvcnRzLnJlbW90ZSA9IHBhcnNlVG9ycmVudFJlbW90ZVxuXG52YXIgYmxvYlRvQnVmZmVyID0gcmVxdWlyZSgnYmxvYi10by1idWZmZXInKVxudmFyIGZzID0gcmVxdWlyZSgnZnMnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBnZXQgPSByZXF1aXJlKCdzaW1wbGUtZ2V0JylcbnZhciBtYWduZXQgPSByZXF1aXJlKCdtYWduZXQtdXJpJylcbnZhciBwYXJzZVRvcnJlbnRGaWxlID0gcmVxdWlyZSgncGFyc2UtdG9ycmVudC1maWxlJylcblxubW9kdWxlLmV4cG9ydHMudG9NYWduZXRVUkkgPSBtYWduZXQuZW5jb2RlXG5tb2R1bGUuZXhwb3J0cy50b1RvcnJlbnRGaWxlID0gcGFyc2VUb3JyZW50RmlsZS5lbmNvZGVcblxuLyoqXG4gKiBQYXJzZSBhIHRvcnJlbnQgaWRlbnRpZmllciAobWFnbmV0IHVyaSwgLnRvcnJlbnQgZmlsZSwgaW5mbyBoYXNoKVxuICogQHBhcmFtICB7c3RyaW5nfEJ1ZmZlcnxPYmplY3R9IHRvcnJlbnRJZFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZVRvcnJlbnQgKHRvcnJlbnRJZCkge1xuICBpZiAodHlwZW9mIHRvcnJlbnRJZCA9PT0gJ3N0cmluZycgJiYgL21hZ25ldDovLnRlc3QodG9ycmVudElkKSkge1xuICAgIC8vIG1hZ25ldCB1cmkgKHN0cmluZylcbiAgICByZXR1cm4gbWFnbmV0KHRvcnJlbnRJZClcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9ycmVudElkID09PSAnc3RyaW5nJyAmJiAoL15bYS1mMC05XXs0MH0kL2kudGVzdCh0b3JyZW50SWQpIHx8IC9eW2EtejItN117MzJ9JC9pLnRlc3QodG9ycmVudElkKSkpIHtcbiAgICAvLyBpbmZvIGhhc2ggKGhleC9iYXNlLTMyIHN0cmluZylcbiAgICByZXR1cm4gbWFnbmV0KCdtYWduZXQ6P3h0PXVybjpidGloOicgKyB0b3JyZW50SWQpXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcnJlbnRJZCkgJiYgdG9ycmVudElkLmxlbmd0aCA9PT0gMjApIHtcbiAgICAvLyBpbmZvIGhhc2ggKGJ1ZmZlcilcbiAgICByZXR1cm4gbWFnbmV0KCdtYWduZXQ6P3h0PXVybjpidGloOicgKyB0b3JyZW50SWQudG9TdHJpbmcoJ2hleCcpKVxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3JyZW50SWQpKSB7XG4gICAgLy8gLnRvcnJlbnQgZmlsZSAoYnVmZmVyKVxuICAgIHJldHVybiBwYXJzZVRvcnJlbnRGaWxlKHRvcnJlbnRJZCkgLy8gbWlnaHQgdGhyb3dcbiAgfSBlbHNlIGlmICh0b3JyZW50SWQgJiYgdG9ycmVudElkLmluZm9IYXNoKSB7XG4gICAgLy8gcGFyc2VkIHRvcnJlbnQgKGZyb20gYHBhcnNlLXRvcnJlbnRgLCBgcGFyc2UtdG9ycmVudC1maWxlYCwgb3IgYG1hZ25ldC11cmlgKVxuICAgIGlmICghdG9ycmVudElkLmFubm91bmNlKSB0b3JyZW50SWQuYW5ub3VuY2UgPSBbXVxuICAgIGlmICh0eXBlb2YgdG9ycmVudElkLmFubm91bmNlID09PSAnc3RyaW5nJykge1xuICAgICAgdG9ycmVudElkLmFubm91bmNlID0gWyB0b3JyZW50SWQuYW5ub3VuY2UgXVxuICAgIH1cbiAgICBpZiAoIXRvcnJlbnRJZC51cmxMaXN0KSB0b3JyZW50SWQudXJsTGlzdCA9IFtdXG4gICAgcmV0dXJuIHRvcnJlbnRJZFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b3JyZW50IGlkZW50aWZpZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9ycmVudFJlbW90ZSAodG9ycmVudElkLCBjYikge1xuICB2YXIgcGFyc2VkVG9ycmVudFxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgRnVuY3Rpb24nKVxuXG4gIHRyeSB7XG4gICAgcGFyc2VkVG9ycmVudCA9IHBhcnNlVG9ycmVudCh0b3JyZW50SWQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElmIHRvcnJlbnQgZmFpbHMgdG8gcGFyc2UsIGl0IGNvdWxkIGJlIGEgQmxvYiwgaHR0cC9odHRwcyBVUkwgb3JcbiAgICAvLyBmaWxlc3lzdGVtIHBhdGgsIHNvIGRvbid0IGNvbnNpZGVyIGl0IGFuIGVycm9yIHlldC5cbiAgfVxuXG4gIGlmIChwYXJzZWRUb3JyZW50ICYmIHBhcnNlZFRvcnJlbnQuaW5mb0hhc2gpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIHBhcnNlZFRvcnJlbnQpXG4gICAgfSlcbiAgfSBlbHNlIGlmIChpc0Jsb2IodG9ycmVudElkKSkge1xuICAgIGJsb2JUb0J1ZmZlcih0b3JyZW50SWQsIGZ1bmN0aW9uIChlcnIsIHRvcnJlbnRCdWYpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihuZXcgRXJyb3IoJ0Vycm9yIGNvbnZlcnRpbmcgQmxvYjogJyArIGVyci5tZXNzYWdlKSlcbiAgICAgIHBhcnNlT3JUaHJvdyh0b3JyZW50QnVmKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGdldCA9PT0gJ2Z1bmN0aW9uJyAmJiAvXmh0dHBzPzovLnRlc3QodG9ycmVudElkKSkge1xuICAgIC8vIGh0dHAsIG9yIGh0dHBzIHVybCB0byB0b3JyZW50IGZpbGVcbiAgICBnZXQuY29uY2F0KHtcbiAgICAgIHVybDogdG9ycmVudElkLFxuICAgICAgaGVhZGVyczogeyAndXNlci1hZ2VudCc6ICdXZWJUb3JyZW50IChodHRwOi8vd2VidG9ycmVudC5pbyknIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMsIHRvcnJlbnRCdWYpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihuZXcgRXJyb3IoJ0Vycm9yIGRvd25sb2FkaW5nIHRvcnJlbnQ6ICcgKyBlcnIubWVzc2FnZSkpXG4gICAgICBwYXJzZU9yVGhyb3codG9ycmVudEJ1ZilcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBmcy5yZWFkRmlsZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdG9ycmVudElkID09PSAnc3RyaW5nJykge1xuICAgIC8vIGFzc3VtZSBpdCdzIGEgZmlsZXN5c3RlbSBwYXRoXG4gICAgZnMucmVhZEZpbGUodG9ycmVudElkLCBmdW5jdGlvbiAoZXJyLCB0b3JyZW50QnVmKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IobmV3IEVycm9yKCdJbnZhbGlkIHRvcnJlbnQgaWRlbnRpZmllcicpKVxuICAgICAgcGFyc2VPclRocm93KHRvcnJlbnRCdWYpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG5ldyBFcnJvcignSW52YWxpZCB0b3JyZW50IGlkZW50aWZpZXInKSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPclRocm93ICh0b3JyZW50QnVmKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFRvcnJlbnQgPSBwYXJzZVRvcnJlbnQodG9ycmVudEJ1ZilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpXG4gICAgfVxuICAgIGlmIChwYXJzZWRUb3JyZW50ICYmIHBhcnNlZFRvcnJlbnQuaW5mb0hhc2gpIGNiKG51bGwsIHBhcnNlZFRvcnJlbnQpXG4gICAgZWxzZSBjYihuZXcgRXJyb3IoJ0ludmFsaWQgdG9ycmVudCBpZGVudGlmaWVyJykpXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIFczQyBgQmxvYmAgb3IgYEZpbGVgIG9iamVjdFxuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Jsb2IgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEJsb2Jcbn1cbiIsIi8qKlxuICogSlNPTiBwYXJzZS5cbiAqXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuICB9XG59OyIsIi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG4gIHZhciBxcnkgPSB7fTtcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHFyeTtcbn07XG4iLCIvKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgICB2YXIgc3JjID0gc3RyLFxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgIHVyaSA9IHt9LFxuICAgICAgICBpID0gMTQ7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsInZhciBjbG9zZXN0ID0gcmVxdWlyZSgnY2xvc2VzdC10bycpXG5cbi8vIENyZWF0ZSBhIHJhbmdlIGZyb20gMTZrYuKAkzRtYlxudmFyIHNpemVzID0gW11cbmZvciAodmFyIGkgPSAxNDsgaSA8PSAyMjsgaSsrKSB7XG4gIHNpemVzLnB1c2goTWF0aC5wb3coMiwgaSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2l6ZSkge1xuICByZXR1cm4gY2xvc2VzdChcbiAgICBzaXplIC8gTWF0aC5wb3coMiwgMTApLCBzaXplcyBcbiAgKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXG52YXIgZnMgPSByZXF1aXJlKCdmcycpIC8vIHdlIG9ubHkgbmVlZCBmcyB0byBnZXQgdGhlIFJlYWRTdHJlYW0gYW5kIFdyaXRlU3RyZWFtIHByb3RvdHlwZXNcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG52YXIgaXNGbiA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nXG59XG5cbnZhciBpc0ZTID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICByZXR1cm4gKHN0cmVhbSBpbnN0YW5jZW9mIChmcy5SZWFkU3RyZWFtIHx8IG5vb3ApIHx8IHN0cmVhbSBpbnN0YW5jZW9mIChmcy5Xcml0ZVN0cmVhbSB8fCBub29wKSkgJiYgaXNGbihzdHJlYW0uY2xvc2UpXG59XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIGlzRm4oc3RyZWFtLmFib3J0KVxufVxuXG52YXIgZGVzdHJveWVyID0gZnVuY3Rpb24gKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gIHZhciBjbG9zZWQgPSBmYWxzZVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWVcbiAgfSlcblxuICBlb3Moc3RyZWFtLCB7cmVhZGFibGU6IHJlYWRpbmcsIHdyaXRhYmxlOiB3cml0aW5nfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgY2xvc2VkID0gdHJ1ZVxuICAgIGNhbGxiYWNrKClcbiAgfSlcblxuICB2YXIgZGVzdHJveWVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm5cbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm5cbiAgICBkZXN0cm95ZWQgPSB0cnVlXG5cbiAgICBpZiAoaXNGUyhzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmNsb3NlKCkgLy8gdXNlIGNsb3NlIGZvciBmcyBzdHJlYW1zIHRvIGF2b2lkIGZkIGxlYWtzXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCkgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc0ZuKHN0cmVhbS5kZXN0cm95KSkgcmV0dXJuIHN0cmVhbS5kZXN0cm95KClcblxuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRXJyb3IoJ3N0cmVhbSB3YXMgZGVzdHJveWVkJykpXG4gIH1cbn1cblxudmFyIGNhbGwgPSBmdW5jdGlvbiAoZm4pIHtcbiAgZm4oKVxufVxuXG52YXIgcGlwZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKVxufVxuXG52YXIgcHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0cmVhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIHZhciBjYWxsYmFjayA9IGlzRm4oc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdIHx8IG5vb3ApICYmIHN0cmVhbXMucG9wKCkgfHwgbm9vcFxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXVxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ3B1bXAgcmVxdWlyZXMgdHdvIHN0cmVhbXMgcGVyIG1pbmltdW0nKVxuXG4gIHZhciBlcnJvclxuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxXG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMFxuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVyclxuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKVxuICAgICAgaWYgKHJlYWRpbmcpIHJldHVyblxuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKVxuICAgICAgY2FsbGJhY2soZXJyb3IpXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwdW1wXG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJ2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gIHZhciBvZmZzZXQgPSAwXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gbGlzdC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGggLSBvZmZzZXRcbiAgICB2YXIgaSA9IChNYXRoLnJhbmRvbSgpICogbGVuKSB8IDBcbiAgICB2YXIgZWwgPSBsaXN0W29mZnNldCArIGldXG5cbiAgICB2YXIgdG1wID0gbGlzdFtvZmZzZXRdXG4gICAgbGlzdFtvZmZzZXRdID0gZWxcbiAgICBsaXN0W29mZnNldCArIGldID0gdG1wXG4gICAgb2Zmc2V0KytcblxuICAgIHJldHVybiBlbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXRlcmF0ZVxuIiwiLypcbkluc3RhbmNlIG9mIHdyaXRhYmxlIHN0cmVhbS5cblxuY2FsbCAuZ2V0KGxlbmd0aCkgb3IgLmRpc2NhcmQobGVuZ3RoKSB0byBnZXQgYSBzdHJlYW0gKHJlbGF0aXZlIHRvIHRoZSBsYXN0IGVuZClcblxuZW1pdHMgJ3N0YWxsZWQnIG9uY2UgZXZlcnl0aGluZyBpcyB3cml0dGVuXG5cblxuKi9cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlU2xpY2VTdHJlYW1cblxuaW5oZXJpdHMoUmFuZ2VTbGljZVN0cmVhbSwgc3RyZWFtLldyaXRhYmxlKVxuXG5mdW5jdGlvbiBSYW5nZVNsaWNlU3RyZWFtIChvZmZzZXQpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICghKHNlbGYgaW5zdGFuY2VvZiBSYW5nZVNsaWNlU3RyZWFtKSkgcmV0dXJuIG5ldyBSYW5nZVNsaWNlU3RyZWFtKG9mZnNldClcblx0c3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG5cdHNlbGYuX3F1ZXVlID0gW11cblx0c2VsZi5fcG9zaXRpb24gPSBvZmZzZXQgfHwgMFxuXHRzZWxmLl9jYiA9IG51bGxcblx0c2VsZi5fYnVmZmVyID0gbnVsbFxuXHRzZWxmLl9vdXQgPSBudWxsXG59XG5cblJhbmdlU2xpY2VTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciBkcmFpbmVkID0gdHJ1ZVxuXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0aWYgKHNlbGYuZGVzdHJveWVkKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvLyBXYWl0IGZvciBtb3JlIHF1ZXVlIGVudHJpZXNcblx0XHRpZiAoc2VsZi5fcXVldWUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRzZWxmLl9idWZmZXIgPSBjaHVua1xuXHRcdFx0c2VsZi5fY2IgPSBjYlxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0c2VsZi5fYnVmZmVyID0gbnVsbFxuXHRcdHZhciBjdXJyUmFuZ2UgPSBzZWxmLl9xdWV1ZVswXVxuXHRcdC8vIFJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiBjaHVuaywgd2hhdCBkYXRhIGRvIHdlIG5lZWQ/XG5cdFx0dmFyIHdyaXRlU3RhcnQgPSBNYXRoLm1heChjdXJyUmFuZ2Uuc3RhcnQgLSBzZWxmLl9wb3NpdGlvbiwgMClcblx0XHR2YXIgd3JpdGVFbmQgPSBjdXJyUmFuZ2UuZW5kIC0gc2VsZi5fcG9zaXRpb25cblxuXHRcdC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdGhyb3cgaXQgYWxsIGF3YXlcblx0XHRpZiAod3JpdGVTdGFydCA+PSBjaHVuay5sZW5ndGgpIHtcblx0XHRcdHNlbGYuX3Bvc2l0aW9uICs9IGNodW5rLmxlbmd0aFxuXHRcdFx0cmV0dXJuIGNiKG51bGwpXG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgbmVlZCB0byB1c2UgaXQgYWxsXG5cdFx0dmFyIHRvV3JpdGVcblx0XHRpZiAod3JpdGVFbmQgPiBjaHVuay5sZW5ndGgpIHtcblx0XHRcdHNlbGYuX3Bvc2l0aW9uICs9IGNodW5rLmxlbmd0aFxuXHRcdFx0aWYgKHdyaXRlU3RhcnQgPT09IDApIHtcblx0XHRcdFx0dG9Xcml0ZSA9IGNodW5rXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b1dyaXRlID0gY2h1bmsuc2xpY2Uod3JpdGVTdGFydClcblx0XHRcdH1cblx0XHRcdGRyYWluZWQgPSBjdXJyUmFuZ2Uuc3RyZWFtLndyaXRlKHRvV3JpdGUpICYmIGRyYWluZWRcblx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0c2VsZi5fcG9zaXRpb24gKz0gd3JpdGVFbmRcblx0XHRpZiAod3JpdGVTdGFydCA9PT0gMCAmJiB3cml0ZUVuZCA9PT0gY2h1bmsubGVuZ3RoKSB7XG5cdFx0XHR0b1dyaXRlID0gY2h1bmtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9Xcml0ZSA9IGNodW5rLnNsaWNlKHdyaXRlU3RhcnQsIHdyaXRlRW5kKVxuXHRcdH1cblx0XHRkcmFpbmVkID0gY3VyclJhbmdlLnN0cmVhbS53cml0ZSh0b1dyaXRlKSAmJiBkcmFpbmVkXG5cdFx0aWYgKGN1cnJSYW5nZS5sYXN0KSB7XG5cdFx0XHRjdXJyUmFuZ2Uuc3RyZWFtLmVuZCgpXG5cdFx0fVxuXHRcdGNodW5rID0gY2h1bmsuc2xpY2Uod3JpdGVFbmQpXG5cdFx0c2VsZi5fcXVldWUuc2hpZnQoKVxuXHR9XG5cblx0aWYgKGRyYWluZWQpIHtcblx0XHRjYihudWxsKVxuXHR9IGVsc2Uge1xuXHRcdGN1cnJSYW5nZS5zdHJlYW0ub25jZSgnZHJhaW4nLCBjYi5iaW5kKG51bGwsIG51bGwpKVxuXHR9XG59XG5cblJhbmdlU2xpY2VTdHJlYW0ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHJhbmdlcykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBudWxsXG5cblx0aWYgKCEocmFuZ2VzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0cmFuZ2VzID0gW3Jhbmdlc11cblx0fVxuXG5cdHZhciBzdHIgPSBuZXcgc3RyZWFtLlBhc3NUaHJvdWdoKClcblxuXHRyYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UsIGkpIHtcblx0XHRzZWxmLl9xdWV1ZS5wdXNoKHtcblx0XHRcdHN0YXJ0OiByYW5nZS5zdGFydCxcblx0XHRcdGVuZDogcmFuZ2UuZW5kLFxuXHRcdFx0c3RyZWFtOiBzdHIsXG5cdFx0XHRsYXN0OiBpID09PSAocmFuZ2VzLmxlbmd0aCAtIDEpXG5cdFx0fSlcblx0fSlcblx0aWYgKHNlbGYuX2J1ZmZlcikge1xuXHRcdHNlbGYuX3dyaXRlKHNlbGYuX2J1ZmZlciwgbnVsbCwgc2VsZi5fY2IpXG5cdH1cblxuXHRyZXR1cm4gc3RyXG59XG5cblJhbmdlU2xpY2VTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXHRzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuXHRpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxufVxuIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn0iLCIvLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xuICB9IGNhdGNoIChfKSB7fSBmaW5hbGx5IHtcbiAgICBpZiAoIVN0cmVhbSkgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICB9XG59KSgpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGhhc1ByZXBlbmRMaXN0ZW5lciA9IHR5cGVvZiBFRS5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIGlmIChoYXNQcmVwZW5kTGlzdGVuZXIpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlXG4gIC8vIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHMgdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zXG4gIC8vIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZSB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbFxuICAvLyBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMCkgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcbiAgICAgIGRlc3RzW19pXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24gKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHJldCA9IG51bGw7ZWxzZSBpZiAob2JqZWN0TW9kZSkgcmV0ID0gbGlzdC5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSkgcmV0ID0gbGlzdC5qb2luKCcnKTtlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0ID0gbGlzdFswXTtlbHNlIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSkgcmV0ID0gJyc7ZWxzZSByZXQgPSBidWZmZXJTaGltLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBfYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBfYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpIHJldCArPSBfYnVmLnNsaWNlKDAsIGNweSk7ZWxzZSBfYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBfYnVmLmxlbmd0aCkgbGlzdFswXSA9IF9idWYuc2xpY2UoY3B5KTtlbHNlIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVHZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn0iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblxuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xufVxuIiwiZXhwb3J0cy5yZW5kZXIgPSByZW5kZXJcbmV4cG9ydHMuYXBwZW5kID0gYXBwZW5kXG52YXIgbWltZSA9IGV4cG9ydHMubWltZSA9IHJlcXVpcmUoJy4vbGliL21pbWUuanNvbicpXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3JlbmRlci1tZWRpYScpXG52YXIgaXNBc2NpaSA9IHJlcXVpcmUoJ2lzLWFzY2lpJylcbnZhciBNZWRpYUVsZW1lbnRXcmFwcGVyID0gcmVxdWlyZSgnbWVkaWFzb3VyY2UnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBzdHJlYW1Ub0Jsb2JVUkwgPSByZXF1aXJlKCdzdHJlYW0tdG8tYmxvYi11cmwnKVxudmFyIHZpZGVvc3RyZWFtID0gcmVxdWlyZSgndmlkZW9zdHJlYW0nKVxuXG52YXIgVklERU9TVFJFQU1fRVhUUyA9IFsgJy5tcDQnLCAnLm00dicsICcubTRhJyBdXG5cbnZhciBNRURJQVNPVVJDRV9WSURFT19FWFRTID0gWyAnLm1wNCcsICcubTR2JywgJy53ZWJtJywgJy5ta3YnIF1cbnZhciBNRURJQVNPVVJDRV9BVURJT19FWFRTID0gWyAnLm00YScsICcubXAzJyBdXG52YXIgTUVESUFTT1VSQ0VfRVhUUyA9IE1FRElBU09VUkNFX1ZJREVPX0VYVFMuY29uY2F0KE1FRElBU09VUkNFX0FVRElPX0VYVFMpXG5cbnZhciBBVURJT19FWFRTID0gWyAnLndhdicsICcuYWFjJywgJy5vZ2cnLCAnLm9nYScgXVxudmFyIElNQUdFX0VYVFMgPSBbICcuanBnJywgJy5qcGVnJywgJy5wbmcnLCAnLmdpZicsICcuYm1wJyBdXG52YXIgSUZSQU1FX0VYVFMgPSBbICcuY3NzJywgJy5odG1sJywgJy5qcycsICcubWQnLCAnLnBkZicsICcudHh0JyBdXG5cbnZhciBNZWRpYVNvdXJjZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NZWRpYVNvdXJjZVxuXG5mdW5jdGlvbiByZW5kZXIgKGZpbGUsIGVsZW0sIGNiKSB7XG4gIHZhbGlkYXRlRmlsZShmaWxlKVxuICBpZiAodHlwZW9mIGVsZW0gPT09ICdzdHJpbmcnKSBlbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtKVxuXG4gIHJlbmRlck1lZGlhKGZpbGUsIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgaWYgKGVsZW0ubm9kZU5hbWUgIT09IHRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUoZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCByZW5kZXIgXCInICsgZXh0bmFtZSArICdcIiBpbnNpZGUgYSBcIicgK1xuICAgICAgICBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKyAnXCIgZWxlbWVudCwgZXhwZWN0ZWQgXCInICsgdGFnTmFtZSArICdcIidcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbVxuICB9LCBjYilcbn1cblxuZnVuY3Rpb24gYXBwZW5kIChmaWxlLCByb290RWxlbSwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBmdW5jdGlvbiAoKSB7fVxuICB2YWxpZGF0ZUZpbGUoZmlsZSlcbiAgaWYgKHR5cGVvZiByb290RWxlbSA9PT0gJ3N0cmluZycpIHJvb3RFbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihyb290RWxlbSlcblxuICBpZiAocm9vdEVsZW0gJiYgKHJvb3RFbGVtLm5vZGVOYW1lID09PSAnVklERU8nIHx8IHJvb3RFbGVtLm5vZGVOYW1lID09PSAnQVVESU8nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHZpZGVvL2F1ZGlvIG5vZGUgYXJndW1lbnQuIEFyZ3VtZW50IG11c3QgYmUgcm9vdCBlbGVtZW50IHRoYXQgJyArXG4gICAgICAndmlkZW8vYXVkaW8gdGFnIHdpbGwgYmUgYXBwZW5kZWQgdG8uJ1xuICAgIClcbiAgfVxuXG4gIHJlbmRlck1lZGlhKGZpbGUsIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgaWYgKHRhZ05hbWUgPT09ICd2aWRlbycgfHwgdGFnTmFtZSA9PT0gJ2F1ZGlvJykgcmV0dXJuIGNyZWF0ZU1lZGlhKHRhZ05hbWUpXG4gICAgZWxzZSByZXR1cm4gY3JlYXRlRWxlbSh0YWdOYW1lKVxuICB9LCBmdW5jdGlvbiAoZXJyLCBlbGVtKSB7XG4gICAgaWYgKGVyciAmJiBlbGVtKSBlbGVtLnJlbW92ZSgpXG4gICAgY2IoZXJyLCBlbGVtKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1lZGlhICh0YWdOYW1lKSB7XG4gICAgdmFyIGVsZW0gPSBjcmVhdGVFbGVtKHRhZ05hbWUpXG4gICAgZWxlbS5jb250cm9scyA9IHRydWVcbiAgICBlbGVtLmF1dG9wbGF5ID0gdHJ1ZVxuICAgIHJvb3RFbGVtLmFwcGVuZENoaWxkKGVsZW0pXG4gICAgcmV0dXJuIGVsZW1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW0gKHRhZ05hbWUpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcbiAgICByb290RWxlbS5hcHBlbmRDaGlsZChlbGVtKVxuICAgIHJldHVybiBlbGVtXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVkaWEgKGZpbGUsIGdldEVsZW0sIGNiKSB7XG4gIGlmICghY2IpIGNiID0gZnVuY3Rpb24gKCkge31cbiAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUoZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpXG4gIHZhciBjdXJyZW50VGltZSA9IDBcbiAgdmFyIGVsZW1cblxuICBpZiAoTUVESUFTT1VSQ0VfRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDApIHtcbiAgICByZW5kZXJNZWRpYVNvdXJjZSgpXG4gIH0gZWxzZSBpZiAoQVVESU9fRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDApIHtcbiAgICByZW5kZXJBdWRpbygpXG4gIH0gZWxzZSBpZiAoSU1BR0VfRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDApIHtcbiAgICByZW5kZXJJbWFnZSgpXG4gIH0gZWxzZSBpZiAoSUZSQU1FX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgcmVuZGVySWZyYW1lKClcbiAgfSBlbHNlIHtcbiAgICB0cnlSZW5kZXJJZnJhbWUoKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTWVkaWFTb3VyY2UgKCkge1xuICAgIHZhciB0YWdOYW1lID0gTUVESUFTT1VSQ0VfVklERU9fRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDAgPyAndmlkZW8nIDogJ2F1ZGlvJ1xuXG4gICAgaWYgKE1lZGlhU291cmNlKSB7XG4gICAgICBpZiAoVklERU9TVFJFQU1fRVhUUy5pbmRleE9mKGV4dG5hbWUpID49IDApIHtcbiAgICAgICAgdXNlVmlkZW9zdHJlYW0oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXNlTWVkaWFTb3VyY2UoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1c2VCbG9iVVJMKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1c2VWaWRlb3N0cmVhbSAoKSB7XG4gICAgICBkZWJ1ZygnVXNlIGB2aWRlb3N0cmVhbWAgcGFja2FnZSBmb3IgJyArIGZpbGUubmFtZSlcbiAgICAgIHByZXBhcmVFbGVtKClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYWxsYmFja1RvTWVkaWFTb3VyY2UpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuICAgICAgdmlkZW9zdHJlYW0oZmlsZSwgZWxlbSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1c2VNZWRpYVNvdXJjZSAoKSB7XG4gICAgICBkZWJ1ZygnVXNlIE1lZGlhU291cmNlIEFQSSBmb3IgJyArIGZpbGUubmFtZSlcbiAgICAgIHByZXBhcmVFbGVtKClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYWxsYmFja1RvQmxvYlVSTClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0Jywgb25Mb2FkU3RhcnQpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXkpXG5cbiAgICAgIHZhciB3cmFwcGVyID0gbmV3IE1lZGlhRWxlbWVudFdyYXBwZXIoZWxlbSlcbiAgICAgIHZhciB3cml0YWJsZSA9IHdyYXBwZXIuY3JlYXRlV3JpdGVTdHJlYW0oZ2V0Q29kZWMoZmlsZS5uYW1lKSlcbiAgICAgIGZpbGUuY3JlYXRlUmVhZFN0cmVhbSgpLnBpcGUod3JpdGFibGUpXG5cbiAgICAgIGlmIChjdXJyZW50VGltZSkgZWxlbS5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXNlQmxvYlVSTCAoKSB7XG4gICAgICBkZWJ1ZygnVXNlIEJsb2IgVVJMIGZvciAnICsgZmlsZS5uYW1lKVxuICAgICAgcHJlcGFyZUVsZW0oKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZhdGFsRXJyb3IpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuICAgICAgZ2V0QmxvYlVSTChmaWxlLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGZhdGFsRXJyb3IoZXJyKVxuICAgICAgICBlbGVtLnNyYyA9IHVybFxuICAgICAgICBpZiAoY3VycmVudFRpbWUpIGVsZW0uY3VycmVudFRpbWUgPSBjdXJyZW50VGltZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWxsYmFja1RvTWVkaWFTb3VyY2UgKGVycikge1xuICAgICAgZGVidWcoJ3ZpZGVvc3RyZWFtIGVycm9yOiBmYWxsYmFjayB0byBNZWRpYVNvdXJjZSBBUEk6ICVvJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGZhbGxiYWNrVG9NZWRpYVNvdXJjZSlcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcblxuICAgICAgdXNlTWVkaWFTb3VyY2UoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhbGxiYWNrVG9CbG9iVVJMIChlcnIpIHtcbiAgICAgIGRlYnVnKCdNZWRpYVNvdXJjZSBBUEkgZXJyb3I6IGZhbGxiYWNrIHRvIEJsb2IgVVJMOiAlbycsIGVyci5tZXNzYWdlIHx8IGVycilcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYWxsYmFja1RvQmxvYlVSTClcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcblxuICAgICAgdXNlQmxvYlVSTCgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUVsZW0gKCkge1xuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIGVsZW0gPSBnZXRFbGVtKHRhZ05hbWUpXG5cbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjdXJyZW50VGltZSA9IGVsZW0uY3VycmVudFRpbWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJBdWRpbyAoKSB7XG4gICAgZWxlbSA9IGdldEVsZW0oJ2F1ZGlvJylcbiAgICBnZXRCbG9iVVJMKGZpbGUsIGZ1bmN0aW9uIChlcnIsIHVybCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGZhdGFsRXJyb3IoZXJyKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZhdGFsRXJyb3IpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuICAgICAgZWxlbS5zcmMgPSB1cmxcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gb25Mb2FkU3RhcnQgKCkge1xuICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0Jywgb25Mb2FkU3RhcnQpXG4gICAgZWxlbS5wbGF5KClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2FuUGxheSAoKSB7XG4gICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuICAgIGNiKG51bGwsIGVsZW0pXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJJbWFnZSAoKSB7XG4gICAgZWxlbSA9IGdldEVsZW0oJ2ltZycpXG4gICAgZ2V0QmxvYlVSTChmaWxlLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBmYXRhbEVycm9yKGVycilcbiAgICAgIGVsZW0uc3JjID0gdXJsXG4gICAgICBlbGVtLmFsdCA9IGZpbGUubmFtZVxuICAgICAgY2IobnVsbCwgZWxlbSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVySWZyYW1lICgpIHtcbiAgICBlbGVtID0gZ2V0RWxlbSgnaWZyYW1lJylcblxuICAgIGdldEJsb2JVUkwoZmlsZSwgZnVuY3Rpb24gKGVyciwgdXJsKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZmF0YWxFcnJvcihlcnIpXG4gICAgICBlbGVtLnNyYyA9IHVybFxuICAgICAgaWYgKGV4dG5hbWUgIT09ICcucGRmJykgZWxlbS5zYW5kYm94ID0gJ2FsbG93LWZvcm1zIGFsbG93LXNjcmlwdHMnXG4gICAgICBjYihudWxsLCBlbGVtKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiB0cnlSZW5kZXJJZnJhbWUgKCkge1xuICAgIGRlYnVnKCdVbmtub3duIGZpbGUgZXh0ZW5zaW9uIFwiJXNcIiAtIHdpbGwgYXR0ZW1wdCB0byByZW5kZXIgaW50byBpZnJhbWUnLCBleHRuYW1lKVxuXG4gICAgdmFyIHN0ciA9ICcnXG4gICAgZmlsZS5jcmVhdGVSZWFkU3RyZWFtKHsgc3RhcnQ6IDAsIGVuZDogMTAwMCB9KVxuICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBzdHIgKz0gY2h1bmtcbiAgICAgIH0pXG4gICAgICAub24oJ2VuZCcsIGRvbmUpXG4gICAgICAub24oJ2Vycm9yJywgY2IpXG5cbiAgICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICAgIGlmIChpc0FzY2lpKHN0cikpIHtcbiAgICAgICAgZGVidWcoJ0ZpbGUgZXh0ZW5zaW9uIFwiJXNcIiBhcHBlYXJzIGFzY2lpLCBzbyB3aWxsIHJlbmRlci4nLCBleHRuYW1lKVxuICAgICAgICByZW5kZXJJZnJhbWUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ0ZpbGUgZXh0ZW5zaW9uIFwiJXNcIiBhcHBlYXJzIG5vbi1hc2NpaSwgd2lsbCBub3QgcmVuZGVyLicsIGV4dG5hbWUpXG4gICAgICAgIGNiKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZmlsZSB0eXBlIFwiJyArIGV4dG5hbWUgKyAnXCI6IENhbm5vdCBhcHBlbmQgdG8gRE9NJykpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmF0YWxFcnJvciAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSAnRXJyb3IgcmVuZGVyaW5nIGZpbGUgXCInICsgZmlsZS5uYW1lICsgJ1wiOiAnICsgZXJyLm1lc3NhZ2VcbiAgICBkZWJ1ZyhlcnIubWVzc2FnZSlcbiAgICBjYihlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmxvYlVSTCAoZmlsZSwgY2IpIHtcbiAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUoZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpXG4gIHN0cmVhbVRvQmxvYlVSTChmaWxlLmNyZWF0ZVJlYWRTdHJlYW0oKSwgbWltZVtleHRuYW1lXSwgY2IpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRmlsZSAoZmlsZSkge1xuICBpZiAoZmlsZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpXG4gIH1cbiAgaWYgKHR5cGVvZiBmaWxlLm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9yIGludmFsaWQgZmlsZS5uYW1lIHByb3BlcnR5JylcbiAgfVxuICBpZiAodHlwZW9mIGZpbGUuY3JlYXRlUmVhZFN0cmVhbSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIGZpbGUuY3JlYXRlUmVhZFN0cmVhbSBwcm9wZXJ0eScpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29kZWMgKG5hbWUpIHtcbiAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUobmFtZSkudG9Mb3dlckNhc2UoKVxuICByZXR1cm4ge1xuICAgICcubTRhJzogJ2F1ZGlvL21wNDsgY29kZWNzPVwibXA0YS40MC41XCInLFxuICAgICcubTR2JzogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS42NDAwMjksIG1wNGEuNDAuNVwiJyxcbiAgICAnLm1rdic6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJhdmMxLjY0MDAyOSwgbXA0YS40MC41XCInLFxuICAgICcubXAzJzogJ2F1ZGlvL21wZWcnLFxuICAgICcubXA0JzogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS42NDAwMjksIG1wNGEuNDAuNVwiJyxcbiAgICAnLndlYm0nOiAndmlkZW8vd2VibTsgY29kZWNzPVwidm9yYmlzLCB2cDhcIidcbiAgfVtleHRuYW1lXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIi4zZ3BcIjogXCJ2aWRlby8zZ3BwXCIsXG4gIFwiLmFhY1wiOiBcImF1ZGlvL2FhY1wiLFxuICBcIi5haWZcIjogXCJhdWRpby94LWFpZmZcIixcbiAgXCIuYWlmZlwiOiBcImF1ZGlvL3gtYWlmZlwiLFxuICBcIi5hdG9tXCI6IFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIixcbiAgXCIuYXZpXCI6IFwidmlkZW8veC1tc3ZpZGVvXCIsXG4gIFwiLmJtcFwiOiBcImltYWdlL2JtcFwiLFxuICBcIi5iejJcIjogXCJhcHBsaWNhdGlvbi94LWJ6aXAyXCIsXG4gIFwiLmNvbmZcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiLmNzc1wiOiBcInRleHQvY3NzXCIsXG4gIFwiLmNzdlwiOiBcInRleHQvY3N2XCIsXG4gIFwiLmRpZmZcIjogXCJ0ZXh0L3gtZGlmZlwiLFxuICBcIi5kb2NcIjogXCJhcHBsaWNhdGlvbi9tc3dvcmRcIixcbiAgXCIuZmx2XCI6IFwidmlkZW8veC1mbHZcIixcbiAgXCIuZ2lmXCI6IFwiaW1hZ2UvZ2lmXCIsXG4gIFwiLmd6XCI6IFwiYXBwbGljYXRpb24veC1nemlwXCIsXG4gIFwiLmh0bVwiOiBcInRleHQvaHRtbFwiLFxuICBcIi5odG1sXCI6IFwidGV4dC9odG1sXCIsXG4gIFwiLmljb1wiOiBcImltYWdlL3ZuZC5taWNyb3NvZnQuaWNvblwiLFxuICBcIi5pY3NcIjogXCJ0ZXh0L2NhbGVuZGFyXCIsXG4gIFwiLmlzb1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIi5qYXJcIjogXCJhcHBsaWNhdGlvbi9qYXZhLWFyY2hpdmVcIixcbiAgXCIuanBlZ1wiOiBcImltYWdlL2pwZWdcIixcbiAgXCIuanBnXCI6IFwiaW1hZ2UvanBlZ1wiLFxuICBcIi5qc1wiOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIixcbiAgXCIuanNvblwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgXCIubGVzc1wiOiBcInRleHQvY3NzXCIsXG4gIFwiLmxvZ1wiOiBcInRleHQvcGxhaW5cIixcbiAgXCIubTN1XCI6IFwiYXVkaW8veC1tcGVndXJsXCIsXG4gIFwiLm00YVwiOiBcImF1ZGlvL21wNFwiLFxuICBcIi5tNHZcIjogXCJ2aWRlby9tcDRcIixcbiAgXCIubWFuaWZlc3RcIjogXCJ0ZXh0L2NhY2hlLW1hbmlmZXN0XCIsXG4gIFwiLm1hcmtkb3duXCI6IFwidGV4dC94LW1hcmtkb3duXCIsXG4gIFwiLm1hdGhtbFwiOiBcImFwcGxpY2F0aW9uL21hdGhtbCt4bWxcIixcbiAgXCIubWRcIjogXCJ0ZXh0L3gtbWFya2Rvd25cIixcbiAgXCIubWlkXCI6IFwiYXVkaW8vbWlkaVwiLFxuICBcIi5taWRpXCI6IFwiYXVkaW8vbWlkaVwiLFxuICBcIi5tb3ZcIjogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgXCIubXAzXCI6IFwiYXVkaW8vbXBlZ1wiLFxuICBcIi5tcDRcIjogXCJ2aWRlby9tcDRcIixcbiAgXCIubXA0dlwiOiBcInZpZGVvL21wNFwiLFxuICBcIi5tcGVnXCI6IFwidmlkZW8vbXBlZ1wiLFxuICBcIi5tcGdcIjogXCJ2aWRlby9tcGVnXCIsXG4gIFwiLm9kcFwiOiBcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uXCIsXG4gIFwiLm9kc1wiOiBcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXRcIixcbiAgXCIub2R0XCI6IFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0XCIsXG4gIFwiLm9nYVwiOiBcImF1ZGlvL29nZ1wiLFxuICBcIi5vZ2dcIjogXCJhcHBsaWNhdGlvbi9vZ2dcIixcbiAgXCIucGRmXCI6IFwiYXBwbGljYXRpb24vcGRmXCIsXG4gIFwiLnBuZ1wiOiBcImltYWdlL3BuZ1wiLFxuICBcIi5wcHNcIjogXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludFwiLFxuICBcIi5wcHRcIjogXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludFwiLFxuICBcIi5wc1wiOiBcImFwcGxpY2F0aW9uL3Bvc3RzY3JpcHRcIixcbiAgXCIucHNkXCI6IFwiaW1hZ2Uvdm5kLmFkb2JlLnBob3Rvc2hvcFwiLFxuICBcIi5xdFwiOiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBcIi5yYXJcIjogXCJhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkXCIsXG4gIFwiLnJkZlwiOiBcImFwcGxpY2F0aW9uL3JkZit4bWxcIixcbiAgXCIucnNzXCI6IFwiYXBwbGljYXRpb24vcnNzK3htbFwiLFxuICBcIi5ydGZcIjogXCJhcHBsaWNhdGlvbi9ydGZcIixcbiAgXCIuc3ZnXCI6IFwiaW1hZ2Uvc3ZnK3htbFwiLFxuICBcIi5zdmd6XCI6IFwiaW1hZ2Uvc3ZnK3htbFwiLFxuICBcIi5zd2ZcIjogXCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiLFxuICBcIi50YXJcIjogXCJhcHBsaWNhdGlvbi94LXRhclwiLFxuICBcIi50YnpcIjogXCJhcHBsaWNhdGlvbi94LWJ6aXAtY29tcHJlc3NlZC10YXJcIixcbiAgXCIudGV4dFwiOiBcInRleHQvcGxhaW5cIixcbiAgXCIudGlmXCI6IFwiaW1hZ2UvdGlmZlwiLFxuICBcIi50aWZmXCI6IFwiaW1hZ2UvdGlmZlwiLFxuICBcIi50b3JyZW50XCI6IFwiYXBwbGljYXRpb24veC1iaXR0b3JyZW50XCIsXG4gIFwiLnR0ZlwiOiBcImFwcGxpY2F0aW9uL3gtZm9udC10dGZcIixcbiAgXCIudHh0XCI6IFwidGV4dC9wbGFpblwiLFxuICBcIi53YXZcIjogXCJhdWRpby93YXZcIixcbiAgXCIud2VibVwiOiBcInZpZGVvL3dlYm1cIixcbiAgXCIud21hXCI6IFwiYXVkaW8veC1tcy13bWFcIixcbiAgXCIud212XCI6IFwidmlkZW8veC1tcy13bXZcIixcbiAgXCIueGxzXCI6IFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsXCIsXG4gIFwiLnhtbFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcIi55YW1sXCI6IFwidGV4dC95YW1sXCIsXG4gIFwiLnltbFwiOiBcInRleHQveWFtbFwiLFxuICBcIi56aXBcIjogXCJhcHBsaWNhdGlvbi96aXBcIlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFza3MsIGxpbWl0LCBjYikge1xuICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpXG4gIHZhciByZXN1bHRzLCBsZW4sIHBlbmRpbmcsIGtleXMsIGlzRXJyb3JlZFxuICB2YXIgaXNTeW5jID0gdHJ1ZVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRhc2tzKSkge1xuICAgIHJlc3VsdHMgPSBbXVxuICAgIHBlbmRpbmcgPSBsZW4gPSB0YXNrcy5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModGFza3MpXG4gICAgcmVzdWx0cyA9IHt9XG4gICAgcGVuZGluZyA9IGxlbiA9IGtleXMubGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgaWYgKGNiKSBjYihlcnIsIHJlc3VsdHMpXG4gICAgICBjYiA9IG51bGxcbiAgICB9XG4gICAgaWYgKGlzU3luYykgcHJvY2Vzcy5uZXh0VGljayhlbmQpXG4gICAgZWxzZSBlbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gZWFjaCAoaSwgZXJyLCByZXN1bHQpIHtcbiAgICByZXN1bHRzW2ldID0gcmVzdWx0XG4gICAgaWYgKGVycikgaXNFcnJvcmVkID0gdHJ1ZVxuICAgIGlmICgtLXBlbmRpbmcgPT09IDAgfHwgZXJyKSB7XG4gICAgICBkb25lKGVycilcbiAgICB9IGVsc2UgaWYgKCFpc0Vycm9yZWQgJiYgbmV4dCA8IGxlbikge1xuICAgICAgdmFyIGtleVxuICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAga2V5ID0ga2V5c1tuZXh0XVxuICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgdGFza3Nba2V5XShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChrZXksIGVyciwgcmVzdWx0KSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gbmV4dFxuICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgdGFza3Nba2V5XShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChrZXksIGVyciwgcmVzdWx0KSB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0ID0gbGltaXRcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgLy8gZW1wdHlcbiAgICBkb25lKG51bGwpXG4gIH0gZWxzZSBpZiAoa2V5cykge1xuICAgIC8vIG9iamVjdFxuICAgIGtleXMuc29tZShmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICB0YXNrc1trZXldKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgeyBlYWNoKGtleSwgZXJyLCByZXN1bHQpIH0pXG4gICAgICBpZiAoaSA9PT0gbGltaXQgLSAxKSByZXR1cm4gdHJ1ZSAvLyBlYXJseSByZXR1cm5cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGFycmF5XG4gICAgdGFza3Muc29tZShmdW5jdGlvbiAodGFzaywgaSkge1xuICAgICAgdGFzayhmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChpLCBlcnIsIHJlc3VsdCkgfSlcbiAgICAgIGlmIChpID09PSBsaW1pdCAtIDEpIHJldHVybiB0cnVlIC8vIGVhcmx5IHJldHVyblxuICAgIH0pXG4gIH1cblxuICBpc1N5bmMgPSBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFza3MsIGNiKSB7XG4gIHZhciByZXN1bHRzLCBwZW5kaW5nLCBrZXlzXG4gIHZhciBpc1N5bmMgPSB0cnVlXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFza3MpKSB7XG4gICAgcmVzdWx0cyA9IFtdXG4gICAgcGVuZGluZyA9IHRhc2tzLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh0YXNrcylcbiAgICByZXN1bHRzID0ge31cbiAgICBwZW5kaW5nID0ga2V5cy5sZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICBpZiAoY2IpIGNiKGVyciwgcmVzdWx0cylcbiAgICAgIGNiID0gbnVsbFxuICAgIH1cbiAgICBpZiAoaXNTeW5jKSBwcm9jZXNzLm5leHRUaWNrKGVuZClcbiAgICBlbHNlIGVuZCgpXG4gIH1cblxuICBmdW5jdGlvbiBlYWNoIChpLCBlcnIsIHJlc3VsdCkge1xuICAgIHJlc3VsdHNbaV0gPSByZXN1bHRcbiAgICBpZiAoLS1wZW5kaW5nID09PSAwIHx8IGVycikge1xuICAgICAgZG9uZShlcnIpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgLy8gZW1wdHlcbiAgICBkb25lKG51bGwpXG4gIH0gZWxzZSBpZiAoa2V5cykge1xuICAgIC8vIG9iamVjdFxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0YXNrc1trZXldKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgeyBlYWNoKGtleSwgZXJyLCByZXN1bHQpIH0pXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBhcnJheVxuICAgIHRhc2tzLmZvckVhY2goZnVuY3Rpb24gKHRhc2ssIGkpIHtcbiAgICAgIHRhc2soZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goaSwgZXJyLCByZXN1bHQpIH0pXG4gICAgfSlcbiAgfVxuXG4gIGlzU3luYyA9IGZhbHNlXG59XG4iLCIvKlxuICogUnVzaGEsIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSxcbiAqIGFzIGRlZmluZWQgaW4gRklQUyBQVUIgMTgwLTEsIHR1bmVkIGZvciBoaWdoIHBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgaW5wdXRzLlxuICogKGh0dHA6Ly9naXRodWIuY29tL3NyaWpzL3J1c2hhKVxuICpcbiAqIEluc3BpcmVkIGJ5IFBhdWwgSm9obnN0b25zIGltcGxlbWVudGF0aW9uIChodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1KS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgU2FtIFJpanMgKGh0dHA6Ly9hd2VzYW0uZGUpLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZSBhcyBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4gKiBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHV0aWwgPSB7XG4gICAgICAgICAgICBnZXREYXRhVHlwZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2J1ZmZlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndmlldyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Jsb2InO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAvLyBUaGUgUnVzaGEgb2JqZWN0IGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIGxvdy1sZXZlbCBSdXNoYUNvcmUuXG4gICAgLy8gSXQgcHJvdmlkZXMgbWVhbnMgb2YgY29udmVydGluZyBkaWZmZXJlbnQgaW5wdXRzIHRvIHRoZVxuICAgIC8vIGZvcm1hdCBhY2NlcHRlZCBieSBSdXNoYUNvcmUgYXMgd2VsbCBhcyBvdGhlciB1dGlsaXR5IG1ldGhvZHMuXG4gICAgZnVuY3Rpb24gUnVzaGEoY2h1bmtTaXplKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgLy8gUHJpdmF0ZSBvYmplY3Qgc3RydWN0dXJlLlxuICAgICAgICB2YXIgc2VsZiQyID0geyBmaWxsOiAwIH07XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIGJ1ZmZlciB0aGF0IHRoZSBzaGExIHJvdXRpbmUgdXNlc1xuICAgICAgICAvLyBpbmNsdWRpbmcgdGhlIHBhZGRpbmcuXG4gICAgICAgIHZhciBwYWRsZW4gPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgICAgICBmb3IgKGxlbiArPSA5OyBsZW4gJSA2NCA+IDA7IGxlbiArPSAxKTtcbiAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYWRaZXJvZXMgPSBmdW5jdGlvbiAoYmluLCBsZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZW4gPj4gMjsgaSA8IGJpbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBiaW5baV0gPSAwO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFkRGF0YSA9IGZ1bmN0aW9uIChiaW4sIGNodW5rTGVuLCBtc2dMZW4pIHtcbiAgICAgICAgICAgIGJpbltjaHVua0xlbiA+PiAyXSB8PSAxMjggPDwgMjQgLSAoY2h1bmtMZW4gJSA0IDw8IDMpO1xuICAgICAgICAgICAgYmluWygoY2h1bmtMZW4gPj4gMikgKyAyICYgfjE1KSArIDE0XSA9IG1zZ0xlbiA+PiAyOTtcbiAgICAgICAgICAgIGJpblsoKGNodW5rTGVuID4+IDIpICsgMiAmIH4xNSkgKyAxNV0gPSBtc2dMZW4gPDwgMztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29udmVydCBhIGJpbmFyeSBzdHJpbmcgYW5kIHdyaXRlIGl0IHRvIHRoZSBoZWFwLlxuICAgICAgICAvLyBBIGJpbmFyeSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gb25seSBjb250YWluIGNoYXIgY29kZXMgPCAyNTYuXG4gICAgICAgIHZhciBjb252U3RyID0gZnVuY3Rpb24gKEg4LCBIMzIsIHN0YXJ0LCBsZW4sIG9mZikge1xuICAgICAgICAgICAgdmFyIHN0ciA9IHRoaXMsIGksIG9tID0gb2ZmICUgNCwgbG0gPSBsZW4gJSA0LCBqID0gbGVuIC0gbG07XG4gICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9tKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAzIHwgMF0gPSBzdHIuY2hhckNvZGVBdChzdGFydCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAyIHwgMF0gPSBzdHIuY2hhckNvZGVBdChzdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMSB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyAyKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSBvbTsgaSA8IGo7IGkgPSBpICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICBIMzJbb2ZmICsgaSA+PiAyXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgaSkgPDwgMjQgfCBzdHIuY2hhckNvZGVBdChzdGFydCArIGkgKyAxKSA8PCAxNiB8IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgaSArIDIpIDw8IDggfCBzdHIuY2hhckNvZGVBdChzdGFydCArIGkgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAobG0pIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMSB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyBqICsgMik7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDIgfCAwXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgaiArIDEpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIEg4W29mZiArIGogKyAzIHwgMF0gPSBzdHIuY2hhckNvZGVBdChzdGFydCArIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDb252ZXJ0IGEgYnVmZmVyIG9yIGFycmF5IGFuZCB3cml0ZSBpdCB0byB0aGUgaGVhcC5cbiAgICAgICAgLy8gVGhlIGJ1ZmZlciBvciBhcnJheSBpcyBleHBlY3RlZCB0byBvbmx5IGNvbnRhaW4gZWxlbWVudHMgPCAyNTYuXG4gICAgICAgIHZhciBjb252QnVmID0gZnVuY3Rpb24gKEg4LCBIMzIsIHN0YXJ0LCBsZW4sIG9mZikge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IHRoaXMsIGksIG9tID0gb2ZmICUgNCwgbG0gPSBsZW4gJSA0LCBqID0gbGVuIC0gbG07XG4gICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9tKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAzIHwgMF0gPSBidWZbc3RhcnRdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMiB8IDBdID0gYnVmW3N0YXJ0ICsgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAxIHwgMF0gPSBidWZbc3RhcnQgKyAyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiB8IDBdID0gYnVmW3N0YXJ0ICsgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gNCAtIG9tOyBpIDwgajsgaSA9IGkgKz0gNCB8IDApIHtcbiAgICAgICAgICAgICAgICBIMzJbb2ZmICsgaSA+PiAyXSA9IGJ1ZltzdGFydCArIGldIDw8IDI0IHwgYnVmW3N0YXJ0ICsgaSArIDFdIDw8IDE2IHwgYnVmW3N0YXJ0ICsgaSArIDJdIDw8IDggfCBidWZbc3RhcnQgKyBpICsgM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGxtKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDEgfCAwXSA9IGJ1ZltzdGFydCArIGogKyAyXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMiB8IDBdID0gYnVmW3N0YXJ0ICsgaiArIDFdO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIEg4W29mZiArIGogKyAzIHwgMF0gPSBidWZbc3RhcnQgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnZCbG9iID0gZnVuY3Rpb24gKEg4LCBIMzIsIHN0YXJ0LCBsZW4sIG9mZikge1xuICAgICAgICAgICAgdmFyIGJsb2IgPSB0aGlzLCBpLCBvbSA9IG9mZiAlIDQsIGxtID0gbGVuICUgNCwgaiA9IGxlbiAtIGxtO1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iLnNsaWNlKHN0YXJ0LCBzdGFydCArIGxlbikpKTtcbiAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob20pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDMgfCAwXSA9IGJ1ZlswXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDIgfCAwXSA9IGJ1ZlsxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDEgfCAwXSA9IGJ1ZlsyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiB8IDBdID0gYnVmWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDQgLSBvbTsgaSA8IGo7IGkgPSBpICs9IDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgSDMyW29mZiArIGkgPj4gMl0gPSBidWZbaV0gPDwgMjQgfCBidWZbaSArIDFdIDw8IDE2IHwgYnVmW2kgKyAyXSA8PCA4IHwgYnVmW2kgKyAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAobG0pIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMSB8IDBdID0gYnVmW2ogKyAyXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMiB8IDBdID0gYnVmW2ogKyAxXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMyB8IDBdID0gYnVmW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udkZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodXRpbC5nZXREYXRhVHlwZShkYXRhKSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udlN0ci5iaW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb252QnVmLmJpbmQoZGF0YSk7XG4gICAgICAgICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb252QnVmLmJpbmQoZGF0YSk7XG4gICAgICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZCdWYuYmluZChuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgICAgICAgICBjYXNlICd2aWV3JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udkJ1Zi5iaW5kKG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZCbG9iLmJpbmQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzbGljZSA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodXRpbC5nZXREYXRhVHlwZShkYXRhKSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCk7XG4gICAgICAgICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCk7XG4gICAgICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgICAgIGNhc2UgJ3ZpZXcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmJ1ZmZlci5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDb252ZXJ0IGFuIEFycmF5QnVmZmVyIGludG8gaXRzIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgdmFyIGhleCA9IGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIGksIHgsIGhleF90YWIgPSAnMDEyMzQ1Njc4OWFiY2RlZicsIHJlcyA9IFtdLCBiaW5hcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSBiaW5hcnJheVtpXTtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBoZXhfdGFiLmNoYXJBdCh4ID4+IDQgJiAxNSkgKyBoZXhfdGFiLmNoYXJBdCh4ID4+IDAgJiAxNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLmpvaW4oJycpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2VpbEhlYXBTaXplID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIC8vIFRoZSBhc20uanMgc3BlYyBzYXlzOlxuICAgICAgICAgICAgLy8gVGhlIGhlYXAgb2JqZWN0J3MgYnl0ZUxlbmd0aCBtdXN0IGJlIGVpdGhlclxuICAgICAgICAgICAgLy8gMl5uIGZvciBuIGluIFsxMiwgMjQpIG9yIDJeMjQgKiBuIGZvciBuIOKJpSAxLlxuICAgICAgICAgICAgLy8gQWxzbywgYnl0ZUxlbmd0aHMgc21hbGxlciB0aGFuIDJeMTYgYXJlIGRlcHJlY2F0ZWQuXG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIC8vIElmIHYgaXMgc21hbGxlciB0aGFuIDJeMTYsIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBzb2x1dGlvblxuICAgICAgICAgICAgLy8gaXMgMl4xNi5cbiAgICAgICAgICAgIGlmICh2IDw9IDY1NTM2KVxuICAgICAgICAgICAgICAgIHJldHVybiA2NTUzNjtcbiAgICAgICAgICAgIC8vIElmIHYgPCAyXjI0LCB3ZSByb3VuZCB1cCB0byAyXm4sXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugcm91bmQgdXAgdG8gMl4yNCAqIG4uXG4gICAgICAgICAgICBpZiAodiA8IDE2Nzc3MjE2KSB7XG4gICAgICAgICAgICAgICAgZm9yIChwID0gMTsgcCA8IHY7IHAgPSBwIDw8IDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSAxNjc3NzIxNjsgcCA8IHY7IHAgKz0gMTY3NzcyMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcyB0byBhIG5ldyBjYXBhY2l0eS5cbiAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICAgICAgaWYgKHNpemUgJSA2NCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NodW5rIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDEyOCBiaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYkMi5tYXhDaHVua0xlbiA9IHNpemU7XG4gICAgICAgICAgICBzZWxmJDIucGFkTWF4Q2h1bmtMZW4gPSBwYWRsZW4oc2l6ZSk7XG4gICAgICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgaGVhcCBpcyB0aGUgc3VtIG9mOlxuICAgICAgICAgICAgLy8gMS4gVGhlIHBhZGRlZCBpbnB1dCBtZXNzYWdlIHNpemVcbiAgICAgICAgICAgIC8vIDIuIFRoZSBleHRlbmRlZCBzcGFjZSB0aGUgYWxnb3JpdGhtIG5lZWRzICgzMjAgYnl0ZSlcbiAgICAgICAgICAgIC8vIDMuIFRoZSAxNjAgYml0IHN0YXRlIHRoZSBhbGdvcml0bSB1c2VzXG4gICAgICAgICAgICBzZWxmJDIuaGVhcCA9IG5ldyBBcnJheUJ1ZmZlcihjZWlsSGVhcFNpemUoc2VsZiQyLnBhZE1heENodW5rTGVuICsgMzIwICsgMjApKTtcbiAgICAgICAgICAgIHNlbGYkMi5oMzIgPSBuZXcgSW50MzJBcnJheShzZWxmJDIuaGVhcCk7XG4gICAgICAgICAgICBzZWxmJDIuaDggPSBuZXcgSW50OEFycmF5KHNlbGYkMi5oZWFwKTtcbiAgICAgICAgICAgIHNlbGYkMi5jb3JlID0gbmV3IFJ1c2hhLl9jb3JlKHtcbiAgICAgICAgICAgICAgICBJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuICAgICAgICAgICAgICAgIERhdGFWaWV3OiBEYXRhVmlld1xuICAgICAgICAgICAgfSwge30sIHNlbGYkMi5oZWFwKTtcbiAgICAgICAgICAgIHNlbGYkMi5idWZmZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJaW5pdGlhbGl6ZXRoZSBkYXRhc3RydWN0dXJlcyBhY2NvcmRpbmdcbiAgICAgICAgLy8gdG8gYSBjaHVuayBzaXl6ZS5cbiAgICAgICAgaW5pdChjaHVua1NpemUgfHwgNjQgKiAxMDI0KTtcbiAgICAgICAgdmFyIGluaXRTdGF0ZSA9IGZ1bmN0aW9uIChoZWFwLCBwYWRNc2dMZW4pIHtcbiAgICAgICAgICAgIHZhciBpbyA9IG5ldyBJbnQzMkFycmF5KGhlYXAsIHBhZE1zZ0xlbiArIDMyMCwgNSk7XG4gICAgICAgICAgICBpb1swXSA9IDE3MzI1ODQxOTM7XG4gICAgICAgICAgICBpb1sxXSA9IC0yNzE3MzM4Nzk7XG4gICAgICAgICAgICBpb1syXSA9IC0xNzMyNTg0MTk0O1xuICAgICAgICAgICAgaW9bM10gPSAyNzE3MzM4Nzg7XG4gICAgICAgICAgICBpb1s0XSA9IC0xMDA5NTg5Nzc2O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFkQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmtMZW4sIG1zZ0xlbikge1xuICAgICAgICAgICAgdmFyIHBhZENodW5rTGVuID0gcGFkbGVuKGNodW5rTGVuKTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IEludDMyQXJyYXkoc2VsZiQyLmhlYXAsIDAsIHBhZENodW5rTGVuID4+IDIpO1xuICAgICAgICAgICAgcGFkWmVyb2VzKHZpZXcsIGNodW5rTGVuKTtcbiAgICAgICAgICAgIHBhZERhdGEodmlldywgY2h1bmtMZW4sIG1zZ0xlbik7XG4gICAgICAgICAgICByZXR1cm4gcGFkQ2h1bmtMZW47XG4gICAgICAgIH07XG4gICAgICAgIC8vIFdyaXRlIGRhdGEgdG8gdGhlIGhlYXAuXG4gICAgICAgIHZhciB3cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBjaHVua09mZnNldCwgY2h1bmtMZW4pIHtcbiAgICAgICAgICAgIGNvbnZGbihkYXRhKShzZWxmJDIuaDgsIHNlbGYkMi5oMzIsIGNodW5rT2Zmc2V0LCBjaHVua0xlbiwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluaXRpYWxpemUgYW5kIGNhbGwgdGhlIFJ1c2hhQ29yZSxcbiAgICAgICAgLy8gYXNzdW1pbmcgYW4gaW5wdXQgYnVmZmVyIG9mIGxlbmd0aCBsZW4gKiA0LlxuICAgICAgICB2YXIgY29yZUNhbGwgPSBmdW5jdGlvbiAoZGF0YSwgY2h1bmtPZmZzZXQsIGNodW5rTGVuLCBtc2dMZW4sIGZpbmFsaXplKSB7XG4gICAgICAgICAgICB2YXIgcGFkQ2h1bmtMZW4gPSBjaHVua0xlbjtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZSkge1xuICAgICAgICAgICAgICAgIHBhZENodW5rTGVuID0gcGFkQ2h1bmsoY2h1bmtMZW4sIG1zZ0xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZShkYXRhLCBjaHVua09mZnNldCwgY2h1bmtMZW4pO1xuICAgICAgICAgICAgc2VsZiQyLmNvcmUuaGFzaChwYWRDaHVua0xlbiwgc2VsZiQyLnBhZE1heENodW5rTGVuKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFJhd0RpZ2VzdCA9IGZ1bmN0aW9uIChoZWFwLCBwYWRNYXhDaHVua0xlbikge1xuICAgICAgICAgICAgdmFyIGlvID0gbmV3IEludDMyQXJyYXkoaGVhcCwgcGFkTWF4Q2h1bmtMZW4gKyAzMjAsIDUpO1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBJbnQzMkFycmF5KDUpO1xuICAgICAgICAgICAgdmFyIGFyciA9IG5ldyBEYXRhVmlldyhvdXQuYnVmZmVyKTtcbiAgICAgICAgICAgIGFyci5zZXRJbnQzMigwLCBpb1swXSwgZmFsc2UpO1xuICAgICAgICAgICAgYXJyLnNldEludDMyKDQsIGlvWzFdLCBmYWxzZSk7XG4gICAgICAgICAgICBhcnIuc2V0SW50MzIoOCwgaW9bMl0sIGZhbHNlKTtcbiAgICAgICAgICAgIGFyci5zZXRJbnQzMigxMiwgaW9bM10sIGZhbHNlKTtcbiAgICAgICAgICAgIGFyci5zZXRJbnQzMigxNiwgaW9bNF0sIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaGFzaCBkaWdlc3QgYXMgYW4gYXJyYXkgb2YgNSAzMmJpdCBpbnRlZ2Vycy5cbiAgICAgICAgdmFyIHJhd0RpZ2VzdCA9IHRoaXMucmF3RGlnZXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHZhciBtc2dMZW4gPSBzdHIuYnl0ZUxlbmd0aCB8fCBzdHIubGVuZ3RoIHx8IHN0ci5zaXplIHx8IDA7XG4gICAgICAgICAgICAgICAgaW5pdFN0YXRlKHNlbGYkMi5oZWFwLCBzZWxmJDIucGFkTWF4Q2h1bmtMZW4pO1xuICAgICAgICAgICAgICAgIHZhciBjaHVua09mZnNldCA9IDAsIGNodW5rTGVuID0gc2VsZiQyLm1heENodW5rTGVuLCBsYXN0O1xuICAgICAgICAgICAgICAgIGZvciAoY2h1bmtPZmZzZXQgPSAwOyBtc2dMZW4gPiBjaHVua09mZnNldCArIGNodW5rTGVuOyBjaHVua09mZnNldCArPSBjaHVua0xlbikge1xuICAgICAgICAgICAgICAgICAgICBjb3JlQ2FsbChzdHIsIGNodW5rT2Zmc2V0LCBjaHVua0xlbiwgbXNnTGVuLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvcmVDYWxsKHN0ciwgY2h1bmtPZmZzZXQsIG1zZ0xlbiAtIGNodW5rT2Zmc2V0LCBtc2dMZW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYXdEaWdlc3Qoc2VsZiQyLmhlYXAsIHNlbGYkMi5wYWRNYXhDaHVua0xlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgZGlnZXN0IGFuZCBkaWdlc3RGcm9tKiBpbnRlcmZhY2UgcmV0dXJucyB0aGUgaGFzaCBkaWdlc3RcbiAgICAgICAgLy8gYXMgYSBoZXggc3RyaW5nLlxuICAgICAgICB0aGlzLmRpZ2VzdCA9IHRoaXMuZGlnZXN0RnJvbVN0cmluZyA9IHRoaXMuZGlnZXN0RnJvbUJ1ZmZlciA9IHRoaXMuZGlnZXN0RnJvbUFycmF5QnVmZmVyID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIGhleChyYXdEaWdlc3Qoc3RyKS5idWZmZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICA7XG4gICAgLy8gVGhlIGxvdy1sZXZlbCBSdXNoQ29yZSBtb2R1bGUgcHJvdmlkZXMgdGhlIGhlYXJ0IG9mIFJ1c2hhLFxuICAgIC8vIGEgaGlnaC1zcGVlZCBzaGExIGltcGxlbWVudGF0aW9uIHdvcmtpbmcgb24gYW4gSW50MzJBcnJheSBoZWFwLlxuICAgIC8vIEF0IGZpcnN0IGdsYW5jZSwgdGhlIGltcGxlbWVudGF0aW9uIHNlZW1zIGNvbXBsaWNhdGVkLCBob3dldmVyXG4gICAgLy8gd2l0aCB0aGUgU0hBMSBzcGVjIGF0IGhhbmQsIGl0IGlzIG9idmlvdXMgdGhpcyBhbG1vc3QgYSB0ZXh0Ym9va1xuICAgIC8vIGltcGxlbWVudGF0aW9uIHRoYXQgaGFzIGEgZmV3IGZ1bmN0aW9ucyBoYW5kLWlubGluZWQgYW5kIGEgZmV3IGxvb3BzXG4gICAgLy8gaGFuZC11bnJvbGxlZC5cbiAgICBSdXNoYS5fY29yZSA9IGZ1bmN0aW9uIFJ1c2hhQ29yZShzdGRsaWIsIGZvcmVpZ24sIGhlYXApIHtcbiAgICAgICAgJ3VzZSBhc20nO1xuICAgICAgICB2YXIgSCA9IG5ldyBzdGRsaWIuSW50MzJBcnJheShoZWFwKTtcbiAgICAgICAgZnVuY3Rpb24gaGFzaChrLCB4KSB7XG4gICAgICAgICAgICAvLyBrIGluIGJ5dGVzXG4gICAgICAgICAgICBrID0gayB8IDA7XG4gICAgICAgICAgICB4ID0geCB8IDA7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGogPSAwLCB5MCA9IDAsIHowID0gMCwgeTEgPSAwLCB6MSA9IDAsIHkyID0gMCwgejIgPSAwLCB5MyA9IDAsIHozID0gMCwgeTQgPSAwLCB6NCA9IDAsIHQwID0gMCwgdDEgPSAwO1xuICAgICAgICAgICAgeTAgPSBIW3ggKyAzMjAgPj4gMl0gfCAwO1xuICAgICAgICAgICAgeTEgPSBIW3ggKyAzMjQgPj4gMl0gfCAwO1xuICAgICAgICAgICAgeTIgPSBIW3ggKyAzMjggPj4gMl0gfCAwO1xuICAgICAgICAgICAgeTMgPSBIW3ggKyAzMzIgPj4gMl0gfCAwO1xuICAgICAgICAgICAgeTQgPSBIW3ggKyAzMzYgPj4gMl0gfCAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgKGkgfCAwKSA8IChrIHwgMCk7IGkgPSBpICsgNjQgfCAwKSB7XG4gICAgICAgICAgICAgICAgejAgPSB5MDtcbiAgICAgICAgICAgICAgICB6MSA9IHkxO1xuICAgICAgICAgICAgICAgIHoyID0geTI7XG4gICAgICAgICAgICAgICAgejMgPSB5MztcbiAgICAgICAgICAgICAgICB6NCA9IHk0O1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IChqIHwgMCkgPCA2NDsgaiA9IGogKyA0IHwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IEhbaSArIGogPj4gMl0gfCAwO1xuICAgICAgICAgICAgICAgICAgICB0MCA9ICgoeTAgPDwgNSB8IHkwID4+PiAyNykgKyAoeTEgJiB5MiB8IH55MSAmIHkzKSB8IDApICsgKCh0MSArIHk0IHwgMCkgKyAxNTE4NTAwMjQ5IHwgMCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICB5NCA9IHkzO1xuICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IHkxIDw8IDMwIHwgeTEgPj4+IDI7XG4gICAgICAgICAgICAgICAgICAgIHkxID0geTA7XG4gICAgICAgICAgICAgICAgICAgIHkwID0gdDA7XG4gICAgICAgICAgICAgICAgICAgIEhbayArIGogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDY0IHwgMDsgKGogfCAwKSA8IChrICsgODAgfCAwKTsgaiA9IGogKyA0IHwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPDwgMSB8IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPj4+IDMxO1xuICAgICAgICAgICAgICAgICAgICB0MCA9ICgoeTAgPDwgNSB8IHkwID4+PiAyNykgKyAoeTEgJiB5MiB8IH55MSAmIHkzKSB8IDApICsgKCh0MSArIHk0IHwgMCkgKyAxNTE4NTAwMjQ5IHwgMCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICB5NCA9IHkzO1xuICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IHkxIDw8IDMwIHwgeTEgPj4+IDI7XG4gICAgICAgICAgICAgICAgICAgIHkxID0geTA7XG4gICAgICAgICAgICAgICAgICAgIHkwID0gdDA7XG4gICAgICAgICAgICAgICAgICAgIEhbaiA+PiAyXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBrICsgODAgfCAwOyAoaiB8IDApIDwgKGsgKyAxNjAgfCAwKTsgaiA9IGogKyA0IHwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPDwgMSB8IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPj4+IDMxO1xuICAgICAgICAgICAgICAgICAgICB0MCA9ICgoeTAgPDwgNSB8IHkwID4+PiAyNykgKyAoeTEgXiB5MiBeIHkzKSB8IDApICsgKCh0MSArIHk0IHwgMCkgKyAxODU5Nzc1MzkzIHwgMCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICB5NCA9IHkzO1xuICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IHkxIDw8IDMwIHwgeTEgPj4+IDI7XG4gICAgICAgICAgICAgICAgICAgIHkxID0geTA7XG4gICAgICAgICAgICAgICAgICAgIHkwID0gdDA7XG4gICAgICAgICAgICAgICAgICAgIEhbaiA+PiAyXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBrICsgMTYwIHwgMDsgKGogfCAwKSA8IChrICsgMjQwIHwgMCk7IGogPSBqICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pIDw8IDEgfCAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pID4+PiAzMTtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSAoKHkwIDw8IDUgfCB5MCA+Pj4gMjcpICsgKHkxICYgeTIgfCB5MSAmIHkzIHwgeTIgJiB5MykgfCAwKSArICgodDEgKyB5NCB8IDApIC0gMTg5NDAwNzU4OCB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2ogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDI0MCB8IDA7IChqIHwgMCkgPCAoayArIDMyMCB8IDApOyBqID0gaiArIDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gKEhbaiAtIDEyID4+IDJdIF4gSFtqIC0gMzIgPj4gMl0gXiBIW2ogLSA1NiA+PiAyXSBeIEhbaiAtIDY0ID4+IDJdKSA8PCAxIHwgKEhbaiAtIDEyID4+IDJdIF4gSFtqIC0gMzIgPj4gMl0gXiBIW2ogLSA1NiA+PiAyXSBeIEhbaiAtIDY0ID4+IDJdKSA+Pj4gMzE7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gKCh5MCA8PCA1IHwgeTAgPj4+IDI3KSArICh5MSBeIHkyIF4geTMpIHwgMCkgKyAoKHQxICsgeTQgfCAwKSAtIDg5OTQ5NzUxNCB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2ogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeTAgPSB5MCArIHowIHwgMDtcbiAgICAgICAgICAgICAgICB5MSA9IHkxICsgejEgfCAwO1xuICAgICAgICAgICAgICAgIHkyID0geTIgKyB6MiB8IDA7XG4gICAgICAgICAgICAgICAgeTMgPSB5MyArIHozIHwgMDtcbiAgICAgICAgICAgICAgICB5NCA9IHk0ICsgejQgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSFt4ICsgMzIwID4+IDJdID0geTA7XG4gICAgICAgICAgICBIW3ggKyAzMjQgPj4gMl0gPSB5MTtcbiAgICAgICAgICAgIEhbeCArIDMyOCA+PiAyXSA9IHkyO1xuICAgICAgICAgICAgSFt4ICsgMzMyID4+IDJdID0geTM7XG4gICAgICAgICAgICBIW3ggKyAzMzYgPj4gMl0gPSB5NDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoYXNoOiBoYXNoIH07XG4gICAgfTtcbiAgICAvLyBJZiB3ZSdlIHJ1bm5pbmcgaW4gTm9kZS5KUywgZXhwb3J0IGEgbW9kdWxlLlxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFJ1c2hhO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LlJ1c2hhID0gUnVzaGE7XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgaW4gYSB3ZWJ3b3JrZXIsIGFjY2VwdFxuICAgIC8vIG1lc3NhZ2VzIGNvbnRhaW5pbmcgYSBqb2JpZCBhbmQgYSBidWZmZXJcbiAgICAvLyBvciBibG9iIG9iamVjdCwgYW5kIHJldHVybiB0aGUgaGFzaCByZXN1bHQuXG4gICAgaWYgKHR5cGVvZiBGaWxlUmVhZGVyU3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyU3luYygpLCBoYXNoZXIgPSBuZXcgUnVzaGEoNCAqIDEwMjQgKiAxMDI0KTtcbiAgICAgICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYXNoLCBkYXRhID0gZXZlbnQuZGF0YS5kYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYXNoID0gaGFzaGVyLmRpZ2VzdChkYXRhKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGhhc2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnYnVmZmVyJylcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGNodW5rcyA9IFtdXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICB9KVxuICBzdHJlYW0ub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikgY2IobnVsbCwgQnVmZmVyLmNvbmNhdChjaHVua3MpKVxuICAgIGNiID0gbnVsbFxuICB9KVxuICBzdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNiKSBjYihlcnIpXG4gICAgY2IgPSBudWxsXG4gIH0pXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNpbXBsZUdldFxuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJylcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgdW56aXBSZXNwb25zZSA9IHJlcXVpcmUoJ3VuemlwLXJlc3BvbnNlJykgLy8gZXhjbHVkZWQgZnJvbSBicm93c2VyIGJ1aWxkXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxuZnVuY3Rpb24gc2ltcGxlR2V0IChvcHRzLCBjYikge1xuICBvcHRzID0gdHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnID8geyB1cmw6IG9wdHMgfSA6IGV4dGVuZChvcHRzKVxuICBjYiA9IG9uY2UoY2IpXG5cbiAgaWYgKG9wdHMudXJsKSBwYXJzZU9wdHNVcmwob3B0cylcbiAgaWYgKG9wdHMuaGVhZGVycyA9PSBudWxsKSBvcHRzLmhlYWRlcnMgPSB7fVxuICBpZiAob3B0cy5tYXhSZWRpcmVjdHMgPT0gbnVsbCkgb3B0cy5tYXhSZWRpcmVjdHMgPSAxMFxuXG4gIHZhciBib2R5ID0gb3B0cy5ib2R5XG4gIG9wdHMuYm9keSA9IHVuZGVmaW5lZFxuICBpZiAoYm9keSAmJiAhb3B0cy5tZXRob2QpIG9wdHMubWV0aG9kID0gJ1BPU1QnXG5cbiAgLy8gUmVxdWVzdCBnemlwL2RlZmxhdGVcbiAgdmFyIGN1c3RvbUFjY2VwdEVuY29kaW5nID0gT2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgcmV0dXJuIGgudG9Mb3dlckNhc2UoKSA9PT0gJ2FjY2VwdC1lbmNvZGluZydcbiAgfSlcbiAgaWYgKCFjdXN0b21BY2NlcHRFbmNvZGluZykgb3B0cy5oZWFkZXJzWydhY2NlcHQtZW5jb2RpbmcnXSA9ICdnemlwLCBkZWZsYXRlJ1xuXG4gIC8vIFN1cHBvcnQgaHR0cDogYW5kIGh0dHBzOiB1cmxzXG4gIHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgPT09ICdodHRwczonID8gaHR0cHMgOiBodHRwXG4gIHZhciByZXEgPSBwcm90b2NvbC5yZXF1ZXN0KG9wdHMsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAvLyBGb2xsb3cgM3h4IHJlZGlyZWN0c1xuICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAzMDAgJiYgcmVzLnN0YXR1c0NvZGUgPCA0MDAgJiYgJ2xvY2F0aW9uJyBpbiByZXMuaGVhZGVycykge1xuICAgICAgb3B0cy51cmwgPSByZXMuaGVhZGVycy5sb2NhdGlvblxuICAgICAgcGFyc2VPcHRzVXJsKG9wdHMpXG4gICAgICByZXMucmVzdW1lKCkgLy8gRGlzY2FyZCByZXNwb25zZVxuXG4gICAgICBvcHRzLm1heFJlZGlyZWN0cyAtPSAxXG4gICAgICBpZiAob3B0cy5tYXhSZWRpcmVjdHMgPiAwKSBzaW1wbGVHZXQob3B0cywgY2IpXG4gICAgICBlbHNlIGNiKG5ldyBFcnJvcigndG9vIG1hbnkgcmVkaXJlY3RzJykpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNiKG51bGwsIHR5cGVvZiB1bnppcFJlc3BvbnNlID09PSAnZnVuY3Rpb24nID8gdW56aXBSZXNwb25zZShyZXMpIDogcmVzKVxuICB9KVxuICByZXEub24oJ2Vycm9yJywgY2IpXG4gIHJlcS5lbmQoYm9keSlcbiAgcmV0dXJuIHJlcVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25jYXQgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgcmV0dXJuIHNpbXBsZUdldChvcHRzLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHZhciBjaHVua3MgPSBbXVxuICAgIHJlcy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgfSlcbiAgICByZXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIHJlcywgQnVmZmVyLmNvbmNhdChjaHVua3MpKVxuICAgIH0pXG4gIH0pXG59XG5cbjtbJ2dldCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdoZWFkJywgJ2RlbGV0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBtb2R1bGUuZXhwb3J0c1ttZXRob2RdID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykgb3B0cyA9IHsgdXJsOiBvcHRzIH1cbiAgICBvcHRzLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIHNpbXBsZUdldChvcHRzLCBjYilcbiAgfVxufSlcblxuZnVuY3Rpb24gcGFyc2VPcHRzVXJsIChvcHRzKSB7XG4gIHZhciBsb2MgPSB1cmwucGFyc2Uob3B0cy51cmwpXG4gIGlmIChsb2MuaG9zdG5hbWUpIG9wdHMuaG9zdG5hbWUgPSBsb2MuaG9zdG5hbWVcbiAgaWYgKGxvYy5wb3J0KSBvcHRzLnBvcnQgPSBsb2MucG9ydFxuICBpZiAobG9jLnByb3RvY29sKSBvcHRzLnByb3RvY29sID0gbG9jLnByb3RvY29sXG4gIGlmIChsb2MuYXV0aCkgb3B0cy5hdXRoID0gbG9jLmF1dGhcbiAgb3B0cy5wYXRoID0gbG9jLnBhdGhcbiAgZGVsZXRlIG9wdHMudXJsXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBlZXJcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc2ltcGxlLXBlZXInKVxudmFyIGdldEJyb3dzZXJSVEMgPSByZXF1aXJlKCdnZXQtYnJvd3Nlci1ydGMnKVxudmFyIGhhdCA9IHJlcXVpcmUoJ2hhdCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbmluaGVyaXRzKFBlZXIsIHN0cmVhbS5EdXBsZXgpXG5cbi8qKlxuICogV2ViUlRDIHBlZXIgY29ubmVjdGlvbi4gU2FtZSBBUEkgYXMgbm9kZSBjb3JlIGBuZXQuU29ja2V0YCwgcGx1cyBhIGZldyBleHRyYSBtZXRob2RzLlxuICogRHVwbGV4IHN0cmVhbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFBlZXIgKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBQZWVyKSkgcmV0dXJuIG5ldyBQZWVyKG9wdHMpXG4gIHNlbGYuX2RlYnVnKCduZXcgcGVlciAlbycsIG9wdHMpXG5cbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cy5hbGxvd0hhbGZPcGVuID0gZmFsc2VcbiAgaWYgKG9wdHMuaGlnaFdhdGVyTWFyayA9PSBudWxsKSBvcHRzLmhpZ2hXYXRlck1hcmsgPSAxMDI0ICogMTAyNFxuXG4gIHN0cmVhbS5EdXBsZXguY2FsbChzZWxmLCBvcHRzKVxuXG4gIHNlbGYuaW5pdGlhdG9yID0gb3B0cy5pbml0aWF0b3IgfHwgZmFsc2VcbiAgc2VsZi5jaGFubmVsQ29uZmlnID0gb3B0cy5jaGFubmVsQ29uZmlnIHx8IFBlZXIuY2hhbm5lbENvbmZpZ1xuICBzZWxmLmNoYW5uZWxOYW1lID0gb3B0cy5pbml0aWF0b3IgPyAob3B0cy5jaGFubmVsTmFtZSB8fCBoYXQoMTYwKSkgOiBudWxsXG4gIHNlbGYuY29uZmlnID0gb3B0cy5jb25maWcgfHwgUGVlci5jb25maWdcbiAgc2VsZi5jb25zdHJhaW50cyA9IG9wdHMuY29uc3RyYWludHMgfHwgUGVlci5jb25zdHJhaW50c1xuICBzZWxmLm9mZmVyQ29uc3RyYWludHMgPSBvcHRzLm9mZmVyQ29uc3RyYWludHNcbiAgc2VsZi5hbnN3ZXJDb25zdHJhaW50cyA9IG9wdHMuYW5zd2VyQ29uc3RyYWludHNcbiAgc2VsZi5yZWNvbm5lY3RUaW1lciA9IG9wdHMucmVjb25uZWN0VGltZXIgfHwgZmFsc2VcbiAgc2VsZi5zZHBUcmFuc2Zvcm0gPSBvcHRzLnNkcFRyYW5zZm9ybSB8fCBmdW5jdGlvbiAoc2RwKSB7IHJldHVybiBzZHAgfVxuICBzZWxmLnN0cmVhbSA9IG9wdHMuc3RyZWFtIHx8IGZhbHNlXG4gIHNlbGYudHJpY2tsZSA9IG9wdHMudHJpY2tsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy50cmlja2xlIDogdHJ1ZVxuXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuXG4gIC8vIHNvIFBlZXIgb2JqZWN0IGFsd2F5cyBoYXMgc2FtZSBzaGFwZSAoVjggb3B0aW1pemF0aW9uKVxuICBzZWxmLnJlbW90ZUFkZHJlc3MgPSB1bmRlZmluZWRcbiAgc2VsZi5yZW1vdGVGYW1pbHkgPSB1bmRlZmluZWRcbiAgc2VsZi5yZW1vdGVQb3J0ID0gdW5kZWZpbmVkXG4gIHNlbGYubG9jYWxBZGRyZXNzID0gdW5kZWZpbmVkXG4gIHNlbGYubG9jYWxQb3J0ID0gdW5kZWZpbmVkXG5cbiAgc2VsZi5faXNXcnRjID0gISFvcHRzLndydGMgLy8gSEFDSzogdG8gZml4IGB3cnRjYCBidWcuIFNlZSBpc3N1ZTogIzYwXG4gIHNlbGYuX3dydGMgPSAob3B0cy53cnRjICYmIHR5cGVvZiBvcHRzLndydGMgPT09ICdvYmplY3QnKVxuICAgID8gb3B0cy53cnRjXG4gICAgOiBnZXRCcm93c2VyUlRDKClcbiAgaWYgKCFzZWxmLl93cnRjKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBTcGVjaWZ5IGBvcHRzLndydGNgIG9wdGlvbiBpbiB0aGlzIGVudmlyb25tZW50JylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBXZWJSVEMgc3VwcG9ydDogTm90IGEgc3VwcG9ydGVkIGJyb3dzZXInKVxuICAgIH1cbiAgfVxuXG4gIHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50ID0gb3B0cy5oaWdoV2F0ZXJNYXJrXG4gIHNlbGYuX3BjUmVhZHkgPSBmYWxzZVxuICBzZWxmLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICBzZWxmLl9pY2VDb21wbGV0ZSA9IGZhbHNlIC8vIGljZSBjYW5kaWRhdGUgdHJpY2tsZSBkb25lIChnb3QgbnVsbCBjYW5kaWRhdGUpXG4gIHNlbGYuX2NoYW5uZWwgPSBudWxsXG4gIHNlbGYuX3BlbmRpbmdDYW5kaWRhdGVzID0gW11cblxuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG4gIHNlbGYuX2ludGVydmFsID0gbnVsbFxuICBzZWxmLl9yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbFxuXG4gIHNlbGYuX3BjID0gbmV3IChzZWxmLl93cnRjLlJUQ1BlZXJDb25uZWN0aW9uKShzZWxmLmNvbmZpZywgc2VsZi5jb25zdHJhaW50cylcbiAgc2VsZi5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UoKVxuICB9XG4gIHNlbGYuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25TaWduYWxpbmdTdGF0ZUNoYW5nZSgpXG4gIH1cbiAgc2VsZi5fcGMub25pY2VjYW5kaWRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBzZWxmLl9vbkljZUNhbmRpZGF0ZShldmVudClcbiAgfVxuXG4gIGlmIChzZWxmLnN0cmVhbSkgc2VsZi5fcGMuYWRkU3RyZWFtKHNlbGYuc3RyZWFtKVxuICBzZWxmLl9wYy5vbmFkZHN0cmVhbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHNlbGYuX29uQWRkU3RyZWFtKGV2ZW50KVxuICB9XG5cbiAgaWYgKHNlbGYuaW5pdGlhdG9yKSB7XG4gICAgc2VsZi5fc2V0dXBEYXRhKHtcbiAgICAgIGNoYW5uZWw6IHNlbGYuX3BjLmNyZWF0ZURhdGFDaGFubmVsKHNlbGYuY2hhbm5lbE5hbWUsIHNlbGYuY2hhbm5lbENvbmZpZylcbiAgICB9KVxuICAgIHNlbGYuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX2NyZWF0ZU9mZmVyKClcbiAgICB9KVxuICAgIC8vIE9ubHkgQ2hyb21lIHRyaWdnZXJzIFwibmVnb3RpYXRpb25uZWVkZWRcIjsgdGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIG90aGVyXG4gICAgLy8gaW1wbGVtZW50YXRpb25zXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHNlbGYuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQoKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9wYy5vbmRhdGFjaGFubmVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzZWxmLl9zZXR1cERhdGEoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgc2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgICAgLy8gV2hlbiBsb2NhbCBwZWVyIGlzIGZpbmlzaGVkIHdyaXRpbmcsIGNsb3NlIGNvbm5lY3Rpb24gdG8gcmVtb3RlIHBlZXIuXG4gICAgICAvLyBIYWxmIG9wZW4gY29ubmVjdGlvbnMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxuICAgICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgZGVzdHJveWluZyBzbyB0aGUgZGF0YWNoYW5uZWwgZmx1c2hlcy5cbiAgICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgbW9yZSByZWxpYWJsZSB3YXkgdG8gYWNjb21wbGlzaCB0aGlzP1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgfSwgMTAwKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBkYXRhIGNoYW5uZWwgaXMgbm90IGNvbm5lY3RlZCB3aGVuIGxvY2FsIHBlZXIgaXMgZmluaXNoZWQgd3JpdGluZywgd2FpdCB1bnRpbFxuICAgICAgLy8gZGF0YSBpcyBmbHVzaGVkIHRvIG5ldHdvcmsgYXQgXCJjb25uZWN0XCIgZXZlbnQuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNlbGYub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICAgIH0sIDEwMClcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5QZWVyLldFQlJUQ19TVVBQT1JUID0gISFnZXRCcm93c2VyUlRDKClcblxuLyoqXG4gKiBFeHBvc2UgY29uZmlnLCBjb25zdHJhaW50cywgYW5kIGRhdGEgY2hhbm5lbCBjb25maWcgZm9yIG92ZXJyaWRpbmcgYWxsIFBlZXJcbiAqIGluc3RhbmNlcy4gT3RoZXJ3aXNlLCBqdXN0IHNldCBvcHRzLmNvbmZpZywgb3B0cy5jb25zdHJhaW50cywgb3Igb3B0cy5jaGFubmVsQ29uZmlnXG4gKiB3aGVuIGNvbnN0cnVjdGluZyBhIFBlZXIuXG4gKi9cblBlZXIuY29uZmlnID0ge1xuICBpY2VTZXJ2ZXJzOiBbXG4gICAge1xuICAgICAgdXJsOiAnc3R1bjoyMy4yMS4xNTAuMTIxJywgLy8gZGVwcmVjYXRlZCwgcmVwbGFjZWQgYnkgYHVybHNgXG4gICAgICB1cmxzOiAnc3R1bjoyMy4yMS4xNTAuMTIxJ1xuICAgIH1cbiAgXVxufVxuUGVlci5jb25zdHJhaW50cyA9IHt9XG5QZWVyLmNoYW5uZWxDb25maWcgPSB7fVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlci5wcm90b3R5cGUsICdidWZmZXJTaXplJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICByZXR1cm4gKHNlbGYuX2NoYW5uZWwgJiYgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCkgfHwgMFxuICB9XG59KVxuXG5QZWVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHsgcG9ydDogc2VsZi5sb2NhbFBvcnQsIGZhbWlseTogJ0lQdjQnLCBhZGRyZXNzOiBzZWxmLmxvY2FsQWRkcmVzcyB9XG59XG5cblBlZXIucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNpZ25hbCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRhdGEgPSB7fVxuICAgIH1cbiAgfVxuICBzZWxmLl9kZWJ1Zygnc2lnbmFsKCknKVxuXG4gIGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX3BjLmFkZEljZUNhbmRpZGF0ZShcbiAgICAgICAgbmV3IHNlbGYuX3dydGMuUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSksXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH1cbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNlbGYuX2Rlc3Ryb3kobmV3IEVycm9yKCdlcnJvciBhZGRpbmcgY2FuZGlkYXRlOiAnICsgZXJyLm1lc3NhZ2UpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRhLnNkcCkge1xuICAgIHNlbGYuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyAoc2VsZi5fd3J0Yy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGRhdGEpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgaWYgKHNlbGYuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHNlbGYuX2NyZWF0ZUFuc3dlcigpXG5cbiAgICAgIHNlbGYuX3BlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goYWRkSWNlQ2FuZGlkYXRlKVxuICAgICAgc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH0pXG4gIH1cbiAgaWYgKGRhdGEuY2FuZGlkYXRlKSB7XG4gICAgaWYgKHNlbGYuX3BjLnJlbW90ZURlc2NyaXB0aW9uKSBhZGRJY2VDYW5kaWRhdGUoZGF0YS5jYW5kaWRhdGUpXG4gICAgZWxzZSBzZWxmLl9wZW5kaW5nQ2FuZGlkYXRlcy5wdXNoKGRhdGEuY2FuZGlkYXRlKVxuICB9XG4gIGlmICghZGF0YS5zZHAgJiYgIWRhdGEuY2FuZGlkYXRlKSB7XG4gICAgc2VsZi5fZGVzdHJveShuZXcgRXJyb3IoJ3NpZ25hbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgc2lnbmFsIGRhdGEnKSlcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGV4dC9iaW5hcnkgZGF0YSB0byB0aGUgcmVtb3RlIHBlZXIuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlWaWV3fEFycmF5QnVmZmVyfEJ1ZmZlcnxzdHJpbmd8QmxvYnxPYmplY3R9IGNodW5rXG4gKi9cblBlZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgLy8gSEFDSzogYHdydGNgIG1vZHVsZSBkb2Vzbid0IGFjY2VwdCBub2RlLmpzIGJ1ZmZlci4gU2VlIGlzc3VlOiAjNjBcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgc2VsZi5faXNXcnRjKSB7XG4gICAgY2h1bmsgPSBuZXcgVWludDhBcnJheShjaHVuaylcbiAgfVxuXG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGggfHwgY2h1bmsuYnl0ZUxlbmd0aCB8fCBjaHVuay5zaXplXG4gIHNlbGYuX2NoYW5uZWwuc2VuZChjaHVuaylcbiAgc2VsZi5fZGVidWcoJ3dyaXRlOiAlZCBieXRlcycsIGxlbilcbn1cblxuUGVlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvbmNsb3NlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZXN0cm95KG51bGwsIG9uY2xvc2UpXG59XG5cblBlZXIucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgb25jbG9zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgaWYgKG9uY2xvc2UpIHNlbGYub25jZSgnY2xvc2UnLCBvbmNsb3NlKVxuXG4gIHNlbGYuX2RlYnVnKCdkZXN0cm95IChlcnJvcjogJXMpJywgZXJyICYmIGVyci5tZXNzYWdlKVxuXG4gIHNlbGYucmVhZGFibGUgPSBzZWxmLndyaXRhYmxlID0gZmFsc2VcblxuICBpZiAoIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHNlbGYucHVzaChudWxsKVxuICBpZiAoIXNlbGYuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHNlbGYuZW5kKClcblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuICBzZWxmLl9wY1JlYWR5ID0gZmFsc2VcbiAgc2VsZi5fY2hhbm5lbFJlYWR5ID0gZmFsc2VcblxuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpXG4gIGNsZWFyVGltZW91dChzZWxmLl9yZWNvbm5lY3RUaW1lb3V0KVxuXG4gIGlmIChzZWxmLl9wYykge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLl9wYy5jbG9zZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgc2VsZi5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgc2VsZi5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbmFkZHN0cmVhbSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbFxuICAgIHNlbGYuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsXG4gIH1cblxuICBpZiAoc2VsZi5fY2hhbm5lbCkge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLl9jaGFubmVsLmNsb3NlKClcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICBzZWxmLl9jaGFubmVsLm9ubWVzc2FnZSA9IG51bGxcbiAgICBzZWxmLl9jaGFubmVsLm9ub3BlbiA9IG51bGxcbiAgICBzZWxmLl9jaGFubmVsLm9uY2xvc2UgPSBudWxsXG4gIH1cbiAgc2VsZi5fcGMgPSBudWxsXG4gIHNlbGYuX2NoYW5uZWwgPSBudWxsXG5cbiAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgc2VsZi5lbWl0KCdjbG9zZScpXG59XG5cblBlZXIucHJvdG90eXBlLl9zZXR1cERhdGEgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2NoYW5uZWwgPSBldmVudC5jaGFubmVsXG4gIHNlbGYuY2hhbm5lbE5hbWUgPSBzZWxmLl9jaGFubmVsLmxhYmVsXG5cbiAgc2VsZi5fY2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICBzZWxmLl9jaGFubmVsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHNlbGYuX29uQ2hhbm5lbE1lc3NhZ2UoZXZlbnQpXG4gIH1cbiAgc2VsZi5fY2hhbm5lbC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25DaGFubmVsT3BlbigpXG4gIH1cbiAgc2VsZi5fY2hhbm5lbC5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uQ2hhbm5lbENsb3NlKClcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cblBlZXIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYihuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpKVxuXG4gIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLnNlbmQoY2h1bmspXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5fb25FcnJvcihlcnIpXG4gICAgfVxuICAgIGlmIChzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50ID4gc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICAgIHNlbGYuX2NiID0gY2JcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fZGVidWcoJ3dyaXRlIGJlZm9yZSBjb25uZWN0JylcbiAgICBzZWxmLl9jaHVuayA9IGNodW5rXG4gICAgc2VsZi5fY2IgPSBjYlxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9jcmVhdGVPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fcGMuY3JlYXRlT2ZmZXIoZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBvZmZlci5zZHAgPSBzZWxmLnNkcFRyYW5zZm9ybShvZmZlci5zZHApXG4gICAgc2VsZi5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlciwgbm9vcCwgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfSlcbiAgICB2YXIgc2VuZE9mZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpZ25hbCA9IHNlbGYuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgb2ZmZXJcbiAgICAgIHNlbGYuX2RlYnVnKCdzaWduYWwnKVxuICAgICAgc2VsZi5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgIHR5cGU6IHNpZ25hbC50eXBlLFxuICAgICAgICBzZHA6IHNpZ25hbC5zZHBcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChzZWxmLnRyaWNrbGUgfHwgc2VsZi5faWNlQ29tcGxldGUpIHNlbmRPZmZlcigpXG4gICAgZWxzZSBzZWxmLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRPZmZlcikgLy8gd2FpdCBmb3IgY2FuZGlkYXRlc1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9LCBzZWxmLm9mZmVyQ29uc3RyYWludHMpXG59XG5cblBlZXIucHJvdG90eXBlLl9jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHNlbGYuX3BjLmNyZWF0ZUFuc3dlcihmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBhbnN3ZXIuc2RwID0gc2VsZi5zZHBUcmFuc2Zvcm0oYW5zd2VyLnNkcClcbiAgICBzZWxmLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlciwgbm9vcCwgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfSlcbiAgICB2YXIgc2VuZEFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaWduYWwgPSBzZWxmLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IGFuc3dlclxuICAgICAgc2VsZi5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICBzZWxmLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgdHlwZTogc2lnbmFsLnR5cGUsXG4gICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHNlbGYudHJpY2tsZSB8fCBzZWxmLl9pY2VDb21wbGV0ZSkgc2VuZEFuc3dlcigpXG4gICAgZWxzZSBzZWxmLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRBbnN3ZXIpXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH0sIHNlbGYuYW5zd2VyQ29uc3RyYWludHMpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBpY2VHYXRoZXJpbmdTdGF0ZSA9IHNlbGYuX3BjLmljZUdhdGhlcmluZ1N0YXRlXG4gIHZhciBpY2VDb25uZWN0aW9uU3RhdGUgPSBzZWxmLl9wYy5pY2VDb25uZWN0aW9uU3RhdGVcbiAgc2VsZi5fZGVidWcoJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSAlcyAlcycsIGljZUdhdGhlcmluZ1N0YXRlLCBpY2VDb25uZWN0aW9uU3RhdGUpXG4gIHNlbGYuZW1pdCgnaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlJywgaWNlR2F0aGVyaW5nU3RhdGUsIGljZUNvbm5lY3Rpb25TdGF0ZSlcbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJykge1xuICAgIGNsZWFyVGltZW91dChzZWxmLl9yZWNvbm5lY3RUaW1lb3V0KVxuICAgIHNlbGYuX3BjUmVhZHkgPSB0cnVlXG4gICAgc2VsZi5fbWF5YmVSZWFkeSgpXG4gIH1cbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICBpZiAoc2VsZi5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgLy8gSWYgdXNlciBoYXMgc2V0IGBvcHQucmVjb25uZWN0VGltZXJgLCBhbGxvdyB0aW1lIGZvciBJQ0UgdG8gYXR0ZW1wdCBhIHJlY29ubmVjdFxuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3JlY29ubmVjdFRpbWVvdXQpXG4gICAgICBzZWxmLl9yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgfSwgc2VsZi5yZWNvbm5lY3RUaW1lcilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgfVxuICB9XG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgc2VsZi5fZGVzdHJveSgpXG4gIH1cbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBzZWxmLl9kZXN0cm95KClcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl9wYy5nZXRTdGF0cykgeyAvLyBObyBhYmlsaXR5IHRvIGNhbGwgc3RhdHNcbiAgICBjYihbXSlcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikgeyAvLyBNb3ppbGxhXG4gICAgc2VsZi5fcGMuZ2V0U3RhdHMobnVsbCwgZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIGl0ZW1zID0gW11cbiAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSlcbiAgICAgIH0pXG4gICAgICBjYihpdGVtcylcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9KVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX3BjLmdldFN0YXRzKGZ1bmN0aW9uIChyZXMpIHsgLy8gQ2hyb21lXG4gICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgcmVzLnJlc3VsdCgpLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB2YXIgaXRlbSA9IHt9XG4gICAgICAgIHJlc3VsdC5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpdGVtW25hbWVdID0gcmVzdWx0LnN0YXQobmFtZSlcbiAgICAgICAgfSlcbiAgICAgICAgaXRlbS5pZCA9IHJlc3VsdC5pZFxuICAgICAgICBpdGVtLnR5cGUgPSByZXN1bHQudHlwZVxuICAgICAgICBpdGVtLnRpbWVzdGFtcCA9IHJlc3VsdC50aW1lc3RhbXBcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuICAgICAgfSlcbiAgICAgIGNiKGl0ZW1zKVxuICAgIH0pXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX21heWJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZWJ1ZygnbWF5YmVSZWFkeSBwYyAlcyBjaGFubmVsICVzJywgc2VsZi5fcGNSZWFkeSwgc2VsZi5fY2hhbm5lbFJlYWR5KVxuICBpZiAoc2VsZi5jb25uZWN0ZWQgfHwgc2VsZi5fY29ubmVjdGluZyB8fCAhc2VsZi5fcGNSZWFkeSB8fCAhc2VsZi5fY2hhbm5lbFJlYWR5KSByZXR1cm5cbiAgc2VsZi5fY29ubmVjdGluZyA9IHRydWVcblxuICBzZWxmLmdldFN0YXRzKGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHNlbGYuX2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHNlbGYuY29ubmVjdGVkID0gdHJ1ZVxuXG4gICAgdmFyIHJlbW90ZUNhbmRpZGF0ZXMgPSB7fVxuICAgIHZhciBsb2NhbENhbmRpZGF0ZXMgPSB7fVxuXG4gICAgZnVuY3Rpb24gc2V0QWN0aXZlQ2FuZGlkYXRlcyAoaXRlbSkge1xuICAgICAgdmFyIGxvY2FsID0gbG9jYWxDYW5kaWRhdGVzW2l0ZW0ubG9jYWxDYW5kaWRhdGVJZF1cbiAgICAgIHZhciByZW1vdGUgPSByZW1vdGVDYW5kaWRhdGVzW2l0ZW0ucmVtb3RlQ2FuZGlkYXRlSWRdXG5cbiAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICBzZWxmLmxvY2FsQWRkcmVzcyA9IGxvY2FsLmlwQWRkcmVzc1xuICAgICAgICBzZWxmLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbC5wb3J0TnVtYmVyKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbS5nb29nTG9jYWxBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBTb21ldGltZXMgYGl0ZW0uaWRgIGlzIHVuZGVmaW5lZCBpbiBgd3J0Y2AgYW5kIENocm9tZVxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3Mvc2ltcGxlLXBlZXIvaXNzdWVzLzY2XG4gICAgICAgIGxvY2FsID0gaXRlbS5nb29nTG9jYWxBZGRyZXNzLnNwbGl0KCc6JylcbiAgICAgICAgc2VsZi5sb2NhbEFkZHJlc3MgPSBsb2NhbFswXVxuICAgICAgICBzZWxmLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbFsxXSlcbiAgICAgIH1cbiAgICAgIHNlbGYuX2RlYnVnKCdjb25uZWN0IGxvY2FsOiAlczolcycsIHNlbGYubG9jYWxBZGRyZXNzLCBzZWxmLmxvY2FsUG9ydClcblxuICAgICAgaWYgKHJlbW90ZSkge1xuICAgICAgICBzZWxmLnJlbW90ZUFkZHJlc3MgPSByZW1vdGUuaXBBZGRyZXNzXG4gICAgICAgIHNlbGYucmVtb3RlUG9ydCA9IE51bWJlcihyZW1vdGUucG9ydE51bWJlcilcbiAgICAgICAgc2VsZi5yZW1vdGVGYW1pbHkgPSAnSVB2NCdcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0uZ29vZ1JlbW90ZUFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlbW90ZSA9IGl0ZW0uZ29vZ1JlbW90ZUFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICBzZWxmLnJlbW90ZUFkZHJlc3MgPSByZW1vdGVbMF1cbiAgICAgICAgc2VsZi5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZVsxXSlcbiAgICAgICAgc2VsZi5yZW1vdGVGYW1pbHkgPSAnSVB2NCdcbiAgICAgIH1cbiAgICAgIHNlbGYuX2RlYnVnKCdjb25uZWN0IHJlbW90ZTogJXM6JXMnLCBzZWxmLnJlbW90ZUFkZHJlc3MsIHNlbGYucmVtb3RlUG9ydClcbiAgICB9XG5cbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbS50eXBlID09PSAncmVtb3RlY2FuZGlkYXRlJykgcmVtb3RlQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdsb2NhbGNhbmRpZGF0ZScpIGxvY2FsQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICB9KVxuXG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGlzQ2FuZGlkYXRlUGFpciA9IChcbiAgICAgICAgKGl0ZW0udHlwZSA9PT0gJ2dvb2dDYW5kaWRhdGVQYWlyJyAmJiBpdGVtLmdvb2dBY3RpdmVDb25uZWN0aW9uID09PSAndHJ1ZScpIHx8XG4gICAgICAgIChpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGVwYWlyJyAmJiBpdGVtLnNlbGVjdGVkKVxuICAgICAgKVxuICAgICAgaWYgKGlzQ2FuZGlkYXRlUGFpcikgc2V0QWN0aXZlQ2FuZGlkYXRlcyhpdGVtKVxuICAgIH0pXG5cbiAgICBpZiAoc2VsZi5fY2h1bmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuc2VuZChzZWxmLl9jaHVuaylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZi5fb25FcnJvcihlcnIpXG4gICAgICB9XG4gICAgICBzZWxmLl9jaHVuayA9IG51bGxcbiAgICAgIHNlbGYuX2RlYnVnKCdzZW50IGNodW5rIGZyb20gXCJ3cml0ZSBiZWZvcmUgY29ubmVjdFwiJylcblxuICAgICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICAgIHNlbGYuX2NiID0gbnVsbFxuICAgICAgY2IobnVsbClcbiAgICB9XG5cbiAgICBzZWxmLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5fY2IgfHwgIXNlbGYuX2NoYW5uZWwgfHwgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50KSByZXR1cm5cbiAgICAgIHNlbGYuX2RlYnVnKCdlbmRpbmcgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpXG4gICAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSBudWxsXG4gICAgICBjYihudWxsKVxuICAgIH0sIDE1MClcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwudW5yZWYpIHNlbGYuX2ludGVydmFsLnVucmVmKClcblxuICAgIHNlbGYuX2RlYnVnKCdjb25uZWN0JylcbiAgICBzZWxmLmVtaXQoJ2Nvbm5lY3QnKVxuICB9KVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25TaWduYWxpbmdTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdzaWduYWxpbmdTdGF0ZUNoYW5nZSAlcycsIHNlbGYuX3BjLnNpZ25hbGluZ1N0YXRlKVxuICBzZWxmLmVtaXQoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlJywgc2VsZi5fcGMuc2lnbmFsaW5nU3RhdGUpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiBzZWxmLnRyaWNrbGUpIHtcbiAgICBzZWxmLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgIGNhbmRpZGF0ZToge1xuICAgICAgICBjYW5kaWRhdGU6IGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUsXG4gICAgICAgIHNkcE1MaW5lSW5kZXg6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxuICAgICAgICBzZHBNaWQ6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNaWRcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2UgaWYgKCFldmVudC5jYW5kaWRhdGUpIHtcbiAgICBzZWxmLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICBzZWxmLmVtaXQoJ19pY2VDb21wbGV0ZScpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBkYXRhID0gZXZlbnQuZGF0YVxuICBzZWxmLl9kZWJ1ZygncmVhZDogJWQgYnl0ZXMnLCBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGgpXG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcbiAgc2VsZi5wdXNoKGRhdGEpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkNoYW5uZWxPcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuY29ubmVjdGVkIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ29uIGNoYW5uZWwgb3BlbicpXG4gIHNlbGYuX2NoYW5uZWxSZWFkeSA9IHRydWVcbiAgc2VsZi5fbWF5YmVSZWFkeSgpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkNoYW5uZWxDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdvbiBjaGFubmVsIGNsb3NlJylcbiAgc2VsZi5fZGVzdHJveSgpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkFkZFN0cmVhbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ29uIGFkZCBzdHJlYW0nKVxuICBzZWxmLmVtaXQoJ3N0cmVhbScsIGV2ZW50LnN0cmVhbSlcbn1cblxuUGVlci5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1ZygnZXJyb3IgJXMnLCBlcnIubWVzc2FnZSB8fCBlcnIpXG4gIHNlbGYuX2Rlc3Ryb3koZXJyKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB2YXIgaWQgPSBzZWxmLmNoYW5uZWxOYW1lICYmIHNlbGYuY2hhbm5lbE5hbWUuc3Vic3RyaW5nKDAsIDcpXG4gIGFyZ3NbMF0gPSAnWycgKyBpZCArICddICcgKyBhcmdzWzBdXG4gIGRlYnVnLmFwcGx5KG51bGwsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbiIsInZhciBSdXNoYSA9IHJlcXVpcmUoJ3J1c2hhJylcblxudmFyIHJ1c2hhID0gbmV3IFJ1c2hhXG52YXIgY3J5cHRvID0gd2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG8gfHwge31cbnZhciBzdWJ0bGUgPSBjcnlwdG8uc3VidGxlIHx8IGNyeXB0by53ZWJraXRTdWJ0bGVcblxuZnVuY3Rpb24gc2hhMXN5bmMgKGJ1Zikge1xuICByZXR1cm4gcnVzaGEuZGlnZXN0KGJ1Zilcbn1cblxuLy8gQnJvd3NlcnMgdGhyb3cgaWYgdGhleSBsYWNrIHN1cHBvcnQgZm9yIGFuIGFsZ29yaXRobS5cbi8vIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCBvbiBub24tc2VjdXJlIG9yaWdpbnMuIChodHRwOi8vZ29vLmdsL2xxNGdDbylcbnRyeSB7XG4gIHN1YnRsZS5kaWdlc3QoeyBuYW1lOiAnc2hhLTEnIH0sIG5ldyBVaW50OEFycmF5KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgc3VidGxlID0gZmFsc2VcbiAgfSlcbn0gY2F0Y2ggKGVycikgeyBzdWJ0bGUgPSBmYWxzZSB9XG5cbmZ1bmN0aW9uIHNoYTEgKGJ1ZiwgY2IpIHtcbiAgaWYgKCFzdWJ0bGUpIHtcbiAgICAvLyBVc2UgUnVzaGFcbiAgICBzZXRUaW1lb3V0KGNiLCAwLCBzaGExc3luYyhidWYpKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gdWludDhhcnJheShidWYpXG4gIH1cblxuICBzdWJ0bGUuZGlnZXN0KHsgbmFtZTogJ3NoYS0xJyB9LCBidWYpXG4gICAgLnRoZW4oZnVuY3Rpb24gc3VjY2VlZCAocmVzdWx0KSB7XG4gICAgICBjYihoZXgobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSkpXG4gICAgfSxcbiAgICBmdW5jdGlvbiBmYWlsIChlcnJvcikge1xuICAgICAgY2Ioc2hhMXN5bmMoYnVmKSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiB1aW50OGFycmF5IChzKSB7XG4gIHZhciBsID0gcy5sZW5ndGhcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHMuY2hhckNvZGVBdChpKVxuICB9XG4gIHJldHVybiBhcnJheVxufVxuXG5mdW5jdGlvbiBoZXggKGJ1Zikge1xuICB2YXIgbCA9IGJ1Zi5sZW5ndGhcbiAgdmFyIGNoYXJzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgYml0ZSA9IGJ1ZltpXVxuICAgIGNoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSlcbiAgICBjaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYTFcbm1vZHVsZS5leHBvcnRzLnN5bmMgPSBzaGExc3luY1xuIiwibW9kdWxlLmV4cG9ydHMgPSBTb2NrZXRcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc2ltcGxlLXdlYnNvY2tldCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciB3cyA9IHJlcXVpcmUoJ3dzJykgLy8gd2Vic29ja2V0cyBpbiBub2RlIC0gd2lsbCBiZSBlbXB0eSBvYmplY3QgaW4gYnJvd3NlclxuXG52YXIgV2ViU29ja2V0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuV2ViU29ja2V0IDogd3NcblxuaW5oZXJpdHMoU29ja2V0LCBzdHJlYW0uRHVwbGV4KVxuXG4vKipcbiAqIFdlYlNvY2tldC4gU2FtZSBBUEkgYXMgbm9kZSBjb3JlIGBuZXQuU29ja2V0YC4gRHVwbGV4IHN0cmVhbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgd2Vic29ja2V0IHNlcnZlciB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbnMgdG8gc3RyZWFtLkR1cGxleFxuICovXG5mdW5jdGlvbiBTb2NrZXQgKHVybCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVybCwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgZGVidWcoJ25ldyB3ZWJzb2NrZXQ6ICVzICVvJywgdXJsLCBvcHRzKVxuXG4gIG9wdHMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlXG4gIGlmIChvcHRzLmhpZ2hXYXRlck1hcmsgPT0gbnVsbCkgb3B0cy5oaWdoV2F0ZXJNYXJrID0gMTAyNCAqIDEwMjRcblxuICBzdHJlYW0uRHVwbGV4LmNhbGwoc2VsZiwgb3B0cylcblxuICBzZWxmLnVybCA9IHVybFxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcblxuICBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCA9IG9wdHMuaGlnaFdhdGVyTWFya1xuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG4gIHNlbGYuX2ludGVydmFsID0gbnVsbFxuXG4gIHRyeSB7XG4gICAgc2VsZi5fd3MgPSBuZXcgV2ViU29ja2V0KHNlbGYudXJsKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX29uRXJyb3IoZXJyKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgc2VsZi5fd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgc2VsZi5fd3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uT3BlbigpXG4gIH1cbiAgc2VsZi5fd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgc2VsZi5fb25NZXNzYWdlKGV2ZW50KVxuICB9XG4gIHNlbGYuX3dzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25DbG9zZSgpXG4gIH1cbiAgc2VsZi5fd3Mub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbkVycm9yKG5ldyBFcnJvcignY29ubmVjdGlvbiBlcnJvciB0byAnICsgc2VsZi51cmwpKVxuICB9XG5cbiAgc2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgICAgLy8gV2hlbiBzdHJlYW0gaXMgZmluaXNoZWQgd3JpdGluZywgY2xvc2Ugc29ja2V0IGNvbm5lY3Rpb24uIEhhbGYgb3BlbiBjb25uZWN0aW9uc1xuICAgICAgLy8gYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxuICAgICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgZGVzdHJveWluZyBzbyB0aGUgc29ja2V0IGZsdXNoZXMuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kZXN0cm95KClcbiAgICAgIH0sIDEwMClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgc29ja2V0IGlzIG5vdCBjb25uZWN0ZWQgd2hlbiBzdHJlYW0gaXMgZmluaXNoZWQgd3JpdGluZywgd2FpdCB1bnRpbCBkYXRhIGlzXG4gICAgICAvLyBmbHVzaGVkIHRvIG5ldHdvcmsgYXQgXCJjb25uZWN0XCIgZXZlbnQuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNlbGYub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICAgIH0sIDEwMClcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5Tb2NrZXQuV0VCU09DS0VUX1NVUFBPUlQgPSAhIVdlYlNvY2tldFxuXG4vKipcbiAqIFNlbmQgdGV4dC9iaW5hcnkgZGF0YSB0byB0aGUgV2ViU29ja2V0IHNlcnZlci5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheVZpZXd8QXJyYXlCdWZmZXJ8QnVmZmVyfHN0cmluZ3xCbG9ifE9iamVjdH0gY2h1bmtcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGggfHwgY2h1bmsuYnl0ZUxlbmd0aCB8fCBjaHVuay5zaXplXG4gIHNlbGYuX3dzLnNlbmQoY2h1bmspXG4gIGRlYnVnKCd3cml0ZTogJWQgYnl0ZXMnLCBsZW4pXG59XG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvbmNsb3NlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZXN0cm95KG51bGwsIG9uY2xvc2UpXG59XG5cblNvY2tldC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBvbmNsb3NlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAob25jbG9zZSkgc2VsZi5vbmNlKCdjbG9zZScsIG9uY2xvc2UpXG5cbiAgZGVidWcoJ2Rlc3Ryb3kgKGVycm9yOiAlcyknLCBlcnIgJiYgZXJyLm1lc3NhZ2UpXG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRoaXMud3JpdGFibGUgPSBmYWxzZVxuXG4gIGlmICghc2VsZi5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgc2VsZi5wdXNoKG51bGwpXG4gIGlmICghc2VsZi5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgc2VsZi5lbmQoKVxuXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcbiAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbClcbiAgc2VsZi5faW50ZXJ2YWwgPSBudWxsXG4gIHNlbGYuX2NodW5rID0gbnVsbFxuICBzZWxmLl9jYiA9IG51bGxcblxuICBpZiAoc2VsZi5fd3MpIHtcbiAgICB2YXIgd3MgPSBzZWxmLl93c1xuICAgIHZhciBvbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgd3Mub25jbG9zZSA9IG51bGxcbiAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICAgIH1cbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgb25DbG9zZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdzLm9uY2xvc2UgPSBvbkNsb3NlXG4gICAgICAgIHdzLmNsb3NlKClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBvbkNsb3NlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3cy5vbm9wZW4gPSBudWxsXG4gICAgd3Mub25tZXNzYWdlID0gbnVsbFxuICAgIHdzLm9uZXJyb3IgPSBudWxsXG4gIH1cbiAgc2VsZi5fd3MgPSBudWxsXG5cbiAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbn1cblxuU29ja2V0LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cblNvY2tldC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIGNiKG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGFmdGVyIHNvY2tldCBpcyBkZXN0cm95ZWQnKSlcblxuICBpZiAoc2VsZi5jb25uZWN0ZWQpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5zZW5kKGNodW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHNlbGYuX29uRXJyb3IoZXJyKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHdzICE9PSAnZnVuY3Rpb24nICYmIHNlbGYuX3dzLmJ1ZmZlcmVkQW1vdW50ID4gc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQpIHtcbiAgICAgIGRlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgc2VsZi5fd3MuYnVmZmVyZWRBbW91bnQpXG4gICAgICBzZWxmLl9jYiA9IGNiXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCd3cml0ZSBiZWZvcmUgY29ubmVjdCcpXG4gICAgc2VsZi5fY2h1bmsgPSBjaHVua1xuICAgIHNlbGYuX2NiID0gY2JcbiAgfVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBkYXRhID0gZXZlbnQuZGF0YVxuICBkZWJ1ZygncmVhZDogJWQgYnl0ZXMnLCBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGgpXG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcbiAgc2VsZi5wdXNoKGRhdGEpXG59XG5cblNvY2tldC5wcm90b3R5cGUuX29uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmNvbm5lY3RlZCB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuY29ubmVjdGVkID0gdHJ1ZVxuXG4gIGlmIChzZWxmLl9jaHVuaykge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLnNlbmQoc2VsZi5fY2h1bmspXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5fb25FcnJvcihlcnIpXG4gICAgfVxuICAgIHNlbGYuX2NodW5rID0gbnVsbFxuICAgIGRlYnVnKCdzZW50IGNodW5rIGZyb20gXCJ3cml0ZSBiZWZvcmUgY29ubmVjdFwiJylcblxuICAgIHZhciBjYiA9IHNlbGYuX2NiXG4gICAgc2VsZi5fY2IgPSBudWxsXG4gICAgY2IobnVsbClcbiAgfVxuXG4gIC8vIE5vIGJhY2twcmVzc3VyZSBpbiBub2RlLiBUaGUgYHdzYCBtb2R1bGUgaGFzIGEgYnVnZ3kgYGJ1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eS5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvNDkyXG4gIGlmICh0eXBlb2Ygd3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5fY2IgfHwgIXNlbGYuX3dzIHx8IHNlbGYuX3dzLmJ1ZmZlcmVkQW1vdW50ID4gc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBkZWJ1ZygnZW5kaW5nIGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCBzZWxmLl93cy5idWZmZXJlZEFtb3VudClcbiAgICAgIHZhciBjYiA9IHNlbGYuX2NiXG4gICAgICBzZWxmLl9jYiA9IG51bGxcbiAgICAgIGNiKG51bGwpXG4gICAgfSwgMTUwKVxuICAgIGlmIChzZWxmLl9pbnRlcnZhbC51bnJlZikgc2VsZi5faW50ZXJ2YWwudW5yZWYoKVxuICB9XG5cbiAgZGVidWcoJ2Nvbm5lY3QnKVxuICBzZWxmLmVtaXQoJ2Nvbm5lY3QnKVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgZGVidWcoJ29uIGNsb3NlJylcbiAgc2VsZi5fZGVzdHJveSgpXG59XG5cblNvY2tldC5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBkZWJ1ZygnZXJyb3I6ICVzJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICBzZWxmLl9kZXN0cm95KGVycilcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuXG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlcih1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IHBhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24oKXtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5lbmdpbmUuaWQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlO1xuICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uKG5zcCl7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKXtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZW5naW5lLmlkO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2bmV0IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZygpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHNvY2tldCl7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbihlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWI7XG4gIHdoaWxlIChzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKSkgc3ViLmRlc3Ryb3koKTtcblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdvbmNsb3NlJyk7XG5cbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG5cbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBoYXNCaW4gPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBjb25uZWN0aW5nOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDEsXG4gIHBpbmc6IDEsXG4gIHBvbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KGlvLCBuc3Ape1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGlmICh0aGlzLmlvLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuc3ViRXZlbnRzKCk7XG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgZW1pdGAuXG4gKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2KXtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhcnNlclR5cGUgPSBwYXJzZXIuRVZFTlQ7IC8vIGRlZmF1bHRcbiAgaWYgKGhhc0JpbihhcmdzKSkgeyBwYXJzZXJUeXBlID0gcGFyc2VyLkJJTkFSWV9FVkVOVDsgfSAvLyBiaW5hcnlcbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogcGFyc2VyVHlwZSwgZGF0YTogYXJncyB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICBkZWxldGUgdGhpcy5mbGFncztcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT0gdGhpcy5uc3ApIHtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5pZDtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgaWYgKHBhY2tldC5uc3AgIT0gdGhpcy5uc3ApIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uKGlkKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgdmFyIHR5cGUgPSBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0s7XG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG4gIH1cblxuICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICB0aGlzLmRlc3Ryb3koKTtcblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAvLyBmaXJlIGV2ZW50c1xuICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uKGNvbXByZXNzKXtcbiAgdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfHwge307XG4gIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCh1cmksIGxvYyl7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgdmFyIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgdmFyIGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKCc6JykgIT09IC0xO1xuICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cbiAgZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gICAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICB2YXIgY3VyUGxhY2VIb2xkZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmogJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIganNvbiA9IHJlcXVpcmUoJ2pzb24zJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgcCA9IHt9O1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gbG9vayB1cCB0eXBlXG4gIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHAuZGF0YSA9IGpzb24ucGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBlcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuIiwidmFyIHRpY2sgPSAxXG52YXIgbWF4VGljayA9IDY1NTM1XG52YXIgcmVzb2x1dGlvbiA9IDRcbnZhciBpbmMgPSBmdW5jdGlvbiAoKSB7XG4gIHRpY2sgPSAodGljayArIDEpICYgbWF4VGlja1xufVxuXG52YXIgdGltZXIgPSBzZXRJbnRlcnZhbChpbmMsICgxMDAwIC8gcmVzb2x1dGlvbikgfCAwKVxuaWYgKHRpbWVyLnVucmVmKSB0aW1lci51bnJlZigpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlY29uZHMpIHtcbiAgdmFyIHNpemUgPSByZXNvbHV0aW9uICogKHNlY29uZHMgfHwgNSlcbiAgdmFyIGJ1ZmZlciA9IFswXVxuICB2YXIgcG9pbnRlciA9IDFcbiAgdmFyIGxhc3QgPSAodGljayAtIDEpICYgbWF4VGlja1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICB2YXIgZGlzdCA9ICh0aWNrIC0gbGFzdCkgJiBtYXhUaWNrXG4gICAgaWYgKGRpc3QgPiBzaXplKSBkaXN0ID0gc2l6ZVxuICAgIGxhc3QgPSB0aWNrXG5cbiAgICB3aGlsZSAoZGlzdC0tKSB7XG4gICAgICBpZiAocG9pbnRlciA9PT0gc2l6ZSkgcG9pbnRlciA9IDBcbiAgICAgIGJ1ZmZlcltwb2ludGVyXSA9IGJ1ZmZlcltwb2ludGVyID09PSAwID8gc2l6ZSAtIDEgOiBwb2ludGVyIC0gMV1cbiAgICAgIHBvaW50ZXIrK1xuICAgIH1cblxuICAgIGlmIChkZWx0YSkgYnVmZmVyW3BvaW50ZXIgLSAxXSArPSBkZWx0YVxuXG4gICAgdmFyIHRvcCA9IGJ1ZmZlcltwb2ludGVyIC0gMV1cbiAgICB2YXIgYnRtID0gYnVmZmVyLmxlbmd0aCA8IHNpemUgPyAwIDogYnVmZmVyW3BvaW50ZXIgPT09IHNpemUgPyAwIDogcG9pbnRlcl1cblxuICAgIHJldHVybiBidWZmZXIubGVuZ3RoIDwgcmVzb2x1dGlvbiA/IHRvcCA6ICh0b3AgLSBidG0pICogcmVzb2x1dGlvbiAvIGJ1ZmZlci5sZW5ndGhcbiAgfVxufVxuIiwidmFyIENsaWVudFJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi9yZXF1ZXN0JylcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgc3RhdHVzQ29kZXMgPSByZXF1aXJlKCdidWlsdGluLXN0YXR1cy1jb2RlcycpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxudmFyIGh0dHAgPSBleHBvcnRzXG5cbmh0dHAucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKVxuXHRcdG9wdHMgPSB1cmwucGFyc2Uob3B0cylcblx0ZWxzZVxuXHRcdG9wdHMgPSBleHRlbmQob3B0cylcblxuXHQvLyBOb3JtYWxseSwgdGhlIHBhZ2UgaXMgbG9hZGVkIGZyb20gaHR0cCBvciBodHRwcywgc28gbm90IHNwZWNpZnlpbmcgYSBwcm90b2NvbFxuXHQvLyB3aWxsIHJlc3VsdCBpbiBhICh2YWxpZCkgcHJvdG9jb2wtcmVsYXRpdmUgdXJsLiBIb3dldmVyLCB0aGlzIHdvbid0IHdvcmsgaWZcblx0Ly8gdGhlIHByb3RvY29sIGlzIHNvbWV0aGluZyBlbHNlLCBsaWtlICdmaWxlOidcblx0dmFyIGRlZmF1bHRQcm90b2NvbCA9IGdsb2JhbC5sb2NhdGlvbi5wcm90b2NvbC5zZWFyY2goL15odHRwcz86JC8pID09PSAtMSA/ICdodHRwOicgOiAnJ1xuXG5cdHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgfHwgZGVmYXVsdFByb3RvY29sXG5cdHZhciBob3N0ID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3Rcblx0dmFyIHBvcnQgPSBvcHRzLnBvcnRcblx0dmFyIHBhdGggPSBvcHRzLnBhdGggfHwgJy8nXG5cblx0Ly8gTmVjZXNzYXJ5IGZvciBJUHY2IGFkZHJlc3Nlc1xuXHRpZiAoaG9zdCAmJiBob3N0LmluZGV4T2YoJzonKSAhPT0gLTEpXG5cdFx0aG9zdCA9ICdbJyArIGhvc3QgKyAnXSdcblxuXHQvLyBUaGlzIG1heSBiZSBhIHJlbGF0aXZlIHVybC4gVGhlIGJyb3dzZXIgc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGludGVycHJldCBpdCBjb3JyZWN0bHkuXG5cdG9wdHMudXJsID0gKGhvc3QgPyAocHJvdG9jb2wgKyAnLy8nICsgaG9zdCkgOiAnJykgKyAocG9ydCA/ICc6JyArIHBvcnQgOiAnJykgKyBwYXRoXG5cdG9wdHMubWV0aG9kID0gKG9wdHMubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpXG5cdG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fVxuXG5cdC8vIEFsc28gdmFsaWQgb3B0cy5hdXRoLCBvcHRzLm1vZGVcblxuXHR2YXIgcmVxID0gbmV3IENsaWVudFJlcXVlc3Qob3B0cylcblx0aWYgKGNiKVxuXHRcdHJlcS5vbigncmVzcG9uc2UnLCBjYilcblx0cmV0dXJuIHJlcVxufVxuXG5odHRwLmdldCA9IGZ1bmN0aW9uIGdldCAob3B0cywgY2IpIHtcblx0dmFyIHJlcSA9IGh0dHAucmVxdWVzdChvcHRzLCBjYilcblx0cmVxLmVuZCgpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5BZ2VudCA9IGZ1bmN0aW9uICgpIHt9XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNFxuXG5odHRwLlNUQVRVU19DT0RFUyA9IHN0YXR1c0NvZGVzXG5cbmh0dHAuTUVUSE9EUyA9IFtcblx0J0NIRUNLT1VUJyxcblx0J0NPTk5FQ1QnLFxuXHQnQ09QWScsXG5cdCdERUxFVEUnLFxuXHQnR0VUJyxcblx0J0hFQUQnLFxuXHQnTE9DSycsXG5cdCdNLVNFQVJDSCcsXG5cdCdNRVJHRScsXG5cdCdNS0FDVElWSVRZJyxcblx0J01LQ09MJyxcblx0J01PVkUnLFxuXHQnTk9USUZZJyxcblx0J09QVElPTlMnLFxuXHQnUEFUQ0gnLFxuXHQnUE9TVCcsXG5cdCdQUk9QRklORCcsXG5cdCdQUk9QUEFUQ0gnLFxuXHQnUFVSR0UnLFxuXHQnUFVUJyxcblx0J1JFUE9SVCcsXG5cdCdTRUFSQ0gnLFxuXHQnU1VCU0NSSUJFJyxcblx0J1RSQUNFJyxcblx0J1VOTE9DSycsXG5cdCdVTlNVQlNDUklCRSdcbl0iLCJleHBvcnRzLmZldGNoID0gaXNGdW5jdGlvbihnbG9iYWwuZmV0Y2gpICYmIGlzRnVuY3Rpb24oZ2xvYmFsLlJlYWRhYmxlQnl0ZVN0cmVhbSlcblxuZXhwb3J0cy5ibG9iQ29uc3RydWN0b3IgPSBmYWxzZVxudHJ5IHtcblx0bmV3IEJsb2IoW25ldyBBcnJheUJ1ZmZlcigxKV0pXG5cdGV4cG9ydHMuYmxvYkNvbnN0cnVjdG9yID0gdHJ1ZVxufSBjYXRjaCAoZSkge31cblxudmFyIHhociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuLy8gSWYgbG9jYXRpb24uaG9zdCBpcyBlbXB0eSwgZS5nLiBpZiB0aGlzIHBhZ2Uvd29ya2VyIHdhcyBsb2FkZWRcbi8vIGZyb20gYSBCbG9iLCB0aGVuIHVzZSBleGFtcGxlLmNvbSB0byBhdm9pZCBhbiBlcnJvclxueGhyLm9wZW4oJ0dFVCcsIGdsb2JhbC5sb2NhdGlvbi5ob3N0ID8gJy8nIDogJ2h0dHBzOi8vZXhhbXBsZS5jb20nKVxuXG5mdW5jdGlvbiBjaGVja1R5cGVTdXBwb3J0ICh0eXBlKSB7XG5cdHRyeSB7XG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHR5cGVcblx0XHRyZXR1cm4geGhyLnJlc3BvbnNlVHlwZSA9PT0gdHlwZVxuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2Vcbn1cblxuLy8gRm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIFNhZmFyaSA3LjAgcmVwb3J0cyB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnb2JqZWN0Jy5cbi8vIFNhZmFyaSA3LjEgYXBwZWFycyB0byBoYXZlIGZpeGVkIHRoaXMgYnVnLlxudmFyIGhhdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnXG52YXIgaGF2ZVNsaWNlID0gaGF2ZUFycmF5QnVmZmVyICYmIGlzRnVuY3Rpb24oZ2xvYmFsLkFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSlcblxuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IGhhdmVBcnJheUJ1ZmZlciAmJiBjaGVja1R5cGVTdXBwb3J0KCdhcnJheWJ1ZmZlcicpXG4vLyBUaGVzZSBuZXh0IHR3byB0ZXN0cyB1bmF2b2lkYWJseSBzaG93IHdhcm5pbmdzIGluIENocm9tZS4gU2luY2UgZmV0Y2ggd2lsbCBhbHdheXNcbi8vIGJlIHVzZWQgaWYgaXQncyBhdmFpbGFibGUsIGp1c3QgcmV0dXJuIGZhbHNlIGZvciB0aGVzZSB0byBhdm9pZCB0aGUgd2FybmluZ3MuXG5leHBvcnRzLm1zc3RyZWFtID0gIWV4cG9ydHMuZmV0Y2ggJiYgaGF2ZVNsaWNlICYmIGNoZWNrVHlwZVN1cHBvcnQoJ21zLXN0cmVhbScpXG5leHBvcnRzLm1vemNodW5rZWRhcnJheWJ1ZmZlciA9ICFleHBvcnRzLmZldGNoICYmIGhhdmVBcnJheUJ1ZmZlciAmJlxuXHRjaGVja1R5cGVTdXBwb3J0KCdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcicpXG5leHBvcnRzLm92ZXJyaWRlTWltZVR5cGUgPSBpc0Z1bmN0aW9uKHhoci5vdmVycmlkZU1pbWVUeXBlKVxuZXhwb3J0cy52YkFycmF5ID0gaXNGdW5jdGlvbihnbG9iYWwuVkJBcnJheSlcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG54aHIgPSBudWxsIC8vIEhlbHAgZ2NcbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgdG9BcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ3RvLWFycmF5YnVmZmVyJylcblxudmFyIEluY29taW5nTWVzc2FnZSA9IHJlc3BvbnNlLkluY29taW5nTWVzc2FnZVxudmFyIHJTdGF0ZXMgPSByZXNwb25zZS5yZWFkeVN0YXRlc1xuXG5mdW5jdGlvbiBkZWNpZGVNb2RlIChwcmVmZXJCaW5hcnkpIHtcblx0aWYgKGNhcGFiaWxpdHkuZmV0Y2gpIHtcblx0XHRyZXR1cm4gJ2ZldGNoJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubW96Y2h1bmtlZGFycmF5YnVmZmVyKSB7XG5cdFx0cmV0dXJuICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcidcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1zc3RyZWFtKSB7XG5cdFx0cmV0dXJuICdtcy1zdHJlYW0nXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5hcnJheWJ1ZmZlciAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ2FycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkudmJBcnJheSAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ3RleHQ6dmJhcnJheSdcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gJ3RleHQnXG5cdH1cbn1cblxudmFyIENsaWVudFJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzdHJlYW0uV3JpdGFibGUuY2FsbChzZWxmKVxuXG5cdHNlbGYuX29wdHMgPSBvcHRzXG5cdHNlbGYuX2JvZHkgPSBbXVxuXHRzZWxmLl9oZWFkZXJzID0ge31cblx0aWYgKG9wdHMuYXV0aClcblx0XHRzZWxmLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgbmV3IEJ1ZmZlcihvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKSlcblx0T2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0c2VsZi5zZXRIZWFkZXIobmFtZSwgb3B0cy5oZWFkZXJzW25hbWVdKVxuXHR9KVxuXG5cdHZhciBwcmVmZXJCaW5hcnlcblx0aWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSlcblxuXHRzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi5fb25GaW5pc2goKVxuXHR9KVxufVxuXG5pbmhlcml0cyhDbGllbnRSZXF1ZXN0LCBzdHJlYW0uV3JpdGFibGUpXG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0dmFyIGxvd2VyTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXHQvLyBUaGlzIGNoZWNrIGlzIG5vdCBuZWNlc3NhcnksIGJ1dCBpdCBwcmV2ZW50cyB3YXJuaW5ncyBmcm9tIGJyb3dzZXJzIGFib3V0IHNldHRpbmcgdW5zYWZlXG5cdC8vIGhlYWRlcnMuIFRvIGJlIGhvbmVzdCBJJ20gbm90IGVudGlyZWx5IHN1cmUgaGlkaW5nIHRoZXNlIHdhcm5pbmdzIGlzIGEgZ29vZCB0aGluZywgYnV0XG5cdC8vIGh0dHAtYnJvd3NlcmlmeSBkaWQgaXQsIHNvIEkgd2lsbCB0b28uXG5cdGlmICh1bnNhZmVIZWFkZXJzLmluZGV4T2YobG93ZXJOYW1lKSAhPT0gLTEpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5faGVhZGVyc1tsb3dlck5hbWVdID0ge1xuXHRcdG5hbWU6IG5hbWUsXG5cdFx0dmFsdWU6IHZhbHVlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHJldHVybiBzZWxmLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0udmFsdWVcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGRlbGV0ZSBzZWxmLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXHR2YXIgb3B0cyA9IHNlbGYuX29wdHNcblxuXHR2YXIgaGVhZGVyc09iaiA9IHNlbGYuX2hlYWRlcnNcblx0dmFyIGJvZHlcblx0aWYgKG9wdHMubWV0aG9kID09PSAnUE9TVCcgfHwgb3B0cy5tZXRob2QgPT09ICdQVVQnIHx8IG9wdHMubWV0aG9kID09PSAnUEFUQ0gnKSB7XG5cdFx0aWYgKGNhcGFiaWxpdHkuYmxvYkNvbnN0cnVjdG9yKSB7XG5cdFx0XHRib2R5ID0gbmV3IGdsb2JhbC5CbG9iKHNlbGYuX2JvZHkubWFwKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdFx0cmV0dXJuIHRvQXJyYXlCdWZmZXIoYnVmZmVyKVxuXHRcdFx0fSksIHtcblx0XHRcdFx0dHlwZTogKGhlYWRlcnNPYmpbJ2NvbnRlbnQtdHlwZSddIHx8IHt9KS52YWx1ZSB8fCAnJ1xuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZ2V0IHV0Zjggc3RyaW5nXG5cdFx0XHRib2R5ID0gQnVmZmVyLmNvbmNhdChzZWxmLl9ib2R5KS50b1N0cmluZygpXG5cdFx0fVxuXHR9XG5cblx0aWYgKHNlbGYuX21vZGUgPT09ICdmZXRjaCcpIHtcblx0XHR2YXIgaGVhZGVycyA9IE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLm1hcChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIFtoZWFkZXJzT2JqW25hbWVdLm5hbWUsIGhlYWRlcnNPYmpbbmFtZV0udmFsdWVdXG5cdFx0fSlcblxuXHRcdGdsb2JhbC5mZXRjaChzZWxmLl9vcHRzLnVybCwge1xuXHRcdFx0bWV0aG9kOiBzZWxmLl9vcHRzLm1ldGhvZCxcblx0XHRcdGhlYWRlcnM6IGhlYWRlcnMsXG5cdFx0XHRib2R5OiBib2R5LFxuXHRcdFx0bW9kZTogJ2NvcnMnLFxuXHRcdFx0Y3JlZGVudGlhbHM6IG9wdHMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJ1xuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2Vcblx0XHRcdHNlbGYuX2Nvbm5lY3QoKVxuXHRcdH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCByZWFzb24pXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHR2YXIgeGhyID0gc2VsZi5feGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKHNlbGYuX29wdHMubWV0aG9kLCBzZWxmLl9vcHRzLnVybCwgdHJ1ZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIENhbid0IHNldCByZXNwb25zZVR5cGUgb24gcmVhbGx5IG9sZCBicm93c2Vyc1xuXHRcdGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gc2VsZi5fbW9kZS5zcGxpdCgnOicpWzBdXG5cblx0XHRpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKVxuXHRcdFx0eGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0cy53aXRoQ3JlZGVudGlhbHNcblxuXHRcdGlmIChzZWxmLl9tb2RlID09PSAndGV4dCcgJiYgJ292ZXJyaWRlTWltZVR5cGUnIGluIHhocilcblx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJylcblxuXHRcdE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlcnNPYmpbbmFtZV0ubmFtZSwgaGVhZGVyc09ialtuYW1lXS52YWx1ZSlcblx0XHR9KVxuXG5cdFx0c2VsZi5fcmVzcG9uc2UgPSBudWxsXG5cdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHN3aXRjaCAoeGhyLnJlYWR5U3RhdGUpIHtcblx0XHRcdFx0Y2FzZSByU3RhdGVzLkxPQURJTkc6XG5cdFx0XHRcdGNhc2UgclN0YXRlcy5ET05FOlxuXHRcdFx0XHRcdHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE5lY2Vzc2FyeSBmb3Igc3RyZWFtaW5nIGluIEZpcmVmb3gsIHNpbmNlIHhoci5yZXNwb25zZSBpcyBPTkxZIGRlZmluZWRcblx0XHQvLyBpbiBvbnByb2dyZXNzLCBub3QgaW4gb25yZWFkeXN0YXRlY2hhbmdlIHdpdGggeGhyLnJlYWR5U3RhdGUgPSAzXG5cdFx0aWYgKHNlbGYuX21vZGUgPT09ICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcicpIHtcblx0XHRcdHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLl9vblhIUlByb2dyZXNzKClcblx0XHRcdH1cblx0XHR9XG5cblx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWEhSIGVycm9yJykpXG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5zZW5kKGJvZHkpXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgeGhyLnN0YXR1cyBpcyByZWFkYWJsZSBhbmQgbm9uLXplcm8sIGluZGljYXRpbmcgbm8gZXJyb3IuXG4gKiBFdmVuIHRob3VnaCB0aGUgc3BlYyBzYXlzIGl0IHNob3VsZCBiZSBhdmFpbGFibGUgaW4gcmVhZHlTdGF0ZSAzLFxuICogYWNjZXNzaW5nIGl0IHRocm93cyBhbiBleGNlcHRpb24gaW4gSUU4XG4gKi9cbmZ1bmN0aW9uIHN0YXR1c1ZhbGlkICh4aHIpIHtcblx0dHJ5IHtcblx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1c1xuXHRcdHJldHVybiAoc3RhdHVzICE9PSBudWxsICYmIHN0YXR1cyAhPT0gMClcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vblhIUlByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoIXN0YXR1c1ZhbGlkKHNlbGYuX3hocikgfHwgc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXG5cdGlmICghc2VsZi5fcmVzcG9uc2UpXG5cdFx0c2VsZi5fY29ubmVjdCgpXG5cblx0c2VsZi5fcmVzcG9uc2UuX29uWEhSUHJvZ3Jlc3MoKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRzZWxmLl9yZXNwb25zZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2Uoc2VsZi5feGhyLCBzZWxmLl9mZXRjaFJlc3BvbnNlLCBzZWxmLl9tb2RlKVxuXHRzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgc2VsZi5fcmVzcG9uc2UpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHNlbGYuX2JvZHkucHVzaChjaHVuaylcblx0Y2IoKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IENsaWVudFJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9kZXN0cm95ZWQgPSB0cnVlXG5cdGlmIChzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9yZXNwb25zZS5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5feGhyKVxuXHRcdHNlbGYuX3hoci5hYm9ydCgpXG5cdC8vIEN1cnJlbnRseSwgdGhlcmUgaXNuJ3QgYSB3YXkgdG8gdHJ1bHkgYWJvcnQgYSBmZXRjaC5cblx0Ly8gSWYgeW91IGxpa2UgYmlrZXNoZWRkaW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMjdcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2IgPSBkYXRhXG5cdFx0ZGF0YSA9IHVuZGVmaW5lZFxuXHR9XG5cblx0c3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbChzZWxmLCBkYXRhLCBlbmNvZGluZywgY2IpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmZsdXNoSGVhZGVycyA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldE5vRGVsYXkgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0U29ja2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge31cblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLXNldHJlcXVlc3RoZWFkZXIlMjglMjktbWV0aG9kXG52YXIgdW5zYWZlSGVhZGVycyA9IFtcblx0J2FjY2VwdC1jaGFyc2V0Jyxcblx0J2FjY2VwdC1lbmNvZGluZycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnLFxuXHQnY29ubmVjdGlvbicsXG5cdCdjb250ZW50LWxlbmd0aCcsXG5cdCdjb29raWUnLFxuXHQnY29va2llMicsXG5cdCdkYXRlJyxcblx0J2RudCcsXG5cdCdleHBlY3QnLFxuXHQnaG9zdCcsXG5cdCdrZWVwLWFsaXZlJyxcblx0J29yaWdpbicsXG5cdCdyZWZlcmVyJyxcblx0J3RlJyxcblx0J3RyYWlsZXInLFxuXHQndHJhbnNmZXItZW5jb2RpbmcnLFxuXHQndXBncmFkZScsXG5cdCd1c2VyLWFnZW50Jyxcblx0J3ZpYSdcbl1cbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgclN0YXRlcyA9IGV4cG9ydHMucmVhZHlTdGF0ZXMgPSB7XG5cdFVOU0VOVDogMCxcblx0T1BFTkVEOiAxLFxuXHRIRUFERVJTX1JFQ0VJVkVEOiAyLFxuXHRMT0FESU5HOiAzLFxuXHRET05FOiA0XG59XG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSBleHBvcnRzLkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uICh4aHIsIHJlc3BvbnNlLCBtb2RlKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzdHJlYW0uUmVhZGFibGUuY2FsbChzZWxmKVxuXG5cdHNlbGYuX21vZGUgPSBtb2RlXG5cdHNlbGYuaGVhZGVycyA9IHt9XG5cdHNlbGYucmF3SGVhZGVycyA9IFtdXG5cdHNlbGYudHJhaWxlcnMgPSB7fVxuXHRzZWxmLnJhd1RyYWlsZXJzID0gW11cblxuXHQvLyBGYWtlIHRoZSAnY2xvc2UnIGV2ZW50LCBidXQgb25seSBvbmNlICdlbmQnIGZpcmVzXG5cdHNlbGYub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUaGUgbmV4dFRpY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgdGhlICdyZXF1ZXN0JyBtb2R1bGUgZnJvbSBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3Bcblx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuZW1pdCgnY2xvc2UnKVxuXHRcdH0pXG5cdH0pXG5cblx0aWYgKG1vZGUgPT09ICdmZXRjaCcpIHtcblx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2VcblxuXHRcdHNlbGYudXJsID0gcmVzcG9uc2UudXJsXG5cdFx0c2VsZi5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dFxuXHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIHZlcnNpb24gb2YgZm9yICg8aXRlbT4gb2YgPGl0ZXJhYmxlPik6XG5cdFx0Ly8gZm9yICh2YXIgPGl0ZW0+LF9pLF9pdCA9IDxpdGVyYWJsZT5bU3ltYm9sLml0ZXJhdG9yXSgpOyA8aXRlbT4gPSAoX2kgPSBfaXQubmV4dCgpKS52YWx1ZSwhX2kuZG9uZTspXG5cdFx0Zm9yICh2YXIgaGVhZGVyLCBfaSwgX2l0ID0gcmVzcG9uc2UuaGVhZGVyc1tTeW1ib2wuaXRlcmF0b3JdKCk7IGhlYWRlciA9IChfaSA9IF9pdC5uZXh0KCkpLnZhbHVlLCAhX2kuZG9uZTspIHtcblx0XHRcdHNlbGYuaGVhZGVyc1toZWFkZXJbMF0udG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJbMV1cblx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuXHRcdH1cblxuXHRcdC8vIFRPRE86IHRoaXMgZG9lc24ndCByZXNwZWN0IGJhY2twcmVzc3VyZS4gT25jZSBXcml0YWJsZVN0cmVhbSBpcyBhdmFpbGFibGUsIHRoaXMgY2FuIGJlIGZpeGVkXG5cdFx0dmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcblx0XHRmdW5jdGlvbiByZWFkICgpIHtcblx0XHRcdHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGlmIChyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRcdHNlbGYucHVzaChudWxsKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucHVzaChuZXcgQnVmZmVyKHJlc3VsdC52YWx1ZSkpXG5cdFx0XHRcdHJlYWQoKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0cmVhZCgpXG5cblx0fSBlbHNlIHtcblx0XHRzZWxmLl94aHIgPSB4aHJcblx0XHRzZWxmLl9wb3MgPSAwXG5cblx0XHRzZWxmLnVybCA9IHhoci5yZXNwb25zZVVSTFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSB4aHIuc3RhdHVzVGV4dFxuXHRcdHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9cXHI/XFxuLylcblx0XHRoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBoZWFkZXIubWF0Y2goL14oW146XSspOlxccyooLiopLylcblx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuaGVhZGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gW11cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0ucHVzaChtYXRjaGVzWzJdKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSArPSAnLCAnICsgbWF0Y2hlc1syXVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gbWF0Y2hlc1syXVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0pXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHNlbGYuX2NoYXJzZXQgPSAneC11c2VyLWRlZmluZWQnXG5cdFx0aWYgKCFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGUpIHtcblx0XHRcdHZhciBtaW1lVHlwZSA9IHNlbGYucmF3SGVhZGVyc1snbWltZS10eXBlJ11cblx0XHRcdGlmIChtaW1lVHlwZSkge1xuXHRcdFx0XHR2YXIgY2hhcnNldE1hdGNoID0gbWltZVR5cGUubWF0Y2goLztcXHMqY2hhcnNldD0oW147XSkoO3wkKS8pXG5cdFx0XHRcdGlmIChjaGFyc2V0TWF0Y2gpIHtcblx0XHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gY2hhcnNldE1hdGNoWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gJ3V0Zi04JyAvLyBiZXN0IGd1ZXNzXG5cdFx0fVxuXHR9XG59XG5cbmluaGVyaXRzKEluY29taW5nTWVzc2FnZSwgc3RyZWFtLlJlYWRhYmxlKVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge31cblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHhociA9IHNlbGYuX3hoclxuXG5cdHZhciByZXNwb25zZSA9IG51bGxcblx0c3dpdGNoIChzZWxmLl9tb2RlKSB7XG5cdFx0Y2FzZSAndGV4dDp2YmFycmF5JzogLy8gRm9yIElFOVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBUaGlzIGZhaWxzIGluIElFOFxuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBnbG9iYWwuVkJBcnJheSh4aHIucmVzcG9uc2VCb2R5KS50b0FycmF5KClcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRpZiAocmVzcG9uc2UgIT09IG51bGwpIHtcblx0XHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIocmVzcG9uc2UpKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmFsbHMgdGhyb3VnaCBpbiBJRThcdFxuXHRcdGNhc2UgJ3RleHQnOlxuXHRcdFx0dHJ5IHsgLy8gVGhpcyB3aWxsIGZhaWwgd2hlbiByZWFkeVN0YXRlID0gMyBpbiBJRTkuIFN3aXRjaCBtb2RlIGFuZCB3YWl0IGZvciByZWFkeVN0YXRlID0gNFxuXHRcdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHRcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5fbW9kZSA9ICd0ZXh0OnZiYXJyYXknXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRpZiAocmVzcG9uc2UubGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdHZhciBuZXdEYXRhID0gcmVzcG9uc2Uuc3Vic3RyKHNlbGYuX3Bvcylcblx0XHRcdFx0aWYgKHNlbGYuX2NoYXJzZXQgPT09ICd4LXVzZXItZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihuZXdEYXRhLmxlbmd0aClcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0XHRidWZmZXJbaV0gPSBuZXdEYXRhLmNoYXJDb2RlQXQoaSkgJiAweGZmXG5cblx0XHRcdFx0XHRzZWxmLnB1c2goYnVmZmVyKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYucHVzaChuZXdEYXRhLCBzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX3BvcyA9IHJlc3BvbnNlLmxlbmd0aFxuXHRcdFx0fVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuRE9ORSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcic6IC8vIHRha2Ugd2hvbGVcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORyB8fCAhcmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtcy1zdHJlYW0nOlxuXHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2Vcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5MT0FESU5HKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBnbG9iYWwuTVNTdHJlYW1SZWFkZXIoKVxuXHRcdFx0cmVhZGVyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChyZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0LnNsaWNlKHNlbGYuX3BvcykpKSlcblx0XHRcdFx0XHRzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHR9XG5cdFx0XHQvLyByZWFkZXIub25lcnJvciA9ID8/PyAvLyBUT0RPOiB0aGlzXG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzcG9uc2UpXG5cdFx0XHRicmVha1xuXHR9XG5cblx0Ly8gVGhlIG1zLXN0cmVhbSBjYXNlIGhhbmRsZXMgZW5kIHNlcGFyYXRlbHkgaW4gcmVhZGVyLm9ubG9hZCgpXG5cdGlmIChzZWxmLl94aHIucmVhZHlTdGF0ZSA9PT0gclN0YXRlcy5ET05FICYmIHNlbGYuX21vZGUgIT09ICdtcy1zdHJlYW0nKSB7XG5cdFx0c2VsZi5wdXNoKG51bGwpXG5cdH1cbn1cbiIsIi8qIGdsb2JhbCBCbG9iLCBVUkwgKi9cblxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCbG9iVVJMIChzdHJlYW0sIG1pbWVUeXBlLCBjYikge1xuICBjYiA9IG9uY2UoY2IpXG4gIHZhciBjaHVua3MgPSBbXVxuICBzdHJlYW1cbiAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgIH0pXG4gICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYmxvYiA9IG1pbWVUeXBlID8gbmV3IEJsb2IoY2h1bmtzLCB7IHR5cGU6IG1pbWVUeXBlIH0pIDogbmV3IEJsb2IoY2h1bmtzKVxuICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgIGNiKG51bGwsIHVybClcbiAgICB9KVxuICAgIC5vbignZXJyb3InLCBjYilcbn1cbiIsInZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QnVmZmVyIChzdHJlYW0sIGxlbmd0aCwgY2IpIHtcbiAgY2IgPSBvbmNlKGNiKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBvZmZzZXQgPSAwXG4gIHN0cmVhbVxuICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgY2h1bmsuY29weShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgICB9KVxuICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCkgeyBjYihudWxsLCBidWYpIH0pXG4gICAgLm9uKCdlcnJvcicsIGNiKVxufVxuIiwidmFyIGFkZHJUb0lQUG9ydCA9IHJlcXVpcmUoJ2FkZHItdG8taXAtcG9ydCcpXG52YXIgaXBhZGRyID0gcmVxdWlyZSgnaXBhZGRyLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWRkcnMpIHtcbiAgaWYgKHR5cGVvZiBhZGRycyA9PT0gJ3N0cmluZycpIHtcbiAgICBhZGRycyA9IFsgYWRkcnMgXVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYWRkcnMubWFwKGZ1bmN0aW9uIChhZGRyKSB7XG4gICAgdmFyIHMgPSBhZGRyVG9JUFBvcnQoYWRkcilcbiAgICBpZiAocy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZGRyZXNzIGZvcm1hdCwgZXhwZWN0aW5nOiAxMC4xMC4xMC41OjEyOCcpXG4gICAgfVxuXG4gICAgdmFyIGlwID0gaXBhZGRyLnBhcnNlKHNbMF0pXG4gICAgdmFyIGlwQnVmID0gbmV3IEJ1ZmZlcihpcC50b0J5dGVBcnJheSgpKVxuICAgIHZhciBwb3J0ID0gTnVtYmVyKHNbMV0pXG4gICAgdmFyIHBvcnRCdWYgPSBuZXcgQnVmZmVyKDIpXG4gICAgcG9ydEJ1Zi53cml0ZVVJbnQxNkJFKHBvcnQsIDApXG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2lwQnVmLCBwb3J0QnVmXSlcbiAgfSkpXG59XG5cbi8qKlxuICogQWxzbyBzdXBwb3J0IHRoaXMgdXNhZ2U6XG4gKiAgIHN0cmluZzJjb21wYWN0Lm11bHRpKFsgJzEwLjEwLjEwLjU6MTI4JywgJzEwMC41Ni41OC45OToyODUyNScgXSlcbiAqXG4gKiBmb3IgcGFyYWxsZWxpc20gd2l0aCB0aGUgYGNvbXBhY3Qyc3RyaW5nYCBtb2R1bGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzLm11bHRpID0gbW9kdWxlLmV4cG9ydHNcbm1vZHVsZS5leHBvcnRzLm11bHRpNiA9IG1vZHVsZS5leHBvcnRzXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5Db3B5cmlnaHQgKGMpIDIwMTEsIENocmlzIFVtYmVsXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gICAgICBcbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gXG5USEUgU09GVFdBUkUuXG4qL1xuXG52YXIgYmFzZTMyID0gcmVxdWlyZSgnLi90aGlydHktdHdvJyk7XG5cbmV4cG9ydHMuZW5jb2RlID0gYmFzZTMyLmVuY29kZTtcbmV4cG9ydHMuZGVjb2RlID0gYmFzZTMyLmRlY29kZTtcbiIsIi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5Db3B5cmlnaHQgKGMpIDIwMTEsIENocmlzIFVtYmVsXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4qL1xuXG52YXIgY2hhclRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiO1xudmFyIGJ5dGVUYWJsZSA9IFtcbiAgICAweGZmLCAweGZmLCAweDFhLCAweDFiLCAweDFjLCAweDFkLCAweDFlLCAweDFmLFxuICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gICAgMHhmZiwgMHgwMCwgMHgwMSwgMHgwMiwgMHgwMywgMHgwNCwgMHgwNSwgMHgwNixcbiAgICAweDA3LCAweDA4LCAweDA5LCAweDBhLCAweDBiLCAweDBjLCAweDBkLCAweDBlLFxuICAgIDB4MGYsIDB4MTAsIDB4MTEsIDB4MTIsIDB4MTMsIDB4MTQsIDB4MTUsIDB4MTYsXG4gICAgMHgxNywgMHgxOCwgMHgxOSwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgICAweGZmLCAweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDA0LCAweDA1LCAweDA2LFxuICAgIDB4MDcsIDB4MDgsIDB4MDksIDB4MGEsIDB4MGIsIDB4MGMsIDB4MGQsIDB4MGUsXG4gICAgMHgwZiwgMHgxMCwgMHgxMSwgMHgxMiwgMHgxMywgMHgxNCwgMHgxNSwgMHgxNixcbiAgICAweDE3LCAweDE4LCAweDE5LCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmXG5dO1xuXG5mdW5jdGlvbiBxdWludGV0Q291bnQoYnVmZikge1xuICAgIHZhciBxdWludGV0cyA9IE1hdGguZmxvb3IoYnVmZi5sZW5ndGggLyA1KTtcbiAgICByZXR1cm4gYnVmZi5sZW5ndGggJSA1ID09IDAgPyBxdWludGV0czogcXVpbnRldHMgKyAxO1xufVxuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKHBsYWluKSB7XG4gICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihwbGFpbikpe1xuICAgIFx0cGxhaW4gPSBuZXcgQnVmZmVyKHBsYWluKTtcbiAgICB9XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgc2hpZnRJbmRleCA9IDA7XG4gICAgdmFyIGRpZ2l0ID0gMDtcbiAgICB2YXIgZW5jb2RlZCA9IG5ldyBCdWZmZXIocXVpbnRldENvdW50KHBsYWluKSAqIDgpO1xuXG4gICAgLyogYnl0ZSBieSBieXRlIGlzbid0IGFzIHByZXR0eSBhcyBxdWludGV0IGJ5IHF1aW50ZXQgYnV0IHRlc3RzIGEgYml0XG4gICAgICAgIGZhc3Rlci4gd2lsbCBoYXZlIHRvIHJldmlzaXQuICovXG4gICAgd2hpbGUoaSA8IHBsYWluLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHBsYWluW2ldO1xuICAgIFxuICAgICAgICBpZihzaGlmdEluZGV4ID4gMykge1xuICAgICAgICAgICAgZGlnaXQgPSBjdXJyZW50ICYgKDB4ZmYgPj4gc2hpZnRJbmRleCk7XG4gICAgICAgICAgICBzaGlmdEluZGV4ID0gKHNoaWZ0SW5kZXggKyA1KSAlIDg7XG4gICAgICAgICAgICBkaWdpdCA9IChkaWdpdCA8PCBzaGlmdEluZGV4KSB8ICgoaSArIDEgPCBwbGFpbi5sZW5ndGgpID9cbiAgICAgICAgICAgICAgICBwbGFpbltpICsgMV0gOiAwKSA+PiAoOCAtIHNoaWZ0SW5kZXgpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlnaXQgPSAoY3VycmVudCA+PiAoOCAtIChzaGlmdEluZGV4ICsgNSkpKSAmIDB4MWY7XG4gICAgICAgICAgICBzaGlmdEluZGV4ID0gKHNoaWZ0SW5kZXggKyA1KSAlIDg7ICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihzaGlmdEluZGV4ID09IDApIGkrKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZW5jb2RlZFtqXSA9IGNoYXJUYWJsZS5jaGFyQ29kZUF0KGRpZ2l0KTtcbiAgICAgICAgaisrO1xuICAgIH1cblxuICAgIGZvcihpID0gajsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspXG4gICAgICAgIGVuY29kZWRbaV0gPSAweDNkOyAvLyc9Jy5jaGFyQ29kZUF0KDApXG4gICAgICAgIFxuICAgIHJldHVybiBlbmNvZGVkO1xufTtcblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgdmFyIHNoaWZ0SW5kZXggPSAwO1xuICAgIHZhciBwbGFpbkRpZ2l0ID0gMDtcbiAgICB2YXIgcGxhaW5DaGFyO1xuICAgIHZhciBwbGFpblBvcyA9IDA7XG4gICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihlbmNvZGVkKSl7XG4gICAgXHRlbmNvZGVkID0gbmV3IEJ1ZmZlcihlbmNvZGVkKTtcbiAgICB9XG4gICAgdmFyIGRlY29kZWQgPSBuZXcgQnVmZmVyKE1hdGguY2VpbChlbmNvZGVkLmxlbmd0aCAqIDUgLyA4KSk7XG4gICAgXG4gICAgLyogYnl0ZSBieSBieXRlIGlzbid0IGFzIHByZXR0eSBhcyBvY3RldCBieSBvY3RldCBidXQgdGVzdHMgYSBiaXRcbiAgICAgICAgZmFzdGVyLiB3aWxsIGhhdmUgdG8gcmV2aXNpdC4gKi8gICAgXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICBcdGlmKGVuY29kZWRbaV0gPT0gMHgzZCl7IC8vJz0nXG4gICAgXHRcdGJyZWFrO1xuICAgIFx0fVxuICAgIFx0XHRcbiAgICAgICAgdmFyIGVuY29kZWRCeXRlID0gZW5jb2RlZFtpXSAtIDB4MzA7XG4gICAgICAgIFxuICAgICAgICBpZihlbmNvZGVkQnl0ZSA8IGJ5dGVUYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBsYWluRGlnaXQgPSBieXRlVGFibGVbZW5jb2RlZEJ5dGVdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihzaGlmdEluZGV4IDw9IDMpIHtcbiAgICAgICAgICAgICAgICBzaGlmdEluZGV4ID0gKHNoaWZ0SW5kZXggKyA1KSAlIDg7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoc2hpZnRJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYWluQ2hhciB8PSBwbGFpbkRpZ2l0O1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkW3BsYWluUG9zXSA9IHBsYWluQ2hhcjtcbiAgICAgICAgICAgICAgICAgICAgcGxhaW5Qb3MrKztcbiAgICAgICAgICAgICAgICAgICAgcGxhaW5DaGFyID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbGFpbkNoYXIgfD0gMHhmZiAmIChwbGFpbkRpZ2l0IDw8ICg4IC0gc2hpZnRJbmRleCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hpZnRJbmRleCA9IChzaGlmdEluZGV4ICsgNSkgJSA4O1xuICAgICAgICAgICAgICAgIHBsYWluQ2hhciB8PSAweGZmICYgKHBsYWluRGlnaXQgPj4+IHNoaWZ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGRlY29kZWRbcGxhaW5Qb3NdID0gcGxhaW5DaGFyO1xuICAgICAgICAgICAgICAgIHBsYWluUG9zKys7XG5cbiAgICAgICAgICAgICAgICBwbGFpbkNoYXIgPSAweGZmICYgKHBsYWluRGlnaXQgPDwgKDggLSBzaGlmdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IC0gaXQgaXMgbm90IGJhc2UzMiBlbmNvZGVkIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLnNsaWNlKDAsIHBsYWluUG9zKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWYpIHtcblx0Ly8gSWYgdGhlIGJ1ZmZlciBpcyBiYWNrZWQgYnkgYSBVaW50OEFycmF5LCBhIGZhc3RlciB2ZXJzaW9uIHdpbGwgd29ya1xuXHRpZiAoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdC8vIElmIHRoZSBidWZmZXIgaXNuJ3QgYSBzdWJhcnJheSwgcmV0dXJuIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG5cdFx0aWYgKGJ1Zi5ieXRlT2Zmc2V0ID09PSAwICYmIGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdHJldHVybiBidWYuYnVmZmVyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYnVmLmJ1ZmZlci5zbGljZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gZ2V0IGEgcHJvcGVyIGNvcHlcblx0XHRcdHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKVxuXHRcdH1cblx0fVxuXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuXHRcdC8vIFRoaXMgaXMgdGhlIHNsb3cgdmVyc2lvbiB0aGF0IHdpbGwgd29yayB3aXRoIGFueSBCdWZmZXJcblx0XHQvLyBpbXBsZW1lbnRhdGlvbiAoZXZlbiBpbiBvbGQgYnJvd3NlcnMpXG5cdFx0dmFyIGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KGJ1Zi5sZW5ndGgpXG5cdFx0dmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnJheUNvcHlbaV0gPSBidWZbaV1cblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5Q29weS5idWZmZXJcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuXHR9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IERpc2NvdmVyeVxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd0b3JyZW50LWRpc2NvdmVyeScpXG52YXIgREhUID0gcmVxdWlyZSgnYml0dG9ycmVudC1kaHQvY2xpZW50JykgLy8gZW1wdHkgb2JqZWN0IGluIGJyb3dzZXJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcGFyYWxsZWwgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwnKVxudmFyIFRyYWNrZXIgPSByZXF1aXJlKCdiaXR0b3JyZW50LXRyYWNrZXIvY2xpZW50JylcblxuaW5oZXJpdHMoRGlzY292ZXJ5LCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIERpc2NvdmVyeSAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIERpc2NvdmVyeSkpIHJldHVybiBuZXcgRGlzY292ZXJ5KG9wdHMpXG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG5cbiAgaWYgKCFvcHRzLnBlZXJJZCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYHBlZXJJZGAgaXMgcmVxdWlyZWQnKVxuICBpZiAoIW9wdHMuaW5mb0hhc2gpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBpbmZvSGFzaGAgaXMgcmVxdWlyZWQnKVxuICBpZiAoIXByb2Nlc3MuYnJvd3NlciAmJiAhb3B0cy5wb3J0KSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgcG9ydGAgaXMgcmVxdWlyZWQnKVxuXG4gIHNlbGYucGVlcklkID0gdHlwZW9mIG9wdHMucGVlcklkID09PSAnc3RyaW5nJ1xuICAgID8gb3B0cy5wZWVySWRcbiAgICA6IG9wdHMucGVlcklkLnRvU3RyaW5nKCdoZXgnKVxuICBzZWxmLmluZm9IYXNoID0gdHlwZW9mIG9wdHMuaW5mb0hhc2ggPT09ICdzdHJpbmcnXG4gICAgPyBvcHRzLmluZm9IYXNoXG4gICAgOiBvcHRzLmluZm9IYXNoLnRvU3RyaW5nKCdoZXgnKVxuICBzZWxmLl9wb3J0ID0gb3B0cy5wb3J0IC8vIHRvcnJlbnQgcG9ydFxuXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcblxuICBzZWxmLl9hbm5vdW5jZSA9IG9wdHMuYW5ub3VuY2UgfHwgW11cbiAgc2VsZi5faW50ZXJ2YWxNcyA9IG9wdHMuaW50ZXJ2YWxNcyB8fCAoMTUgKiA2MCAqIDEwMDApXG4gIHNlbGYuX3RyYWNrZXJPcHRzID0gbnVsbFxuICBzZWxmLl9kaHRBbm5vdW5jaW5nID0gZmFsc2VcbiAgc2VsZi5fZGh0VGltZW91dCA9IGZhbHNlXG4gIHNlbGYuX2ludGVybmFsREhUID0gZmFsc2UgLy8gaXMgdGhlIERIVCBjcmVhdGVkIGludGVybmFsbHk/XG5cbiAgc2VsZi5fb25XYXJuaW5nID0gZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgfVxuICBzZWxmLl9vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbiAgc2VsZi5fb25ESFRQZWVyID0gZnVuY3Rpb24gKHBlZXIsIGluZm9IYXNoKSB7XG4gICAgaWYgKGluZm9IYXNoLnRvU3RyaW5nKCdoZXgnKSAhPT0gc2VsZi5pbmZvSGFzaCkgcmV0dXJuXG4gICAgc2VsZi5lbWl0KCdwZWVyJywgcGVlci5ob3N0ICsgJzonICsgcGVlci5wb3J0KVxuICB9XG4gIHNlbGYuX29uVHJhY2tlclBlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICAgIHNlbGYuZW1pdCgncGVlcicsIHBlZXIpXG4gIH1cbiAgc2VsZi5fb25UcmFja2VyQW5ub3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCd0cmFja2VyQW5ub3VuY2UnKVxuICB9XG5cbiAgaWYgKG9wdHMudHJhY2tlciA9PT0gZmFsc2UpIHtcbiAgICBzZWxmLnRyYWNrZXIgPSBudWxsXG4gIH0gZWxzZSBpZiAob3B0cy50cmFja2VyICYmIHR5cGVvZiBvcHRzLnRyYWNrZXIgPT09ICdvYmplY3QnKSB7XG4gICAgc2VsZi5fdHJhY2tlck9wdHMgPSBleHRlbmQob3B0cy50cmFja2VyKVxuICAgIHNlbGYudHJhY2tlciA9IHNlbGYuX2NyZWF0ZVRyYWNrZXIoKVxuICB9IGVsc2Uge1xuICAgIHNlbGYudHJhY2tlciA9IHNlbGYuX2NyZWF0ZVRyYWNrZXIoKVxuICB9XG5cbiAgaWYgKG9wdHMuZGh0ID09PSBmYWxzZSB8fCB0eXBlb2YgREhUICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5kaHQgPSBudWxsXG4gIH0gZWxzZSBpZiAob3B0cy5kaHQgJiYgdHlwZW9mIG9wdHMuZGh0LmFkZE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLmRodCA9IG9wdHMuZGh0XG4gIH0gZWxzZSBpZiAob3B0cy5kaHQgJiYgdHlwZW9mIG9wdHMuZGh0ID09PSAnb2JqZWN0Jykge1xuICAgIHNlbGYuZGh0ID0gY3JlYXRlREhUKG9wdHMuZGh0UG9ydCwgb3B0cy5kaHQpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5kaHQgPSBjcmVhdGVESFQob3B0cy5kaHRQb3J0KVxuICB9XG5cbiAgaWYgKHNlbGYuZGh0KSB7XG4gICAgc2VsZi5kaHQub24oJ3BlZXInLCBzZWxmLl9vbkRIVFBlZXIpXG4gICAgc2VsZi5fZGh0QW5ub3VuY2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlREhUIChwb3J0LCBvcHRzKSB7XG4gICAgdmFyIGRodCA9IG5ldyBESFQob3B0cylcbiAgICBkaHQub24oJ3dhcm5pbmcnLCBzZWxmLl9vbldhcm5pbmcpXG4gICAgZGh0Lm9uKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG4gICAgZGh0Lmxpc3Rlbihwb3J0KVxuICAgIHNlbGYuX2ludGVybmFsREhUID0gdHJ1ZVxuICAgIHJldHVybiBkaHRcbiAgfVxufVxuXG5EaXNjb3ZlcnkucHJvdG90eXBlLnVwZGF0ZVBvcnQgPSBmdW5jdGlvbiAocG9ydCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHBvcnQgPT09IHNlbGYuX3BvcnQpIHJldHVyblxuICBzZWxmLl9wb3J0ID0gcG9ydFxuXG4gIGlmIChzZWxmLmRodCkgc2VsZi5fZGh0QW5ub3VuY2UoKVxuXG4gIGlmIChzZWxmLnRyYWNrZXIpIHtcbiAgICBzZWxmLnRyYWNrZXIuc3RvcCgpXG4gICAgc2VsZi50cmFja2VyLmRlc3Ryb3koZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi50cmFja2VyID0gc2VsZi5fY3JlYXRlVHJhY2tlcigpXG4gICAgfSlcbiAgfVxufVxuXG5EaXNjb3ZlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGNsZWFyVGltZW91dChzZWxmLl9kaHRUaW1lb3V0KVxuXG4gIHZhciB0YXNrcyA9IFtdXG5cbiAgaWYgKHNlbGYudHJhY2tlcikge1xuICAgIHNlbGYudHJhY2tlci5zdG9wKClcbiAgICBzZWxmLnRyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ3dhcm5pbmcnLCBzZWxmLl9vbldhcm5pbmcpXG4gICAgc2VsZi50cmFja2VyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG4gICAgc2VsZi50cmFja2VyLnJlbW92ZUxpc3RlbmVyKCdwZWVyJywgc2VsZi5fb25UcmFja2VyUGVlcilcbiAgICBzZWxmLnRyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIHNlbGYuX29uVHJhY2tlckFubm91bmNlKVxuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLnRyYWNrZXIuZGVzdHJveShjYilcbiAgICB9KVxuICB9XG5cbiAgaWYgKHNlbGYuZGh0KSB7XG4gICAgc2VsZi5kaHQucmVtb3ZlTGlzdGVuZXIoJ3BlZXInLCBzZWxmLl9vbkRIVFBlZXIpXG4gIH1cblxuICBpZiAoc2VsZi5faW50ZXJuYWxESFQpIHtcbiAgICBzZWxmLmRodC5yZW1vdmVMaXN0ZW5lcignd2FybmluZycsIHNlbGYuX29uV2FybmluZylcbiAgICBzZWxmLmRodC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9vbkVycm9yKVxuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLmRodC5kZXN0cm95KGNiKVxuICAgIH0pXG4gIH1cblxuICBwYXJhbGxlbCh0YXNrcywgY2IpXG5cbiAgLy8gY2xlYW51cFxuICBzZWxmLmRodCA9IG51bGxcbiAgc2VsZi50cmFja2VyID0gbnVsbFxuICBzZWxmLl9hbm5vdW5jZSA9IG51bGxcbn1cblxuRGlzY292ZXJ5LnByb3RvdHlwZS5fY3JlYXRlVHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIG9wdHMgPSBleHRlbmQoc2VsZi5fdHJhY2tlck9wdHMsIHtcbiAgICBpbmZvSGFzaDogc2VsZi5pbmZvSGFzaCxcbiAgICBhbm5vdW5jZTogc2VsZi5fYW5ub3VuY2UsXG4gICAgcGVlcklkOiBzZWxmLnBlZXJJZCxcbiAgICBwb3J0OiBzZWxmLl9wb3J0XG4gIH0pXG5cbiAgdmFyIHRyYWNrZXIgPSBuZXcgVHJhY2tlcihvcHRzKVxuICB0cmFja2VyLm9uKCd3YXJuaW5nJywgc2VsZi5fb25XYXJuaW5nKVxuICB0cmFja2VyLm9uKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG4gIHRyYWNrZXIub24oJ3BlZXInLCBzZWxmLl9vblRyYWNrZXJQZWVyKVxuICB0cmFja2VyLm9uKCd1cGRhdGUnLCBzZWxmLl9vblRyYWNrZXJBbm5vdW5jZSlcbiAgdHJhY2tlci5zZXRJbnRlcnZhbChzZWxmLl9pbnRlcnZhbE1zKVxuICB0cmFja2VyLnN0YXJ0KClcbiAgcmV0dXJuIHRyYWNrZXJcbn1cblxuRGlzY292ZXJ5LnByb3RvdHlwZS5fZGh0QW5ub3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5fZGh0QW5ub3VuY2luZykgcmV0dXJuXG4gIGRlYnVnKCdkaHQgYW5ub3VuY2UnKVxuXG4gIHNlbGYuX2RodEFubm91bmNpbmcgPSB0cnVlXG4gIGNsZWFyVGltZW91dChzZWxmLl9kaHRUaW1lb3V0KVxuXG4gIHNlbGYuZGh0LmFubm91bmNlKHNlbGYuaW5mb0hhc2gsIHNlbGYuX3BvcnQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9kaHRBbm5vdW5jaW5nID0gZmFsc2VcbiAgICBkZWJ1ZygnZGh0IGFubm91bmNlIGNvbXBsZXRlJylcblxuICAgIGlmIChlcnIpIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgICBzZWxmLmVtaXQoJ2RodEFubm91bmNlJylcblxuICAgIGlmICghc2VsZi5kZXN0cm95ZWQpIHtcbiAgICAgIHNlbGYuX2RodFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZGh0QW5ub3VuY2UoKVxuICAgICAgfSwgZ2V0UmFuZG9tVGltZW91dCgpKVxuICAgICAgaWYgKHNlbGYuX2RodFRpbWVvdXQudW5yZWYpIHNlbGYuX2RodFRpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfSlcblxuICAvLyBSZXR1cm5zIHRpbWVvdXQgaW50ZXJ2YWwsIHdpdGggc29tZSByYW5kb20gaml0dGVyXG4gIGZ1bmN0aW9uIGdldFJhbmRvbVRpbWVvdXQgKCkge1xuICAgIHJldHVybiBzZWxmLl9pbnRlcnZhbE1zICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2VsZi5faW50ZXJ2YWxNcyAvIDUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gUGllY2VcblxudmFyIEJMT0NLX0xFTkdUSCA9IDEgPDwgMTRcblxuZnVuY3Rpb24gUGllY2UgKGxlbmd0aCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGllY2UpKSByZXR1cm4gbmV3IFBpZWNlKGxlbmd0aClcblxuICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICB0aGlzLm1pc3NpbmcgPSBsZW5ndGhcbiAgdGhpcy5zb3VyY2VzID0gbnVsbFxuXG4gIHRoaXMuX2NodW5rcyA9IE1hdGguY2VpbChsZW5ndGggLyBCTE9DS19MRU5HVEgpXG4gIHRoaXMuX3JlbWFpbmRlciA9IChsZW5ndGggJSBCTE9DS19MRU5HVEgpIHx8IEJMT0NLX0xFTkdUSFxuICB0aGlzLl9idWZmZXJlZCA9IDBcbiAgdGhpcy5fYnVmZmVyID0gbnVsbFxuICB0aGlzLl9jYW5jZWxsYXRpb25zID0gbnVsbFxuICB0aGlzLl9yZXNlcnZhdGlvbnMgPSAwXG4gIHRoaXMuX2ZsdXNoZWQgPSBmYWxzZVxufVxuXG5QaWVjZS5CTE9DS19MRU5HVEggPSBCTE9DS19MRU5HVEhcblxuUGllY2UucHJvdG90eXBlLmNodW5rTGVuZ3RoID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIGkgPT09IHRoaXMuX2NodW5rcyAtIDEgPyB0aGlzLl9yZW1haW5kZXIgOiBCTE9DS19MRU5HVEhcbn1cblxuUGllY2UucHJvdG90eXBlLmNodW5rTGVuZ3RoUmVtYWluaW5nID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gKGkgKiBCTE9DS19MRU5HVEgpXG59XG5cblBpZWNlLnByb3RvdHlwZS5jaHVua09mZnNldCA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiBpICogQkxPQ0tfTEVOR1RIXG59XG5cblBpZWNlLnByb3RvdHlwZS5yZXNlcnZlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm4gLTFcbiAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvbnMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY2FuY2VsbGF0aW9ucy5wb3AoKVxuICBpZiAodGhpcy5fcmVzZXJ2YXRpb25zIDwgdGhpcy5fY2h1bmtzKSByZXR1cm4gdGhpcy5fcmVzZXJ2YXRpb25zKytcbiAgcmV0dXJuIC0xXG59XG5cblBpZWNlLnByb3RvdHlwZS5yZXNlcnZlUmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm4gLTFcbiAgaWYgKHRoaXMuX3Jlc2VydmF0aW9ucyA8IHRoaXMuX2NodW5rcykge1xuICAgIHZhciBtaW4gPSB0aGlzLl9yZXNlcnZhdGlvbnNcbiAgICB0aGlzLl9yZXNlcnZhdGlvbnMgPSB0aGlzLl9jaHVua3NcbiAgICByZXR1cm4gbWluXG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cblBpZWNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoaSkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm5cbiAgdGhpcy5fY2FuY2VsbGF0aW9ucy5wdXNoKGkpXG59XG5cblBpZWNlLnByb3RvdHlwZS5jYW5jZWxSZW1haW5pbmcgPSBmdW5jdGlvbiAoaSkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm5cbiAgdGhpcy5fcmVzZXJ2YXRpb25zID0gaVxufVxuXG5QaWVjZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgaWYgKCF0aGlzLmluaXQoKSkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHRoaXMuX2J1ZmZlcltpXVxufVxuXG5QaWVjZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGksIGRhdGEsIHNvdXJjZSkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm4gZmFsc2VcbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoXG4gIHZhciBibG9ja3MgPSBNYXRoLmNlaWwobGVuIC8gQkxPQ0tfTEVOR1RIKVxuICBmb3IgKHZhciBqID0gMDsgaiA8IGJsb2NrczsgaisrKSB7XG4gICAgaWYgKCF0aGlzLl9idWZmZXJbaSArIGpdKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gaiAqIEJMT0NLX0xFTkdUSFxuICAgICAgdmFyIHNwbGl0RGF0YSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBCTE9DS19MRU5HVEgpXG4gICAgICB0aGlzLl9idWZmZXJlZCsrXG4gICAgICB0aGlzLl9idWZmZXJbaSArIGpdID0gc3BsaXREYXRhXG4gICAgICB0aGlzLm1pc3NpbmcgLT0gc3BsaXREYXRhLmxlbmd0aFxuICAgICAgaWYgKHRoaXMuc291cmNlcy5pbmRleE9mKHNvdXJjZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuc291cmNlcy5wdXNoKHNvdXJjZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkID09PSB0aGlzLl9jaHVua3Ncbn1cblxuUGllY2UucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX2J1ZmZlciB8fCB0aGlzLl9jaHVua3MgIT09IHRoaXMuX2J1ZmZlcmVkKSByZXR1cm4gbnVsbFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXIsIHRoaXMubGVuZ3RoKVxuICB0aGlzLl9idWZmZXIgPSBudWxsXG4gIHRoaXMuX2NhbmNlbGxhdGlvbnMgPSBudWxsXG4gIHRoaXMuc291cmNlcyA9IG51bGxcbiAgdGhpcy5fZmx1c2hlZCA9IHRydWVcbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5QaWVjZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2ZsdXNoZWQpIHJldHVybiBmYWxzZVxuICBpZiAodGhpcy5fYnVmZmVyKSByZXR1cm4gdHJ1ZVxuICB0aGlzLl9idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5fY2h1bmtzKVxuICB0aGlzLl9jYW5jZWxsYXRpb25zID0gW11cbiAgdGhpcy5zb3VyY2VzID0gW11cbiAgcmV0dXJuIHRydWVcbn1cbiIsIi8qKlxuICogQ29udmVydCBhIHR5cGVkIGFycmF5IHRvIGEgQnVmZmVyIHdpdGhvdXQgYSBjb3B5XG4gKlxuICogQXV0aG9yOiAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBMaWNlbnNlOiAgTUlUXG4gKlxuICogYG5wbSBpbnN0YWxsIHR5cGVkYXJyYXktdG8tYnVmZmVyYFxuICovXG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZGFycmF5Jykuc3RyaWN0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHlwZWRhcnJheVRvQnVmZmVyIChhcnIpIHtcbiAgaWYgKGlzVHlwZWRBcnJheShhcnIpKSB7XG4gICAgLy8gVG8gYXZvaWQgYSBjb3B5LCB1c2UgdGhlIHR5cGVkIGFycmF5J3MgdW5kZXJseWluZyBBcnJheUJ1ZmZlciB0byBiYWNrIG5ldyBCdWZmZXJcbiAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihhcnIuYnVmZmVyKVxuICAgIGlmIChhcnIuYnl0ZUxlbmd0aCAhPT0gYXJyLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAvLyBSZXNwZWN0IHRoZSBcInZpZXdcIiwgaS5lLiBieXRlT2Zmc2V0IGFuZCBieXRlTGVuZ3RoLCB3aXRob3V0IGRvaW5nIGEgY29weVxuICAgICAgYnVmID0gYnVmLnNsaWNlKGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZU9mZnNldCArIGFyci5ieXRlTGVuZ3RoKVxuICAgIH1cbiAgICByZXR1cm4gYnVmXG4gIH0gZWxzZSB7XG4gICAgLy8gUGFzcyB0aHJvdWdoIGFsbCBvdGhlciB0eXBlcyB0byB0aGUgYEJ1ZmZlcmAgY29uc3RydWN0b3JcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcnIpXG4gIH1cbn1cbiIsInZhciBVSU5UXzMyX01BWCA9IDB4ZmZmZmZmZmZcblxuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDhcbn1cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtLCBidWYsIG9mZnNldCkge1xuICBpZiAoIWJ1ZikgYnVmID0gbmV3IEJ1ZmZlcig4KVxuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIHZhciB0b3AgPSBNYXRoLmZsb29yKG51bSAvIFVJTlRfMzJfTUFYKVxuICB2YXIgcmVtID0gbnVtIC0gdG9wICogVUlOVF8zMl9NQVhcblxuICBidWYud3JpdGVVSW50MzJCRSh0b3AsIG9mZnNldClcbiAgYnVmLndyaXRlVUludDMyQkUocmVtLCBvZmZzZXQgKyA0KVxuICByZXR1cm4gYnVmXG59XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgaWYgKCFidWYpIGJ1ZiA9IG5ldyBCdWZmZXIoNClcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICB2YXIgdG9wID0gYnVmLnJlYWRVSW50MzJCRShvZmZzZXQpXG4gIHZhciByZW0gPSBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpXG5cbiAgcmV0dXJuIHRvcCAqIFVJTlRfMzJfTUFYICsgcmVtXG59XG5cbmV4cG9ydHMuZW5jb2RlLmJ5dGVzID0gOFxuZXhwb3J0cy5kZWNvZGUuYnl0ZXMgPSA4XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiPWxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoY29tcGFyZShhLCBiKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlX2VxKGxpc3QpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGIgPSBsaXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpLCBiPWEpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoYSAhPT0gYikge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QsIGNvbXBhcmUsIHNvcnRlZCkge1xuICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZVxuXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaSkge1xuICBpZiAoaSA+PSBhcnIubGVuZ3RoIHx8IGkgPCAwKSByZXR1cm5cbiAgdmFyIGxhc3QgPSBhcnIucG9wKClcbiAgaWYgKGkgPCBhcnIubGVuZ3RoKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXVxuICAgIGFycltpXSA9IGxhc3RcbiAgICByZXR1cm4gdG1wXG4gIH1cbiAgcmV0dXJuIGxhc3Rcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwidmFyIGJlbmNvZGUgPSByZXF1aXJlKCdiZW5jb2RlJylcbnZhciBCaXRGaWVsZCA9IHJlcXVpcmUoJ2JpdGZpZWxkJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgndXRfbWV0YWRhdGEnKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNoYTEgPSByZXF1aXJlKCdzaW1wbGUtc2hhMScpXG5cbnZhciBNQVhfTUVUQURBVEFfU0laRSA9IDEwMDAwMDAwIC8vIDEwTUJcbnZhciBCSVRGSUVMRF9HUk9XID0gMTAwMFxudmFyIFBJRUNFX0xFTkdUSCA9IDE2ICogMTAyNFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICBpbmhlcml0cyh1dE1ldGFkYXRhLCBFdmVudEVtaXR0ZXIpXG5cbiAgZnVuY3Rpb24gdXRNZXRhZGF0YSAod2lyZSkge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgICB0aGlzLl93aXJlID0gd2lyZVxuXG4gICAgdGhpcy5fbWV0YWRhdGFDb21wbGV0ZSA9IGZhbHNlXG4gICAgdGhpcy5fbWV0YWRhdGFTaXplID0gbnVsbFxuICAgIHRoaXMuX3JlbWFpbmluZ1JlamVjdHMgPSBudWxsIC8vIGhvdyBtYW55IHJlamVjdCBtZXNzYWdlcyB0byB0b2xlcmF0ZSBiZWZvcmUgcXVpdHRpbmdcbiAgICB0aGlzLl9mZXRjaGluZyA9IGZhbHNlXG5cbiAgICAvLyBUaGUgbGFyZ2VzdCAudG9ycmVudCBmaWxlIHRoYXQgSSBrbm93IG9mIGlzIH4xLTJNQiwgd2hpY2ggaXMgfjEwMCBwaWVjZXMuXG4gICAgLy8gVGhlcmVmb3JlLCBjYXAgdGhlIGJpdGZpZWxkIHRvIDEweCB0aGF0ICgxMDAwIHBpZWNlcykgc28gYSBtYWxpY2lvdXMgcGVlciBjYW4ndFxuICAgIC8vIG1ha2UgaXQgZ3JvdyB0byBmaWxsIGFsbCBtZW1vcnkuXG4gICAgdGhpcy5fYml0ZmllbGQgPSBuZXcgQml0RmllbGQoMCwgeyBncm93OiBCSVRGSUVMRF9HUk9XIH0pXG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG1ldGFkYXRhKSkge1xuICAgICAgdGhpcy5zZXRNZXRhZGF0YShtZXRhZGF0YSlcbiAgICB9XG4gIH1cblxuICAvLyBOYW1lIG9mIHRoZSBiaXR0b3JyZW50LXByb3RvY29sIGV4dGVuc2lvblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5uYW1lID0gJ3V0X21ldGFkYXRhJ1xuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGluZm9IYXNoLCBwZWVySWQsIGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLl9pbmZvSGFzaCA9IGluZm9IYXNoXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5vbkV4dGVuZGVkSGFuZHNoYWtlID0gZnVuY3Rpb24gKGhhbmRzaGFrZSkge1xuICAgIGlmICghaGFuZHNoYWtlLm0gfHwgIWhhbmRzaGFrZS5tLnV0X21ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQZWVyIGRvZXMgbm90IHN1cHBvcnQgdXRfbWV0YWRhdGEnKSlcbiAgICB9XG4gICAgaWYgKCFoYW5kc2hha2UubWV0YWRhdGFfc2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBkb2VzIG5vdCBoYXZlIG1ldGFkYXRhJykpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgaGFuZHNoYWtlLm1ldGFkYXRhX3NpemUgIT09ICdudW1iZXInIHx8XG4gICAgICAgIE1BWF9NRVRBREFUQV9TSVpFIDwgaGFuZHNoYWtlLm1ldGFkYXRhX3NpemUgfHxcbiAgICAgICAgaGFuZHNoYWtlLm1ldGFkYXRhX3NpemUgPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBnYXZlIGludmFsaWQgbWV0YWRhdGEgc2l6ZScpKVxuICAgIH1cblxuICAgIHRoaXMuX21ldGFkYXRhU2l6ZSA9IGhhbmRzaGFrZS5tZXRhZGF0YV9zaXplXG4gICAgdGhpcy5fbnVtUGllY2VzID0gTWF0aC5jZWlsKHRoaXMuX21ldGFkYXRhU2l6ZSAvIFBJRUNFX0xFTkdUSClcbiAgICB0aGlzLl9yZW1haW5pbmdSZWplY3RzID0gdGhpcy5fbnVtUGllY2VzICogMlxuXG4gICAgaWYgKHRoaXMuX2ZldGNoaW5nKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0UGllY2VzKClcbiAgICB9XG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIGRpY3QsIHRyYWlsZXJcbiAgICB0cnkge1xuICAgICAgdmFyIHN0ciA9IGJ1Zi50b1N0cmluZygpXG4gICAgICB2YXIgdHJhaWxlckluZGV4ID0gc3RyLmluZGV4T2YoJ2VlJykgKyAyXG4gICAgICBkaWN0ID0gYmVuY29kZS5kZWNvZGUoc3RyLnN1YnN0cmluZygwLCB0cmFpbGVySW5kZXgpKVxuICAgICAgdHJhaWxlciA9IGJ1Zi5zbGljZSh0cmFpbGVySW5kZXgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBkcm9wIGludmFsaWQgbWVzc2FnZXNcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN3aXRjaCAoZGljdC5tc2dfdHlwZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvLyB1dF9tZXRhZGF0YSByZXF1ZXN0IChmcm9tIHBlZXIpXG4gICAgICAgIC8vIGV4YW1wbGU6IHsgJ21zZ190eXBlJzogMCwgJ3BpZWNlJzogMCB9XG4gICAgICAgIHRoaXMuX29uUmVxdWVzdChkaWN0LnBpZWNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxOlxuICAgICAgICAvLyB1dF9tZXRhZGF0YSBkYXRhIChpbiByZXNwb25zZSB0byBvdXIgcmVxdWVzdClcbiAgICAgICAgLy8gZXhhbXBsZTogeyAnbXNnX3R5cGUnOiAxLCAncGllY2UnOiAwLCAndG90YWxfc2l6ZSc6IDM0MjUgfVxuICAgICAgICB0aGlzLl9vbkRhdGEoZGljdC5waWVjZSwgdHJhaWxlciwgZGljdC50b3RhbF9zaXplKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyB1dF9tZXRhZGF0YSByZWplY3QgKHBlZXIgZG9lc24ndCBoYXZlIHBpZWNlIHdlIHJlcXVlc3RlZClcbiAgICAgICAgLy8geyAnbXNnX3R5cGUnOiAyLCAncGllY2UnOiAwIH1cbiAgICAgICAgdGhpcy5fb25SZWplY3QoZGljdC5waWVjZSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNrIHRoZSBwZWVyIHRvIHNlbmQgbWV0YWRhdGEuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9tZXRhZGF0YUNvbXBsZXRlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fZmV0Y2hpbmcgPSB0cnVlXG4gICAgaWYgKHRoaXMuX21ldGFkYXRhU2l6ZSkge1xuICAgICAgdGhpcy5fcmVxdWVzdFBpZWNlcygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYXNraW5nIHRoZSBwZWVyIHRvIHNlbmQgbWV0YWRhdGEuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mZXRjaGluZyA9IGZhbHNlXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5zZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgIGlmICh0aGlzLl9tZXRhZGF0YUNvbXBsZXRlKSByZXR1cm4gdHJ1ZVxuICAgIGRlYnVnKCdzZXQgbWV0YWRhdGEnKVxuXG4gICAgLy8gaWYgZnVsbCB0b3JyZW50IGRpY3Rpb25hcnkgd2FzIHBhc3NlZCBpbiwgcHVsbCBvdXQganVzdCBgaW5mb2Aga2V5XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpbmZvID0gYmVuY29kZS5kZWNvZGUobWV0YWRhdGEpLmluZm9cbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIG1ldGFkYXRhID0gYmVuY29kZS5lbmNvZGUoaW5mbylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAvLyBjaGVjayBoYXNoXG4gICAgaWYgKHRoaXMuX2luZm9IYXNoICYmIHRoaXMuX2luZm9IYXNoICE9PSBzaGExLnN5bmMobWV0YWRhdGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLmNhbmNlbCgpXG5cbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGFcbiAgICB0aGlzLl9tZXRhZGF0YUNvbXBsZXRlID0gdHJ1ZVxuICAgIHRoaXMuX21ldGFkYXRhU2l6ZSA9IHRoaXMubWV0YWRhdGEubGVuZ3RoXG4gICAgdGhpcy5fd2lyZS5leHRlbmRlZEhhbmRzaGFrZS5tZXRhZGF0YV9zaXplID0gdGhpcy5fbWV0YWRhdGFTaXplXG5cbiAgICB0aGlzLmVtaXQoJ21ldGFkYXRhJywgYmVuY29kZS5lbmNvZGUoeyBpbmZvOiBiZW5jb2RlLmRlY29kZSh0aGlzLm1ldGFkYXRhKSB9KSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uIChkaWN0LCB0cmFpbGVyKSB7XG4gICAgdmFyIGJ1ZiA9IGJlbmNvZGUuZW5jb2RlKGRpY3QpXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0cmFpbGVyKSkge1xuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB0cmFpbGVyXSlcbiAgICB9XG4gICAgdGhpcy5fd2lyZS5leHRlbmRlZCgndXRfbWV0YWRhdGEnLCBidWYpXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uIChwaWVjZSkge1xuICAgIHRoaXMuX3NlbmQoeyBtc2dfdHlwZTogMCwgcGllY2U6IHBpZWNlIH0pXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fZGF0YSA9IGZ1bmN0aW9uIChwaWVjZSwgYnVmLCB0b3RhbFNpemUpIHtcbiAgICB2YXIgbXNnID0geyBtc2dfdHlwZTogMSwgcGllY2U6IHBpZWNlIH1cbiAgICBpZiAodHlwZW9mIHRvdGFsU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIG1zZy50b3RhbF9zaXplID0gdG90YWxTaXplXG4gICAgfVxuICAgIHRoaXMuX3NlbmQobXNnLCBidWYpXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgdGhpcy5fc2VuZCh7IG1zZ190eXBlOiAyLCBwaWVjZTogcGllY2UgfSlcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9vblJlcXVlc3QgPSBmdW5jdGlvbiAocGllY2UpIHtcbiAgICBpZiAoIXRoaXMuX21ldGFkYXRhQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuX3JlamVjdChwaWVjZSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBwaWVjZSAqIFBJRUNFX0xFTkdUSFxuICAgIHZhciBlbmQgPSBzdGFydCArIFBJRUNFX0xFTkdUSFxuICAgIGlmIChlbmQgPiB0aGlzLl9tZXRhZGF0YVNpemUpIHtcbiAgICAgIGVuZCA9IHRoaXMuX21ldGFkYXRhU2l6ZVxuICAgIH1cbiAgICB2YXIgYnVmID0gdGhpcy5tZXRhZGF0YS5zbGljZShzdGFydCwgZW5kKVxuICAgIHRoaXMuX2RhdGEocGllY2UsIGJ1ZiwgdGhpcy5fbWV0YWRhdGFTaXplKVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX29uRGF0YSA9IGZ1bmN0aW9uIChwaWVjZSwgYnVmLCB0b3RhbFNpemUpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCA+IFBJRUNFX0xFTkdUSCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGJ1Zi5jb3B5KHRoaXMubWV0YWRhdGEsIHBpZWNlICogUElFQ0VfTEVOR1RIKVxuICAgIHRoaXMuX2JpdGZpZWxkLnNldChwaWVjZSlcbiAgICB0aGlzLl9jaGVja0RvbmUoKVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX29uUmVqZWN0ID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZ1JlamVjdHMgPiAwICYmIHRoaXMuX2ZldGNoaW5nKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlbid0IGJlZW4gcmVqZWN0ZWQgdG9vIG11Y2gsIHRoZW4gdHJ5IHRvIHJlcXVlc3QgdGhlIHBpZWNlIGFnYWluXG4gICAgICB0aGlzLl9yZXF1ZXN0KHBpZWNlKVxuICAgICAgdGhpcy5fcmVtYWluaW5nUmVqZWN0cyAtPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBzZW50IFwicmVqZWN0XCIgdG9vIG11Y2gnKSlcbiAgICB9XG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fcmVxdWVzdFBpZWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1ldGFkYXRhID0gQnVmZmVyLmFsbG9jKHRoaXMuX21ldGFkYXRhU2l6ZSlcbiAgICBmb3IgKHZhciBwaWVjZSA9IDA7IHBpZWNlIDwgdGhpcy5fbnVtUGllY2VzOyBwaWVjZSsrKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0KHBpZWNlKVxuICAgIH1cbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9jaGVja0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbmUgPSB0cnVlXG4gICAgZm9yICh2YXIgcGllY2UgPSAwOyBwaWVjZSA8IHRoaXMuX251bVBpZWNlczsgcGllY2UrKykge1xuICAgICAgaWYgKCF0aGlzLl9iaXRmaWVsZC5nZXQocGllY2UpKSB7XG4gICAgICAgIGRvbmUgPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRvbmUpIHJldHVyblxuXG4gICAgLy8gYXR0ZW1wdCB0byBzZXQgbWV0YWRhdGEgLS0gbWF5IGZhaWwgc2hhMSBjaGVja1xuICAgIHZhciBzdWNjZXNzID0gdGhpcy5zZXRNZXRhZGF0YSh0aGlzLm1ldGFkYXRhKVxuXG4gICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9mYWlsZWRNZXRhZGF0YSgpXG4gICAgfVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX2ZhaWxlZE1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlc2V0IGJpdGZpZWxkICYgdHJ5IGFnYWluXG4gICAgdGhpcy5fYml0ZmllbGQgPSBuZXcgQml0RmllbGQoMCwgeyBncm93OiBCSVRGSUVMRF9HUk9XIH0pXG4gICAgdGhpcy5fcmVtYWluaW5nUmVqZWN0cyAtPSB0aGlzLl9udW1QaWVjZXNcbiAgICBpZiAodGhpcy5fcmVtYWluaW5nUmVqZWN0cyA+IDApIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RQaWVjZXMoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ1BlZXIgc2VudCBpbnZhbGlkIG1ldGFkYXRhJykpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHV0TWV0YWRhdGFcbn1cbiIsIi8qIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlICovXG5cbi8vIFRPRE86IGlwdjYgc3VwcG9ydFxuLy8gVE9ETzogcGFyc2UgYW5kIHNlbmQgcGVlciBmbGFncyAoY3VycmVudGx5IHVudXNlZClcbi8vIE5PVEU6IGFkZFBlZXIgc2hvdWxkIHRha2UgaW4gYW4gb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50LCBmbGFnc1xuLy8gVE9ETzogZGVzdHJveSB3aXJlIGlmIHBlZXIgc2VuZHMgUEVYIG1lc3NhZ2VzIHRvbyBmcmVxdWVudGx5XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBjb21wYWN0MnN0cmluZyA9IHJlcXVpcmUoJ2NvbXBhY3Qyc3RyaW5nJylcbnZhciBzdHJpbmcyY29tcGFjdCA9IHJlcXVpcmUoJ3N0cmluZzJjb21wYWN0JylcbnZhciBiZW5jb2RlID0gcmVxdWlyZSgnYmVuY29kZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbnZhciBQRVhfSU5URVJWQUwgPSA2NTAwMCAvLyBqdXN0IG92ZXIgb25lIG1pbnV0ZVxudmFyIFBFWF9NQVhfUEVFUlMgPSA1MCAgICAvLyBtYXggbnVtYmVyIG9mIHBlZXJzIHRvIGFkdmVydGlzZSBwZXIgUEVYIG1lc3NhZ2VcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGluaGVyaXRzKHV0X3BleCwgRXZlbnRFbWl0dGVyKVxuXG4gIGZ1bmN0aW9uIHV0X3BleCAod2lyZSkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG5cbiAgICBzZWxmLl93aXJlID0gd2lyZVxuICAgIHNlbGYuX2ludGVydmFsSWQgPSBudWxsXG5cbiAgICBzZWxmLnJlc2V0KClcbiAgfVxuXG4gIHV0X3BleC5wcm90b3R5cGUubmFtZSA9ICd1dF9wZXgnXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHNlbmRpbmcgcmVndWxhciBQRVggdXBkYXRlcyB0byByZW1vdGUgcGVlci5cbiAgICovXG4gIHV0X3BleC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbElkKVxuICAgIHNlbGYuX2ludGVydmFsSWQgPSBzZXRJbnRlcnZhbChzZWxmLl9zZW5kTWVzc2FnZS5iaW5kKHNlbGYpLCBQRVhfSU5URVJWQUwpXG4gICAgaWYgKHNlbGYuX2ludGVydmFsSWQudW5yZWYpIHNlbGYuX2ludGVydmFsSWQudW5yZWYoKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3Agc2VuZGluZyBQRVggdXBkYXRlcyB0byB0aGUgcmVtb3RlIHBlZXIuXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbElkKVxuICAgIHNlbGYuX2ludGVydmFsSWQgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgc2VuZGluZyB1cGRhdGVzIHRvIHRoZSByZW1vdGUgcGVlciBhbmQgcmVzZXRzIGludGVybmFsIHN0YXRlIG9mIHBlZXJzIHNlZW4uXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHNlbGYuX3JlbW90ZUFkZGVkUGVlcnMgPSB7fVxuICAgIHNlbGYuX3JlbW90ZURyb3BwZWRQZWVycyA9IHt9XG4gICAgc2VsZi5fbG9jYWxBZGRlZFBlZXJzID0ge31cbiAgICBzZWxmLl9sb2NhbERyb3BwZWRQZWVycyA9IHt9XG4gICAgc2VsZi5zdG9wKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGVlciB0byB0aGUgbG9jYWxseSBkaXNjb3ZlcmVkIHBlZXIgbGlzdCBmb3IgdGhlIG5leHQgUEVYIG1lc3NhZ2UuXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLmFkZFBlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGlmIChwZWVyLmluZGV4T2YoJzonKSA8IDApIHJldHVybiAvLyBkaXNyZWdhcmQgaW52YWxpZCBwZWVyc1xuICAgIGlmIChwZWVyIGluIHNlbGYuX3JlbW90ZUFkZGVkUGVlcnMpIHJldHVybiAvLyBuZXZlciBhZHZlcnRpc2UgcGVlciB0aGUgcmVtb3RlIHdpcmUgYWxyZWFkeSBzZW50IHVzXG4gICAgaWYgKHBlZXIgaW4gc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnMpIGRlbGV0ZSBzZWxmLl9sb2NhbERyb3BwZWRQZWVyc1twZWVyXVxuICAgIHNlbGYuX2xvY2FsQWRkZWRQZWVyc1twZWVyXSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGVlciB0byB0aGUgbG9jYWxseSBkcm9wcGVkIHBlZXIgbGlzdCBmb3IgdGhlIG5leHQgUEVYIG1lc3NhZ2UuXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLmRyb3BQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAocGVlci5pbmRleE9mKCc6JykgPCAwKSByZXR1cm4gLy8gZGlzcmVnYXJkIGludmFsaWQgcGVlcnNcbiAgICBpZiAocGVlciBpbiBzZWxmLl9yZW1vdGVEcm9wcGVkUGVlcnMpIHJldHVybiAvLyBuZXZlciBhZHZlcnRpc2UgcGVlciB0aGUgcmVtb3RlIHdpcmUgYWxyZWFkeSBzZW50IHVzXG4gICAgaWYgKHBlZXIgaW4gc2VsZi5fbG9jYWxBZGRlZFBlZXJzKSBkZWxldGUgc2VsZi5fbG9jYWxBZGRlZFBlZXJzW3BlZXJdXG4gICAgc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnNbcGVlcl0gPSB0cnVlXG4gIH1cblxuICB1dF9wZXgucHJvdG90eXBlLm9uRXh0ZW5kZWRIYW5kc2hha2UgPSBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgaWYgKCFoYW5kc2hha2UubSB8fCAhaGFuZHNoYWtlLm0udXRfcGV4KSB7XG4gICAgICByZXR1cm4gc2VsZi5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQZWVyIGRvZXMgbm90IHN1cHBvcnQgdXRfcGV4JykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBFWCBtZXNzYWdlcyBhcmUgYmVuY29kZWQgZGljdGlvbmFyaWVzIHdpdGggdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgKiAnYWRkZWQnICAgICA6IGFycmF5IG9mIHBlZXJzIG1ldCBzaW5jZSBsYXN0IFBFWCBtZXNzYWdlXG4gICAqICdhZGRlZC5mJyAgIDogYXJyYXkgb2YgZmxhZ3MgcGVyIHBlZXJcbiAgICogICcweDAxJyAgICAgOiBwZWVyIHByZWZlcnMgZW5jcnlwdGlvblxuICAgKiAgJzB4MDInICAgICA6IHBlZXIgaXMgc2VlZGVyXG4gICAqICdkcm9wcGVkJyAgIDogYXJyYXkgb2YgcGVlcnMgbG9jYWxseSBkcm9wcGVkIGZyb20gc3dhcm0gc2luY2UgbGFzdCBQRVggbWVzc2FnZVxuICAgKiAnYWRkZWQ2JyAgICA6IGlwdjYgdmVyc2lvbiBvZiAnYWRkZWQnXG4gICAqICdhZGRlZDYuZicgIDogaXB2NiB2ZXJzaW9uIG9mICdhZGRlZC5mJ1xuICAgKiAnZHJvcHBlZC5mJyA6IGlwdjYgdmVyc2lvbiBvZiAnZHJvcHBlZCdcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBiZW5jb2RlZCBQRVggZGljdGlvbmFyeVxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdmFyIG1lc3NhZ2VcblxuICAgIHRyeSB7XG4gICAgICBtZXNzYWdlID0gYmVuY29kZS5kZWNvZGUoYnVmKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZHJvcCBpbnZhbGlkIG1lc3NhZ2VzXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS5hZGRlZCkge1xuICAgICAgY29tcGFjdDJzdHJpbmcubXVsdGkobWVzc2FnZS5hZGRlZCkuZm9yRWFjaChmdW5jdGlvbiAocGVlcikge1xuICAgICAgICBkZWxldGUgc2VsZi5fcmVtb3RlRHJvcHBlZFBlZXJzW3BlZXJdXG4gICAgICAgIGlmICghKHBlZXIgaW4gc2VsZi5fcmVtb3RlQWRkZWRQZWVycykpIHtcbiAgICAgICAgICBzZWxmLl9yZW1vdGVBZGRlZFBlZXJzW3BlZXJdID0gdHJ1ZVxuICAgICAgICAgIHNlbGYuZW1pdCgncGVlcicsIHBlZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UuZHJvcHBlZCkge1xuICAgICAgY29tcGFjdDJzdHJpbmcubXVsdGkobWVzc2FnZS5kcm9wcGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl9yZW1vdGVBZGRlZFBlZXJzW3BlZXJdXG4gICAgICAgIGlmICghKHBlZXIgaW4gc2VsZi5fcmVtb3RlRHJvcHBlZFBlZXJzKSkge1xuICAgICAgICAgIHNlbGYuX3JlbW90ZURyb3BwZWRQZWVyc1twZWVyXSA9IHRydWVcbiAgICAgICAgICBzZWxmLmVtaXQoJ2Ryb3BwZWQnLCBwZWVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIFBFWCBtZXNzYWdlIHRvIHRoZSByZW1vdGUgcGVlciBpbmNsdWRpbmcgaW5mb3JtYXRpb24gYWJvdXQgYW55IGxvY2FsbHlcbiAgICogYWRkZWQgLyBkcm9wcGVkIHBlZXJzLlxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5fc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICB2YXIgbG9jYWxBZGRlZCA9IE9iamVjdC5rZXlzKHNlbGYuX2xvY2FsQWRkZWRQZWVycykuc2xpY2UoMCwgUEVYX01BWF9QRUVSUylcbiAgICB2YXIgbG9jYWxEcm9wcGVkID0gT2JqZWN0LmtleXMoc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnMpLnNsaWNlKDAsIFBFWF9NQVhfUEVFUlMpXG5cbiAgICB2YXIgYWRkZWQgPSBCdWZmZXIuY29uY2F0KGxvY2FsQWRkZWQubWFwKHN0cmluZzJjb21wYWN0KSlcbiAgICB2YXIgZHJvcHBlZCA9IEJ1ZmZlci5jb25jYXQobG9jYWxEcm9wcGVkLm1hcChzdHJpbmcyY29tcGFjdCkpXG5cbiAgICB2YXIgYWRkZWRGbGFncyA9IEJ1ZmZlci5jb25jYXQobG9jYWxBZGRlZC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBmbGFnc1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoWzBdKVxuICAgIH0pKVxuXG4gICAgLy8gdXBkYXRlIGxvY2FsIGRlbHRhc1xuICAgIGxvY2FsQWRkZWQuZm9yRWFjaChmdW5jdGlvbiAocGVlcikgeyBkZWxldGUgc2VsZi5fbG9jYWxBZGRlZFBlZXJzW3BlZXJdIH0pXG4gICAgbG9jYWxEcm9wcGVkLmZvckVhY2goZnVuY3Rpb24gKHBlZXIpIHsgZGVsZXRlIHNlbGYuX2xvY2FsRHJvcHBlZFBlZXJzW3BlZXJdIH0pXG5cbiAgICAvLyBzZW5kIFBFWCBtZXNzYWdlXG4gICAgc2VsZi5fd2lyZS5leHRlbmRlZCgndXRfcGV4Jywge1xuICAgICAgJ2FkZGVkJzogYWRkZWQsXG4gICAgICAnYWRkZWQuZic6IGFkZGVkRmxhZ3MsXG4gICAgICAnZHJvcHBlZCc6IGRyb3BwZWQsXG4gICAgICAnYWRkZWQ2JzogbmV3IEJ1ZmZlcigwKSxcbiAgICAgICdhZGRlZDYuZic6IG5ldyBCdWZmZXIoMCksXG4gICAgICAnZHJvcHBlZDYnOiBuZXcgQnVmZmVyKDApXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB1dF9wZXhcbn1cbiIsInZhciBEaWN0ID0gcmVxdWlyZShcIi4vZGljdFwiKVxuXG4vKipcbiAqIERlY29kZXMgYmVuY29kZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGRhdGFcbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnQgKG9wdGlvbmFsKVxuICogQHBhcmFtICB7TnVtYmVyfSBlbmQgKG9wdGlvbmFsKVxuICogQHBhcmFtICB7U3RyaW5nfSBlbmNvZGluZyAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtPYmplY3R8QXJyYXl8QnVmZmVyfFN0cmluZ3xOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZSggZGF0YSwgc3RhcnQsIGVuZCwgZW5jb2RpbmcgKSB7XG4gIFxuICBpZiggdHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICBzdGFydCA9IHVuZGVmaW5lZFxuICB9XG4gIFxuICBpZiggdHlwZW9mIGVuZCAhPT0gJ251bWJlcicgJiYgZW5jb2RpbmcgPT0gbnVsbCApIHtcbiAgICBlbmNvZGluZyA9IGVuZFxuICAgIGVuZCA9IHVuZGVmaW5lZFxuICB9XG4gIFxuICBkZWNvZGUucG9zaXRpb24gPSAwXG4gIGRlY29kZS5lbmNvZGluZyA9IGVuY29kaW5nIHx8IG51bGxcblxuICBkZWNvZGUuZGF0YSA9ICEoIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSApXG4gICAgPyBuZXcgQnVmZmVyKCBkYXRhIClcbiAgICA6IGRhdGEuc2xpY2UoIHN0YXJ0LCBlbmQgKVxuICBcbiAgZGVjb2RlLmJ5dGVzID0gZGVjb2RlLmRhdGEubGVuZ3RoXG4gIFxuICByZXR1cm4gZGVjb2RlLm5leHQoKVxuXG59XG5cbmRlY29kZS5ieXRlcyA9IDBcbmRlY29kZS5wb3NpdGlvbiA9IDBcbmRlY29kZS5kYXRhICAgICA9IG51bGxcbmRlY29kZS5lbmNvZGluZyA9IG51bGxcblxuZGVjb2RlLm5leHQgPSBmdW5jdGlvbigpIHtcblxuICBzd2l0Y2goIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gKSB7XG4gICAgY2FzZSAweDY0OiByZXR1cm4gZGVjb2RlLmRpY3Rpb25hcnkoKTsgYnJlYWtcbiAgICBjYXNlIDB4NkM6IHJldHVybiBkZWNvZGUubGlzdCgpOyBicmVha1xuICAgIGNhc2UgMHg2OTogcmV0dXJuIGRlY29kZS5pbnRlZ2VyKCk7IGJyZWFrXG4gICAgZGVmYXVsdDogICByZXR1cm4gZGVjb2RlLmJ1ZmZlcigpOyBicmVha1xuICB9XG5cbn1cblxuZGVjb2RlLmZpbmQgPSBmdW5jdGlvbiggY2hyICkge1xuXG4gIHZhciBpID0gZGVjb2RlLnBvc2l0aW9uXG4gIHZhciBjID0gZGVjb2RlLmRhdGEubGVuZ3RoXG4gIHZhciBkID0gZGVjb2RlLmRhdGFcblxuICB3aGlsZSggaSA8IGMgKSB7XG4gICAgaWYoIGRbaV0gPT09IGNociApXG4gICAgICByZXR1cm4gaVxuICAgIGkrK1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdJbnZhbGlkIGRhdGE6IE1pc3NpbmcgZGVsaW1pdGVyIFwiJyArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZSggY2hyICkgKyAnXCIgWzB4JyArXG4gICAgY2hyLnRvU3RyaW5nKCAxNiApICsgJ10nXG4gIClcblxufVxuXG5kZWNvZGUuZGljdGlvbmFyeSA9IGZ1bmN0aW9uKCkge1xuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGRpY3QgPSBuZXcgRGljdCgpXG5cbiAgd2hpbGUoIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gIT09IDB4NjUgKSB7XG4gICAgZGljdC5iaW5hcnlTZXQoZGVjb2RlLmJ1ZmZlcigpLCBkZWNvZGUubmV4dCgpKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gZGljdFxuXG59XG5cbmRlY29kZS5saXN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgbHN0ID0gW11cblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBsc3QucHVzaCggZGVjb2RlLm5leHQoKSApXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBsc3RcblxufVxuXG5kZWNvZGUuaW50ZWdlciA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBlbmQgICAgPSBkZWNvZGUuZmluZCggMHg2NSApXG4gIHZhciBudW1iZXIgPSBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uICsgMSwgZW5kIClcblxuICBkZWNvZGUucG9zaXRpb24gKz0gZW5kICsgMSAtIGRlY29kZS5wb3NpdGlvblxuXG4gIHJldHVybiBwYXJzZUludCggbnVtYmVyLCAxMCApXG5cbn1cblxuZGVjb2RlLmJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzZXAgICAgPSBkZWNvZGUuZmluZCggMHgzQSApXG4gIHZhciBsZW5ndGggPSBwYXJzZUludCggZGVjb2RlLmRhdGEudG9TdHJpbmcoICdhc2NpaScsIGRlY29kZS5wb3NpdGlvbiwgc2VwICksIDEwIClcbiAgdmFyIGVuZCAgICA9ICsrc2VwICsgbGVuZ3RoXG5cbiAgZGVjb2RlLnBvc2l0aW9uID0gZW5kXG5cbiAgcmV0dXJuIGRlY29kZS5lbmNvZGluZ1xuICAgID8gZGVjb2RlLmRhdGEudG9TdHJpbmcoIGRlY29kZS5lbmNvZGluZywgc2VwLCBlbmQgKVxuICAgIDogZGVjb2RlLmRhdGEuc2xpY2UoIHNlcCwgZW5kIClcblxufVxuXG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZVxuIiwiLyoqXG4gKiBFbmNvZGVzIGRhdGEgaW4gYmVuY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE9iamVjdHxOdW1iZXJ8Qm9vbGVhbn0gZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBlbmNvZGUoIGRhdGEsIGJ1ZmZlciwgb2Zmc2V0ICkge1xuICBcbiAgdmFyIGJ1ZmZlcnMgPSBbXVxuICB2YXIgcmVzdWx0ID0gbnVsbFxuICBcbiAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGEgKVxuICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KCBidWZmZXJzIClcbiAgZW5jb2RlLmJ5dGVzID0gcmVzdWx0Lmxlbmd0aFxuICBcbiAgaWYoIEJ1ZmZlci5pc0J1ZmZlciggYnVmZmVyICkgKSB7XG4gICAgcmVzdWx0LmNvcHkoIGJ1ZmZlciwgb2Zmc2V0IClcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRcbiAgXG59XG5cbmVuY29kZS5ieXRlcyA9IC0xXG5lbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gZmFsc2VcblxuZW5jb2RlLl9lbmNvZGUgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBpZiggQnVmZmVyLmlzQnVmZmVyKGRhdGEpICkge1xuICAgIGJ1ZmZlcnMucHVzaChuZXcgQnVmZmVyKGRhdGEubGVuZ3RoICsgJzonKSlcbiAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2goIHR5cGVvZiBkYXRhICkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBkYXRhIClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlcbiAgICAgICAgPyBlbmNvZGUubGlzdCggYnVmZmVycywgZGF0YSApXG4gICAgICAgIDogZW5jb2RlLmRpY3QoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgPyAxIDogMCApXG4gICAgICBicmVha1xuICB9XG5cbn1cblxudmFyIGJ1ZmZfZSA9IG5ldyBCdWZmZXIoJ2UnKVxuICAsIGJ1ZmZfZCA9IG5ldyBCdWZmZXIoJ2QnKVxuICAsIGJ1ZmZfbCA9IG5ldyBCdWZmZXIoJ2wnKVxuXG5lbmNvZGUuYnVmZmVyID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKEJ1ZmZlci5ieXRlTGVuZ3RoKCBkYXRhICkgKyAnOicgKyBkYXRhKSApXG59XG5cbmVuY29kZS5udW1iZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcbiAgdmFyIG1heExvID0gMHg4MDAwMDAwMFxuICB2YXIgaGkgPSAoIGRhdGEgLyBtYXhMbyApIDw8IDBcbiAgdmFyIGxvID0gKCBkYXRhICUgbWF4TG8gICkgPDwgMFxuICB2YXIgdmFsID0gaGkgKiBtYXhMbyArIGxvXG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKCAnaScgKyB2YWwgKyAnZScgKSlcblxuICBpZiggdmFsICE9PSBkYXRhICYmICFlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkICkge1xuICAgIGVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSB0cnVlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dBUk5JTkc6IFBvc3NpYmxlIGRhdGEgY29ycnVwdGlvbiBkZXRlY3RlZCB3aXRoIHZhbHVlIFwiJytkYXRhKydcIjonLFxuICAgICAgJ0JlbmNvZGluZyBvbmx5IGRlZmluZXMgc3VwcG9ydCBmb3IgaW50ZWdlcnMsIHZhbHVlIHdhcyBjb252ZXJ0ZWQgdG8gXCInK3ZhbCsnXCInXG4gICAgKVxuICAgIGNvbnNvbGUudHJhY2UoKVxuICB9XG5cbn1cblxuZW5jb2RlLmRpY3QgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZCApXG5cbiAgdmFyIGogPSAwXG4gIHZhciBrXG4gIC8vIGZpeCBmb3IgaXNzdWUgIzEzIC0gc29ydGVkIGRpY3RzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGRhdGEgKS5zb3J0KClcbiAgdmFyIGtsID0ga2V5cy5sZW5ndGhcblxuICBmb3IoIDsgaiA8IGtsIDsgaisrKSB7XG4gICAgaz1rZXlzW2pdXG4gICAgZW5jb2RlLmJ1ZmZlciggYnVmZmVycywgayApXG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFba10gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxufVxuXG5lbmNvZGUubGlzdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIHZhciBpID0gMCwgaiA9IDFcbiAgdmFyIGMgPSBkYXRhLmxlbmd0aFxuICBidWZmZXJzLnB1c2goIGJ1ZmZfbCApXG5cbiAgZm9yKCA7IGkgPCBjOyBpKysgKSB7XG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFbaV0gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxuXG59XG5cbi8vIEV4cG9zZVxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcbiIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gYnl0ZTE7XG5cdFx0fVxuXG5cdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRcdHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJ2YXIgYnMgPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoJylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtcDQgPSByZXF1aXJlKCdtcDQtc3RyZWFtJylcbnZhciBCb3ggPSByZXF1aXJlKCdtcDQtYm94LWVuY29kaW5nJylcbnZhciBSYW5nZVNsaWNlU3RyZWFtID0gcmVxdWlyZSgncmFuZ2Utc2xpY2Utc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBNUDRSZW11eGVyXG5cbmZ1bmN0aW9uIE1QNFJlbXV4ZXIgKGZpbGUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG5cdHNlbGYuX3RyYWNrcyA9IFtdXG5cdHNlbGYuX2ZyYWdtZW50U2VxdWVuY2UgPSAxXG5cdHNlbGYuX2ZpbGUgPSBmaWxlXG5cdHNlbGYuX2RlY29kZXIgPSBudWxsXG5cdHNlbGYuX2ZpbmRNb292KDApXG59XG5cbmluaGVyaXRzKE1QNFJlbXV4ZXIsIEV2ZW50RW1pdHRlcilcblxuTVA0UmVtdXhlci5wcm90b3R5cGUuX2ZpbmRNb292ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVjb2Rlcikge1xuXHRcdHNlbGYuX2RlY29kZXIuZGVzdHJveSgpXG5cdH1cblxuXHRzZWxmLl9kZWNvZGVyID0gbXA0LmRlY29kZSgpXG5cdHZhciBmaWxlU3RyZWFtID0gc2VsZi5fZmlsZS5jcmVhdGVSZWFkU3RyZWFtKHtcblx0XHRzdGFydDogb2Zmc2V0XG5cdH0pXG5cdGZpbGVTdHJlYW0ucGlwZShzZWxmLl9kZWNvZGVyKVxuXG5cdHNlbGYuX2RlY29kZXIub25jZSgnYm94JywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcblx0XHRpZiAoaGVhZGVycy50eXBlID09PSAnbW9vdicpIHtcblx0XHRcdHNlbGYuX2RlY29kZXIuZGVjb2RlKGZ1bmN0aW9uIChtb292KSB7XG5cdFx0XHRcdGZpbGVTdHJlYW0uZGVzdHJveSgpXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0c2VsZi5fcHJvY2Vzc01vb3YobW9vdilcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0ZXJyLm1lc3NhZ2UgPSAnQ2Fubm90IHBhcnNlIG1wNCBmaWxlOiAnICsgZXJyLm1lc3NhZ2Vcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmaWxlU3RyZWFtLmRlc3Ryb3koKVxuXHRcdFx0c2VsZi5fZmluZE1vb3Yob2Zmc2V0ICsgaGVhZGVycy5sZW5ndGgpXG5cdFx0fVxuXHR9KVxufVxuXG5mdW5jdGlvbiBSdW5MZW5ndGhJbmRleCAoZW50cmllcywgY291bnROYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9lbnRyaWVzID0gZW50cmllc1xuXHRzZWxmLl9jb3VudE5hbWUgPSBjb3VudE5hbWUgfHwgJ2NvdW50J1xuXHRzZWxmLl9pbmRleCA9IDBcblx0c2VsZi5fb2Zmc2V0ID0gMFxuXG5cdHNlbGYudmFsdWUgPSBzZWxmLl9lbnRyaWVzWzBdXG59XG5cblJ1bkxlbmd0aEluZGV4LnByb3RvdHlwZS5pbmMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9vZmZzZXQrK1xuXHRpZiAoc2VsZi5fb2Zmc2V0ID49IHNlbGYuX2VudHJpZXNbc2VsZi5faW5kZXhdW3NlbGYuX2NvdW50TmFtZV0pIHtcblx0XHRzZWxmLl9pbmRleCsrXG5cdFx0c2VsZi5fb2Zmc2V0ID0gMFxuXHR9XG5cblx0c2VsZi52YWx1ZSA9IHNlbGYuX2VudHJpZXNbc2VsZi5faW5kZXhdXG59XG5cbk1QNFJlbXV4ZXIucHJvdG90eXBlLl9wcm9jZXNzTW9vdiA9IGZ1bmN0aW9uIChtb292KSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciB0cmFrcyA9IG1vb3YudHJha3Ncblx0c2VsZi5fdHJhY2tzID0gW11cblx0c2VsZi5faGFzVmlkZW8gPSBmYWxzZVxuXHRzZWxmLl9oYXNBdWRpbyA9IGZhbHNlXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdHJha3MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdHJhayA9IHRyYWtzW2ldXG5cdFx0dmFyIHN0YmwgPSB0cmFrLm1kaWEubWluZi5zdGJsXG5cdFx0dmFyIHN0c2RFbnRyeSA9IHN0Ymwuc3RzZC5lbnRyaWVzWzBdXG5cdFx0dmFyIGhhbmRsZXJUeXBlID0gdHJhay5tZGlhLmhkbHIuaGFuZGxlclR5cGVcblx0XHR2YXIgY29kZWNcblx0XHR2YXIgbWltZVxuXHRcdGlmIChoYW5kbGVyVHlwZSA9PT0gJ3ZpZGUnICYmIHN0c2RFbnRyeS50eXBlID09PSAnYXZjMScpIHtcblx0XHRcdGlmIChzZWxmLl9oYXNWaWRlbykge1xuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0c2VsZi5faGFzVmlkZW8gPSB0cnVlXG5cdFx0XHRjb2RlYyA9ICdhdmMxJ1xuXHRcdFx0aWYgKHN0c2RFbnRyeS5hdmNDKSB7XG5cdFx0XHRcdGNvZGVjICs9ICcuJyArIHN0c2RFbnRyeS5hdmNDLm1pbWVDb2RlY1xuXHRcdFx0fVxuXHRcdFx0bWltZSA9ICd2aWRlby9tcDQ7IGNvZGVjcz1cIicgKyBjb2RlYyArICdcIidcblx0XHR9IGVsc2UgaWYgKGhhbmRsZXJUeXBlID09PSAnc291bicgJiYgc3RzZEVudHJ5LnR5cGUgPT09ICdtcDRhJykge1xuXHRcdFx0aWYgKHNlbGYuX2hhc0F1ZGlvKSB7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRzZWxmLl9oYXNBdWRpbyA9IHRydWVcblx0XHRcdGNvZGVjID0gJ21wNGEnXG5cdFx0XHRpZiAoc3RzZEVudHJ5LmVzZHMgJiYgc3RzZEVudHJ5LmVzZHMubWltZUNvZGVjKSB7XG5cdFx0XHRcdGNvZGVjICs9ICcuJyArIHN0c2RFbnRyeS5lc2RzLm1pbWVDb2RlY1xuXHRcdFx0fVxuXHRcdFx0bWltZSA9ICdhdWRpby9tcDQ7IGNvZGVjcz1cIicgKyBjb2RlYyArICdcIidcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGludWVcblx0XHR9XG5cblx0XHR2YXIgc2FtcGxlcyA9IFtdXG5cdFx0dmFyIHNhbXBsZSA9IDBcblxuXHRcdC8vIENodW5rL3Bvc2l0aW9uIGRhdGFcblx0XHR2YXIgc2FtcGxlSW5DaHVuayA9IDBcblx0XHR2YXIgY2h1bmsgPSAwXG5cdFx0dmFyIG9mZnNldEluQ2h1bmsgPSAwXG5cdFx0dmFyIHNhbXBsZVRvQ2h1bmtJbmRleCA9IDBcblxuXHRcdC8vIFRpbWUgZGF0YVxuXHRcdHZhciBkdHMgPSAwXG5cdFx0dmFyIGRlY29kaW5nVGltZUVudHJ5ID0gbmV3IFJ1bkxlbmd0aEluZGV4KHN0Ymwuc3R0cy5lbnRyaWVzKVxuXHRcdHZhciBwcmVzZW50YXRpb25PZmZzZXRFbnRyeSA9IG51bGxcblx0XHRpZiAoc3RibC5jdHRzKSB7XG5cdFx0XHRwcmVzZW50YXRpb25PZmZzZXRFbnRyeSA9IG5ldyBSdW5MZW5ndGhJbmRleChzdGJsLmN0dHMuZW50cmllcylcblx0XHR9XG5cblx0XHQvLyBTeW5jIHRhYmxlIGluZGV4XG5cdFx0dmFyIHN5bmNTYW1wbGVJbmRleCA9IDBcblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHR2YXIgY3VyckNodW5rRW50cnkgPSBzdGJsLnN0c2MuZW50cmllc1tzYW1wbGVUb0NodW5rSW5kZXhdXG5cblx0XHRcdC8vIENvbXB1dGUgc2l6ZVxuXHRcdFx0dmFyIHNpemUgPSBzdGJsLnN0c3ouZW50cmllc1tzYW1wbGVdXG5cblx0XHRcdC8vIENvbXB1dGUgdGltZSBkYXRhXG5cdFx0XHR2YXIgZHVyYXRpb24gPSBkZWNvZGluZ1RpbWVFbnRyeS52YWx1ZS5kdXJhdGlvblxuXHRcdFx0dmFyIHByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvbk9mZnNldEVudHJ5ID8gcHJlc2VudGF0aW9uT2Zmc2V0RW50cnkudmFsdWUuY29tcG9zaXRpb25PZmZzZXQgOiAwXG5cblx0XHRcdC8vIENvbXB1dGUgc3luY1xuXHRcdFx0dmFyIHN5bmMgPSB0cnVlXG5cdFx0XHRpZiAoc3RibC5zdHNzKSB7XG5cdFx0XHRcdHN5bmMgPSBzdGJsLnN0c3MuZW50cmllc1tzeW5jU2FtcGxlSW5kZXhdID09PSBzYW1wbGUgKyAxXG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBuZXcgc2FtcGxlIGVudHJ5XG5cdFx0XHRzYW1wbGVzLnB1c2goe1xuXHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRcdGR0czogZHRzLFxuXHRcdFx0XHRwcmVzZW50YXRpb25PZmZzZXQ6IHByZXNlbnRhdGlvbk9mZnNldCxcblx0XHRcdFx0c3luYzogc3luYyxcblx0XHRcdFx0b2Zmc2V0OiBvZmZzZXRJbkNodW5rICsgc3RibC5zdGNvLmVudHJpZXNbY2h1bmtdXG5cdFx0XHR9KVxuXG5cdFx0XHQvLyBHbyB0byBuZXh0IHNhbXBsZVxuXHRcdFx0c2FtcGxlKytcblx0XHRcdGlmIChzYW1wbGUgPj0gc3RibC5zdHN6LmVudHJpZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cblx0XHRcdC8vIE1vdmUgcG9zaXRpb24vY2h1bmtcblx0XHRcdHNhbXBsZUluQ2h1bmsrK1xuXHRcdFx0b2Zmc2V0SW5DaHVuayArPSBzaXplXG5cdFx0XHRpZiAoc2FtcGxlSW5DaHVuayA+PSBjdXJyQ2h1bmtFbnRyeS5zYW1wbGVzUGVyQ2h1bmspIHtcblx0XHRcdFx0Ly8gTW92ZSB0byBuZXcgY2h1bmtcblx0XHRcdFx0c2FtcGxlSW5DaHVuayA9IDBcblx0XHRcdFx0b2Zmc2V0SW5DaHVuayA9IDBcblx0XHRcdFx0Y2h1bmsrK1xuXHRcdFx0XHQvLyBNb3ZlIHNhbXBsZSB0byBjaHVuayBib3ggaW5kZXhcblx0XHRcdFx0dmFyIG5leHRDaHVua0VudHJ5ID0gc3RibC5zdHNjLmVudHJpZXNbc2FtcGxlVG9DaHVua0luZGV4ICsgMV1cblx0XHRcdFx0aWYgKG5leHRDaHVua0VudHJ5ICYmIGNodW5rICsgMSA+PSBuZXh0Q2h1bmtFbnRyeS5maXJzdENodW5rKSB7XG5cdFx0XHRcdFx0c2FtcGxlVG9DaHVua0luZGV4Kytcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBNb3ZlIHRpbWUgZm9yd2FyZFxuXHRcdFx0ZHRzICs9IGR1cmF0aW9uXG5cdFx0XHRkZWNvZGluZ1RpbWVFbnRyeS5pbmMoKVxuXHRcdFx0cHJlc2VudGF0aW9uT2Zmc2V0RW50cnkgJiYgcHJlc2VudGF0aW9uT2Zmc2V0RW50cnkuaW5jKClcblxuXHRcdFx0Ly8gTW92ZSBzeW5jIHRhYmxlIGluZGV4XG5cdFx0XHRpZiAoc3luYykge1xuXHRcdFx0XHRzeW5jU2FtcGxlSW5kZXgrK1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRyYWsubWRpYS5tZGhkLmR1cmF0aW9uID0gMFxuXHRcdHRyYWsudGtoZC5kdXJhdGlvbiA9IDBcblxuXHRcdHZhciBkZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleCA9IGN1cnJDaHVua0VudHJ5LnNhbXBsZURlc2NyaXB0aW9uSWRcblxuXHRcdHZhciB0cmFja01vb3YgPSB7XG5cdFx0XHR0eXBlOiAnbW9vdicsXG5cdFx0XHRtdmhkOiBtb292Lm12aGQsXG5cdFx0XHR0cmFrczogW3tcblx0XHRcdFx0dGtoZDogdHJhay50a2hkLFxuXHRcdFx0XHRtZGlhOiB7XG5cdFx0XHRcdFx0bWRoZDogdHJhay5tZGlhLm1kaGQsXG5cdFx0XHRcdFx0aGRscjogdHJhay5tZGlhLmhkbHIsXG5cdFx0XHRcdFx0ZWxuZzogdHJhay5tZGlhLmVsbmcsXG5cdFx0XHRcdFx0bWluZjoge1xuXHRcdFx0XHRcdFx0dm1oZDogdHJhay5tZGlhLm1pbmYudm1oZCxcblx0XHRcdFx0XHRcdHNtaGQ6IHRyYWsubWRpYS5taW5mLnNtaGQsXG5cdFx0XHRcdFx0XHRkaW5mOiB0cmFrLm1kaWEubWluZi5kaW5mLFxuXHRcdFx0XHRcdFx0c3RibDoge1xuXHRcdFx0XHRcdFx0XHRzdHNkOiBzdGJsLnN0c2QsXG5cdFx0XHRcdFx0XHRcdHN0dHM6IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdGN0dHM6IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdHN0c2M6IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdHN0c3o6IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdHN0Y286IGVtcHR5KCksXG5cdFx0XHRcdFx0XHRcdHN0c3M6IGVtcHR5KClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1dLFxuXHRcdFx0bXZleDoge1xuXHRcdFx0XHRtZWhkOiB7XG5cdFx0XHRcdFx0ZnJhZ21lbnREdXJhdGlvbjogbW9vdi5tdmhkLmR1cmF0aW9uXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRyZXhzOiBbe1xuXHRcdFx0XHRcdHRyYWNrSWQ6IHRyYWsudGtoZC50cmFja0lkLFxuXHRcdFx0XHRcdGRlZmF1bHRTYW1wbGVEZXNjcmlwdGlvbkluZGV4OiBkZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleCxcblx0XHRcdFx0XHRkZWZhdWx0U2FtcGxlRHVyYXRpb246IDAsXG5cdFx0XHRcdFx0ZGVmYXVsdFNhbXBsZVNpemU6IDAsXG5cdFx0XHRcdFx0ZGVmYXVsdFNhbXBsZUZsYWdzOiAwXG5cdFx0XHRcdH1dXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5fdHJhY2tzLnB1c2goe1xuXHRcdFx0dHJhY2tJZDogdHJhay50a2hkLnRyYWNrSWQsXG5cdFx0XHR0aW1lU2NhbGU6IHRyYWsubWRpYS5tZGhkLnRpbWVTY2FsZSxcblx0XHRcdHNhbXBsZXM6IHNhbXBsZXMsXG5cdFx0XHRjdXJyU2FtcGxlOiBudWxsLFxuXHRcdFx0Y3VyclRpbWU6IG51bGwsXG5cdFx0XHRtb292OiB0cmFja01vb3YsXG5cdFx0XHRtaW1lOiBtaW1lXG5cdFx0fSlcblx0fVxuXG5cdGlmIChzZWxmLl90cmFja3MubGVuZ3RoID09PSAwKSB7XG5cdFx0c2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gcGxheWFibGUgdHJhY2tzJykpXG5cdFx0cmV0dXJuXG5cdH1cblxuXHQvLyBNdXN0IGJlIHNldCBsYXN0IHNpbmNlIHRoaXMgaXMgdXNlZCBhYm92ZVxuXHRtb292Lm12aGQuZHVyYXRpb24gPSAwXG5cblx0c2VsZi5fZnR5cCA9IHtcblx0XHR0eXBlOiAnZnR5cCcsXG5cdFx0YnJhbmQ6ICdpc281Jyxcblx0XHRicmFuZFZlcnNpb246IDAsXG5cdFx0Y29tcGF0aWJsZUJyYW5kczogW1xuXHRcdFx0J2lzbzUnXG5cdFx0XVxuXHR9XG5cblx0dmFyIGZ0eXBCdWYgPSBCb3guZW5jb2RlKHNlbGYuX2Z0eXApXG5cdHZhciBkYXRhID0gc2VsZi5fdHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHtcblx0XHR2YXIgbW9vdkJ1ZiA9IEJveC5lbmNvZGUodHJhY2subW9vdilcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWltZTogdHJhY2subWltZSxcblx0XHRcdGluaXQ6IEJ1ZmZlci5jb25jYXQoW2Z0eXBCdWYsIG1vb3ZCdWZdKVxuXHRcdH1cblx0fSlcblxuXHRzZWxmLmVtaXQoJ3JlYWR5JywgZGF0YSlcbn1cblxuZnVuY3Rpb24gZW1wdHkgKCkge1xuXHRyZXR1cm4ge1xuXHRcdHZlcnNpb246IDAsXG5cdFx0ZmxhZ3M6IDAsXG5cdFx0ZW50cmllczogW11cblx0fVxufVxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICghc2VsZi5fdHJhY2tzKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgcmVhZHkgeWV0OyB3YWl0IGZvciBcXCdyZWFkeVxcJyBldmVudCcpXG5cdH1cblxuXHRpZiAoc2VsZi5fZmlsZVN0cmVhbSkge1xuXHRcdHNlbGYuX2ZpbGVTdHJlYW0uZGVzdHJveSgpXG5cdFx0c2VsZi5fZmlsZVN0cmVhbSA9IG51bGxcblx0fVxuXG5cdHZhciBzdGFydE9mZnNldCA9IC0xXG5cdHNlbGYuX3RyYWNrcy5tYXAoZnVuY3Rpb24gKHRyYWNrLCBpKSB7XG5cdFx0Ly8gZmluZCB0aGUga2V5ZnJhbWUgYmVmb3JlIHRoZSB0aW1lXG5cdFx0Ly8gc3RyZWFtIGZyb20gdGhlcmVcblx0XHRpZiAodHJhY2sub3V0U3RyZWFtKSB7XG5cdFx0XHR0cmFjay5vdXRTdHJlYW0uZGVzdHJveSgpXG5cdFx0fVxuXHRcdGlmICh0cmFjay5pblN0cmVhbSkge1xuXHRcdFx0dHJhY2suaW5TdHJlYW0uZGVzdHJveSgpXG5cdFx0XHR0cmFjay5pblN0cmVhbSA9IG51bGxcblx0XHR9XG5cdFx0dmFyIG91dFN0cmVhbSA9IHRyYWNrLm91dFN0cmVhbSA9IG1wNC5lbmNvZGUoKVxuXHRcdHZhciBmcmFnbWVudCA9IHNlbGYuX2dlbmVyYXRlRnJhZ21lbnQoaSwgdGltZSlcblx0XHRpZiAoIWZyYWdtZW50KSB7XG5cdFx0XHRyZXR1cm4gb3V0U3RyZWFtLmZpbmFsaXplKClcblx0XHR9XG5cblx0XHRpZiAoc3RhcnRPZmZzZXQgPT09IC0xIHx8IGZyYWdtZW50LnJhbmdlc1swXS5zdGFydCA8IHN0YXJ0T2Zmc2V0KSB7XG5cdFx0XHRzdGFydE9mZnNldCA9IGZyYWdtZW50LnJhbmdlc1swXS5zdGFydFxuXHRcdH1cblxuXHRcdHdyaXRlRnJhZ21lbnQoZnJhZ21lbnQpXG5cblx0XHRmdW5jdGlvbiB3cml0ZUZyYWdtZW50IChmcmFnKSB7XG5cdFx0XHRpZiAob3V0U3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuXG5cdFx0XHRvdXRTdHJlYW0uYm94KGZyYWcubW9vZiwgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRpZiAoZXJyKSByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0aWYgKG91dFN0cmVhbS5kZXN0cm95ZWQpIHJldHVyblxuXHRcdFx0XHR2YXIgc2xpY2VkU3RyZWFtID0gdHJhY2suaW5TdHJlYW0uc2xpY2UoZnJhZy5yYW5nZXMpXG5cdFx0XHRcdHNsaWNlZFN0cmVhbS5waXBlKG91dFN0cmVhbS5tZWRpYURhdGEoZnJhZy5sZW5ndGgsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRpZiAoZXJyKSByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0XHRpZiAob3V0U3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuXG5cdFx0XHRcdFx0dmFyIG5leHRGcmFnID0gc2VsZi5fZ2VuZXJhdGVGcmFnbWVudChpKVxuXHRcdFx0XHRcdGlmICghbmV4dEZyYWcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBvdXRTdHJlYW0uZmluYWxpemUoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3cml0ZUZyYWdtZW50KG5leHRGcmFnKVxuXHRcdFx0XHR9KSlcblx0XHRcdH0pXG5cdFx0fVxuXHR9KVxuXG5cdGlmIChzdGFydE9mZnNldCA+PSAwKSB7XG5cdFx0dmFyIGZpbGVTdHJlYW0gPSBzZWxmLl9maWxlU3RyZWFtID0gc2VsZi5fZmlsZS5jcmVhdGVSZWFkU3RyZWFtKHtcblx0XHRcdHN0YXJ0OiBzdGFydE9mZnNldFxuXHRcdH0pXG5cblx0XHRzZWxmLl90cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdHRyYWNrLmluU3RyZWFtID0gbmV3IFJhbmdlU2xpY2VTdHJlYW0oc3RhcnRPZmZzZXQpXG5cdFx0XHRmaWxlU3RyZWFtLnBpcGUodHJhY2suaW5TdHJlYW0pXG5cdFx0fSlcblx0fVxuXG5cdHJldHVybiBzZWxmLl90cmFja3MubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuXHRcdHJldHVybiB0cmFjay5vdXRTdHJlYW1cblx0fSlcbn1cblxuTVA0UmVtdXhlci5wcm90b3R5cGUuX2ZpbmRTYW1wbGVCZWZvcmUgPSBmdW5jdGlvbiAodHJhY2tJbmQsIHRpbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHRyYWNrID0gc2VsZi5fdHJhY2tzW3RyYWNrSW5kXVxuXHR2YXIgc2NhbGVkVGltZSA9IE1hdGguZmxvb3IodHJhY2sudGltZVNjYWxlICogdGltZSlcblx0dmFyIHNhbXBsZSA9IGJzKHRyYWNrLnNhbXBsZXMsIHNjYWxlZFRpbWUsIGZ1bmN0aW9uIChzYW1wbGUsIHQpIHtcblx0XHR2YXIgcHRzID0gc2FtcGxlLmR0cyArIHNhbXBsZS5wcmVzZW50YXRpb25PZmZzZXQvLyAtIHRyYWNrLmVkaXRTaGlmdFxuXHRcdHJldHVybiBwdHMgLSB0XG5cdH0pXG5cdGlmIChzYW1wbGUgPT09IC0xKSB7XG5cdFx0c2FtcGxlID0gMFxuXHR9IGVsc2UgaWYgKHNhbXBsZSA8IDApIHtcblx0XHRzYW1wbGUgPSAtc2FtcGxlIC0gMlxuXHR9XG5cdC8vIHNhbXBsZSBpcyBub3cgdGhlIGxhc3Qgc2FtcGxlIHdpdGggZHRzIDw9IHRpbWVcblx0Ly8gRmluZCB0aGUgcHJlY2VlZGluZyBzeW5jIHNhbXBsZVxuXHR3aGlsZSAoIXRyYWNrLnNhbXBsZXNbc2FtcGxlXS5zeW5jKSB7XG5cdFx0c2FtcGxlLS1cblx0fVxuXHRyZXR1cm4gc2FtcGxlXG59XG5cbnZhciBNSU5fRlJBR01FTlRfRFVSQVRJT04gPSAxIC8vIHNlY29uZFxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5fZ2VuZXJhdGVGcmFnbWVudCA9IGZ1bmN0aW9uICh0cmFjaywgdGltZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0Lypcblx0MS4gRmluZCBjb3JyZWN0IHNhbXBsZVxuXHQyLiBQcm9jZXNzIGJhY2t3YXJkIHVudGlsIHN5bmMgc2FtcGxlIGZvdW5kXG5cdDMuIFByb2Nlc3MgZm9yd2FyZCB1bnRpbCBuZXh0IHN5bmMgc2FtcGxlIGFmdGVyIE1JTl9GUkFHTUVOVF9EVVJBVElPTiBmb3VuZFxuXHQqL1xuXHR2YXIgY3VyclRyYWNrID0gc2VsZi5fdHJhY2tzW3RyYWNrXVxuXHR2YXIgZmlyc3RTYW1wbGVcblx0aWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZpcnN0U2FtcGxlID0gc2VsZi5fZmluZFNhbXBsZUJlZm9yZSh0cmFjaywgdGltZSlcblx0fSBlbHNlIHtcblx0XHRmaXJzdFNhbXBsZSA9IGN1cnJUcmFjay5jdXJyU2FtcGxlXG5cdH1cblxuXHRpZiAoZmlyc3RTYW1wbGUgPj0gY3VyclRyYWNrLnNhbXBsZXMubGVuZ3RoKVxuXHRcdHJldHVybiBudWxsXG5cblx0dmFyIHN0YXJ0RHRzID0gY3VyclRyYWNrLnNhbXBsZXNbZmlyc3RTYW1wbGVdLmR0c1xuXG5cdHZhciB0b3RhbExlbiA9IDBcblx0dmFyIHJhbmdlcyA9IFtdXG5cdGZvciAodmFyIGN1cnJTYW1wbGUgPSBmaXJzdFNhbXBsZTsgY3VyclNhbXBsZSA8IGN1cnJUcmFjay5zYW1wbGVzLmxlbmd0aDsgY3VyclNhbXBsZSsrKSB7XG5cdFx0dmFyIHNhbXBsZSA9IGN1cnJUcmFjay5zYW1wbGVzW2N1cnJTYW1wbGVdXG5cdFx0aWYgKHNhbXBsZS5zeW5jICYmIHNhbXBsZS5kdHMgLSBzdGFydER0cyA+PSBjdXJyVHJhY2sudGltZVNjYWxlICogTUlOX0ZSQUdNRU5UX0RVUkFUSU9OKSB7XG5cdFx0XHRicmVhayAvLyBUaGlzIGlzIGEgcmVhc29uYWJsZSBwbGFjZSB0byBlbmQgdGhlIGZyYWdtZW50XG5cdFx0fVxuXG5cdFx0dG90YWxMZW4gKz0gc2FtcGxlLnNpemVcblx0XHR2YXIgY3VyclJhbmdlID0gcmFuZ2VzLmxlbmd0aCAtIDFcblx0XHRpZiAoY3VyclJhbmdlIDwgMCB8fCByYW5nZXNbY3VyclJhbmdlXS5lbmQgIT09IHNhbXBsZS5vZmZzZXQpIHtcblx0XHRcdC8vIFB1c2ggYSBuZXcgcmFuZ2Vcblx0XHRcdHJhbmdlcy5wdXNoKHtcblx0XHRcdFx0c3RhcnQ6IHNhbXBsZS5vZmZzZXQsXG5cdFx0XHRcdGVuZDogc2FtcGxlLm9mZnNldCArIHNhbXBsZS5zaXplXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYW5nZXNbY3VyclJhbmdlXS5lbmQgKz0gc2FtcGxlLnNpemVcblx0XHR9XG5cdH1cblxuXHRjdXJyVHJhY2suY3VyclNhbXBsZSA9IGN1cnJTYW1wbGVcblxuXHRyZXR1cm4ge1xuXHRcdG1vb2Y6IHNlbGYuX2dlbmVyYXRlTW9vZih0cmFjaywgZmlyc3RTYW1wbGUsIGN1cnJTYW1wbGUpLFxuXHRcdHJhbmdlczogcmFuZ2VzLFxuXHRcdGxlbmd0aDogdG90YWxMZW5cblx0fVxufVxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5fZ2VuZXJhdGVNb29mID0gZnVuY3Rpb24gKHRyYWNrLCBmaXJzdFNhbXBsZSwgbGFzdFNhbXBsZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgY3VyclRyYWNrID0gc2VsZi5fdHJhY2tzW3RyYWNrXVxuXG5cdHZhciBlbnRyaWVzID0gW11cblx0Zm9yICh2YXIgaiA9IGZpcnN0U2FtcGxlOyBqIDwgbGFzdFNhbXBsZTsgaisrKSB7XG5cdFx0dmFyIGN1cnJTYW1wbGUgPSBjdXJyVHJhY2suc2FtcGxlc1tqXVxuXHRcdGVudHJpZXMucHVzaCh7XG5cdFx0XHRzYW1wbGVEdXJhdGlvbjogY3VyclNhbXBsZS5kdXJhdGlvbixcblx0XHRcdHNhbXBsZVNpemU6IGN1cnJTYW1wbGUuc2l6ZSxcblx0XHRcdHNhbXBsZUZsYWdzOiBjdXJyU2FtcGxlLnN5bmMgPyAweDIwMDAwMDAgOiAweDEwMTAwMDAsXG5cdFx0XHRzYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQ6IGN1cnJTYW1wbGUucHJlc2VudGF0aW9uT2Zmc2V0XG5cdFx0fSlcblx0fVxuXG5cdHZhciBtb29mID0ge1xuXHRcdHR5cGU6ICdtb29mJyxcblx0XHRtZmhkOiB7XG5cdFx0XHRzZXF1ZW5jZU51bWJlcjogc2VsZi5fZnJhZ21lbnRTZXF1ZW5jZSsrXG5cdFx0fSxcblx0XHR0cmFmczogW3tcblx0XHRcdHRmaGQ6IHtcblx0XHRcdFx0ZmxhZ3M6IDB4MjAwMDAsIC8vIGRlZmF1bHQtYmFzZS1pcy1tb29mXG5cdFx0XHRcdHRyYWNrSWQ6IGN1cnJUcmFjay50cmFja0lkXG5cdFx0XHR9LFxuXHRcdFx0dGZkdDoge1xuXHRcdFx0XHRiYXNlTWVkaWFEZWNvZGVUaW1lOiBjdXJyVHJhY2suc2FtcGxlc1tmaXJzdFNhbXBsZV0uZHRzXG5cdFx0XHR9LFxuXHRcdFx0dHJ1bjoge1xuXHRcdFx0XHRmbGFnczogMHhmMDEsXG5cdFx0XHRcdGRhdGFPZmZzZXQ6IDgsIC8vIFRoZSBtb29mIHNpemUgaGFzIHRvIGJlIGFkZGVkIHRvIHRoaXMgbGF0ZXIgYXMgd2VsbFxuXHRcdFx0XHRlbnRyaWVzOiBlbnRyaWVzXG5cdFx0XHR9XG5cdFx0fV1cblx0fVxuXG5cdC8vIFVwZGF0ZSB0aGUgb2Zmc2V0XG5cdG1vb2YudHJhZnNbMF0udHJ1bi5kYXRhT2Zmc2V0ICs9IEJveC5lbmNvZGluZ0xlbmd0aChtb29mKVxuXG5cdHJldHVybiBtb29mXG59XG4iLCJ2YXIgTWVkaWFFbGVtZW50V3JhcHBlciA9IHJlcXVpcmUoJ21lZGlhc291cmNlJylcbnZhciBwdW1wID0gcmVxdWlyZSgncHVtcCcpXG5cbnZhciBNUDRSZW11eGVyID0gcmVxdWlyZSgnLi9tcDQtcmVtdXhlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gVmlkZW9TdHJlYW1cblxuZnVuY3Rpb24gVmlkZW9TdHJlYW0gKGZpbGUsIG1lZGlhRWxlbSwgb3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFZpZGVvU3RyZWFtKSkgcmV0dXJuIG5ldyBWaWRlb1N0cmVhbShmaWxlLCBtZWRpYUVsZW0sIG9wdHMpXG5cdG9wdHMgPSBvcHRzIHx8IHt9XG5cblx0c2VsZi5fZWxlbSA9IG1lZGlhRWxlbVxuXHRzZWxmLl9lbGVtV3JhcHBlciA9IG5ldyBNZWRpYUVsZW1lbnRXcmFwcGVyKG1lZGlhRWxlbSlcblx0c2VsZi5fd2FpdGluZ0ZpcmVkID0gZmFsc2Vcblx0c2VsZi5fdHJhY2tNZXRhID0gbnVsbFxuXHRzZWxmLl9maWxlID0gZmlsZVxuXHRzZWxmLl90cmFja3MgPSBudWxsXG5cdGlmIChzZWxmLl9lbGVtLnByZWxvYWQgIT09ICdub25lJykge1xuXHRcdHNlbGYuX2NyZWF0ZU11eGVyKClcblx0fVxuXG5cdHNlbGYuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0c2VsZi5kZXN0cm95KCkgLy8gZG9uJ3QgcGFzcyBlcnIgdGhvdWdoIHNvIHRoZSB1c2VyIGRvZXNuJ3QgbmVlZCB0byBsaXN0ZW4gZm9yIGVycm9yc1xuXHR9XG5cdHNlbGYuX29uV2FpdGluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRzZWxmLl93YWl0aW5nRmlyZWQgPSB0cnVlXG5cdFx0aWYgKCFzZWxmLl9tdXhlcikge1xuXHRcdFx0c2VsZi5fY3JlYXRlTXV4ZXIoKVxuXHRcdH0gZWxzZSBpZiAoc2VsZi5fdHJhY2tzKSB7XG5cdFx0XHRzZWxmLl9wdW1wKClcblx0XHR9XG5cdH1cblx0c2VsZi5fZWxlbS5hZGRFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgc2VsZi5fb25XYWl0aW5nKVxuXHRzZWxmLl9lbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fb25FcnJvcilcbn1cblxuVmlkZW9TdHJlYW0ucHJvdG90eXBlLl9jcmVhdGVNdXhlciA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHNlbGYuX211eGVyID0gbmV3IE1QNFJlbXV4ZXIoc2VsZi5fZmlsZSlcblx0c2VsZi5fbXV4ZXIub24oJ3JlYWR5JywgZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRzZWxmLl90cmFja3MgPSBkYXRhLm1hcChmdW5jdGlvbiAodHJhY2tEYXRhKSB7XG5cdFx0XHR2YXIgbWVkaWFTb3VyY2UgPSBzZWxmLl9lbGVtV3JhcHBlci5jcmVhdGVXcml0ZVN0cmVhbSh0cmFja0RhdGEubWltZSlcblx0XHRcdG1lZGlhU291cmNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0c2VsZi5fZWxlbVdyYXBwZXIuZXJyb3IoZXJyKVxuXHRcdFx0fSlcblx0XHRcdG1lZGlhU291cmNlLndyaXRlKHRyYWNrRGF0YS5pbml0KVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bXV4ZWQ6IG51bGwsXG5cdFx0XHRcdG1lZGlhU291cmNlOiBtZWRpYVNvdXJjZVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRpZiAoc2VsZi5fd2FpdGluZ0ZpcmVkIHx8IHNlbGYuX2VsZW0ucHJlbG9hZCA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRzZWxmLl9wdW1wKClcblx0XHR9XG5cdH0pXG5cblx0c2VsZi5fbXV4ZXIub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHRcdHNlbGYuX2VsZW1XcmFwcGVyLmVycm9yKGVycilcblx0fSlcbn1cblxuVmlkZW9TdHJlYW0ucHJvdG90eXBlLl9wdW1wID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgbXV4ZWQgPSBzZWxmLl9tdXhlci5zZWVrKHNlbGYuX2VsZW0uY3VycmVudFRpbWUsICFzZWxmLl90cmFja3MpXG5cblx0c2VsZi5fdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrLCBpKSB7XG5cdFx0aWYgKHRyYWNrLm11eGVkKSB7XG5cdFx0XHR0cmFjay5tdXhlZC5kZXN0cm95KClcblx0XHRcdHRyYWNrLm1lZGlhU291cmNlID0gc2VsZi5fZWxlbVdyYXBwZXIuY3JlYXRlV3JpdGVTdHJlYW0odHJhY2subWVkaWFTb3VyY2UpXG5cdFx0XHR0cmFjay5tZWRpYVNvdXJjZS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdHNlbGYuX2VsZW1XcmFwcGVyLmVycm9yKGVycilcblx0XHRcdH0pXG5cdFx0fVxuXHRcdHRyYWNrLm11eGVkID0gbXV4ZWRbaV1cblx0XHRwdW1wKHRyYWNrLm11eGVkLCB0cmFjay5tZWRpYVNvdXJjZSlcblx0fSlcbn1cblxuVmlkZW9TdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAoc2VsZi5kZXN0cm95ZWQpIHtcblx0XHRyZXR1cm5cblx0fVxuXHRzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuXHRzZWxmLl9lbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCBzZWxmLl9vbldhaXRpbmcpXG5cdHNlbGYuX2VsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9vbkVycm9yKVxuXG5cdGlmIChzZWxmLl90cmFja3MpIHtcblx0XHRzZWxmLl90cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdHRyYWNrLm11eGVkLmRlc3Ryb3koKVxuXHRcdH0pXG5cdH1cblxuXHRzZWxmLl9lbGVtLnNyYyA9ICcnXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFdlYlRvcnJlbnRcblxudmFyIGNvbmNhdCA9IHJlcXVpcmUoJ3NpbXBsZS1jb25jYXQnKVxudmFyIGNyZWF0ZVRvcnJlbnQgPSByZXF1aXJlKCdjcmVhdGUtdG9ycmVudCcpXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd3ZWJ0b3JyZW50JylcbnZhciBESFQgPSByZXF1aXJlKCdiaXR0b3JyZW50LWRodC9jbGllbnQnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgaGF0ID0gcmVxdWlyZSgnaGF0JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBsb2FkSVBTZXQgPSByZXF1aXJlKCdsb2FkLWlwLXNldCcpIC8vIGJyb3dzZXIgZXhjbHVkZVxudmFyIHBhcmFsbGVsID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsJylcbnZhciBwYXJzZVRvcnJlbnQgPSByZXF1aXJlKCdwYXJzZS10b3JyZW50JylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgUGVlciA9IHJlcXVpcmUoJ3NpbXBsZS1wZWVyJylcbnZhciBzcGVlZG9tZXRlciA9IHJlcXVpcmUoJ3NwZWVkb21ldGVyJylcbnZhciB6ZXJvRmlsbCA9IHJlcXVpcmUoJ3plcm8tZmlsbCcpXG5cbnZhciBUQ1BQb29sID0gcmVxdWlyZSgnLi9saWIvdGNwLXBvb2wnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBUb3JyZW50ID0gcmVxdWlyZSgnLi9saWIvdG9ycmVudCcpXG5cbi8qKlxuICogV2ViVG9ycmVudCB2ZXJzaW9uLlxuICovXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4vKipcbiAqIFZlcnNpb24gbnVtYmVyIGluIEF6dXJldXMtc3R5bGUuIEdlbmVyYXRlZCBmcm9tIG1ham9yIGFuZCBtaW5vciBzZW12ZXIgdmVyc2lvbi5cbiAqIEZvciBleGFtcGxlOlxuICogICAnMC4xNi4xJyAtPiAnMDAxNidcbiAqICAgJzEuMi41JyAtPiAnMDEwMidcbiAqL1xudmFyIFZFUlNJT05fU1RSID0gVkVSU0lPTi5tYXRjaCgvKFswLTldKykvZykuc2xpY2UoMCwgMikubWFwKHplcm9GaWxsKDIpKS5qb2luKCcnKVxuXG4vKipcbiAqIFZlcnNpb24gcHJlZml4IHN0cmluZyAodXNlZCBpbiBwZWVyIElEKS4gV2ViVG9ycmVudCB1c2VzIHRoZSBBenVyZXVzLXN0eWxlXG4gKiBlbmNvZGluZzogJy0nLCB0d28gY2hhcmFjdGVycyBmb3IgY2xpZW50IGlkICgnV1cnKSwgZm91ciBhc2NpaSBkaWdpdHMgZm9yIHZlcnNpb25cbiAqIG51bWJlciwgJy0nLCBmb2xsb3dlZCBieSByYW5kb20gbnVtYmVycy5cbiAqIEZvciBleGFtcGxlOlxuICogICAnLVdXMDEwMi0nLi4uXG4gKi9cbnZhciBWRVJTSU9OX1BSRUZJWCA9ICctV1cnICsgVkVSU0lPTl9TVFIgKyAnLSdcblxuaW5oZXJpdHMoV2ViVG9ycmVudCwgRXZlbnRFbWl0dGVyKVxuXG4vKipcbiAqIFdlYlRvcnJlbnQgQ2xpZW50XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdHNcbiAqL1xuZnVuY3Rpb24gV2ViVG9ycmVudCAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFdlYlRvcnJlbnQpKSByZXR1cm4gbmV3IFdlYlRvcnJlbnQob3B0cylcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcblxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHNlbGYucGVlcklkID0gdHlwZW9mIG9wdHMucGVlcklkID09PSAnc3RyaW5nJ1xuICAgID8gb3B0cy5wZWVySWRcbiAgICA6IChvcHRzLnBlZXJJZCB8fCBuZXcgQnVmZmVyKFZFUlNJT05fUFJFRklYICsgaGF0KDQ4KSkpLnRvU3RyaW5nKCdoZXgnKVxuICBzZWxmLnBlZXJJZEJ1ZmZlciA9IG5ldyBCdWZmZXIoc2VsZi5wZWVySWQsICdoZXgnKVxuXG4gIHNlbGYubm9kZUlkID0gdHlwZW9mIG9wdHMubm9kZUlkID09PSAnc3RyaW5nJ1xuICAgID8gb3B0cy5ub2RlSWRcbiAgICA6IChvcHRzLm5vZGVJZCAmJiBvcHRzLm5vZGVJZC50b1N0cmluZygnaGV4JykpIHx8IGhhdCgxNjApXG4gIHNlbGYubm9kZUlkQnVmZmVyID0gbmV3IEJ1ZmZlcihzZWxmLm5vZGVJZCwgJ2hleCcpXG5cbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuICBzZWxmLmxpc3RlbmluZyA9IGZhbHNlXG4gIHNlbGYudG9ycmVudFBvcnQgPSBvcHRzLnRvcnJlbnRQb3J0IHx8IDBcbiAgc2VsZi5kaHRQb3J0ID0gb3B0cy5kaHRQb3J0IHx8IDBcbiAgc2VsZi50cmFja2VyID0gb3B0cy50cmFja2VyICE9PSB1bmRlZmluZWQgPyBvcHRzLnRyYWNrZXIgOiB0cnVlXG4gIHNlbGYudG9ycmVudHMgPSBbXVxuICBzZWxmLm1heENvbm5zID0gTnVtYmVyKG9wdHMubWF4Q29ubnMpIHx8IDU1XG5cbiAgc2VsZi5fcnRjQ29uZmlnID0gb3B0cy5ydGNDb25maWdcbiAgc2VsZi5fd3J0YyA9IG9wdHMud3J0YyB8fCBnbG9iYWwuV1JUQyAvLyB0byBzdXBwb3J0IGB3ZWJ0b3JyZW50LWh5YnJpZGAgcGFja2FnZVxuXG4gIGlmICh0eXBlb2YgVENQUG9vbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuX3RjcFBvb2wgPSBuZXcgVENQUG9vbChzZWxmKVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fb25MaXN0ZW5pbmcoKVxuICAgIH0pXG4gIH1cblxuICAvLyBzdGF0c1xuICBzZWxmLl9kb3dubG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuICBzZWxmLl91cGxvYWRTcGVlZCA9IHNwZWVkb21ldGVyKClcblxuICBpZiAob3B0cy5kaHQgIT09IGZhbHNlICYmIHR5cGVvZiBESFQgPT09ICdmdW5jdGlvbicgLyogYnJvd3NlciBleGNsdWRlICovKSB7XG4gICAgLy8gdXNlIGEgc2luZ2xlIERIVCBpbnN0YW5jZSBmb3IgYWxsIHRvcnJlbnRzLCBzbyB0aGUgcm91dGluZyB0YWJsZSBjYW4gYmUgcmV1c2VkXG4gICAgc2VsZi5kaHQgPSBuZXcgREhUKGV4dGVuZCh7IG5vZGVJZDogc2VsZi5ub2RlSWQgfSwgb3B0cy5kaHQpKVxuXG4gICAgc2VsZi5kaHQub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBzZWxmLl9kZXN0cm95KGVycilcbiAgICB9KVxuXG4gICAgc2VsZi5kaHQub25jZSgnbGlzdGVuaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFkZHJlc3MgPSBzZWxmLmRodC5hZGRyZXNzKClcbiAgICAgIGlmIChhZGRyZXNzKSBzZWxmLmRodFBvcnQgPSBhZGRyZXNzLnBvcnRcbiAgICB9KVxuXG4gICAgLy8gSWdub3JlIHdhcm5pbmcgd2hlbiB0aGVyZSBhcmUgPiAxMCB0b3JyZW50cyBpbiB0aGUgY2xpZW50XG4gICAgc2VsZi5kaHQuc2V0TWF4TGlzdGVuZXJzKDApXG5cbiAgICBzZWxmLmRodC5saXN0ZW4oc2VsZi5kaHRQb3J0KVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZGh0ID0gZmFsc2VcbiAgfVxuXG4gIGRlYnVnKCduZXcgd2VidG9ycmVudCAocGVlcklkICVzLCBub2RlSWQgJXMpJywgc2VsZi5wZWVySWQsIHNlbGYubm9kZUlkKVxuXG4gIGlmICh0eXBlb2YgbG9hZElQU2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbG9hZElQU2V0KG9wdHMuYmxvY2tsaXN0LCB7XG4gICAgICBoZWFkZXJzOiB7ICd1c2VyLWFnZW50JzogJ1dlYlRvcnJlbnQvJyArIFZFUlNJT04gKyAnIChodHRwOi8vd2VidG9ycmVudC5pbyknIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyLCBpcFNldCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGJsb2NrbGlzdDogJyArIGVyci5tZXNzYWdlKVxuICAgICAgc2VsZi5ibG9ja2VkID0gaXBTZXRcbiAgICAgIHJlYWR5KClcbiAgICB9KVxuICB9IGVsc2UgcHJvY2Vzcy5uZXh0VGljayhyZWFkeSlcblxuICBmdW5jdGlvbiByZWFkeSAoKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzZWxmLnJlYWR5ID0gdHJ1ZVxuICAgIHNlbGYuZW1pdCgncmVhZHknKVxuICB9XG59XG5cbldlYlRvcnJlbnQuV0VCUlRDX1NVUFBPUlQgPSBQZWVyLldFQlJUQ19TVVBQT1JUXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJUb3JyZW50LnByb3RvdHlwZSwgJ2Rvd25sb2FkU3BlZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG93bmxvYWRTcGVlZCgpIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJUb3JyZW50LnByb3RvdHlwZSwgJ3VwbG9hZFNwZWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3VwbG9hZFNwZWVkKCkgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlRvcnJlbnQucHJvdG90eXBlLCAncHJvZ3Jlc3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b3JyZW50cyA9IHRoaXMudG9ycmVudHMuZmlsdGVyKGZ1bmN0aW9uICh0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG9ycmVudC5wcm9ncmVzcyAhPT0gMVxuICAgIH0pXG4gICAgdmFyIGRvd25sb2FkZWQgPSB0b3JyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG90YWwgKyB0b3JyZW50LmRvd25sb2FkZWRcbiAgICB9LCAwKVxuICAgIHZhciBsZW5ndGggPSB0b3JyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG90YWwgKyAodG9ycmVudC5sZW5ndGggfHwgMClcbiAgICB9LCAwKSB8fCAxXG4gICAgcmV0dXJuIGRvd25sb2FkZWQgLyBsZW5ndGhcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlRvcnJlbnQucHJvdG90eXBlLCAncmF0aW8nLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB1cGxvYWRlZCA9IHRoaXMudG9ycmVudHMucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgdG9ycmVudCkge1xuICAgICAgcmV0dXJuIHRvdGFsICsgdG9ycmVudC51cGxvYWRlZFxuICAgIH0sIDApXG4gICAgdmFyIHJlY2VpdmVkID0gdGhpcy50b3JyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG90YWwgKyB0b3JyZW50LnJlY2VpdmVkXG4gICAgfSwgMCkgfHwgMVxuICAgIHJldHVybiB1cGxvYWRlZCAvIHJlY2VpdmVkXG4gIH1cbn0pXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdG9ycmVudCB3aXRoIHRoZSBnaXZlbiBgdG9ycmVudElkYC4gQ29udmVuaWVuY2UgbWV0aG9kLiBFYXNpZXIgdGhhblxuICogc2VhcmNoaW5nIHRocm91Z2ggdGhlIGBjbGllbnQudG9ycmVudHNgIGFycmF5LiBSZXR1cm5zIGBudWxsYCBpZiBubyBtYXRjaGluZyB0b3JyZW50XG4gKiBmb3VuZC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8QnVmZmVyfE9iamVjdHxUb3JyZW50fSB0b3JyZW50SWRcbiAqIEByZXR1cm4ge1RvcnJlbnR8bnVsbH1cbiAqL1xuV2ViVG9ycmVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRvcnJlbnRJZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGksIHRvcnJlbnRcbiAgdmFyIGxlbiA9IHNlbGYudG9ycmVudHMubGVuZ3RoXG5cbiAgaWYgKHRvcnJlbnRJZCBpbnN0YW5jZW9mIFRvcnJlbnQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRvcnJlbnQgPSBzZWxmLnRvcnJlbnRzW2ldXG4gICAgICBpZiAodG9ycmVudCA9PT0gdG9ycmVudElkKSByZXR1cm4gdG9ycmVudFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkXG4gICAgdHJ5IHsgcGFyc2VkID0gcGFyc2VUb3JyZW50KHRvcnJlbnRJZCkgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsXG4gICAgaWYgKCFwYXJzZWQuaW5mb0hhc2gpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b3JyZW50IGlkZW50aWZpZXInKVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0b3JyZW50ID0gc2VsZi50b3JyZW50c1tpXVxuICAgICAgaWYgKHRvcnJlbnQuaW5mb0hhc2ggPT09IHBhcnNlZC5pbmZvSGFzaCkgcmV0dXJuIHRvcnJlbnRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuV2ViVG9ycmVudC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbiAodG9ycmVudElkLCBvcHRzLCBvbnRvcnJlbnQpIHtcbiAgY29uc29sZS53YXJuKCdXZWJUb3JyZW50OiBjbGllbnQuZG93bmxvYWQoKSBpcyBkZXByZWNhdGVkLiBVc2UgY2xpZW50LmFkZCgpIGluc3RlYWQnKVxuICByZXR1cm4gdGhpcy5hZGQodG9ycmVudElkLCBvcHRzLCBvbnRvcnJlbnQpXG59XG5cbi8qKlxuICogU3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgdG9ycmVudC4gQWxpYXNlZCBhcyBgY2xpZW50LmRvd25sb2FkYC5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxPYmplY3R9IHRvcnJlbnRJZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgdG9ycmVudC1zcGVjaWZpYyBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb250b3JyZW50IGNhbGxlZCB3aGVuIHRoZSB0b3JyZW50IGlzIHJlYWR5IChoYXMgbWV0YWRhdGEpXG4gKi9cbldlYlRvcnJlbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0b3JyZW50SWQsIG9wdHMsIG9udG9ycmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudCBpcyBkZXN0cm95ZWQnKVxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmLmFkZCh0b3JyZW50SWQsIG51bGwsIG9wdHMpXG5cbiAgZGVidWcoJ2FkZCcpXG4gIG9wdHMgPSBvcHRzID8gZXh0ZW5kKG9wdHMpIDoge31cblxuICB2YXIgdG9ycmVudCA9IG5ldyBUb3JyZW50KHRvcnJlbnRJZCwgc2VsZiwgb3B0cylcbiAgc2VsZi50b3JyZW50cy5wdXNoKHRvcnJlbnQpXG5cbiAgdG9ycmVudC5vbmNlKCdpbmZvSGFzaCcsIG9uSW5mb0hhc2gpXG4gIHRvcnJlbnQub25jZSgncmVhZHknLCBvblJlYWR5KVxuICB0b3JyZW50Lm9uY2UoJ2Nsb3NlJywgb25DbG9zZSlcblxuICBmdW5jdGlvbiBvbkluZm9IYXNoICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLnRvcnJlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHNlbGYudG9ycmVudHNbaV1cbiAgICAgIGlmICh0LmluZm9IYXNoID09PSB0b3JyZW50LmluZm9IYXNoICYmIHQgIT09IHRvcnJlbnQpIHtcbiAgICAgICAgdG9ycmVudC5fZGVzdHJveShuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgZHVwbGljYXRlIHRvcnJlbnQgJyArIHRvcnJlbnQuaW5mb0hhc2gpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJlYWR5ICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0eXBlb2Ygb250b3JyZW50ID09PSAnZnVuY3Rpb24nKSBvbnRvcnJlbnQodG9ycmVudClcbiAgICBzZWxmLmVtaXQoJ3RvcnJlbnQnLCB0b3JyZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gb25DbG9zZSAoKSB7XG4gICAgdG9ycmVudC5yZW1vdmVMaXN0ZW5lcignaW5mb0hhc2gnLCBvbkluZm9IYXNoKVxuICAgIHRvcnJlbnQucmVtb3ZlTGlzdGVuZXIoJ3JlYWR5Jywgb25SZWFkeSlcbiAgICB0b3JyZW50LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG4gIH1cblxuICByZXR1cm4gdG9ycmVudFxufVxuXG4vKipcbiAqIFN0YXJ0IHNlZWRpbmcgYSBuZXcgZmlsZS9mb2xkZXIuXG4gKiBAcGFyYW0gIHtzdHJpbmd8RmlsZXxGaWxlTGlzdHxCdWZmZXJ8QXJyYXkuPHN0cmluZ3xGaWxlfEJ1ZmZlcj59IGlucHV0XG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRzXG4gKiBAcGFyYW0gIHtmdW5jdGlvbj19IG9uc2VlZCBjYWxsZWQgd2hlbiB0b3JyZW50IGlzIHNlZWRpbmdcbiAqL1xuV2ViVG9ycmVudC5wcm90b3R5cGUuc2VlZCA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0cywgb25zZWVkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignY2xpZW50IGlzIGRlc3Ryb3llZCcpXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGYuc2VlZChpbnB1dCwgbnVsbCwgb3B0cylcblxuICBkZWJ1Zygnc2VlZCcpXG4gIG9wdHMgPSBvcHRzID8gZXh0ZW5kKG9wdHMpIDoge31cblxuICAvLyBXaGVuIHNlZWRpbmcgZnJvbSBmcyBwYXRoLCBpbml0aWFsaXplIHN0b3JlIGZyb20gdGhhdCBwYXRoIHRvIGF2b2lkIGEgY29weVxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykgb3B0cy5wYXRoID0gcGF0aC5kaXJuYW1lKGlucHV0KVxuICBpZiAoIW9wdHMuY3JlYXRlZEJ5KSBvcHRzLmNyZWF0ZWRCeSA9ICdXZWJUb3JyZW50LycgKyBWRVJTSU9OX1NUUlxuICBpZiAoIXNlbGYudHJhY2tlcikgb3B0cy5hbm5vdW5jZSA9IFtdXG5cbiAgdmFyIHRvcnJlbnQgPSBzZWxmLmFkZChudWxsLCBvcHRzLCBvblRvcnJlbnQpXG4gIHZhciBzdHJlYW1zXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkgaW5wdXQgPSBbIGlucHV0IF1cbiAgcGFyYWxsZWwoaW5wdXQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgaWYgKGlzUmVhZGFibGUoaXRlbSkpIGNvbmNhdChpdGVtLCBjYilcbiAgICAgIGVsc2UgY2IobnVsbCwgaXRlbSlcbiAgICB9XG4gIH0pLCBmdW5jdGlvbiAoZXJyLCBpbnB1dCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGVycikgcmV0dXJuIHRvcnJlbnQuX2Rlc3Ryb3koZXJyKVxuXG4gICAgY3JlYXRlVG9ycmVudC5wYXJzZUlucHV0KGlucHV0LCBvcHRzLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIGlmIChlcnIpIHJldHVybiB0b3JyZW50Ll9kZXN0cm95KGVycilcblxuICAgICAgc3RyZWFtcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZS5nZXRTdHJlYW1cbiAgICAgIH0pXG5cbiAgICAgIGNyZWF0ZVRvcnJlbnQoaW5wdXQsIG9wdHMsIGZ1bmN0aW9uIChlcnIsIHRvcnJlbnRCdWYpIHtcbiAgICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHRvcnJlbnQuX2Rlc3Ryb3koZXJyKVxuXG4gICAgICAgIHZhciBleGlzdGluZ1RvcnJlbnQgPSBzZWxmLmdldCh0b3JyZW50QnVmKVxuICAgICAgICBpZiAoZXhpc3RpbmdUb3JyZW50KSB7XG4gICAgICAgICAgdG9ycmVudC5fZGVzdHJveShuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgZHVwbGljYXRlIHRvcnJlbnQgJyArIGV4aXN0aW5nVG9ycmVudC5pbmZvSGFzaCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9ycmVudC5fb25Ub3JyZW50SWQodG9ycmVudEJ1ZilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIG9uVG9ycmVudCAodG9ycmVudCkge1xuICAgIHZhciB0YXNrcyA9IFtcbiAgICAgIGZ1bmN0aW9uIChjYikge1xuICAgICAgICB0b3JyZW50LmxvYWQoc3RyZWFtcywgY2IpXG4gICAgICB9XG4gICAgXVxuICAgIGlmIChzZWxmLmRodCkge1xuICAgICAgdGFza3MucHVzaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdG9ycmVudC5vbmNlKCdkaHRBbm5vdW5jZScsIGNiKVxuICAgICAgfSlcbiAgICB9XG4gICAgcGFyYWxsZWwodGFza3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBpZiAoZXJyKSByZXR1cm4gdG9ycmVudC5fZGVzdHJveShlcnIpXG4gICAgICBfb25zZWVkKHRvcnJlbnQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vbnNlZWQgKHRvcnJlbnQpIHtcbiAgICBkZWJ1Zygnb24gc2VlZCcpXG4gICAgaWYgKHR5cGVvZiBvbnNlZWQgPT09ICdmdW5jdGlvbicpIG9uc2VlZCh0b3JyZW50KVxuICAgIHNlbGYuZW1pdCgnc2VlZCcsIHRvcnJlbnQpXG4gIH1cblxuICByZXR1cm4gdG9ycmVudFxufVxuXG4vKipcbiAqIFJlbW92ZSBhIHRvcnJlbnQgZnJvbSB0aGUgY2xpZW50LlxuICogQHBhcmFtICB7c3RyaW5nfEJ1ZmZlcnxUb3JyZW50fSAgIHRvcnJlbnRJZFxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbldlYlRvcnJlbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0b3JyZW50SWQsIGNiKSB7XG4gIGRlYnVnKCdyZW1vdmUnKVxuICB2YXIgdG9ycmVudCA9IHRoaXMuZ2V0KHRvcnJlbnRJZClcbiAgaWYgKCF0b3JyZW50KSB0aHJvdyBuZXcgRXJyb3IoJ05vIHRvcnJlbnQgd2l0aCBpZCAnICsgdG9ycmVudElkKVxuICB0aGlzLl9yZW1vdmUodG9ycmVudElkLCBjYilcbn1cblxuV2ViVG9ycmVudC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uICh0b3JyZW50SWQsIGNiKSB7XG4gIHZhciB0b3JyZW50ID0gdGhpcy5nZXQodG9ycmVudElkKVxuICBpZiAoIXRvcnJlbnQpIHJldHVyblxuICB0aGlzLnRvcnJlbnRzLnNwbGljZSh0aGlzLnRvcnJlbnRzLmluZGV4T2YodG9ycmVudCksIDEpXG4gIHRvcnJlbnQuZGVzdHJveShjYilcbn1cblxuV2ViVG9ycmVudC5wcm90b3R5cGUuYWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmxpc3RlbmluZykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHRoaXMuX3RjcFBvb2xcbiAgICA/IHRoaXMuX3RjcFBvb2wuc2VydmVyLmFkZHJlc3MoKVxuICAgIDogeyBhZGRyZXNzOiAnMC4wLjAuMCcsIGZhbWlseTogJ0lQdjQnLCBwb3J0OiAwIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBjbGllbnQsIGluY2x1ZGluZyBhbGwgdG9ycmVudHMgYW5kIGNvbm5lY3Rpb25zIHRvIHBlZXJzLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbldlYlRvcnJlbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudCBhbHJlYWR5IGRlc3Ryb3llZCcpXG4gIHRoaXMuX2Rlc3Ryb3kobnVsbCwgY2IpXG59XG5cbldlYlRvcnJlbnQucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKCdjbGllbnQgZGVzdHJveScpXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIHZhciB0YXNrcyA9IHNlbGYudG9ycmVudHMubWFwKGZ1bmN0aW9uICh0b3JyZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgdG9ycmVudC5kZXN0cm95KGNiKVxuICAgIH1cbiAgfSlcblxuICBpZiAoc2VsZi5fdGNwUG9vbCkge1xuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLl90Y3BQb29sLmRlc3Ryb3koY2IpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzZWxmLmRodCkge1xuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLmRodC5kZXN0cm95KGNiKVxuICAgIH0pXG4gIH1cblxuICBwYXJhbGxlbCh0YXNrcywgY2IpXG5cbiAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcblxuICBzZWxmLnRvcnJlbnRzID0gW11cbiAgc2VsZi5fdGNwUG9vbCA9IG51bGxcbiAgc2VsZi5kaHQgPSBudWxsXG59XG5cbldlYlRvcnJlbnQucHJvdG90eXBlLl9vbkxpc3RlbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5saXN0ZW5pbmcgPSB0cnVlXG5cbiAgaWYgKHRoaXMuX3RjcFBvb2wpIHtcbiAgICAvLyBTb21ldGltZXMgc2VydmVyLmFkZHJlc3MoKSByZXR1cm5zIGBudWxsYCBpbiBEb2NrZXIuXG4gICAgLy8gV2ViVG9ycmVudCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9iaXR0b3JyZW50LXN3YXJtL3B1bGwvMThcbiAgICB2YXIgYWRkcmVzcyA9IHRoaXMuX3RjcFBvb2wuc2VydmVyLmFkZHJlc3MoKVxuICAgIGlmIChhZGRyZXNzKSB0aGlzLnRvcnJlbnRQb3J0ID0gYWRkcmVzcy5wb3J0XG4gIH1cblxuICB0aGlzLmVtaXQoJ2xpc3RlbmluZycpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBub2RlIFJlYWRhYmxlIHN0cmVhbVxuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBGaWxlU3RyZWFtXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3dlYnRvcnJlbnQ6ZmlsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbmluaGVyaXRzKEZpbGVTdHJlYW0sIHN0cmVhbS5SZWFkYWJsZSlcblxuLyoqXG4gKiBSZWFkYWJsZSBzdHJlYW0gb2YgYSB0b3JyZW50IGZpbGVcbiAqXG4gKiBAcGFyYW0ge0ZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zdGFydCBzdHJlYW0gc2xpY2Ugb2YgZmlsZSwgc3RhcnRpbmcgZnJvbSB0aGlzIGJ5dGUgKGluY2x1c2l2ZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmVuZCBzdHJlYW0gc2xpY2Ugb2YgZmlsZSwgZW5kaW5nIHdpdGggdGhpcyBieXRlIChpbmNsdXNpdmUpXG4gKi9cbmZ1bmN0aW9uIEZpbGVTdHJlYW0gKGZpbGUsIG9wdHMpIHtcbiAgc3RyZWFtLlJlYWRhYmxlLmNhbGwodGhpcywgb3B0cylcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHRoaXMuX3RvcnJlbnQgPSBmaWxlLl90b3JyZW50XG5cbiAgdmFyIHN0YXJ0ID0gKG9wdHMgJiYgb3B0cy5zdGFydCkgfHwgMFxuICB2YXIgZW5kID0gKG9wdHMgJiYgb3B0cy5lbmQgJiYgb3B0cy5lbmQgPCBmaWxlLmxlbmd0aClcbiAgICA/IG9wdHMuZW5kXG4gICAgOiBmaWxlLmxlbmd0aCAtIDFcblxuICB2YXIgcGllY2VMZW5ndGggPSBmaWxlLl90b3JyZW50LnBpZWNlTGVuZ3RoXG5cbiAgdGhpcy5fc3RhcnRQaWVjZSA9IChzdGFydCArIGZpbGUub2Zmc2V0KSAvIHBpZWNlTGVuZ3RoIHwgMFxuICB0aGlzLl9lbmRQaWVjZSA9IChlbmQgKyBmaWxlLm9mZnNldCkgLyBwaWVjZUxlbmd0aCB8IDBcblxuICB0aGlzLl9waWVjZSA9IHRoaXMuX3N0YXJ0UGllY2VcbiAgdGhpcy5fb2Zmc2V0ID0gKHN0YXJ0ICsgZmlsZS5vZmZzZXQpIC0gKHRoaXMuX3N0YXJ0UGllY2UgKiBwaWVjZUxlbmd0aClcblxuICB0aGlzLl9taXNzaW5nID0gZW5kIC0gc3RhcnQgKyAxXG4gIHRoaXMuX3JlYWRpbmcgPSBmYWxzZVxuICB0aGlzLl9ub3RpZnlpbmcgPSBmYWxzZVxuICB0aGlzLl9jcml0aWNhbExlbmd0aCA9IE1hdGgubWluKCgxMDI0ICogMTAyNCAvIHBpZWNlTGVuZ3RoKSB8IDAsIDIpXG59XG5cbkZpbGVTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcmVhZGluZykgcmV0dXJuXG4gIHRoaXMuX3JlYWRpbmcgPSB0cnVlXG4gIHRoaXMuX25vdGlmeSgpXG59XG5cbkZpbGVTdHJlYW0ucHJvdG90eXBlLl9ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICghc2VsZi5fcmVhZGluZyB8fCBzZWxmLl9taXNzaW5nID09PSAwKSByZXR1cm5cbiAgaWYgKCFzZWxmLl90b3JyZW50LmJpdGZpZWxkLmdldChzZWxmLl9waWVjZSkpIHtcbiAgICByZXR1cm4gc2VsZi5fdG9ycmVudC5jcml0aWNhbChzZWxmLl9waWVjZSwgc2VsZi5fcGllY2UgKyBzZWxmLl9jcml0aWNhbExlbmd0aClcbiAgfVxuXG4gIGlmIChzZWxmLl9ub3RpZnlpbmcpIHJldHVyblxuICBzZWxmLl9ub3RpZnlpbmcgPSB0cnVlXG5cbiAgdmFyIHAgPSBzZWxmLl9waWVjZVxuICBzZWxmLl90b3JyZW50LnN0b3JlLmdldChwLCBmdW5jdGlvbiAoZXJyLCBidWZmZXIpIHtcbiAgICBzZWxmLl9ub3RpZnlpbmcgPSBmYWxzZVxuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGVycikgcmV0dXJuIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICAgIGRlYnVnKCdyZWFkICVzIChsZW5ndGggJXMpIChlcnIgJXMpJywgcCwgYnVmZmVyLmxlbmd0aCwgZXJyICYmIGVyci5tZXNzYWdlKVxuXG4gICAgaWYgKHNlbGYuX29mZnNldCkge1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKHNlbGYuX29mZnNldClcbiAgICAgIHNlbGYuX29mZnNldCA9IDBcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fbWlzc2luZyA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBzZWxmLl9taXNzaW5nKVxuICAgIH1cbiAgICBzZWxmLl9taXNzaW5nIC09IGJ1ZmZlci5sZW5ndGhcblxuICAgIGRlYnVnKCdwdXNoaW5nIGJ1ZmZlciBvZiBsZW5ndGggJXMnLCBidWZmZXIubGVuZ3RoKVxuICAgIHNlbGYuX3JlYWRpbmcgPSBmYWxzZVxuICAgIHNlbGYucHVzaChidWZmZXIpXG5cbiAgICBpZiAoc2VsZi5fbWlzc2luZyA9PT0gMCkgc2VsZi5wdXNoKG51bGwpXG4gIH0pXG4gIHNlbGYuX3BpZWNlICs9IDFcbn1cblxuRmlsZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvbmNsb3NlKSB7XG4gIHRoaXMuX2Rlc3Ryb3kobnVsbCwgb25jbG9zZSlcbn1cblxuRmlsZVN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBvbmNsb3NlKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGlmICghdGhpcy5fdG9ycmVudC5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl90b3JyZW50LmRlc2VsZWN0KHRoaXMuX3N0YXJ0UGllY2UsIHRoaXMuX2VuZFBpZWNlLCB0cnVlKVxuICB9XG5cbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG4gIGlmIChvbmNsb3NlKSBvbmNsb3NlKClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gRmlsZVxuXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgRmlsZVN0cmVhbSA9IHJlcXVpcmUoJy4vZmlsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciByZW5kZXIgPSByZXF1aXJlKCdyZW5kZXItbWVkaWEnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgc3RyZWFtVG9CbG9iVVJMID0gcmVxdWlyZSgnc3RyZWFtLXRvLWJsb2ItdXJsJylcbnZhciBzdHJlYW1Ub0J1ZmZlciA9IHJlcXVpcmUoJ3N0cmVhbS13aXRoLWtub3duLWxlbmd0aC10by1idWZmZXInKVxuXG5pbmhlcml0cyhGaWxlLCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIEZpbGUgKHRvcnJlbnQsIGZpbGUpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICB0aGlzLl90b3JyZW50ID0gdG9ycmVudFxuXG4gIHRoaXMubmFtZSA9IGZpbGUubmFtZVxuICB0aGlzLnBhdGggPSBmaWxlLnBhdGhcbiAgdGhpcy5sZW5ndGggPSBmaWxlLmxlbmd0aFxuICB0aGlzLm9mZnNldCA9IGZpbGUub2Zmc2V0XG5cbiAgdGhpcy5kb25lID0gZmFsc2VcblxuICB2YXIgc3RhcnQgPSBmaWxlLm9mZnNldFxuICB2YXIgZW5kID0gc3RhcnQgKyBmaWxlLmxlbmd0aCAtIDFcblxuICB0aGlzLl9zdGFydFBpZWNlID0gc3RhcnQgLyB0aGlzLl90b3JyZW50LnBpZWNlTGVuZ3RoIHwgMFxuICB0aGlzLl9lbmRQaWVjZSA9IGVuZCAvIHRoaXMuX3RvcnJlbnQucGllY2VMZW5ndGggfCAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5kb25lID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgnZG9uZScpXG4gIH1cbn1cblxuRmlsZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gIHRoaXMuX3RvcnJlbnQuc2VsZWN0KHRoaXMuX3N0YXJ0UGllY2UsIHRoaXMuX2VuZFBpZWNlLCBwcmlvcml0eSlcbn1cblxuRmlsZS5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gIHRoaXMuX3RvcnJlbnQuZGVzZWxlY3QodGhpcy5fc3RhcnRQaWVjZSwgdGhpcy5fZW5kUGllY2UsIGZhbHNlKVxufVxuXG5GaWxlLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBlbXB0eSA9IG5ldyBzdHJlYW0uUGFzc1Rocm91Z2goKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgZW1wdHkuZW5kKClcbiAgICB9KVxuICAgIHJldHVybiBlbXB0eVxuICB9XG5cbiAgdmFyIGZpbGVTdHJlYW0gPSBuZXcgRmlsZVN0cmVhbShzZWxmLCBvcHRzKVxuICBzZWxmLl90b3JyZW50LnNlbGVjdChmaWxlU3RyZWFtLl9zdGFydFBpZWNlLCBmaWxlU3RyZWFtLl9lbmRQaWVjZSwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xuICAgIGZpbGVTdHJlYW0uX25vdGlmeSgpXG4gIH0pXG4gIGVvcyhmaWxlU3RyZWFtLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzZWxmLl90b3JyZW50LmRlc3Ryb3llZCkge1xuICAgICAgc2VsZi5fdG9ycmVudC5kZXNlbGVjdChmaWxlU3RyZWFtLl9zdGFydFBpZWNlLCBmaWxlU3RyZWFtLl9lbmRQaWVjZSwgdHJ1ZSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBmaWxlU3RyZWFtXG59XG5cbkZpbGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIChjYikge1xuICBzdHJlYW1Ub0J1ZmZlcih0aGlzLmNyZWF0ZVJlYWRTdHJlYW0oKSwgdGhpcy5sZW5ndGgsIGNiKVxufVxuXG5GaWxlLnByb3RvdHlwZS5nZXRCbG9iVVJMID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdicm93c2VyLW9ubHkgbWV0aG9kJylcbiAgdmFyIG1pbWUgPSByZW5kZXIubWltZVtwYXRoLmV4dG5hbWUodGhpcy5uYW1lKS50b0xvd2VyQ2FzZSgpXVxuICBzdHJlYW1Ub0Jsb2JVUkwodGhpcy5jcmVhdGVSZWFkU3RyZWFtKCksIG1pbWUsIGNiKVxufVxuXG5GaWxlLnByb3RvdHlwZS5hcHBlbmRUbyA9IGZ1bmN0aW9uIChlbGVtLCBjYikge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignYnJvd3Nlci1vbmx5IG1ldGhvZCcpXG4gIHJlbmRlci5hcHBlbmQodGhpcywgZWxlbSwgY2IpXG59XG5cbkZpbGUucHJvdG90eXBlLnJlbmRlclRvID0gZnVuY3Rpb24gKGVsZW0sIGNiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdicm93c2VyLW9ubHkgbWV0aG9kJylcbiAgcmVuZGVyLnJlbmRlcih0aGlzLCBlbGVtLCBjYilcbn1cblxuRmlsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3RvcnJlbnQgPSBudWxsXG59XG4iLCJ2YXIgYXJyYXlSZW1vdmUgPSByZXF1aXJlKCd1bm9yZGVyZWQtYXJyYXktcmVtb3ZlJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3dlYnRvcnJlbnQ6cGVlcicpXG52YXIgV2lyZSA9IHJlcXVpcmUoJ2JpdHRvcnJlbnQtcHJvdG9jb2wnKVxuXG52YXIgV2ViQ29ubiA9IHJlcXVpcmUoJy4vd2ViY29ubicpXG5cbnZhciBDT05ORUNUX1RJTUVPVVRfVENQID0gNTAwMFxudmFyIENPTk5FQ1RfVElNRU9VVF9XRUJSVEMgPSAyNTAwMFxudmFyIEhBTkRTSEFLRV9USU1FT1VUID0gMjUwMDBcblxuLyoqXG4gKiBXZWJSVEMgcGVlciBjb25uZWN0aW9ucyBzdGFydCBvdXQgY29ubmVjdGVkLCBiZWNhdXNlIFdlYlJUQyBwZWVycyByZXF1aXJlIGFuXG4gKiBcImludHJvZHVjdGlvblwiIChpLmUuIFdlYlJUQyBzaWduYWxpbmcpLCBhbmQgdGhlcmUncyBubyBlcXVpdmFsZW50IHRvIGFuIElQIGFkZHJlc3NcbiAqIHRoYXQgbGV0cyB5b3UgcmVmZXIgdG8gYSBXZWJSVEMgZW5kcG9pbnQuXG4gKi9cbmV4cG9ydHMuY3JlYXRlV2ViUlRDUGVlciA9IGZ1bmN0aW9uIChjb25uLCBzd2FybSkge1xuICB2YXIgcGVlciA9IG5ldyBQZWVyKGNvbm4uaWQsICd3ZWJydGMnKVxuICBwZWVyLmNvbm4gPSBjb25uXG4gIHBlZXIuc3dhcm0gPSBzd2FybVxuXG4gIGlmIChwZWVyLmNvbm4uY29ubmVjdGVkKSB7XG4gICAgcGVlci5vbkNvbm5lY3QoKVxuICB9IGVsc2Uge1xuICAgIHBlZXIuY29ubi5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkgeyBwZWVyLm9uQ29ubmVjdCgpIH0pXG4gICAgcGVlci5jb25uLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyBwZWVyLmRlc3Ryb3koZXJyKSB9KVxuICAgIHBlZXIuc3RhcnRDb25uZWN0VGltZW91dCgpXG4gIH1cblxuICByZXR1cm4gcGVlclxufVxuXG4vKipcbiAqIEluY29taW5nIFRDUCBwZWVycyBzdGFydCBvdXQgY29ubmVjdGVkLCBiZWNhdXNlIHRoZSByZW1vdGUgcGVlciBjb25uZWN0ZWQgdG8gdGhlXG4gKiBsaXN0ZW5pbmcgcG9ydCBvZiB0aGUgVENQIHNlcnZlci4gVW50aWwgdGhlIHJlbW90ZSBwZWVyIHNlbmRzIGEgaGFuZHNoYWtlLCB3ZSBkb24ndFxuICoga25vdyB3aGF0IHN3YXJtIHRoZSBjb25uZWN0aW9uIGlzIGludGVuZGVkIGZvci5cbiAqL1xuZXhwb3J0cy5jcmVhdGVUQ1BJbmNvbWluZ1BlZXIgPSBmdW5jdGlvbiAoY29ubikge1xuICB2YXIgYWRkciA9IGNvbm4ucmVtb3RlQWRkcmVzcyArICc6JyArIGNvbm4ucmVtb3RlUG9ydFxuICB2YXIgcGVlciA9IG5ldyBQZWVyKGFkZHIsICd0Y3BJbmNvbWluZycpXG4gIHBlZXIuY29ubiA9IGNvbm5cbiAgcGVlci5hZGRyID0gYWRkclxuXG4gIHBlZXIub25Db25uZWN0KClcblxuICByZXR1cm4gcGVlclxufVxuXG4vKipcbiAqIE91dGdvaW5nIFRDUCBwZWVycyBzdGFydCBvdXQgd2l0aCBqdXN0IGFuIElQIGFkZHJlc3MuIEF0IHNvbWUgcG9pbnQgKHdoZW4gdGhlcmUgaXMgYW5cbiAqIGF2YWlsYWJsZSBjb25uZWN0aW9uKSwgdGhlIGNsaWVudCBjYW4gYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBhZGRyZXNzLlxuICovXG5leHBvcnRzLmNyZWF0ZVRDUE91dGdvaW5nUGVlciA9IGZ1bmN0aW9uIChhZGRyLCBzd2FybSkge1xuICB2YXIgcGVlciA9IG5ldyBQZWVyKGFkZHIsICd0Y3BPdXRnb2luZycpXG4gIHBlZXIuYWRkciA9IGFkZHJcbiAgcGVlci5zd2FybSA9IHN3YXJtXG5cbiAgcmV0dXJuIHBlZXJcbn1cblxuLyoqXG4gKiBQZWVyIHRoYXQgcmVwcmVzZW50cyBhIFdlYiBTZWVkIChCRVAxNyAvIEJFUDE5KS5cbiAqL1xuZXhwb3J0cy5jcmVhdGVXZWJTZWVkUGVlciA9IGZ1bmN0aW9uICh1cmwsIHN3YXJtKSB7XG4gIHZhciBwZWVyID0gbmV3IFBlZXIodXJsLCAnd2ViU2VlZCcpXG4gIHBlZXIuc3dhcm0gPSBzd2FybVxuICBwZWVyLmNvbm4gPSBuZXcgV2ViQ29ubih1cmwsIHN3YXJtKVxuXG4gIHBlZXIub25Db25uZWN0KClcblxuICByZXR1cm4gcGVlclxufVxuXG4vKipcbiAqIFBlZXIuIFJlcHJlc2VudHMgYSBwZWVyIGluIHRoZSB0b3JyZW50IHN3YXJtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcImlwOnBvcnRcIiBzdHJpbmcsIHBlZXIgaWQgKGZvciBXZWJSVEMgcGVlcnMpLCBvciB1cmwgKGZvciBXZWIgU2VlZHMpXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgcGVlclxuICovXG5mdW5jdGlvbiBQZWVyIChpZCwgdHlwZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5pZCA9IGlkXG4gIHNlbGYudHlwZSA9IHR5cGVcblxuICBkZWJ1ZygnbmV3IFBlZXIgJXMnLCBpZClcblxuICBzZWxmLmFkZHIgPSBudWxsXG4gIHNlbGYuY29ubiA9IG51bGxcbiAgc2VsZi5zd2FybSA9IG51bGxcbiAgc2VsZi53aXJlID0gbnVsbFxuXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuICBzZWxmLnRpbWVvdXQgPSBudWxsIC8vIGhhbmRzaGFrZSB0aW1lb3V0XG4gIHNlbGYucmV0cmllcyA9IDAgLy8gb3V0Z29pbmcgVENQIGNvbm5lY3Rpb24gcmV0cnkgY291bnRcblxuICBzZWxmLnNlbnRIYW5kc2hha2UgPSBmYWxzZVxufVxuXG4vKipcbiAqIENhbGxlZCBvbmNlIHRoZSBwZWVyIGlzIGNvbm5lY3RlZCAoaS5lLiBmaXJlZCAnY29ubmVjdCcgZXZlbnQpXG4gKiBAcGFyYW0ge1NvY2tldH0gY29ublxuICovXG5QZWVyLnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmNvbm5lY3RlZCA9IHRydWVcblxuICBkZWJ1ZygnUGVlciAlcyBjb25uZWN0ZWQnLCBzZWxmLmlkKVxuXG4gIGNsZWFyVGltZW91dChzZWxmLmNvbm5lY3RUaW1lb3V0KVxuXG4gIHZhciBjb25uID0gc2VsZi5jb25uXG4gIGNvbm4ub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveSgpXG4gIH0pXG4gIGNvbm4ub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgY29ubi5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgY29ubi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLmRlc3Ryb3koZXJyKVxuICB9KVxuXG4gIHZhciB3aXJlID0gc2VsZi53aXJlID0gbmV3IFdpcmUoKVxuICB3aXJlLnR5cGUgPSBzZWxmLnR5cGVcbiAgd2lyZS5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgd2lyZS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3koKVxuICB9KVxuICB3aXJlLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3koKVxuICB9KVxuICB3aXJlLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuZGVzdHJveShlcnIpXG4gIH0pXG5cbiAgd2lyZS5vbmNlKCdoYW5kc2hha2UnLCBmdW5jdGlvbiAoaW5mb0hhc2gsIHBlZXJJZCkge1xuICAgIHNlbGYub25IYW5kc2hha2UoaW5mb0hhc2gsIHBlZXJJZClcbiAgfSlcbiAgc2VsZi5zdGFydEhhbmRzaGFrZVRpbWVvdXQoKVxuXG4gIGNvbm4ucGlwZSh3aXJlKS5waXBlKGNvbm4pXG4gIGlmIChzZWxmLnN3YXJtICYmICFzZWxmLnNlbnRIYW5kc2hha2UpIHNlbGYuaGFuZHNoYWtlKClcbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBoYW5kc2hha2UgaXMgcmVjZWl2ZWQgZnJvbSByZW1vdGUgcGVlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHBlZXJJZFxuICovXG5QZWVyLnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChpbmZvSGFzaCwgcGVlcklkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuc3dhcm0pIHJldHVybiAvLyBgc2VsZi5zd2FybWAgbm90IHNldCB5ZXQsIHNvIGRvIG5vdGhpbmdcblxuICBpZiAoc2VsZi5zd2FybS5kZXN0cm95ZWQpIHJldHVybiBzZWxmLmRlc3Ryb3kobmV3IEVycm9yKCdzd2FybSBhbHJlYWR5IGRlc3Ryb3llZCcpKVxuICBpZiAoaW5mb0hhc2ggIT09IHNlbGYuc3dhcm0uaW5mb0hhc2gpIHtcbiAgICByZXR1cm4gc2VsZi5kZXN0cm95KG5ldyBFcnJvcigndW5leHBlY3RlZCBoYW5kc2hha2UgaW5mbyBoYXNoIGZvciB0aGlzIHN3YXJtJykpXG4gIH1cbiAgaWYgKHBlZXJJZCA9PT0gc2VsZi5zd2FybS5wZWVySWQpIHtcbiAgICByZXR1cm4gc2VsZi5kZXN0cm95KG5ldyBFcnJvcigncmVmdXNpbmcgdG8gY29ubmVjdCB0byBvdXJzZWx2ZXMnKSlcbiAgfVxuXG4gIGRlYnVnKCdQZWVyICVzIGdvdCBoYW5kc2hha2UgJXMnLCBzZWxmLmlkLCBpbmZvSGFzaClcblxuICBjbGVhclRpbWVvdXQoc2VsZi5oYW5kc2hha2VUaW1lb3V0KVxuXG4gIHNlbGYucmV0cmllcyA9IDBcblxuICB2YXIgYWRkciA9IHNlbGYuYWRkclxuICBpZiAoIWFkZHIgJiYgc2VsZi5jb25uLnJlbW90ZUFkZHJlc3MpIHtcbiAgICBhZGRyID0gc2VsZi5jb25uLnJlbW90ZUFkZHJlc3MgKyAnOicgKyBzZWxmLmNvbm4ucmVtb3RlUG9ydFxuICB9XG4gIHNlbGYuc3dhcm0uX29uV2lyZShzZWxmLndpcmUsIGFkZHIpXG5cbiAgLy8gc3dhcm0gY291bGQgYmUgZGVzdHJveWVkIGluIHVzZXIncyAnd2lyZScgZXZlbnQgaGFuZGxlclxuICBpZiAoIXNlbGYuc3dhcm0gfHwgc2VsZi5zd2FybS5kZXN0cm95ZWQpIHJldHVyblxuXG4gIGlmICghc2VsZi5zZW50SGFuZHNoYWtlKSBzZWxmLmhhbmRzaGFrZSgpXG59XG5cblBlZXIucHJvdG90eXBlLmhhbmRzaGFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBvcHRzID0ge1xuICAgIGRodDogc2VsZi5zd2FybS5wcml2YXRlID8gZmFsc2UgOiAhIXNlbGYuc3dhcm0uY2xpZW50LmRodFxuICB9XG4gIHNlbGYud2lyZS5oYW5kc2hha2Uoc2VsZi5zd2FybS5pbmZvSGFzaCwgc2VsZi5zd2FybS5jbGllbnQucGVlcklkLCBvcHRzKVxuICBzZWxmLnNlbnRIYW5kc2hha2UgPSB0cnVlXG59XG5cblBlZXIucHJvdG90eXBlLnN0YXJ0Q29ubmVjdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBjbGVhclRpbWVvdXQoc2VsZi5jb25uZWN0VGltZW91dClcbiAgc2VsZi5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ2Nvbm5lY3QgdGltZW91dCcpKVxuICB9LCBzZWxmLnR5cGUgPT09ICd3ZWJydGMnID8gQ09OTkVDVF9USU1FT1VUX1dFQlJUQyA6IENPTk5FQ1RfVElNRU9VVF9UQ1ApXG4gIGlmIChzZWxmLmNvbm5lY3RUaW1lb3V0LnVucmVmKSBzZWxmLmNvbm5lY3RUaW1lb3V0LnVucmVmKClcbn1cblxuUGVlci5wcm90b3R5cGUuc3RhcnRIYW5kc2hha2VUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgY2xlYXJUaW1lb3V0KHNlbGYuaGFuZHNoYWtlVGltZW91dClcbiAgc2VsZi5oYW5kc2hha2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KG5ldyBFcnJvcignaGFuZHNoYWtlIHRpbWVvdXQnKSlcbiAgfSwgSEFORFNIQUtFX1RJTUVPVVQpXG4gIGlmIChzZWxmLmhhbmRzaGFrZVRpbWVvdXQudW5yZWYpIHNlbGYuaGFuZHNoYWtlVGltZW91dC51bnJlZigpXG59XG5cblBlZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuXG4gIGRlYnVnKCdkZXN0cm95ICVzIChlcnJvcjogJXMpJywgc2VsZi5pZCwgZXJyICYmIChlcnIubWVzc2FnZSB8fCBlcnIpKVxuXG4gIGNsZWFyVGltZW91dChzZWxmLmNvbm5lY3RUaW1lb3V0KVxuICBjbGVhclRpbWVvdXQoc2VsZi5oYW5kc2hha2VUaW1lb3V0KVxuXG4gIHZhciBzd2FybSA9IHNlbGYuc3dhcm1cbiAgdmFyIGNvbm4gPSBzZWxmLmNvbm5cbiAgdmFyIHdpcmUgPSBzZWxmLndpcmVcblxuICBzZWxmLnN3YXJtID0gbnVsbFxuICBzZWxmLmNvbm4gPSBudWxsXG4gIHNlbGYud2lyZSA9IG51bGxcblxuICBpZiAoc3dhcm0gJiYgd2lyZSkge1xuICAgIGFycmF5UmVtb3ZlKHN3YXJtLndpcmVzLCBzd2FybS53aXJlcy5pbmRleE9mKHdpcmUpKVxuICB9XG4gIGlmIChjb25uKSB7XG4gICAgY29ubi5vbignZXJyb3InLCBub29wKVxuICAgIGNvbm4uZGVzdHJveSgpXG4gIH1cbiAgaWYgKHdpcmUpIHdpcmUuZGVzdHJveSgpXG4gIGlmIChzd2FybSkgc3dhcm0ucmVtb3ZlUGVlcihzZWxmLmlkKVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFJhcml0eU1hcFxuXG4vKipcbiAqIE1hcHBpbmcgb2YgdG9ycmVudCBwaWVjZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBhdmFpbGFiaWxpdHkgaW4gdGhlIHRvcnJlbnQgc3dhcm0uIFVzZWRcbiAqIGJ5IHRoZSB0b3JyZW50IG1hbmFnZXIgZm9yIGltcGxlbWVudGluZyB0aGUgcmFyZXN0IHBpZWNlIGZpcnN0IHNlbGVjdGlvbiBzdHJhdGVneS5cbiAqL1xuZnVuY3Rpb24gUmFyaXR5TWFwICh0b3JyZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuX3RvcnJlbnQgPSB0b3JyZW50XG4gIHNlbGYuX251bVBpZWNlcyA9IHRvcnJlbnQucGllY2VzLmxlbmd0aFxuICBzZWxmLl9waWVjZXMgPSBbXVxuXG4gIHNlbGYuX29uV2lyZSA9IGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgc2VsZi5yZWNhbGN1bGF0ZSgpXG4gICAgc2VsZi5faW5pdFdpcmUod2lyZSlcbiAgfVxuICBzZWxmLl9vbldpcmVIYXZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgc2VsZi5fcGllY2VzW2luZGV4XSArPSAxXG4gIH1cbiAgc2VsZi5fb25XaXJlQml0ZmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5yZWNhbGN1bGF0ZSgpXG4gIH1cblxuICBzZWxmLl90b3JyZW50LndpcmVzLmZvckVhY2goZnVuY3Rpb24gKHdpcmUpIHtcbiAgICBzZWxmLl9pbml0V2lyZSh3aXJlKVxuICB9KVxuICBzZWxmLl90b3JyZW50Lm9uKCd3aXJlJywgc2VsZi5fb25XaXJlKVxuICBzZWxmLnJlY2FsY3VsYXRlKClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGluZGV4IG9mIHRoZSByYXJlc3QgcGllY2UuIE9wdGlvbmFsbHksIHBhc3MgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gZXhjbHVkZVxuICogY2VydGFpbiBwaWVjZXMgKGZvciBpbnN0YW5jZSwgdGhvc2UgdGhhdCB3ZSBhbHJlYWR5IGhhdmUpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHBpZWNlRmlsdGVyRnVuY1xuICogQHJldHVybiB7bnVtYmVyfSBpbmRleCBvZiByYXJlc3QgcGllY2UsIG9yIC0xXG4gKi9cblJhcml0eU1hcC5wcm90b3R5cGUuZ2V0UmFyZXN0UGllY2UgPSBmdW5jdGlvbiAocGllY2VGaWx0ZXJGdW5jKSB7XG4gIGlmICghcGllY2VGaWx0ZXJGdW5jKSBwaWVjZUZpbHRlckZ1bmMgPSB0cnVlRm5cblxuICB2YXIgY2FuZGlkYXRlcyA9IFtdXG4gIHZhciBtaW4gPSBJbmZpbml0eVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbnVtUGllY2VzOyArK2kpIHtcbiAgICBpZiAoIXBpZWNlRmlsdGVyRnVuYyhpKSkgY29udGludWVcblxuICAgIHZhciBhdmFpbGFiaWxpdHkgPSB0aGlzLl9waWVjZXNbaV1cbiAgICBpZiAoYXZhaWxhYmlsaXR5ID09PSBtaW4pIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaChpKVxuICAgIH0gZWxzZSBpZiAoYXZhaWxhYmlsaXR5IDwgbWluKSB7XG4gICAgICBjYW5kaWRhdGVzID0gWyBpIF1cbiAgICAgIG1pbiA9IGF2YWlsYWJpbGl0eVxuICAgIH1cbiAgfVxuXG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGllY2VzIHdpdGggdGhlIHNhbWUgYXZhaWxhYmlsaXR5LCBjaG9vc2Ugb25lIHJhbmRvbWx5XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbTWF0aC5yYW5kb20oKSAqIGNhbmRpZGF0ZXMubGVuZ3RoIHwgMF1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTFcbiAgfVxufVxuXG5SYXJpdHlNYXAucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl90b3JyZW50LnJlbW92ZUxpc3RlbmVyKCd3aXJlJywgc2VsZi5fb25XaXJlKVxuICBzZWxmLl90b3JyZW50LndpcmVzLmZvckVhY2goZnVuY3Rpb24gKHdpcmUpIHtcbiAgICBzZWxmLl9jbGVhbnVwV2lyZUV2ZW50cyh3aXJlKVxuICB9KVxuICBzZWxmLl90b3JyZW50ID0gbnVsbFxuICBzZWxmLl9waWVjZXMgPSBudWxsXG5cbiAgc2VsZi5fb25XaXJlID0gbnVsbFxuICBzZWxmLl9vbldpcmVIYXZlID0gbnVsbFxuICBzZWxmLl9vbldpcmVCaXRmaWVsZCA9IG51bGxcbn1cblxuUmFyaXR5TWFwLnByb3RvdHlwZS5faW5pdFdpcmUgPSBmdW5jdGlvbiAod2lyZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB3aXJlLl9vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2NsZWFudXBXaXJlRXZlbnRzKHdpcmUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9udW1QaWVjZXM7ICsraSkge1xuICAgICAgc2VsZi5fcGllY2VzW2ldIC09IHdpcmUucGVlclBpZWNlcy5nZXQoaSlcbiAgICB9XG4gIH1cblxuICB3aXJlLm9uKCdoYXZlJywgc2VsZi5fb25XaXJlSGF2ZSlcbiAgd2lyZS5vbignYml0ZmllbGQnLCBzZWxmLl9vbldpcmVCaXRmaWVsZClcbiAgd2lyZS5vbmNlKCdjbG9zZScsIHdpcmUuX29uQ2xvc2UpXG59XG5cbi8qKlxuICogUmVjYWxjdWxhdGVzIHBpZWNlIGF2YWlsYWJpbGl0eSBhY3Jvc3MgYWxsIHBlZXJzIGluIHRoZSB0b3JyZW50LlxuICovXG5SYXJpdHlNYXAucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbnVtUGllY2VzOyArK2kpIHtcbiAgICB0aGlzLl9waWVjZXNbaV0gPSAwXG4gIH1cblxuICB2YXIgbnVtV2lyZXMgPSB0aGlzLl90b3JyZW50LndpcmVzLmxlbmd0aFxuICBmb3IgKGkgPSAwOyBpIDwgbnVtV2lyZXM7ICsraSkge1xuICAgIHZhciB3aXJlID0gdGhpcy5fdG9ycmVudC53aXJlc1tpXVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fbnVtUGllY2VzOyArK2opIHtcbiAgICAgIHRoaXMuX3BpZWNlc1tqXSArPSB3aXJlLnBlZXJQaWVjZXMuZ2V0KGopXG4gICAgfVxuICB9XG59XG5cblJhcml0eU1hcC5wcm90b3R5cGUuX2NsZWFudXBXaXJlRXZlbnRzID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgd2lyZS5yZW1vdmVMaXN0ZW5lcignaGF2ZScsIHRoaXMuX29uV2lyZUhhdmUpXG4gIHdpcmUucmVtb3ZlTGlzdGVuZXIoJ2JpdGZpZWxkJywgdGhpcy5fb25XaXJlQml0ZmllbGQpXG4gIGlmICh3aXJlLl9vbkNsb3NlKSB3aXJlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHdpcmUuX29uQ2xvc2UpXG4gIHdpcmUuX29uQ2xvc2UgPSBudWxsXG59XG5cbmZ1bmN0aW9uIHRydWVGbiAoKSB7XG4gIHJldHVybiB0cnVlXG59XG4iLCIvKiBnbG9iYWwgVVJMLCBCbG9iICovXG5cbm1vZHVsZS5leHBvcnRzID0gVG9ycmVudFxuXG52YXIgYWRkclRvSVBQb3J0ID0gcmVxdWlyZSgnYWRkci10by1pcC1wb3J0JylcbnZhciBCaXRGaWVsZCA9IHJlcXVpcmUoJ2JpdGZpZWxkJylcbnZhciBDaHVua1N0b3JlV3JpdGVTdHJlYW0gPSByZXF1aXJlKCdjaHVuay1zdG9yZS1zdHJlYW0vd3JpdGUnKVxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2VidG9ycmVudDp0b3JyZW50JylcbnZhciBEaXNjb3ZlcnkgPSByZXF1aXJlKCd0b3JyZW50LWRpc2NvdmVyeScpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGV4dGVuZE11dGFibGUgPSByZXF1aXJlKCd4dGVuZC9tdXRhYmxlJylcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBGU0NodW5rU3RvcmUgPSByZXF1aXJlKCdmcy1jaHVuay1zdG9yZScpIC8vIGJyb3dzZXI6IGBtZW1vcnktY2h1bmstc3RvcmVgXG52YXIgSW1tZWRpYXRlQ2h1bmtTdG9yZSA9IHJlcXVpcmUoJ2ltbWVkaWF0ZS1jaHVuay1zdG9yZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTXVsdGlTdHJlYW0gPSByZXF1aXJlKCdtdWx0aXN0cmVhbScpXG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0JykgLy8gYnJvd3NlciBleGNsdWRlXG52YXIgb3MgPSByZXF1aXJlKCdvcycpIC8vIGJyb3dzZXIgZXhjbHVkZVxudmFyIHBhcmFsbGVsID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsJylcbnZhciBwYXJhbGxlbExpbWl0ID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsLWxpbWl0JylcbnZhciBwYXJzZVRvcnJlbnQgPSByZXF1aXJlKCdwYXJzZS10b3JyZW50JylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJ3BhdGgtZXhpc3RzJykgLy8gYnJvd3NlciBleGNsdWRlXG52YXIgUGllY2UgPSByZXF1aXJlKCd0b3JyZW50LXBpZWNlJylcbnZhciBwdW1wID0gcmVxdWlyZSgncHVtcCcpXG52YXIgcmFuZG9tSXRlcmF0ZSA9IHJlcXVpcmUoJ3JhbmRvbS1pdGVyYXRlJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIHNwZWVkb21ldGVyID0gcmVxdWlyZSgnc3BlZWRvbWV0ZXInKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcbnZhciB1dE1ldGFkYXRhID0gcmVxdWlyZSgndXRfbWV0YWRhdGEnKVxudmFyIHV0UGV4ID0gcmVxdWlyZSgndXRfcGV4JykgLy8gYnJvd3NlciBleGNsdWRlXG5cbnZhciBGaWxlID0gcmVxdWlyZSgnLi9maWxlJylcbnZhciBQZWVyID0gcmVxdWlyZSgnLi9wZWVyJylcbnZhciBSYXJpdHlNYXAgPSByZXF1aXJlKCcuL3Jhcml0eS1tYXAnKVxudmFyIFNlcnZlciA9IHJlcXVpcmUoJy4vc2VydmVyJykgLy8gYnJvd3NlciBleGNsdWRlXG5cbnZhciBNQVhfQkxPQ0tfTEVOR1RIID0gMTI4ICogMTAyNFxudmFyIFBJRUNFX1RJTUVPVVQgPSAzMDAwMFxudmFyIENIT0tFX1RJTUVPVVQgPSA1MDAwXG52YXIgU1BFRURfVEhSRVNIT0xEID0gMyAqIFBpZWNlLkJMT0NLX0xFTkdUSFxuXG52YXIgUElQRUxJTkVfTUlOX0RVUkFUSU9OID0gMC41XG52YXIgUElQRUxJTkVfTUFYX0RVUkFUSU9OID0gMVxuXG52YXIgUkVDSE9LRV9JTlRFUlZBTCA9IDEwMDAwIC8vIDEwIHNlY29uZHNcbnZhciBSRUNIT0tFX09QVElNSVNUSUNfRFVSQVRJT04gPSAyIC8vIDMwIHNlY29uZHNcblxudmFyIEZJTEVTWVNURU1fQ09OQ1VSUkVOQ1kgPSAyXG5cbnZhciBSRUNPTk5FQ1RfV0FJVCA9IFsgMTAwMCwgNTAwMCwgMTUwMDAgXVxuXG52YXIgVE1QID0gdHlwZW9mIHBhdGhFeGlzdHMuc3luYyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IHBhdGguam9pbihwYXRoRXhpc3RzLnN5bmMoJy90bXAnKSA/ICcvdG1wJyA6IG9zLnRtcERpcigpLCAnd2VidG9ycmVudCcpXG4gIDogJy90bXAvd2VidG9ycmVudCdcblxuaW5oZXJpdHMoVG9ycmVudCwgRXZlbnRFbWl0dGVyKVxuXG5mdW5jdGlvbiBUb3JyZW50ICh0b3JyZW50SWQsIGNsaWVudCwgb3B0cykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gIHRoaXMuX2RlYnVnSWQgPSB0aGlzLmNsaWVudC5wZWVySWQuc2xpY2UoMzIpXG5cbiAgdGhpcy5fZGVidWcoJ25ldyB0b3JyZW50JylcblxuICB0aGlzLmFubm91bmNlID0gb3B0cy5hbm5vdW5jZVxuICB0aGlzLnVybExpc3QgPSBvcHRzLnVybExpc3RcblxuICB0aGlzLnBhdGggPSBvcHRzLnBhdGhcbiAgdGhpcy5fc3RvcmUgPSBvcHRzLnN0b3JlIHx8IEZTQ2h1bmtTdG9yZVxuICB0aGlzLl9nZXRBbm5vdW5jZU9wdHMgPSBvcHRzLmdldEFubm91bmNlT3B0c1xuXG4gIHRoaXMuc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5IHx8ICdzZXF1ZW50aWFsJ1xuXG4gIHRoaXMubWF4V2ViQ29ubnMgPSBvcHRzLm1heFdlYkNvbm5zIHx8IDRcblxuICB0aGlzLl9yZWNob2tlTnVtU2xvdHMgPSAob3B0cy51cGxvYWRzID09PSBmYWxzZSB8fCBvcHRzLnVwbG9hZHMgPT09IDApXG4gICAgPyAwXG4gICAgOiAoK29wdHMudXBsb2FkcyB8fCAxMClcbiAgdGhpcy5fcmVjaG9rZU9wdGltaXN0aWNXaXJlID0gbnVsbFxuICB0aGlzLl9yZWNob2tlT3B0aW1pc3RpY1RpbWUgPSAwXG4gIHRoaXMuX3JlY2hva2VJbnRlcnZhbElkID0gbnVsbFxuXG4gIHRoaXMucmVhZHkgPSBmYWxzZVxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgdGhpcy5kb25lID0gZmFsc2VcblxuICB0aGlzLm1ldGFkYXRhID0gbnVsbFxuICB0aGlzLnN0b3JlID0gbnVsbFxuICB0aGlzLmZpbGVzID0gW11cbiAgdGhpcy5waWVjZXMgPSBbXVxuXG4gIHRoaXMuX2FtSW50ZXJlc3RlZCA9IGZhbHNlXG4gIHRoaXMuX3NlbGVjdGlvbnMgPSBbXVxuICB0aGlzLl9jcml0aWNhbCA9IFtdXG5cbiAgdGhpcy53aXJlcyA9IFtdIC8vIG9wZW4gd2lyZXMgKGFkZGVkICphZnRlciogaGFuZHNoYWtlKVxuXG4gIHRoaXMuX3F1ZXVlID0gW10gLy8gcXVldWUgb2Ygb3V0Z29pbmcgdGNwIHBlZXJzIHRvIGNvbm5lY3QgdG9cbiAgdGhpcy5fcGVlcnMgPSB7fSAvLyBjb25uZWN0ZWQgcGVlcnMgKGFkZHIvcGVlcklkIC0+IFBlZXIpXG4gIHRoaXMuX3BlZXJzTGVuZ3RoID0gMCAvLyBudW1iZXIgb2YgZWxlbWVudHMgaW4gYHRoaXMuX3BlZXJzYCAoY2FjaGUsIGZvciBwZXJmKVxuXG4gIC8vIHN0YXRzXG4gIHRoaXMucmVjZWl2ZWQgPSAwXG4gIHRoaXMudXBsb2FkZWQgPSAwXG4gIHRoaXMuX2Rvd25sb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG4gIHRoaXMuX3VwbG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuXG4gIC8vIGZvciBjbGVhbnVwXG4gIHRoaXMuX3NlcnZlcnMgPSBbXVxuXG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIGFuZCBleHBvc2UgYSBob29rIGluc3RlYWRcbiAgLy8gb3B0aW1pemF0aW9uOiBkb24ndCByZWNoZWNrIGV2ZXJ5IGZpbGUgaWYgaXQgaGFzbid0IGNoYW5nZWRcbiAgdGhpcy5fZmlsZU1vZHRpbWVzID0gb3B0cy5maWxlTW9kdGltZXNcblxuICBpZiAodG9ycmVudElkICE9PSBudWxsKSB0aGlzLl9vblRvcnJlbnRJZCh0b3JyZW50SWQpXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ3RpbWVSZW1haW5pbmcnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRvbmUpIHJldHVybiAwXG4gICAgaWYgKHRoaXMuZG93bmxvYWRTcGVlZCA9PT0gMCkgcmV0dXJuIEluZmluaXR5XG4gICAgcmV0dXJuICgodGhpcy5sZW5ndGggLSB0aGlzLmRvd25sb2FkZWQpIC8gdGhpcy5kb3dubG9hZFNwZWVkKSAqIDEwMDBcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnZG93bmxvYWRlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmJpdGZpZWxkKSByZXR1cm4gMFxuICAgIHZhciBkb3dubG9hZGVkID0gMFxuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuID0gdGhpcy5waWVjZXMubGVuZ3RoOyBpbmRleCA8IGxlbjsgKytpbmRleCkge1xuICAgICAgaWYgKHRoaXMuYml0ZmllbGQuZ2V0KGluZGV4KSkgeyAvLyB2ZXJpZmllZCBkYXRhXG4gICAgICAgIGRvd25sb2FkZWQgKz0gKGluZGV4ID09PSBsZW4gLSAxKSA/IHRoaXMubGFzdFBpZWNlTGVuZ3RoIDogdGhpcy5waWVjZUxlbmd0aFxuICAgICAgfSBlbHNlIHsgLy8gXCJpbiBwcm9ncmVzc1wiIGRhdGFcbiAgICAgICAgdmFyIHBpZWNlID0gdGhpcy5waWVjZXNbaW5kZXhdXG4gICAgICAgIGRvd25sb2FkZWQgKz0gKHBpZWNlLmxlbmd0aCAtIHBpZWNlLm1pc3NpbmcpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb3dubG9hZGVkXG4gIH1cbn0pXG5cbi8vIFRPRE86IHJlLWVuYWJsZSB0aGlzLiBUaGUgbnVtYmVyIG9mIG1pc3NpbmcgcGllY2VzLiBVc2VkIHRvIGltcGxlbWVudCAnZW5kIGdhbWUnIG1vZGUuXG4vLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmFnZS5wcm90b3R5cGUsICdudW1NaXNzaW5nJywge1xuLy8gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbi8vICAgICB2YXIgc2VsZiA9IHRoaXNcbi8vICAgICB2YXIgbnVtTWlzc2luZyA9IHNlbGYucGllY2VzLmxlbmd0aFxuLy8gICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuID0gc2VsZi5waWVjZXMubGVuZ3RoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuLy8gICAgICAgbnVtTWlzc2luZyAtPSBzZWxmLmJpdGZpZWxkLmdldChpbmRleClcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIG51bU1pc3Npbmdcbi8vICAgfVxuLy8gfSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnZG93bmxvYWRTcGVlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kb3dubG9hZFNwZWVkKCkgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAndXBsb2FkU3BlZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdXBsb2FkU3BlZWQoKSB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdwcm9ncmVzcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxlbmd0aCA/IHRoaXMuZG93bmxvYWRlZCAvIHRoaXMubGVuZ3RoIDogMCB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdyYXRpbycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVwbG9hZGVkIC8gKHRoaXMucmVjZWl2ZWQgfHwgMSkgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnbnVtUGVlcnMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53aXJlcy5sZW5ndGggfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAndG9ycmVudEZpbGVCbG9iVVJMJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignYnJvd3Nlci1vbmx5IHByb3BlcnR5JylcbiAgICBpZiAoIXRoaXMudG9ycmVudEZpbGUpIHJldHVybiBudWxsXG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICBuZXcgQmxvYihbIHRoaXMudG9ycmVudEZpbGUgXSwgeyB0eXBlOiAnYXBwbGljYXRpb24veC1iaXR0b3JyZW50JyB9KVxuICAgIClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnX251bVF1ZXVlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aCArICh0aGlzLl9wZWVyc0xlbmd0aCAtIHRoaXMuX251bUNvbm5zKVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdfbnVtQ29ubnMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBudW1Db25ucyA9IDBcbiAgICBmb3IgKHZhciBpZCBpbiBzZWxmLl9wZWVycykge1xuICAgICAgaWYgKHNlbGYuX3BlZXJzW2lkXS5jb25uZWN0ZWQpIG51bUNvbm5zICs9IDFcbiAgICB9XG4gICAgcmV0dXJuIG51bUNvbm5zXG4gIH1cbn0pXG5cbi8vIFRPRE86IHJlbW92ZSBpbiB2MlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnc3dhcm0nLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKCdXZWJUb3JyZW50OiBgdG9ycmVudC5zd2FybWAgaXMgZGVwcmVjYXRlZC4gVXNlIGB0b3JyZW50YCBkaXJlY3RseSBpbnN0ZWFkLicpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufSlcblxuVG9ycmVudC5wcm90b3R5cGUuX29uVG9ycmVudElkID0gZnVuY3Rpb24gKHRvcnJlbnRJZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICB2YXIgcGFyc2VkVG9ycmVudFxuICB0cnkgeyBwYXJzZWRUb3JyZW50ID0gcGFyc2VUb3JyZW50KHRvcnJlbnRJZCkgfSBjYXRjaCAoZXJyKSB7fVxuICBpZiAocGFyc2VkVG9ycmVudCkge1xuICAgIC8vIEF0dGVtcHQgdG8gc2V0IGluZm9IYXNoIHByb3BlcnR5IHN5bmNocm9ub3VzbHlcbiAgICBzZWxmLmluZm9IYXNoID0gcGFyc2VkVG9ycmVudC5pbmZvSGFzaFxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIHNlbGYuX29uUGFyc2VkVG9ycmVudChwYXJzZWRUb3JyZW50KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdG9ycmVudElkIGZhaWxlZCB0byBwYXJzZSwgaXQgY291bGQgYmUgaW4gYSBmb3JtIHRoYXQgcmVxdWlyZXMgYW4gYXN5bmNcbiAgICAvLyBvcGVyYXRpb24sIGkuZS4gaHR0cC9odHRwcyBsaW5rLCBmaWxlc3lzdGVtIHBhdGgsIG9yIEJsb2IuXG4gICAgcGFyc2VUb3JyZW50LnJlbW90ZSh0b3JyZW50SWQsIGZ1bmN0aW9uIChlcnIsIHBhcnNlZFRvcnJlbnQpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5fZGVzdHJveShlcnIpXG4gICAgICBzZWxmLl9vblBhcnNlZFRvcnJlbnQocGFyc2VkVG9ycmVudClcbiAgICB9KVxuICB9XG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9vblBhcnNlZFRvcnJlbnQgPSBmdW5jdGlvbiAocGFyc2VkVG9ycmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBzZWxmLl9wcm9jZXNzUGFyc2VkVG9ycmVudChwYXJzZWRUb3JyZW50KVxuXG4gIGlmICghc2VsZi5pbmZvSGFzaCkge1xuICAgIHJldHVybiBzZWxmLl9kZXN0cm95KG5ldyBFcnJvcignTWFsZm9ybWVkIHRvcnJlbnQgZGF0YTogTm8gaW5mbyBoYXNoJykpXG4gIH1cblxuICBpZiAoIXNlbGYucGF0aCkgc2VsZi5wYXRoID0gcGF0aC5qb2luKFRNUCwgc2VsZi5pbmZvSGFzaClcblxuICBzZWxmLl9yZWNob2tlSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9yZWNob2tlKClcbiAgfSwgUkVDSE9LRV9JTlRFUlZBTClcbiAgaWYgKHNlbGYuX3JlY2hva2VJbnRlcnZhbElkLnVucmVmKSBzZWxmLl9yZWNob2tlSW50ZXJ2YWxJZC51bnJlZigpXG5cbiAgc2VsZi5lbWl0KCdpbmZvSGFzaCcsIHNlbGYuaW5mb0hhc2gpXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIC8vIHVzZXIgbWlnaHQgZGVzdHJveSB0b3JyZW50IGluIGBpbmZvSGFzaGAgZXZlbnQgaGFuZGxlclxuXG4gIGlmIChzZWxmLmNsaWVudC5saXN0ZW5pbmcpIHtcbiAgICBzZWxmLl9vbkxpc3RlbmluZygpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5jbGllbnQub25jZSgnbGlzdGVuaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fb25MaXN0ZW5pbmcoKVxuICAgIH0pXG4gIH1cbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX3Byb2Nlc3NQYXJzZWRUb3JyZW50ID0gZnVuY3Rpb24gKHBhcnNlZFRvcnJlbnQpIHtcbiAgaWYgKHRoaXMuYW5ub3VuY2UpIHtcbiAgICAvLyBBbGxvdyBzcGVjaWZ5aW5nIHRyYWNrZXJzIHZpYSBgb3B0c2AgcGFyYW1ldGVyXG4gICAgcGFyc2VkVG9ycmVudC5hbm5vdW5jZSA9IHBhcnNlZFRvcnJlbnQuYW5ub3VuY2UuY29uY2F0KHRoaXMuYW5ub3VuY2UpXG4gIH1cblxuICBpZiAodGhpcy5jbGllbnQudHJhY2tlciAmJiBnbG9iYWwuV0VCVE9SUkVOVF9BTk5PVU5DRSAmJiAhdGhpcy5wcml2YXRlKSB7XG4gICAgLy8gU28gYHdlYnRvcnJlbnQtaHlicmlkYCBjYW4gZm9yY2Ugc3BlY2lmaWMgdHJhY2tlcnMgdG8gYmUgdXNlZFxuICAgIHBhcnNlZFRvcnJlbnQuYW5ub3VuY2UgPSBwYXJzZWRUb3JyZW50LmFubm91bmNlLmNvbmNhdChnbG9iYWwuV0VCVE9SUkVOVF9BTk5PVU5DRSlcbiAgfVxuXG4gIGlmICh0aGlzLnVybExpc3QpIHtcbiAgICAvLyBBbGxvdyBzcGVjaWZ5aW5nIHdlYiBzZWVkcyB2aWEgYG9wdHNgIHBhcmFtZXRlclxuICAgIHBhcnNlZFRvcnJlbnQudXJsTGlzdCA9IHBhcnNlZFRvcnJlbnQudXJsTGlzdC5jb25jYXQodGhpcy51cmxMaXN0KVxuICB9XG5cbiAgdW5pcShwYXJzZWRUb3JyZW50LmFubm91bmNlKVxuICB1bmlxKHBhcnNlZFRvcnJlbnQudXJsTGlzdClcblxuICBleHRlbmRNdXRhYmxlKHRoaXMsIHBhcnNlZFRvcnJlbnQpXG5cbiAgdGhpcy5tYWduZXRVUkkgPSBwYXJzZVRvcnJlbnQudG9NYWduZXRVUkkocGFyc2VkVG9ycmVudClcbiAgdGhpcy50b3JyZW50RmlsZSA9IHBhcnNlVG9ycmVudC50b1RvcnJlbnRGaWxlKHBhcnNlZFRvcnJlbnQpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9vbkxpc3RlbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRpc2NvdmVyeSB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciB0cmFja2VyT3B0cyA9IHtcbiAgICBydGNDb25maWc6IHNlbGYuY2xpZW50Ll9ydGNDb25maWcsXG4gICAgd3J0Yzogc2VsZi5jbGllbnQuX3dydGMsXG4gICAgZ2V0QW5ub3VuY2VPcHRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgdXBsb2FkZWQ6IHNlbGYudXBsb2FkZWQsXG4gICAgICAgIGRvd25sb2FkZWQ6IHNlbGYuZG93bmxvYWRlZCxcbiAgICAgICAgbGVmdDogTWF0aC5tYXgoc2VsZi5sZW5ndGggLSBzZWxmLmRvd25sb2FkZWQsIDApXG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5fZ2V0QW5ub3VuY2VPcHRzKSBvcHRzID0gZXh0ZW5kKG9wdHMsIHNlbGYuX2dldEFubm91bmNlT3B0cygpKVxuICAgICAgcmV0dXJuIG9wdHNcbiAgICB9XG4gIH1cblxuICAvLyBiZWdpbiBkaXNjb3ZlcmluZyBwZWVycyB2aWEgREhUIGFuZCB0cmFja2Vyc1xuICBzZWxmLmRpc2NvdmVyeSA9IG5ldyBEaXNjb3Zlcnkoe1xuICAgIGluZm9IYXNoOiBzZWxmLmluZm9IYXNoLFxuICAgIGFubm91bmNlOiBzZWxmLmFubm91bmNlLFxuICAgIHBlZXJJZDogc2VsZi5jbGllbnQucGVlcklkLFxuICAgIGRodDogIXNlbGYucHJpdmF0ZSAmJiBzZWxmLmNsaWVudC5kaHQsXG4gICAgdHJhY2tlcjogc2VsZi5jbGllbnQudHJhY2tlciAmJiB0cmFja2VyT3B0cyxcbiAgICBwb3J0OiBzZWxmLmNsaWVudC50b3JyZW50UG9ydFxuICB9KVxuXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCdlcnJvcicsIG9uRXJyb3IpXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCdwZWVyJywgb25QZWVyKVxuICBzZWxmLmRpc2NvdmVyeS5vbigndHJhY2tlckFubm91bmNlJywgb25UcmFja2VyQW5ub3VuY2UpXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCdkaHRBbm5vdW5jZScsIG9uREhUQW5ub3VuY2UpXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCd3YXJuaW5nJywgb25XYXJuaW5nKVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IgKGVycikge1xuICAgIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25QZWVyIChwZWVyKSB7XG4gICAgLy8gRG9uJ3QgY3JlYXRlIG5ldyBvdXRnb2luZyBUQ1AgY29ubmVjdGlvbnMgd2hlbiB0b3JyZW50IGlzIGRvbmVcbiAgICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnICYmIHNlbGYuZG9uZSkgcmV0dXJuXG4gICAgc2VsZi5hZGRQZWVyKHBlZXIpXG4gIH1cblxuICBmdW5jdGlvbiBvblRyYWNrZXJBbm5vdW5jZSAoKSB7XG4gICAgc2VsZi5lbWl0KCd0cmFja2VyQW5ub3VuY2UnKVxuICB9XG5cbiAgZnVuY3Rpb24gb25ESFRBbm5vdW5jZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdkaHRBbm5vdW5jZScpXG4gIH1cblxuICBmdW5jdGlvbiBvbldhcm5pbmcgKGVycikge1xuICAgIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgfVxuXG4gIC8vIGlmIGZ1bGwgbWV0YWRhdGEgd2FzIGluY2x1ZGVkIGluIGluaXRpYWwgdG9ycmVudCBpZCwgdXNlIGl0IGltbWVkaWF0ZWx5LiBPdGhlcndpc2UsXG4gIC8vIHdhaXQgZm9yIHRvcnJlbnQtZGlzY292ZXJ5IHRvIGZpbmQgcGVlcnMgYW5kIHV0X21ldGFkYXRhIHRvIGdldCB0aGUgbWV0YWRhdGEuXG4gIGlmIChzZWxmLmluZm8pIHNlbGYuX29uTWV0YWRhdGEoc2VsZilcbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgZnVsbCB0b3JyZW50IG1ldGFkYXRhIGlzIHJlY2VpdmVkLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fb25NZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYubWV0YWRhdGEgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1ZygnZ290IG1ldGFkYXRhJylcblxuICB2YXIgcGFyc2VkVG9ycmVudFxuICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuaW5mb0hhc2gpIHtcbiAgICAvLyBgbWV0YWRhdGFgIGlzIGEgcGFyc2VkIHRvcnJlbnQgKGZyb20gcGFyc2UtdG9ycmVudCBtb2R1bGUpXG4gICAgcGFyc2VkVG9ycmVudCA9IG1ldGFkYXRhXG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFRvcnJlbnQgPSBwYXJzZVRvcnJlbnQobWV0YWRhdGEpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5fZGVzdHJveShlcnIpXG4gICAgfVxuICB9XG5cbiAgc2VsZi5fcHJvY2Vzc1BhcnNlZFRvcnJlbnQocGFyc2VkVG9ycmVudClcbiAgc2VsZi5tZXRhZGF0YSA9IHNlbGYudG9ycmVudEZpbGVcblxuICAvLyBhZGQgd2ViIHNlZWQgdXJscyAoQkVQMTkpXG4gIHNlbGYudXJsTGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpIHtcbiAgICBzZWxmLmFkZFdlYlNlZWQodXJsKVxuICB9KVxuXG4gIHNlbGYuX3Jhcml0eU1hcCA9IG5ldyBSYXJpdHlNYXAoc2VsZilcblxuICBzZWxmLnN0b3JlID0gbmV3IEltbWVkaWF0ZUNodW5rU3RvcmUoXG4gICAgbmV3IHNlbGYuX3N0b3JlKHNlbGYucGllY2VMZW5ndGgsIHtcbiAgICAgIHRvcnJlbnQ6IHtcbiAgICAgICAgaW5mb0hhc2g6IHNlbGYuaW5mb0hhc2hcbiAgICAgIH0sXG4gICAgICBmaWxlczogc2VsZi5maWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoOiBwYXRoLmpvaW4oc2VsZi5wYXRoLCBmaWxlLnBhdGgpLFxuICAgICAgICAgIGxlbmd0aDogZmlsZS5sZW5ndGgsXG4gICAgICAgICAgb2Zmc2V0OiBmaWxlLm9mZnNldFxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGxlbmd0aDogc2VsZi5sZW5ndGhcbiAgICB9KVxuICApXG5cbiAgc2VsZi5maWxlcyA9IHNlbGYuZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWxlKHNlbGYsIGZpbGUpXG4gIH0pXG5cbiAgc2VsZi5faGFzaGVzID0gc2VsZi5waWVjZXNcblxuICBzZWxmLnBpZWNlcyA9IHNlbGYucGllY2VzLm1hcChmdW5jdGlvbiAoaGFzaCwgaSkge1xuICAgIHZhciBwaWVjZUxlbmd0aCA9IChpID09PSBzZWxmLnBpZWNlcy5sZW5ndGggLSAxKVxuICAgICAgPyBzZWxmLmxhc3RQaWVjZUxlbmd0aFxuICAgICAgOiBzZWxmLnBpZWNlTGVuZ3RoXG4gICAgcmV0dXJuIG5ldyBQaWVjZShwaWVjZUxlbmd0aClcbiAgfSlcblxuICBzZWxmLl9yZXNlcnZhdGlvbnMgPSBzZWxmLnBpZWNlcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXVxuICB9KVxuXG4gIHNlbGYuYml0ZmllbGQgPSBuZXcgQml0RmllbGQoc2VsZi5waWVjZXMubGVuZ3RoKVxuXG4gIHNlbGYud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBoYXZlIHRoZSBtZXRhZGF0YSBhdCB0aGUgdGltZSB1dF9tZXRhZGF0YSB3YXMgaW5pdGlhbGl6ZWQgZm9yIHRoaXNcbiAgICAvLyB3aXJlLCB3ZSBzdGlsbCB3YW50IHRvIG1ha2UgaXQgYXZhaWxhYmxlIHRvIHRoZSBwZWVyIGluIGNhc2UgdGhleSByZXF1ZXN0IGl0LlxuICAgIGlmICh3aXJlLnV0X21ldGFkYXRhKSB3aXJlLnV0X21ldGFkYXRhLnNldE1ldGFkYXRhKHNlbGYubWV0YWRhdGEpXG5cbiAgICBzZWxmLl9vbldpcmVXaXRoTWV0YWRhdGEod2lyZSlcbiAgfSlcblxuICBzZWxmLl9kZWJ1ZygndmVyaWZ5aW5nIGV4aXN0aW5nIHRvcnJlbnQgZGF0YScpXG4gIGlmIChzZWxmLl9maWxlTW9kdGltZXMgJiYgc2VsZi5fc3RvcmUgPT09IEZTQ2h1bmtTdG9yZSkge1xuICAgIC8vIGRvbid0IHZlcmlmeSBpZiB0aGUgZmlsZXMgaGF2ZW4ndCBiZWVuIG1vZGlmaWVkIHNpbmNlIHdlIGxhc3QgY2hlY2tlZFxuICAgIHNlbGYuZ2V0RmlsZU1vZHRpbWVzKGZ1bmN0aW9uIChlcnIsIGZpbGVNb2R0aW1lcykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuX2Rlc3Ryb3koZXJyKVxuXG4gICAgICB2YXIgdW5jaGFuZ2VkID0gc2VsZi5maWxlcy5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmaWxlTW9kdGltZXNbaW5kZXhdID09PSBzZWxmLl9maWxlTW9kdGltZXNbaW5kZXhdXG4gICAgICB9KS5ldmVyeShmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFxuICAgICAgfSlcblxuICAgICAgaWYgKHVuY2hhbmdlZCkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc2VsZi5waWVjZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgc2VsZi5fbWFya1ZlcmlmaWVkKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuX29uU3RvcmUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fdmVyaWZ5UGllY2VzKClcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX3ZlcmlmeVBpZWNlcygpXG4gIH1cblxuICBzZWxmLmVtaXQoJ21ldGFkYXRhJylcbn1cblxuLypcbiAqIFRPRE86IHJlbW92ZSB0aGlzXG4gKiBHZXRzIHRoZSBsYXN0IG1vZGlmaWVkIHRpbWUgb2YgZXZlcnkgZmlsZSBvbiBkaXNrIGZvciB0aGlzIHRvcnJlbnQuXG4gKiBPbmx5IHZhbGlkIGluIE5vZGUsIG5vdCBpbiB0aGUgYnJvd3Nlci5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuZ2V0RmlsZU1vZHRpbWVzID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmV0ID0gW11cbiAgcGFyYWxsZWxMaW1pdChzZWxmLmZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBmcy5zdGF0KHBhdGguam9pbihzZWxmLnBhdGgsIGZpbGUucGF0aCksIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIHJldHVybiBjYihlcnIpXG4gICAgICAgIHJldFtpbmRleF0gPSBzdGF0ICYmIHN0YXQubXRpbWUuZ2V0VGltZSgpXG4gICAgICAgIGNiKG51bGwpXG4gICAgICB9KVxuICAgIH1cbiAgfSksIEZJTEVTWVNURU1fQ09OQ1VSUkVOQ1ksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9kZWJ1ZygnZG9uZSBnZXR0aW5nIGZpbGUgbW9kdGltZXMnKVxuICAgIGNiKGVyciwgcmV0KVxuICB9KVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fdmVyaWZ5UGllY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcGFyYWxsZWxMaW1pdChzZWxmLnBpZWNlcy5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpKVxuICAgICAgc2VsZi5zdG9yZS5nZXQoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGJ1Zikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IobnVsbCkgLy8gaWdub3JlIGVycm9yXG4gICAgICAgIHNoYTEoYnVmLCBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgIGlmIChoYXNoID09PSBzZWxmLl9oYXNoZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYucGllY2VzW2luZGV4XSkgcmV0dXJuXG4gICAgICAgICAgICBzZWxmLl9kZWJ1ZygncGllY2UgdmVyaWZpZWQgJXMnLCBpbmRleClcbiAgICAgICAgICAgIHNlbGYuX21hcmtWZXJpZmllZChpbmRleClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5fZGVidWcoJ3BpZWNlIGludmFsaWQgJXMnLCBpbmRleClcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IobnVsbClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9KSwgRklMRVNZU1RFTV9DT05DVVJSRU5DWSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLl9kZXN0cm95KGVycilcbiAgICBzZWxmLl9kZWJ1ZygnZG9uZSB2ZXJpZnlpbmcnKVxuICAgIHNlbGYuX29uU3RvcmUoKVxuICB9KVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fbWFya1ZlcmlmaWVkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHRoaXMucGllY2VzW2luZGV4XSA9IG51bGxcbiAgdGhpcy5fcmVzZXJ2YXRpb25zW2luZGV4XSA9IG51bGxcbiAgdGhpcy5iaXRmaWVsZC5zZXQoaW5kZXgsIHRydWUpXG59XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIG1ldGFkYXRhLCBsaXN0ZW5pbmcgc2VydmVyLCBhbmQgdW5kZXJseWluZyBjaHVuayBzdG9yZSBpcyBpbml0aWFsaXplZC5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX29uU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gc3RvcmUnKVxuXG4gIC8vIHN0YXJ0IG9mZiBzZWxlY3RpbmcgdGhlIGVudGlyZSB0b3JyZW50IHdpdGggbG93IHByaW9yaXR5XG4gIHNlbGYuc2VsZWN0KDAsIHNlbGYucGllY2VzLmxlbmd0aCAtIDEsIGZhbHNlKVxuXG4gIHNlbGYucmVhZHkgPSB0cnVlXG4gIHNlbGYuZW1pdCgncmVhZHknKVxuXG4gIC8vIEZpbGVzIG1heSBzdGFydCBvdXQgZG9uZSBpZiB0aGUgZmlsZSB3YXMgYWxyZWFkeSBpbiB0aGUgc3RvcmVcbiAgc2VsZi5fY2hlY2tEb25lKClcblxuICAvLyBJbiBjYXNlIGFueSBzZWxlY3Rpb25zIHdlcmUgbWFkZSBiZWZvcmUgdG9ycmVudCB3YXMgcmVhZHlcbiAgc2VsZi5fdXBkYXRlU2VsZWN0aW9ucygpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2Rlc3Ryb3kobnVsbCwgY2IpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuICBzZWxmLl9kZWJ1ZygnZGVzdHJveScpXG5cbiAgc2VsZi5jbGllbnQuX3JlbW92ZShzZWxmKVxuXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5fcmVjaG9rZUludGVydmFsSWQpXG5cbiAgaWYgKHNlbGYuX3Jhcml0eU1hcCkge1xuICAgIHNlbGYuX3Jhcml0eU1hcC5kZXN0cm95KClcbiAgfVxuXG4gIGZvciAodmFyIGlkIGluIHNlbGYuX3BlZXJzKSB7XG4gICAgc2VsZi5yZW1vdmVQZWVyKGlkKVxuICB9XG5cbiAgc2VsZi5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSBmaWxlLl9kZXN0cm95KClcbiAgfSlcblxuICB2YXIgdGFza3MgPSBzZWxmLl9zZXJ2ZXJzLm1hcChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgc2VydmVyLmRlc3Ryb3koY2IpXG4gICAgfVxuICB9KVxuXG4gIGlmIChzZWxmLmRpc2NvdmVyeSkge1xuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLmRpc2NvdmVyeS5kZXN0cm95KGNiKVxuICAgIH0pXG4gIH1cblxuICBpZiAoc2VsZi5zdG9yZSkge1xuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLnN0b3JlLmNsb3NlKGNiKVxuICAgIH0pXG4gIH1cblxuICBwYXJhbGxlbCh0YXNrcywgY2IpXG5cbiAgaWYgKGVycikge1xuICAgIC8vIFRvcnJlbnQgZXJyb3JzIGFyZSBlbWl0dGVkIGF0IGB0b3JyZW50Lm9uKCdlcnJvcicpYC4gSWYgdGhlcmUgYXJlIG5vICdlcnJvcicgZXZlbnRcbiAgICAvLyBoYW5kbGVycyBvbiB0aGUgdG9ycmVudCBpbnN0YW5jZSwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCBhdFxuICAgIC8vIGBjbGllbnQub24oJ2Vycm9yJylgLiBUaGlzIHByZXZlbnRzIGNyYXNoaW5nIHRoZSB1c2VyJ3MgcHJvZ3JhbSwgYnV0IGl0IG1ha2VzIGl0XG4gICAgLy8gaW1wb3NzaWJsZSB0byBkZXRlcm1pbmUgYSBjbGllbnQgZXJyb3IgdmVyc3VzIGEgdG9ycmVudCBlcnJvciAod2hlcmUgdGhlIGNsaWVudFxuICAgIC8vIGlzIHN0aWxsIHVzYWJsZSBhZnRlcndhcmRzKS4gVXNlcnMgYXJlIHJlY29tbWVuZGVkIGZvciBlcnJvcnMgaW4gYm90aCBwbGFjZXNcbiAgICAvLyB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBlcnJvciB0eXBlcy5cbiAgICBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICBzZWxmLmNsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9XG4gIH1cblxuICBzZWxmLmVtaXQoJ2Nsb3NlJylcblxuICBzZWxmLmNsaWVudCA9IG51bGxcbiAgc2VsZi5maWxlcyA9IFtdXG4gIHNlbGYuZGlzY292ZXJ5ID0gbnVsbFxuICBzZWxmLnN0b3JlID0gbnVsbFxuICBzZWxmLl9yYXJpdHlNYXAgPSBudWxsXG4gIHNlbGYuX3BlZXJzID0gbnVsbFxuICBzZWxmLl9zZXJ2ZXJzID0gbnVsbFxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5hZGRQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG4gIGlmICghc2VsZi5pbmZvSGFzaCkgdGhyb3cgbmV3IEVycm9yKCdhZGRQZWVyKCkgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgYGluZm9IYXNoYCBldmVudCcpXG5cbiAgaWYgKHNlbGYuY2xpZW50LmJsb2NrZWQpIHtcbiAgICB2YXIgaG9zdFxuICAgIGlmICh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwYXJ0c1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFydHMgPSBhZGRyVG9JUFBvcnQocGVlcilcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IGludmFsaWQgJXMnLCBwZWVyKVxuICAgICAgICBzZWxmLmVtaXQoJ2ludmFsaWRQZWVyJywgcGVlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBob3N0ID0gcGFydHNbMF1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwZWVyLnJlbW90ZUFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBob3N0ID0gcGVlci5yZW1vdGVBZGRyZXNzXG4gICAgfVxuXG4gICAgaWYgKGhvc3QgJiYgc2VsZi5jbGllbnQuYmxvY2tlZC5jb250YWlucyhob3N0KSkge1xuICAgICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IGJsb2NrZWQgJXMnLCBwZWVyKVxuICAgICAgaWYgKHR5cGVvZiBwZWVyICE9PSAnc3RyaW5nJykgcGVlci5kZXN0cm95KClcbiAgICAgIHNlbGYuZW1pdCgnYmxvY2tlZFBlZXInLCBwZWVyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgdmFyIHdhc0FkZGVkID0gISFzZWxmLl9hZGRQZWVyKHBlZXIpXG4gIGlmICh3YXNBZGRlZCkge1xuICAgIHNlbGYuZW1pdCgncGVlcicsIHBlZXIpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5lbWl0KCdpbnZhbGlkUGVlcicsIHBlZXIpXG4gIH1cbiAgcmV0dXJuIHdhc0FkZGVkXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9hZGRQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkge1xuICAgIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBwZWVyOiB0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG4gICAgaWYgKHR5cGVvZiBwZWVyICE9PSAnc3RyaW5nJykgcGVlci5kZXN0cm95KClcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmICh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycgJiYgIXNlbGYuX3ZhbGlkQWRkcihwZWVyKSkge1xuICAgIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBwZWVyOiBpbnZhbGlkICVzJywgcGVlcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIGlkID0gKHBlZXIgJiYgcGVlci5pZCkgfHwgcGVlclxuICBpZiAoc2VsZi5fcGVlcnNbaWRdKSB7XG4gICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IGR1cGxpY2F0ZSAoJXMpJywgaWQpXG4gICAgaWYgKHR5cGVvZiBwZWVyICE9PSAnc3RyaW5nJykgcGVlci5kZXN0cm95KClcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHNlbGYucGF1c2VkKSB7XG4gICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IHRvcnJlbnQgaXMgcGF1c2VkJylcbiAgICBpZiAodHlwZW9mIHBlZXIgIT09ICdzdHJpbmcnKSBwZWVyLmRlc3Ryb3koKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBzZWxmLl9kZWJ1ZygnYWRkIHBlZXIgJXMnLCBpZClcblxuICB2YXIgbmV3UGVlclxuICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYHBlZXJgIGlzIGFuIGFkZHIgKFwiaXA6cG9ydFwiIHN0cmluZylcbiAgICBuZXdQZWVyID0gUGVlci5jcmVhdGVUQ1BPdXRnb2luZ1BlZXIocGVlciwgc2VsZilcbiAgfSBlbHNlIHtcbiAgICAvLyBgcGVlcmAgaXMgYSBXZWJSVEMgY29ubmVjdGlvbiAoc2ltcGxlLXBlZXIpXG4gICAgbmV3UGVlciA9IFBlZXIuY3JlYXRlV2ViUlRDUGVlcihwZWVyLCBzZWxmKVxuICB9XG5cbiAgc2VsZi5fcGVlcnNbbmV3UGVlci5pZF0gPSBuZXdQZWVyXG4gIHNlbGYuX3BlZXJzTGVuZ3RoICs9IDFcblxuICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYHBlZXJgIGlzIGFuIGFkZHIgKFwiaXA6cG9ydFwiIHN0cmluZylcbiAgICBzZWxmLl9xdWV1ZS5wdXNoKG5ld1BlZXIpXG4gICAgc2VsZi5fZHJhaW4oKVxuICB9XG5cbiAgcmV0dXJuIG5ld1BlZXJcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuYWRkV2ViU2VlZCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcblxuICBpZiAoIS9eaHR0cHM/OlxcL1xcLy4rLy50ZXN0KHVybCkpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaWdub3JpbmcgaW52YWxpZCB3ZWIgc2VlZCAlcycsIHVybClcbiAgICB0aGlzLmVtaXQoJ2ludmFsaWRQZWVyJywgdXJsKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHRoaXMuX3BlZXJzW3VybF0pIHtcbiAgICB0aGlzLl9kZWJ1ZygnaWdub3JpbmcgZHVwbGljYXRlIHdlYiBzZWVkICVzJywgdXJsKVxuICAgIHRoaXMuZW1pdCgnaW52YWxpZFBlZXInLCB1cmwpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLl9kZWJ1ZygnYWRkIHdlYiBzZWVkICVzJywgdXJsKVxuXG4gIHZhciBuZXdQZWVyID0gUGVlci5jcmVhdGVXZWJTZWVkUGVlcih1cmwsIHRoaXMpXG4gIHRoaXMuX3BlZXJzW25ld1BlZXIuaWRdID0gbmV3UGVlclxuICB0aGlzLl9wZWVyc0xlbmd0aCArPSAxXG5cbiAgdGhpcy5lbWl0KCdwZWVyJywgdXJsKVxufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmNvbWluZyBUQ1AgcGVlciBjb25uZWN0cyB0byB0aGlzIHRvcnJlbnQgc3dhcm0uIENhbGxlZCB3aXRoIGFcbiAqIHBlZXIgdGhhdCBoYXMgYWxyZWFkeSBzZW50IGEgaGFuZHNoYWtlLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fYWRkSW5jb21pbmdQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIHBlZXIuZGVzdHJveShuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJykpXG4gIGlmIChzZWxmLnBhdXNlZCkgcmV0dXJuIHBlZXIuZGVzdHJveShuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgcGF1c2VkJykpXG5cbiAgdGhpcy5fZGVidWcoJ2FkZCBpbmNvbWluZyBwZWVyICVzJywgcGVlci5pZClcblxuICBzZWxmLl9wZWVyc1twZWVyLmlkXSA9IHBlZXJcbiAgc2VsZi5fcGVlcnNMZW5ndGggKz0gMVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5yZW1vdmVQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpZCA9IChwZWVyICYmIHBlZXIuaWQpIHx8IHBlZXJcbiAgcGVlciA9IHNlbGYuX3BlZXJzW2lkXVxuXG4gIGlmICghcGVlcikgcmV0dXJuXG5cbiAgdGhpcy5fZGVidWcoJ3JlbW92ZVBlZXIgJXMnLCBpZClcblxuICBkZWxldGUgc2VsZi5fcGVlcnNbaWRdXG4gIHNlbGYuX3BlZXJzTGVuZ3RoIC09IDFcblxuICBwZWVyLmRlc3Ryb3koKVxuXG4gIC8vIElmIHRvcnJlbnQgc3dhcm0gd2FzIGF0IGNhcGFjaXR5IGJlZm9yZSwgdHJ5IHRvIG9wZW4gYSBuZXcgY29ubmVjdGlvbiBub3dcbiAgc2VsZi5fZHJhaW4oKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcHJpb3JpdHksIG5vdGlmeSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcblxuICBpZiAoc3RhcnQgPiBlbmQgfHwgc3RhcnQgPCAwIHx8IGVuZCA+PSBzZWxmLnBpZWNlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2VsZWN0aW9uICcsIHN0YXJ0LCAnOicsIGVuZClcbiAgfVxuICBwcmlvcml0eSA9IE51bWJlcihwcmlvcml0eSkgfHwgMFxuXG4gIHNlbGYuX2RlYnVnKCdzZWxlY3QgJXMtJXMgKHByaW9yaXR5ICVzKScsIHN0YXJ0LCBlbmQsIHByaW9yaXR5KVxuXG4gIHNlbGYuX3NlbGVjdGlvbnMucHVzaCh7XG4gICAgZnJvbTogc3RhcnQsXG4gICAgdG86IGVuZCxcbiAgICBvZmZzZXQ6IDAsXG4gICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgIG5vdGlmeTogbm90aWZ5IHx8IG5vb3BcbiAgfSlcblxuICBzZWxmLl9zZWxlY3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHlcbiAgfSlcblxuICBzZWxmLl91cGRhdGVTZWxlY3Rpb25zKClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcHJpb3JpdHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG5cbiAgcHJpb3JpdHkgPSBOdW1iZXIocHJpb3JpdHkpIHx8IDBcbiAgc2VsZi5fZGVidWcoJ2Rlc2VsZWN0ICVzLSVzIChwcmlvcml0eSAlcyknLCBzdGFydCwgZW5kLCBwcmlvcml0eSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcyA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cbiAgICBpZiAocy5mcm9tID09PSBzdGFydCAmJiBzLnRvID09PSBlbmQgJiYgcy5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIHNlbGYuX3NlbGVjdGlvbnMuc3BsaWNlKGktLSwgMSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgc2VsZi5fdXBkYXRlU2VsZWN0aW9ucygpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmNyaXRpY2FsID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG5cbiAgc2VsZi5fZGVidWcoJ2NyaXRpY2FsICVzLSVzJywgc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBzZWxmLl9jcml0aWNhbFtpXSA9IHRydWVcbiAgfVxuXG4gIHNlbGYuX3VwZGF0ZVNlbGVjdGlvbnMoKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fb25XaXJlID0gZnVuY3Rpb24gKHdpcmUsIGFkZHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2RlYnVnKCdnb3Qgd2lyZSAlcyAoJXMpJywgd2lyZS5fZGVidWdJZCwgYWRkciB8fCAnVW5rbm93bicpXG5cbiAgd2lyZS5vbignZG93bmxvYWQnLCBmdW5jdGlvbiAoZG93bmxvYWRlZCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgc2VsZi5yZWNlaXZlZCArPSBkb3dubG9hZGVkXG4gICAgc2VsZi5fZG93bmxvYWRTcGVlZChkb3dubG9hZGVkKVxuICAgIHNlbGYuY2xpZW50Ll9kb3dubG9hZFNwZWVkKGRvd25sb2FkZWQpXG4gICAgc2VsZi5lbWl0KCdkb3dubG9hZCcsIGRvd25sb2FkZWQpXG4gICAgc2VsZi5jbGllbnQuZW1pdCgnZG93bmxvYWQnLCBkb3dubG9hZGVkKVxuICB9KVxuXG4gIHdpcmUub24oJ3VwbG9hZCcsIGZ1bmN0aW9uICh1cGxvYWRlZCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgc2VsZi51cGxvYWRlZCArPSB1cGxvYWRlZFxuICAgIHNlbGYuX3VwbG9hZFNwZWVkKHVwbG9hZGVkKVxuICAgIHNlbGYuY2xpZW50Ll91cGxvYWRTcGVlZCh1cGxvYWRlZClcbiAgICBzZWxmLmVtaXQoJ3VwbG9hZCcsIHVwbG9hZGVkKVxuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3VwbG9hZCcsIHVwbG9hZGVkKVxuICB9KVxuXG4gIHNlbGYud2lyZXMucHVzaCh3aXJlKVxuXG4gIGlmIChhZGRyKSB7XG4gICAgLy8gU29tZXRpbWVzIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKCkgZG9lc24ndCByZXR1cm4gYW4gaXA6cG9ydCBmb3IgcGVlcnNcbiAgICB2YXIgcGFydHMgPSBhZGRyVG9JUFBvcnQoYWRkcilcbiAgICB3aXJlLnJlbW90ZUFkZHJlc3MgPSBwYXJ0c1swXVxuICAgIHdpcmUucmVtb3RlUG9ydCA9IHBhcnRzWzFdXG4gIH1cblxuICAvLyBXaGVuIHBlZXIgc2VuZHMgUE9SVCBtZXNzYWdlLCBhZGQgdGhhdCBESFQgbm9kZSB0byByb3V0aW5nIHRhYmxlXG4gIGlmIChzZWxmLmNsaWVudC5kaHQgJiYgc2VsZi5jbGllbnQuZGh0Lmxpc3RlbmluZykge1xuICAgIHdpcmUub24oJ3BvcnQnLCBmdW5jdGlvbiAocG9ydCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkIHx8IHNlbGYuY2xpZW50LmRodC5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoIXdpcmUucmVtb3RlQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gc2VsZi5fZGVidWcoJ2lnbm9yaW5nIFBPUlQgZnJvbSBwZWVyIHdpdGggbm8gYWRkcmVzcycpXG4gICAgICB9XG4gICAgICBpZiAocG9ydCA9PT0gMCB8fCBwb3J0ID4gNjU1MzYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBpbnZhbGlkIFBPUlQgZnJvbSBwZWVyJylcbiAgICAgIH1cblxuICAgICAgc2VsZi5fZGVidWcoJ3BvcnQ6ICVzIChmcm9tICVzKScsIHBvcnQsIGFkZHIpXG4gICAgICBzZWxmLmNsaWVudC5kaHQuYWRkTm9kZSh7IGhvc3Q6IHdpcmUucmVtb3RlQWRkcmVzcywgcG9ydDogcG9ydCB9KVxuICAgIH0pXG4gIH1cblxuICB3aXJlLm9uKCd0aW1lb3V0JywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2RlYnVnKCd3aXJlIHRpbWVvdXQgKCVzKScsIGFkZHIpXG4gICAgLy8gVE9ETzogdGhpcyBtaWdodCBiZSBkZXN0cm95aW5nIHdpcmVzIHRvbyBlYWdlcmx5XG4gICAgd2lyZS5kZXN0cm95KClcbiAgfSlcblxuICAvLyBUaW1lb3V0IGZvciBwaWVjZSByZXF1ZXN0cyB0byB0aGlzIHBlZXJcbiAgd2lyZS5zZXRUaW1lb3V0KFBJRUNFX1RJTUVPVVQsIHRydWUpXG5cbiAgLy8gU2VuZCBLRUVQLUFMSVZFIChldmVyeSA2MHMpIHNvIHBlZXJzIHdpbGwgbm90IGRpc2Nvbm5lY3QgdGhlIHdpcmVcbiAgd2lyZS5zZXRLZWVwQWxpdmUodHJ1ZSlcblxuICAvLyB1c2UgdXRfbWV0YWRhdGEgZXh0ZW5zaW9uXG4gIHdpcmUudXNlKHV0TWV0YWRhdGEoc2VsZi5tZXRhZGF0YSkpXG5cbiAgd2lyZS51dF9tZXRhZGF0YS5vbignd2FybmluZycsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9kZWJ1ZygndXRfbWV0YWRhdGEgd2FybmluZzogJXMnLCBlcnIubWVzc2FnZSlcbiAgfSlcblxuICBpZiAoIXNlbGYubWV0YWRhdGEpIHtcbiAgICB3aXJlLnV0X21ldGFkYXRhLm9uKCdtZXRhZGF0YScsIGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgc2VsZi5fZGVidWcoJ2dvdCBtZXRhZGF0YSB2aWEgdXRfbWV0YWRhdGEnKVxuICAgICAgc2VsZi5fb25NZXRhZGF0YShtZXRhZGF0YSlcbiAgICB9KVxuICAgIHdpcmUudXRfbWV0YWRhdGEuZmV0Y2goKVxuICB9XG5cbiAgLy8gdXNlIHV0X3BleCBleHRlbnNpb24gaWYgdGhlIHRvcnJlbnQgaXMgbm90IGZsYWdnZWQgYXMgcHJpdmF0ZVxuICBpZiAodHlwZW9mIHV0UGV4ID09PSAnZnVuY3Rpb24nICYmICFzZWxmLnByaXZhdGUpIHtcbiAgICB3aXJlLnVzZSh1dFBleCgpKVxuXG4gICAgd2lyZS51dF9wZXgub24oJ3BlZXInLCBmdW5jdGlvbiAocGVlcikge1xuICAgICAgLy8gT25seSBhZGQgcG90ZW50aWFsIG5ldyBwZWVycyB3aGVuIHdlJ3JlIG5vdCBzZWVkaW5nXG4gICAgICBpZiAoc2VsZi5kb25lKSByZXR1cm5cbiAgICAgIHNlbGYuX2RlYnVnKCd1dF9wZXg6IGdvdCBwZWVyOiAlcyAoZnJvbSAlcyknLCBwZWVyLCBhZGRyKVxuICAgICAgc2VsZi5hZGRQZWVyKHBlZXIpXG4gICAgfSlcblxuICAgIHdpcmUudXRfcGV4Lm9uKCdkcm9wcGVkJywgZnVuY3Rpb24gKHBlZXIpIHtcbiAgICAgIC8vIHRoZSByZW1vdGUgcGVlciBiZWxpZXZlcyBhIGdpdmVuIHBlZXIgaGFzIGJlZW4gZHJvcHBlZCBmcm9tIHRoZSB0b3JyZW50IHN3YXJtLlxuICAgICAgLy8gaWYgd2UncmUgbm90IGN1cnJlbnRseSBjb25uZWN0ZWQgdG8gaXQsIHRoZW4gcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXVlLlxuICAgICAgdmFyIHBlZXJPYmogPSBzZWxmLl9wZWVyc1twZWVyXVxuICAgICAgaWYgKHBlZXJPYmogJiYgIXBlZXJPYmouY29ubmVjdGVkKSB7XG4gICAgICAgIHNlbGYuX2RlYnVnKCd1dF9wZXg6IGRyb3BwZWQgcGVlcjogJXMgKGZyb20gJXMpJywgcGVlciwgYWRkcilcbiAgICAgICAgc2VsZi5yZW1vdmVQZWVyKHBlZXIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHdpcmUub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTdG9wIHNlbmRpbmcgdXBkYXRlcyB0byByZW1vdGUgcGVlclxuICAgICAgd2lyZS51dF9wZXgucmVzZXQoKVxuICAgIH0pXG4gIH1cblxuICAvLyBIb29rIHRvIGFsbG93IHVzZXItZGVmaW5lZCBgYml0dG9ycmVudC1wcm90b2NvbGAgZXh0ZW5zaW9uc1xuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYml0dG9ycmVudC1wcm90b2NvbCNleHRlbnNpb24tYXBpXG4gIHNlbGYuZW1pdCgnd2lyZScsIHdpcmUsIGFkZHIpXG5cbiAgaWYgKHNlbGYubWV0YWRhdGEpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRoaXMgYWxsb3dzIHdpcmUuaGFuZHNoYWtlKCkgdG8gYmUgY2FsbGVkIChieSBQZWVyLm9uSGFuZHNoYWtlKSBiZWZvcmUgYW55XG4gICAgICAvLyBtZXNzYWdlcyBnZXQgc2VudCBvbiB0aGUgd2lyZVxuICAgICAgc2VsZi5fb25XaXJlV2l0aE1ldGFkYXRhKHdpcmUpXG4gICAgfSlcbiAgfVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fb25XaXJlV2l0aE1ldGFkYXRhID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB0aW1lb3V0SWQgPSBudWxsXG5cbiAgZnVuY3Rpb24gb25DaG9rZVRpbWVvdXQgKCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCB8fCB3aXJlLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBpZiAoc2VsZi5fbnVtUXVldWVkID4gMiAqIChzZWxmLl9udW1Db25ucyAtIHNlbGYubnVtUGVlcnMpICYmXG4gICAgICB3aXJlLmFtSW50ZXJlc3RlZCkge1xuICAgICAgd2lyZS5kZXN0cm95KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChvbkNob2tlVGltZW91dCwgQ0hPS0VfVElNRU9VVClcbiAgICAgIGlmICh0aW1lb3V0SWQudW5yZWYpIHRpbWVvdXRJZC51bnJlZigpXG4gICAgfVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlZWRTdGF0dXMgKCkge1xuICAgIGlmICh3aXJlLnBlZXJQaWVjZXMubGVuZ3RoICE9PSBzZWxmLnBpZWNlcy5sZW5ndGgpIHJldHVyblxuICAgIGZvciAoOyBpIDwgc2VsZi5waWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghd2lyZS5wZWVyUGllY2VzLmdldChpKSkgcmV0dXJuXG4gICAgfVxuICAgIHdpcmUuaXNTZWVkZXIgPSB0cnVlXG4gICAgd2lyZS5jaG9rZSgpIC8vIGFsd2F5cyBjaG9rZSBzZWVkZXJzXG4gIH1cblxuICB3aXJlLm9uKCdiaXRmaWVsZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVTZWVkU3RhdHVzKClcbiAgICBzZWxmLl91cGRhdGUoKVxuICB9KVxuXG4gIHdpcmUub24oJ2hhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlU2VlZFN0YXR1cygpXG4gICAgc2VsZi5fdXBkYXRlKClcbiAgfSlcblxuICB3aXJlLm9uY2UoJ2ludGVyZXN0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgd2lyZS51bmNob2tlKClcbiAgfSlcblxuICB3aXJlLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gIH0pXG5cbiAgd2lyZS5vbignY2hva2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KG9uQ2hva2VUaW1lb3V0LCBDSE9LRV9USU1FT1VUKVxuICAgIGlmICh0aW1lb3V0SWQudW5yZWYpIHRpbWVvdXRJZC51bnJlZigpXG4gIH0pXG5cbiAgd2lyZS5vbigndW5jaG9rZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgIHNlbGYuX3VwZGF0ZSgpXG4gIH0pXG5cbiAgd2lyZS5vbigncmVxdWVzdCcsIGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGNiKSB7XG4gICAgaWYgKGxlbmd0aCA+IE1BWF9CTE9DS19MRU5HVEgpIHtcbiAgICAgIC8vIFBlciBzcGVjLCBkaXNjb25uZWN0IGZyb20gcGVlcnMgdGhhdCByZXF1ZXN0ID4xMjhLQlxuICAgICAgcmV0dXJuIHdpcmUuZGVzdHJveSgpXG4gICAgfVxuICAgIGlmIChzZWxmLnBpZWNlc1tpbmRleF0pIHJldHVyblxuICAgIHNlbGYuc3RvcmUuZ2V0KGluZGV4LCB7IG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCB9LCBjYilcbiAgfSlcblxuICB3aXJlLmJpdGZpZWxkKHNlbGYuYml0ZmllbGQpIC8vIGFsd2F5cyBzZW5kIGJpdGZpZWxkIChyZXF1aXJlZClcbiAgd2lyZS5pbnRlcmVzdGVkKCkgLy8gYWx3YXlzIHN0YXJ0IG91dCBpbnRlcmVzdGVkXG5cbiAgLy8gU2VuZCBQT1JUIG1lc3NhZ2UgdG8gcGVlcnMgdGhhdCBzdXBwb3J0IERIVFxuICBpZiAod2lyZS5wZWVyRXh0ZW5zaW9ucy5kaHQgJiYgc2VsZi5jbGllbnQuZGh0ICYmIHNlbGYuY2xpZW50LmRodC5saXN0ZW5pbmcpIHtcbiAgICB3aXJlLnBvcnQoc2VsZi5jbGllbnQuZGh0LmFkZHJlc3MoKS5wb3J0KVxuICB9XG5cbiAgdGltZW91dElkID0gc2V0VGltZW91dChvbkNob2tlVGltZW91dCwgQ0hPS0VfVElNRU9VVClcbiAgaWYgKHRpbWVvdXRJZC51bnJlZikgdGltZW91dElkLnVucmVmKClcblxuICB3aXJlLmlzU2VlZGVyID0gZmFsc2VcbiAgdXBkYXRlU2VlZFN0YXR1cygpXG59XG5cbi8qKlxuICogQ2FsbGVkIG9uIHNlbGVjdGlvbiBjaGFuZ2VzLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fdXBkYXRlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5yZWFkeSB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fZ2NTZWxlY3Rpb25zKClcbiAgfSlcbiAgc2VsZi5fdXBkYXRlSW50ZXJlc3QoKVxuICBzZWxmLl91cGRhdGUoKVxufVxuXG4vKipcbiAqIEdhcmJhZ2UgY29sbGVjdCBzZWxlY3Rpb25zIHdpdGggcmVzcGVjdCB0byB0aGUgc3RvcmUncyBjdXJyZW50IHN0YXRlLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fZ2NTZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcyA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cbiAgICB2YXIgb2xkT2Zmc2V0ID0gcy5vZmZzZXRcblxuICAgIC8vIGNoZWNrIGZvciBuZXdseSBkb3dubG9hZGVkIHBpZWNlcyBpbiBzZWxlY3Rpb25cbiAgICB3aGlsZSAoc2VsZi5iaXRmaWVsZC5nZXQocy5mcm9tICsgcy5vZmZzZXQpICYmIHMuZnJvbSArIHMub2Zmc2V0IDwgcy50bykge1xuICAgICAgcy5vZmZzZXQrK1xuICAgIH1cblxuICAgIGlmIChvbGRPZmZzZXQgIT09IHMub2Zmc2V0KSBzLm5vdGlmeSgpXG4gICAgaWYgKHMudG8gIT09IHMuZnJvbSArIHMub2Zmc2V0KSBjb250aW51ZVxuICAgIGlmICghc2VsZi5iaXRmaWVsZC5nZXQocy5mcm9tICsgcy5vZmZzZXQpKSBjb250aW51ZVxuXG4gICAgLy8gcmVtb3ZlIGZ1bGx5IGRvd25sb2FkZWQgc2VsZWN0aW9uXG4gICAgc2VsZi5fc2VsZWN0aW9ucy5zcGxpY2UoaS0tLCAxKSAvLyBkZWNyZW1lbnQgaSB0byBvZmZzZXQgc3BsaWNlXG4gICAgcy5ub3RpZnkoKSAvLyBUT0RPOiB0aGlzIG1heSBub3RpZnkgdHdpY2UgaW4gYSByb3cuIGlzIHRoaXMgYSBwcm9ibGVtP1xuICAgIHNlbGYuX3VwZGF0ZUludGVyZXN0KClcbiAgfVxuXG4gIGlmICghc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGgpIHNlbGYuZW1pdCgnaWRsZScpXG59XG5cbi8qKlxuICogVXBkYXRlIGludGVyZXN0ZWQgc3RhdHVzIGZvciBhbGwgcGVlcnMuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl91cGRhdGVJbnRlcmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIHByZXYgPSBzZWxmLl9hbUludGVyZXN0ZWRcbiAgc2VsZi5fYW1JbnRlcmVzdGVkID0gISFzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aFxuXG4gIHNlbGYud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgIC8vIFRPRE86IG9ubHkgY2FsbCB3aXJlLmludGVyZXN0ZWQgaWYgdGhlIHdpcmUgaGFzIGF0IGxlYXN0IG9uZSBwaWVjZSB3ZSBuZWVkXG4gICAgaWYgKHNlbGYuX2FtSW50ZXJlc3RlZCkgd2lyZS5pbnRlcmVzdGVkKClcbiAgICBlbHNlIHdpcmUudW5pbnRlcmVzdGVkKClcbiAgfSlcblxuICBpZiAocHJldiA9PT0gc2VsZi5fYW1JbnRlcmVzdGVkKSByZXR1cm5cbiAgaWYgKHNlbGYuX2FtSW50ZXJlc3RlZCkgc2VsZi5lbWl0KCdpbnRlcmVzdGVkJylcbiAgZWxzZSBzZWxmLmVtaXQoJ3VuaW50ZXJlc3RlZCcpXG59XG5cbi8qKlxuICogSGVhcnRiZWF0IHRvIHVwZGF0ZSBhbGwgcGVlcnMgYW5kIHRoZWlyIHJlcXVlc3RzLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICAvLyB1cGRhdGUgd2lyZXMgaW4gcmFuZG9tIG9yZGVyIGZvciBiZXR0ZXIgcmVxdWVzdCBkaXN0cmlidXRpb25cbiAgdmFyIGl0ZSA9IHJhbmRvbUl0ZXJhdGUoc2VsZi53aXJlcylcbiAgdmFyIHdpcmVcbiAgd2hpbGUgKCh3aXJlID0gaXRlKCkpKSB7XG4gICAgc2VsZi5fdXBkYXRlV2lyZSh3aXJlKVxuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gdXBkYXRlIGEgcGVlcidzIHJlcXVlc3RzXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl91cGRhdGVXaXJlID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHdpcmUucGVlckNob2tpbmcpIHJldHVyblxuICBpZiAoIXdpcmUuZG93bmxvYWRlZCkgcmV0dXJuIHZhbGlkYXRlV2lyZSgpXG5cbiAgdmFyIG1pbk91dHN0YW5kaW5nUmVxdWVzdHMgPSBnZXRCbG9ja1BpcGVsaW5lTGVuZ3RoKHdpcmUsIFBJUEVMSU5FX01JTl9EVVJBVElPTilcbiAgaWYgKHdpcmUucmVxdWVzdHMubGVuZ3RoID49IG1pbk91dHN0YW5kaW5nUmVxdWVzdHMpIHJldHVyblxuICB2YXIgbWF4T3V0c3RhbmRpbmdSZXF1ZXN0cyA9IGdldEJsb2NrUGlwZWxpbmVMZW5ndGgod2lyZSwgUElQRUxJTkVfTUFYX0RVUkFUSU9OKVxuXG4gIHRyeVNlbGVjdFdpcmUoZmFsc2UpIHx8IHRyeVNlbGVjdFdpcmUodHJ1ZSlcblxuICBmdW5jdGlvbiBnZW5QaWVjZUZpbHRlckZ1bmMgKHN0YXJ0LCBlbmQsIHRyaWVkLCByYW5rKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaSA+PSBzdGFydCAmJiBpIDw9IGVuZCAmJiAhKGkgaW4gdHJpZWQpICYmIHdpcmUucGVlclBpZWNlcy5nZXQoaSkgJiYgKCFyYW5rIHx8IHJhbmsoaSkpXG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogRG8gd2UgbmVlZCBib3RoIHZhbGlkYXRlV2lyZSBhbmQgdHJ5U2VsZWN0V2lyZT9cbiAgZnVuY3Rpb24gdmFsaWRhdGVXaXJlICgpIHtcbiAgICBpZiAod2lyZS5yZXF1ZXN0cy5sZW5ndGgpIHJldHVyblxuXG4gICAgdmFyIGkgPSBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBuZXh0ID0gc2VsZi5fc2VsZWN0aW9uc1tpXVxuICAgICAgdmFyIHBpZWNlXG4gICAgICBpZiAoc2VsZi5zdHJhdGVneSA9PT0gJ3JhcmVzdCcpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbmV4dC5mcm9tICsgbmV4dC5vZmZzZXRcbiAgICAgICAgdmFyIGVuZCA9IG5leHQudG9cbiAgICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0ICsgMVxuICAgICAgICB2YXIgdHJpZWQgPSB7fVxuICAgICAgICB2YXIgdHJpZXMgPSAwXG4gICAgICAgIHZhciBmaWx0ZXIgPSBnZW5QaWVjZUZpbHRlckZ1bmMoc3RhcnQsIGVuZCwgdHJpZWQpXG5cbiAgICAgICAgd2hpbGUgKHRyaWVzIDwgbGVuKSB7XG4gICAgICAgICAgcGllY2UgPSBzZWxmLl9yYXJpdHlNYXAuZ2V0UmFyZXN0UGllY2UoZmlsdGVyKVxuICAgICAgICAgIGlmIChwaWVjZSA8IDApIGJyZWFrXG4gICAgICAgICAgaWYgKHNlbGYuX3JlcXVlc3Qod2lyZSwgcGllY2UsIGZhbHNlKSkgcmV0dXJuXG4gICAgICAgICAgdHJpZWRbcGllY2VdID0gdHJ1ZVxuICAgICAgICAgIHRyaWVzICs9IDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChwaWVjZSA9IG5leHQudG87IHBpZWNlID49IG5leHQuZnJvbSArIG5leHQub2Zmc2V0OyAtLXBpZWNlKSB7XG4gICAgICAgICAgaWYgKCF3aXJlLnBlZXJQaWVjZXMuZ2V0KHBpZWNlKSkgY29udGludWVcbiAgICAgICAgICBpZiAoc2VsZi5fcmVxdWVzdCh3aXJlLCBwaWVjZSwgZmFsc2UpKSByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHdpcmUgZmFpbGVkIHRvIHZhbGlkYXRlIGFzIHVzZWZ1bDsgc2hvdWxkIHdlIGNsb3NlIGl0P1xuICAgIC8vIHByb2JhYmx5IG5vdCwgc2luY2UgJ2hhdmUnIGFuZCAnYml0ZmllbGQnIG1lc3NhZ2VzIG1pZ2h0IGJlIGNvbWluZ1xuICB9XG5cbiAgZnVuY3Rpb24gc3BlZWRSYW5rZXIgKCkge1xuICAgIHZhciBzcGVlZCA9IHdpcmUuZG93bmxvYWRTcGVlZCgpIHx8IDFcbiAgICBpZiAoc3BlZWQgPiBTUEVFRF9USFJFU0hPTEQpIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH1cblxuICAgIHZhciBzZWNzID0gTWF0aC5tYXgoMSwgd2lyZS5yZXF1ZXN0cy5sZW5ndGgpICogUGllY2UuQkxPQ0tfTEVOR1RIIC8gc3BlZWRcbiAgICB2YXIgdHJpZXMgPSAxMFxuICAgIHZhciBwdHIgPSAwXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBpZiAoIXRyaWVzIHx8IHNlbGYuYml0ZmllbGQuZ2V0KGluZGV4KSkgcmV0dXJuIHRydWVcblxuICAgICAgdmFyIG1pc3NpbmcgPSBzZWxmLnBpZWNlc1tpbmRleF0ubWlzc2luZ1xuXG4gICAgICBmb3IgKDsgcHRyIDwgc2VsZi53aXJlcy5sZW5ndGg7IHB0cisrKSB7XG4gICAgICAgIHZhciBvdGhlcldpcmUgPSBzZWxmLndpcmVzW3B0cl1cbiAgICAgICAgdmFyIG90aGVyU3BlZWQgPSBvdGhlcldpcmUuZG93bmxvYWRTcGVlZCgpXG5cbiAgICAgICAgaWYgKG90aGVyU3BlZWQgPCBTUEVFRF9USFJFU0hPTEQpIGNvbnRpbnVlXG4gICAgICAgIGlmIChvdGhlclNwZWVkIDw9IHNwZWVkKSBjb250aW51ZVxuICAgICAgICBpZiAoIW90aGVyV2lyZS5wZWVyUGllY2VzLmdldChpbmRleCkpIGNvbnRpbnVlXG4gICAgICAgIGlmICgobWlzc2luZyAtPSBvdGhlclNwZWVkICogc2VjcykgPiAwKSBjb250aW51ZVxuXG4gICAgICAgIHRyaWVzLS1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2h1ZmZsZVByaW9yaXR5IChpKSB7XG4gICAgdmFyIGxhc3QgPSBpXG4gICAgZm9yICh2YXIgaiA9IGk7IGogPCBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aCAmJiBzZWxmLl9zZWxlY3Rpb25zW2pdLnByaW9yaXR5OyBqKyspIHtcbiAgICAgIGxhc3QgPSBqXG4gICAgfVxuICAgIHZhciB0bXAgPSBzZWxmLl9zZWxlY3Rpb25zW2ldXG4gICAgc2VsZi5fc2VsZWN0aW9uc1tpXSA9IHNlbGYuX3NlbGVjdGlvbnNbbGFzdF1cbiAgICBzZWxmLl9zZWxlY3Rpb25zW2xhc3RdID0gdG1wXG4gIH1cblxuICBmdW5jdGlvbiB0cnlTZWxlY3RXaXJlIChob3Rzd2FwKSB7XG4gICAgaWYgKHdpcmUucmVxdWVzdHMubGVuZ3RoID49IG1heE91dHN0YW5kaW5nUmVxdWVzdHMpIHJldHVybiB0cnVlXG4gICAgdmFyIHJhbmsgPSBzcGVlZFJhbmtlcigpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gc2VsZi5fc2VsZWN0aW9uc1tpXVxuXG4gICAgICB2YXIgcGllY2VcbiAgICAgIGlmIChzZWxmLnN0cmF0ZWd5ID09PSAncmFyZXN0Jykge1xuICAgICAgICB2YXIgc3RhcnQgPSBuZXh0LmZyb20gKyBuZXh0Lm9mZnNldFxuICAgICAgICB2YXIgZW5kID0gbmV4dC50b1xuICAgICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQgKyAxXG4gICAgICAgIHZhciB0cmllZCA9IHt9XG4gICAgICAgIHZhciB0cmllcyA9IDBcbiAgICAgICAgdmFyIGZpbHRlciA9IGdlblBpZWNlRmlsdGVyRnVuYyhzdGFydCwgZW5kLCB0cmllZCwgcmFuaylcblxuICAgICAgICB3aGlsZSAodHJpZXMgPCBsZW4pIHtcbiAgICAgICAgICBwaWVjZSA9IHNlbGYuX3Jhcml0eU1hcC5nZXRSYXJlc3RQaWVjZShmaWx0ZXIpXG4gICAgICAgICAgaWYgKHBpZWNlIDwgMCkgYnJlYWtcblxuICAgICAgICAgIC8vIHJlcXVlc3QgYWxsIG5vbi1yZXNlcnZlZCBibG9ja3MgaW4gdGhpcyBwaWVjZVxuICAgICAgICAgIHdoaWxlIChzZWxmLl9yZXF1ZXN0KHdpcmUsIHBpZWNlLCBzZWxmLl9jcml0aWNhbFtwaWVjZV0gfHwgaG90c3dhcCkpIHt9XG5cbiAgICAgICAgICBpZiAod2lyZS5yZXF1ZXN0cy5sZW5ndGggPCBtYXhPdXRzdGFuZGluZ1JlcXVlc3RzKSB7XG4gICAgICAgICAgICB0cmllZFtwaWVjZV0gPSB0cnVlXG4gICAgICAgICAgICB0cmllcysrXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0LnByaW9yaXR5KSBzaHVmZmxlUHJpb3JpdHkoaSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHBpZWNlID0gbmV4dC5mcm9tICsgbmV4dC5vZmZzZXQ7IHBpZWNlIDw9IG5leHQudG87IHBpZWNlKyspIHtcbiAgICAgICAgICBpZiAoIXdpcmUucGVlclBpZWNlcy5nZXQocGllY2UpIHx8ICFyYW5rKHBpZWNlKSkgY29udGludWVcblxuICAgICAgICAgIC8vIHJlcXVlc3QgYWxsIG5vbi1yZXNlcnZlZCBibG9ja3MgaW4gcGllY2VcbiAgICAgICAgICB3aGlsZSAoc2VsZi5fcmVxdWVzdCh3aXJlLCBwaWVjZSwgc2VsZi5fY3JpdGljYWxbcGllY2VdIHx8IGhvdHN3YXApKSB7fVxuXG4gICAgICAgICAgaWYgKHdpcmUucmVxdWVzdHMubGVuZ3RoIDwgbWF4T3V0c3RhbmRpbmdSZXF1ZXN0cykgY29udGludWVcblxuICAgICAgICAgIGlmIChuZXh0LnByaW9yaXR5KSBzaHVmZmxlUHJpb3JpdHkoaSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsZWQgcGVyaW9kaWNhbGx5IHRvIHVwZGF0ZSB0aGUgY2hva2VkIHN0YXR1cyBvZiBhbGwgcGVlcnMsIGhhbmRsaW5nIG9wdGltaXN0aWNcbiAqIHVuY2hva2luZyBhcyBkZXNjcmliZWQgaW4gQkVQMy5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX3JlY2hva2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYucmVhZHkpIHJldHVyblxuXG4gIGlmIChzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1RpbWUgPiAwKSBzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1RpbWUgLT0gMVxuICBlbHNlIHNlbGYuX3JlY2hva2VPcHRpbWlzdGljV2lyZSA9IG51bGxcblxuICB2YXIgcGVlcnMgPSBbXVxuXG4gIHNlbGYud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgIGlmICghd2lyZS5pc1NlZWRlciAmJiB3aXJlICE9PSBzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1dpcmUpIHtcbiAgICAgIHBlZXJzLnB1c2goe1xuICAgICAgICB3aXJlOiB3aXJlLFxuICAgICAgICBkb3dubG9hZFNwZWVkOiB3aXJlLmRvd25sb2FkU3BlZWQoKSxcbiAgICAgICAgdXBsb2FkU3BlZWQ6IHdpcmUudXBsb2FkU3BlZWQoKSxcbiAgICAgICAgc2FsdDogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgaXNDaG9rZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHBlZXJzLnNvcnQocmVjaG9rZVNvcnQpXG5cbiAgdmFyIHVuY2hva2VJbnRlcmVzdGVkID0gMFxuICB2YXIgaSA9IDBcbiAgZm9yICg7IGkgPCBwZWVycy5sZW5ndGggJiYgdW5jaG9rZUludGVyZXN0ZWQgPCBzZWxmLl9yZWNob2tlTnVtU2xvdHM7ICsraSkge1xuICAgIHBlZXJzW2ldLmlzQ2hva2VkID0gZmFsc2VcbiAgICBpZiAocGVlcnNbaV0ud2lyZS5wZWVySW50ZXJlc3RlZCkgdW5jaG9rZUludGVyZXN0ZWQgKz0gMVxuICB9XG5cbiAgLy8gT3B0aW1pc3RpY2FsbHkgdW5jaG9rZSBhIHBlZXJcbiAgaWYgKCFzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1dpcmUgJiYgaSA8IHBlZXJzLmxlbmd0aCAmJiBzZWxmLl9yZWNob2tlTnVtU2xvdHMpIHtcbiAgICB2YXIgY2FuZGlkYXRlcyA9IHBlZXJzLnNsaWNlKGkpLmZpbHRlcihmdW5jdGlvbiAocGVlcikgeyByZXR1cm4gcGVlci53aXJlLnBlZXJJbnRlcmVzdGVkIH0pXG4gICAgdmFyIG9wdGltaXN0aWMgPSBjYW5kaWRhdGVzW3JhbmRvbUludChjYW5kaWRhdGVzLmxlbmd0aCldXG5cbiAgICBpZiAob3B0aW1pc3RpYykge1xuICAgICAgb3B0aW1pc3RpYy5pc0Nob2tlZCA9IGZhbHNlXG4gICAgICBzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1dpcmUgPSBvcHRpbWlzdGljLndpcmVcbiAgICAgIHNlbGYuX3JlY2hva2VPcHRpbWlzdGljVGltZSA9IFJFQ0hPS0VfT1BUSU1JU1RJQ19EVVJBVElPTlxuICAgIH1cbiAgfVxuXG4gIC8vIFVuY2hva2UgYmVzdCBwZWVyc1xuICBwZWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgaWYgKHBlZXIud2lyZS5hbUNob2tpbmcgIT09IHBlZXIuaXNDaG9rZWQpIHtcbiAgICAgIGlmIChwZWVyLmlzQ2hva2VkKSBwZWVyLndpcmUuY2hva2UoKVxuICAgICAgZWxzZSBwZWVyLndpcmUudW5jaG9rZSgpXG4gICAgfVxuICB9KVxuXG4gIGZ1bmN0aW9uIHJlY2hva2VTb3J0IChwZWVyQSwgcGVlckIpIHtcbiAgICAvLyBQcmVmZXIgaGlnaGVyIGRvd25sb2FkIHNwZWVkXG4gICAgaWYgKHBlZXJBLmRvd25sb2FkU3BlZWQgIT09IHBlZXJCLmRvd25sb2FkU3BlZWQpIHtcbiAgICAgIHJldHVybiBwZWVyQi5kb3dubG9hZFNwZWVkIC0gcGVlckEuZG93bmxvYWRTcGVlZFxuICAgIH1cblxuICAgIC8vIFByZWZlciBoaWdoZXIgdXBsb2FkIHNwZWVkXG4gICAgaWYgKHBlZXJBLnVwbG9hZFNwZWVkICE9PSBwZWVyQi51cGxvYWRTcGVlZCkge1xuICAgICAgcmV0dXJuIHBlZXJCLnVwbG9hZFNwZWVkIC0gcGVlckEudXBsb2FkU3BlZWRcbiAgICB9XG5cbiAgICAvLyBQcmVmZXIgdW5jaG9rZWRcbiAgICBpZiAocGVlckEud2lyZS5hbUNob2tpbmcgIT09IHBlZXJCLndpcmUuYW1DaG9raW5nKSB7XG4gICAgICByZXR1cm4gcGVlckEud2lyZS5hbUNob2tpbmcgPyAxIDogLTFcbiAgICB9XG5cbiAgICAvLyBSYW5kb20gb3JkZXJcbiAgICByZXR1cm4gcGVlckEuc2FsdCAtIHBlZXJCLnNhbHRcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGNhbmNlbCBhIHNsb3cgYmxvY2sgcmVxdWVzdCBmcm9tIGFub3RoZXIgd2lyZSBzdWNoIHRoYXQgdGhlXG4gKiBnaXZlbiB3aXJlIG1heSBlZmZlY3RpdmVseSBzd2FwIG91dCB0aGUgcmVxdWVzdCBmb3Igb25lIG9mIGl0cyBvd24uXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9ob3Rzd2FwID0gZnVuY3Rpb24gKHdpcmUsIGluZGV4KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBzcGVlZCA9IHdpcmUuZG93bmxvYWRTcGVlZCgpXG4gIGlmIChzcGVlZCA8IFBpZWNlLkJMT0NLX0xFTkdUSCkgcmV0dXJuIGZhbHNlXG4gIGlmICghc2VsZi5fcmVzZXJ2YXRpb25zW2luZGV4XSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIHIgPSBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdXG4gIGlmICghcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIG1pblNwZWVkID0gSW5maW5pdHlcbiAgdmFyIG1pbldpcmVcblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlcldpcmUgPSByW2ldXG4gICAgaWYgKCFvdGhlcldpcmUgfHwgb3RoZXJXaXJlID09PSB3aXJlKSBjb250aW51ZVxuXG4gICAgdmFyIG90aGVyU3BlZWQgPSBvdGhlcldpcmUuZG93bmxvYWRTcGVlZCgpXG4gICAgaWYgKG90aGVyU3BlZWQgPj0gU1BFRURfVEhSRVNIT0xEKSBjb250aW51ZVxuICAgIGlmICgyICogb3RoZXJTcGVlZCA+IHNwZWVkIHx8IG90aGVyU3BlZWQgPiBtaW5TcGVlZCkgY29udGludWVcblxuICAgIG1pbldpcmUgPSBvdGhlcldpcmVcbiAgICBtaW5TcGVlZCA9IG90aGVyU3BlZWRcbiAgfVxuXG4gIGlmICghbWluV2lyZSkgcmV0dXJuIGZhbHNlXG5cbiAgZm9yIChpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocltpXSA9PT0gbWluV2lyZSkgcltpXSA9IG51bGxcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBtaW5XaXJlLnJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlcSA9IG1pbldpcmUucmVxdWVzdHNbaV1cbiAgICBpZiAocmVxLnBpZWNlICE9PSBpbmRleCkgY29udGludWVcblxuICAgIHNlbGYucGllY2VzW2luZGV4XS5jYW5jZWwoKHJlcS5vZmZzZXQgLyBQaWVjZS5CTE9DS19MRU5HVEgpIHwgMClcbiAgfVxuXG4gIHNlbGYuZW1pdCgnaG90c3dhcCcsIG1pbldpcmUsIHdpcmUsIGluZGV4KVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlcXVlc3QgYSBibG9jayBmcm9tIHRoZSBnaXZlbiB3aXJlLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uICh3aXJlLCBpbmRleCwgaG90c3dhcCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG51bVJlcXVlc3RzID0gd2lyZS5yZXF1ZXN0cy5sZW5ndGhcbiAgdmFyIGlzV2ViU2VlZCA9IHdpcmUudHlwZSA9PT0gJ3dlYlNlZWQnXG5cbiAgaWYgKHNlbGYuYml0ZmllbGQuZ2V0KGluZGV4KSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIG1heE91dHN0YW5kaW5nUmVxdWVzdHMgPSBpc1dlYlNlZWRcbiAgICA/IE1hdGgubWluKFxuICAgICAgICBnZXRQaWVjZVBpcGVsaW5lTGVuZ3RoKHdpcmUsIFBJUEVMSU5FX01BWF9EVVJBVElPTiwgc2VsZi5waWVjZUxlbmd0aCksXG4gICAgICAgIHNlbGYubWF4V2ViQ29ubnNcbiAgICAgIClcbiAgICA6IGdldEJsb2NrUGlwZWxpbmVMZW5ndGgod2lyZSwgUElQRUxJTkVfTUFYX0RVUkFUSU9OKVxuXG4gIGlmIChudW1SZXF1ZXN0cyA+PSBtYXhPdXRzdGFuZGluZ1JlcXVlc3RzKSByZXR1cm4gZmFsc2VcbiAgLy8gdmFyIGVuZEdhbWUgPSAod2lyZS5yZXF1ZXN0cy5sZW5ndGggPT09IDAgJiYgc2VsZi5zdG9yZS5udW1NaXNzaW5nIDwgMzApXG5cbiAgdmFyIHBpZWNlID0gc2VsZi5waWVjZXNbaW5kZXhdXG4gIHZhciByZXNlcnZhdGlvbiA9IGlzV2ViU2VlZCA/IHBpZWNlLnJlc2VydmVSZW1haW5pbmcoKSA6IHBpZWNlLnJlc2VydmUoKVxuXG4gIGlmIChyZXNlcnZhdGlvbiA9PT0gLTEgJiYgaG90c3dhcCAmJiBzZWxmLl9ob3Rzd2FwKHdpcmUsIGluZGV4KSkge1xuICAgIHJlc2VydmF0aW9uID0gaXNXZWJTZWVkID8gcGllY2UucmVzZXJ2ZVJlbWFpbmluZygpIDogcGllY2UucmVzZXJ2ZSgpXG4gIH1cbiAgaWYgKHJlc2VydmF0aW9uID09PSAtMSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIHIgPSBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdXG4gIGlmICghcikgciA9IHNlbGYuX3Jlc2VydmF0aW9uc1tpbmRleF0gPSBbXVxuICB2YXIgaSA9IHIuaW5kZXhPZihudWxsKVxuICBpZiAoaSA9PT0gLTEpIGkgPSByLmxlbmd0aFxuICByW2ldID0gd2lyZVxuXG4gIHZhciBjaHVua09mZnNldCA9IHBpZWNlLmNodW5rT2Zmc2V0KHJlc2VydmF0aW9uKVxuICB2YXIgY2h1bmtMZW5ndGggPSBpc1dlYlNlZWQgPyBwaWVjZS5jaHVua0xlbmd0aFJlbWFpbmluZyhyZXNlcnZhdGlvbikgOiBwaWVjZS5jaHVua0xlbmd0aChyZXNlcnZhdGlvbilcblxuICB3aXJlLnJlcXVlc3QoaW5kZXgsIGNodW5rT2Zmc2V0LCBjaHVua0xlbmd0aCwgZnVuY3Rpb24gb25DaHVuayAoZXJyLCBjaHVuaykge1xuICAgIC8vIFRPRE86IHdoYXQgaXMgdGhpcyBmb3I/XG4gICAgaWYgKCFzZWxmLnJlYWR5KSByZXR1cm4gc2VsZi5vbmNlKCdyZWFkeScsIGZ1bmN0aW9uICgpIHsgb25DaHVuayhlcnIsIGNodW5rKSB9KVxuXG4gICAgaWYgKHJbaV0gPT09IHdpcmUpIHJbaV0gPSBudWxsXG5cbiAgICBpZiAocGllY2UgIT09IHNlbGYucGllY2VzW2luZGV4XSkgcmV0dXJuIG9uVXBkYXRlVGljaygpXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBzZWxmLl9kZWJ1ZyhcbiAgICAgICAgJ2Vycm9yIGdldHRpbmcgcGllY2UgJXMgKG9mZnNldDogJXMgbGVuZ3RoOiAlcykgZnJvbSAlczogJXMnLFxuICAgICAgICBpbmRleCwgY2h1bmtPZmZzZXQsIGNodW5rTGVuZ3RoLCB3aXJlLnJlbW90ZUFkZHJlc3MgKyAnOicgKyB3aXJlLnJlbW90ZVBvcnQsXG4gICAgICAgIGVyci5tZXNzYWdlXG4gICAgICApXG4gICAgICBpc1dlYlNlZWQgPyBwaWVjZS5jYW5jZWxSZW1haW5pbmcocmVzZXJ2YXRpb24pIDogcGllY2UuY2FuY2VsKHJlc2VydmF0aW9uKVxuICAgICAgb25VcGRhdGVUaWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnKFxuICAgICAgJ2dvdCBwaWVjZSAlcyAob2Zmc2V0OiAlcyBsZW5ndGg6ICVzKSBmcm9tICVzJyxcbiAgICAgIGluZGV4LCBjaHVua09mZnNldCwgY2h1bmtMZW5ndGgsIHdpcmUucmVtb3RlQWRkcmVzcyArICc6JyArIHdpcmUucmVtb3RlUG9ydFxuICAgIClcblxuICAgIGlmICghcGllY2Uuc2V0KHJlc2VydmF0aW9uLCBjaHVuaywgd2lyZSkpIHJldHVybiBvblVwZGF0ZVRpY2soKVxuXG4gICAgdmFyIGJ1ZiA9IHBpZWNlLmZsdXNoKClcblxuICAgIC8vIFRPRE86IG1pZ2h0IG5lZWQgdG8gc2V0IHNlbGYucGllY2VzW2luZGV4XSA9IG51bGwgaGVyZSBzaW5jZSBzaGExIGlzIGFzeW5jXG5cbiAgICBzaGExKGJ1ZiwgZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIGlmIChoYXNoID09PSBzZWxmLl9oYXNoZXNbaW5kZXhdKSB7XG4gICAgICAgIGlmICghc2VsZi5waWVjZXNbaW5kZXhdKSByZXR1cm5cbiAgICAgICAgc2VsZi5fZGVidWcoJ3BpZWNlIHZlcmlmaWVkICVzJywgaW5kZXgpXG5cbiAgICAgICAgc2VsZi5waWVjZXNbaW5kZXhdID0gbnVsbFxuICAgICAgICBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdID0gbnVsbFxuICAgICAgICBzZWxmLmJpdGZpZWxkLnNldChpbmRleCwgdHJ1ZSlcblxuICAgICAgICBzZWxmLnN0b3JlLnB1dChpbmRleCwgYnVmKVxuXG4gICAgICAgIHNlbGYud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgICAgICAgIHdpcmUuaGF2ZShpbmRleClcbiAgICAgICAgfSlcblxuICAgICAgICBzZWxmLl9jaGVja0RvbmUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5waWVjZXNbaW5kZXhdID0gbmV3IFBpZWNlKHBpZWNlLmxlbmd0aClcbiAgICAgICAgc2VsZi5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQaWVjZSAnICsgaW5kZXggKyAnIGZhaWxlZCB2ZXJpZmljYXRpb24nKSlcbiAgICAgIH1cbiAgICAgIG9uVXBkYXRlVGljaygpXG4gICAgfSlcbiAgfSlcblxuICBmdW5jdGlvbiBvblVwZGF0ZVRpY2sgKCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBzZWxmLl91cGRhdGUoKSB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX2NoZWNrRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgLy8gYXJlIGFueSBuZXcgZmlsZXMgZG9uZT9cbiAgc2VsZi5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgaWYgKGZpbGUuZG9uZSkgcmV0dXJuXG4gICAgZm9yICh2YXIgaSA9IGZpbGUuX3N0YXJ0UGllY2U7IGkgPD0gZmlsZS5fZW5kUGllY2U7ICsraSkge1xuICAgICAgaWYgKCFzZWxmLmJpdGZpZWxkLmdldChpKSkgcmV0dXJuXG4gICAgfVxuICAgIGZpbGUuZG9uZSA9IHRydWVcbiAgICBmaWxlLmVtaXQoJ2RvbmUnKVxuICAgIHNlbGYuX2RlYnVnKCdmaWxlIGRvbmU6ICcgKyBmaWxlLm5hbWUpXG4gIH0pXG5cbiAgLy8gaXMgdGhlIHRvcnJlbnQgZG9uZT8gKGlmIGFsbCBjdXJyZW50IHNlbGVjdGlvbnMgYXJlIHNhdGlzZmllZCwgb3IgdGhlcmUgYXJlXG4gIC8vIG5vIHNlbGVjdGlvbnMsIHRoZW4gdG9ycmVudCBpcyBkb25lKVxuICB2YXIgZG9uZSA9IHRydWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cbiAgICBmb3IgKHZhciBwaWVjZSA9IHNlbGVjdGlvbi5mcm9tOyBwaWVjZSA8PSBzZWxlY3Rpb24udG87IHBpZWNlKyspIHtcbiAgICAgIGlmICghc2VsZi5iaXRmaWVsZC5nZXQocGllY2UpKSB7XG4gICAgICAgIGRvbmUgPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRvbmUpIGJyZWFrXG4gIH1cbiAgaWYgKCFzZWxmLmRvbmUgJiYgZG9uZSkge1xuICAgIHNlbGYuZG9uZSA9IHRydWVcbiAgICBzZWxmLl9kZWJ1ZygndG9ycmVudCBkb25lOiAnICsgc2VsZi5pbmZvSGFzaClcbiAgICBpZiAoc2VsZi5kaXNjb3ZlcnkudHJhY2tlcikge1xuICAgICAgc2VsZi5kaXNjb3ZlcnkudHJhY2tlci5jb21wbGV0ZSgpXG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZG9uZScpXG4gIH1cblxuICBzZWxmLl9nY1NlbGVjdGlvbnMoKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHN0cmVhbXMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuICBpZiAoIXNlbGYucmVhZHkpIHJldHVybiBzZWxmLm9uY2UoJ3JlYWR5JywgZnVuY3Rpb24gKCkgeyBzZWxmLmxvYWQoc3RyZWFtcywgY2IpIH0pXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0cmVhbXMpKSBzdHJlYW1zID0gWyBzdHJlYW1zIF1cbiAgaWYgKCFjYikgY2IgPSBub29wXG5cbiAgdmFyIHJlYWRhYmxlID0gbmV3IE11bHRpU3RyZWFtKHN0cmVhbXMpXG4gIHZhciB3cml0YWJsZSA9IG5ldyBDaHVua1N0b3JlV3JpdGVTdHJlYW0oc2VsZi5zdG9yZSwgc2VsZi5waWVjZUxlbmd0aClcblxuICBwdW1wKHJlYWRhYmxlLCB3cml0YWJsZSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5waWVjZXMuZm9yRWFjaChmdW5jdGlvbiAocGllY2UsIGluZGV4KSB7XG4gICAgICBzZWxmLnBpZWNlc1tpbmRleF0gPSBudWxsXG4gICAgICBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdID0gbnVsbFxuICAgICAgc2VsZi5iaXRmaWVsZC5zZXQoaW5kZXgsIHRydWUpXG4gICAgfSlcbiAgICBzZWxmLl9jaGVja0RvbmUoKVxuICAgIGNiKG51bGwpXG4gIH0pXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmNyZWF0ZVNlcnZlciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICh0eXBlb2YgU2VydmVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ25vZGUuanMtb25seSBtZXRob2QnKVxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuICB2YXIgc2VydmVyID0gbmV3IFNlcnZlcih0aGlzLCBvcHRzKVxuICB0aGlzLl9zZXJ2ZXJzLnB1c2goc2VydmVyKVxuICByZXR1cm4gc2VydmVyXG59XG5cblRvcnJlbnQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZWJ1ZygncGF1c2UnKVxuICB0aGlzLnBhdXNlZCA9IHRydWVcbn1cblxuVG9ycmVudC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZWJ1ZygncmVzdW1lJylcbiAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICB0aGlzLl9kcmFpbigpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgYXJnc1swXSA9ICdbJyArIHRoaXMuX2RlYnVnSWQgKyAnXSAnICsgYXJnc1swXVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmdzKVxufVxuXG4vKipcbiAqIFBvcCBhIHBlZXIgb2ZmIHRoZSBGSUZPIHF1ZXVlIGFuZCBjb25uZWN0IHRvIGl0LiBXaGVuIF9kcmFpbigpIGdldHMgY2FsbGVkLFxuICogdGhlIHF1ZXVlIHdpbGwgdXN1YWxseSBoYXZlIG9ubHkgb25lIHBlZXIgaW4gaXQsIGV4Y2VwdCB3aGVuIHRoZXJlIGFyZSB0b29cbiAqIG1hbnkgcGVlcnMgKG92ZXIgYHRoaXMubWF4Q29ubnNgKSBpbiB3aGljaCBjYXNlIHRoZXkgd2lsbCBqdXN0IHNpdCBpbiB0aGVcbiAqIHF1ZXVlIHVudGlsIGFub3RoZXIgY29ubmVjdGlvbiBjbG9zZXMuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX2RlYnVnKCdfZHJhaW4gbnVtQ29ubnMgJXMgbWF4Q29ubnMgJXMnLCBzZWxmLl9udW1Db25ucywgc2VsZi5jbGllbnQubWF4Q29ubnMpXG4gIGlmICh0eXBlb2YgbmV0LmNvbm5lY3QgIT09ICdmdW5jdGlvbicgfHwgc2VsZi5kZXN0cm95ZWQgfHwgc2VsZi5wYXVzZWQgfHxcbiAgICAgIHNlbGYuX251bUNvbm5zID49IHNlbGYuY2xpZW50Lm1heENvbm5zKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fZGVidWcoJ2RyYWluICglcyBxdWV1ZWQsICVzLyVzIHBlZXJzKScsIHNlbGYuX251bVF1ZXVlZCwgc2VsZi5udW1QZWVycywgc2VsZi5jbGllbnQubWF4Q29ubnMpXG5cbiAgdmFyIHBlZXIgPSBzZWxmLl9xdWV1ZS5zaGlmdCgpXG4gIGlmICghcGVlcikgcmV0dXJuIC8vIHF1ZXVlIGNvdWxkIGJlIGVtcHR5XG5cbiAgdGhpcy5fZGVidWcoJ3RjcCBjb25uZWN0IGF0dGVtcHQgdG8gJXMnLCBwZWVyLmFkZHIpXG5cbiAgdmFyIHBhcnRzID0gYWRkclRvSVBQb3J0KHBlZXIuYWRkcilcbiAgdmFyIG9wdHMgPSB7XG4gICAgaG9zdDogcGFydHNbMF0sXG4gICAgcG9ydDogcGFydHNbMV1cbiAgfVxuXG4gIHZhciBjb25uID0gcGVlci5jb25uID0gbmV0LmNvbm5lY3Qob3B0cylcblxuICBjb25uLm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7IHBlZXIub25Db25uZWN0KCkgfSlcbiAgY29ubi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgcGVlci5kZXN0cm95KGVycikgfSlcbiAgcGVlci5zdGFydENvbm5lY3RUaW1lb3V0KClcblxuICAvLyBXaGVuIGNvbm5lY3Rpb24gY2xvc2VzLCBhdHRlbXB0IHJlY29ubmVjdCBhZnRlciB0aW1lb3V0ICh3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYpXG4gIGNvbm4ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAvLyBUT0RPOiBJZiB0b3JyZW50IGlzIGRvbmUsIGRvIG5vdCB0cnkgdG8gcmVjb25uZWN0IGFmdGVyIGEgdGltZW91dFxuXG4gICAgaWYgKHBlZXIucmV0cmllcyA+PSBSRUNPTk5FQ1RfV0FJVC5sZW5ndGgpIHtcbiAgICAgIHNlbGYuX2RlYnVnKFxuICAgICAgICAnY29ubiAlcyBjbG9zZWQ6IHdpbGwgbm90IHJlLWFkZCAobWF4ICVzIGF0dGVtcHRzKScsXG4gICAgICAgIHBlZXIuYWRkciwgUkVDT05ORUNUX1dBSVQubGVuZ3RoXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgbXMgPSBSRUNPTk5FQ1RfV0FJVFtwZWVyLnJldHJpZXNdXG4gICAgc2VsZi5fZGVidWcoXG4gICAgICAnY29ubiAlcyBjbG9zZWQ6IHdpbGwgcmUtYWRkIHRvIHF1ZXVlIGluICVzbXMgKGF0dGVtcHQgJXMpJyxcbiAgICAgIHBlZXIuYWRkciwgbXMsIHBlZXIucmV0cmllcyArIDFcbiAgICApXG5cbiAgICB2YXIgcmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gcmVjb25uZWN0VGltZW91dCAoKSB7XG4gICAgICB2YXIgbmV3UGVlciA9IHNlbGYuX2FkZFBlZXIocGVlci5hZGRyKVxuICAgICAgaWYgKG5ld1BlZXIpIG5ld1BlZXIucmV0cmllcyA9IHBlZXIucmV0cmllcyArIDFcbiAgICB9LCBtcylcbiAgICBpZiAocmVjb25uZWN0VGltZW91dC51bnJlZikgcmVjb25uZWN0VGltZW91dC51bnJlZigpXG4gIH0pXG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgc3RyaW5nIGlzIHZhbGlkIElQdjQvNiBhZGRyZXNzLlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl92YWxpZEFkZHIgPSBmdW5jdGlvbiAoYWRkcikge1xuICB2YXIgcGFydHNcbiAgdHJ5IHtcbiAgICBwYXJ0cyA9IGFkZHJUb0lQUG9ydChhZGRyKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGhvc3QgPSBwYXJ0c1swXVxuICB2YXIgcG9ydCA9IHBhcnRzWzFdXG4gIHJldHVybiBwb3J0ID4gMCAmJiBwb3J0IDwgNjU1MzUgJiZcbiAgICAhKGhvc3QgPT09ICcxMjcuMC4wLjEnICYmIHBvcnQgPT09IHRoaXMuY2xpZW50LnRvcnJlbnRQb3J0KVxufVxuXG5mdW5jdGlvbiBnZXRCbG9ja1BpcGVsaW5lTGVuZ3RoICh3aXJlLCBkdXJhdGlvbikge1xuICByZXR1cm4gMiArIE1hdGguY2VpbChkdXJhdGlvbiAqIHdpcmUuZG93bmxvYWRTcGVlZCgpIC8gUGllY2UuQkxPQ0tfTEVOR1RIKVxufVxuXG5mdW5jdGlvbiBnZXRQaWVjZVBpcGVsaW5lTGVuZ3RoICh3aXJlLCBkdXJhdGlvbiwgcGllY2VMZW5ndGgpIHtcbiAgcmV0dXJuIDEgKyBNYXRoLmNlaWwoZHVyYXRpb24gKiB3aXJlLmRvd25sb2FkU3BlZWQoKSAvIHBpZWNlTGVuZ3RoKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBpbiBbMCxoaWdoKVxuICovXG5mdW5jdGlvbiByYW5kb21JbnQgKGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiBoaWdoIHwgMFxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFdlYkNvbm5cblxudmFyIEJpdEZpZWxkID0gcmVxdWlyZSgnYml0ZmllbGQnKVxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2VidG9ycmVudDp3ZWJjb25uJylcbnZhciBnZXQgPSByZXF1aXJlKCdzaW1wbGUtZ2V0JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIFdpcmUgPSByZXF1aXJlKCdiaXR0b3JyZW50LXByb3RvY29sJylcblxuaW5oZXJpdHMoV2ViQ29ubiwgV2lyZSlcblxuLyoqXG4gKiBDb252ZXJ0cyByZXF1ZXN0cyBmb3IgdG9ycmVudCBibG9ja3MgaW50byBodHRwIHJhbmdlIHJlcXVlc3RzLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB3ZWIgc2VlZCB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b3JyZW50XG4gKi9cbmZ1bmN0aW9uIFdlYkNvbm4gKHVybCwgdG9ycmVudCkge1xuICBXaXJlLmNhbGwodGhpcylcblxuICB0aGlzLnVybCA9IHVybFxuICB0aGlzLndlYlBlZXJJZCA9IHNoYTEuc3luYyh1cmwpXG4gIHRoaXMuX3RvcnJlbnQgPSB0b3JyZW50XG5cbiAgdGhpcy5faW5pdCgpXG59XG5cbldlYkNvbm4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5zZXRLZWVwQWxpdmUodHJ1ZSlcblxuICBzZWxmLm9uY2UoJ2hhbmRzaGFrZScsIGZ1bmN0aW9uIChpbmZvSGFzaCwgcGVlcklkKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzZWxmLmhhbmRzaGFrZShpbmZvSGFzaCwgc2VsZi53ZWJQZWVySWQpXG4gICAgdmFyIG51bVBpZWNlcyA9IHNlbGYuX3RvcnJlbnQucGllY2VzLmxlbmd0aFxuICAgIHZhciBiaXRmaWVsZCA9IG5ldyBCaXRGaWVsZChudW1QaWVjZXMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtUGllY2VzOyBpKyspIHtcbiAgICAgIGJpdGZpZWxkLnNldChpLCB0cnVlKVxuICAgIH1cbiAgICBzZWxmLmJpdGZpZWxkKGJpdGZpZWxkKVxuICB9KVxuXG4gIHNlbGYub25jZSgnaW50ZXJlc3RlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1ZygnaW50ZXJlc3RlZCcpXG4gICAgc2VsZi51bmNob2tlKClcbiAgfSlcblxuICBzZWxmLm9uKCd1bmludGVyZXN0ZWQnLCBmdW5jdGlvbiAoKSB7IGRlYnVnKCd1bmludGVyZXN0ZWQnKSB9KVxuICBzZWxmLm9uKCdjaG9rZScsIGZ1bmN0aW9uICgpIHsgZGVidWcoJ2Nob2tlJykgfSlcbiAgc2VsZi5vbigndW5jaG9rZScsIGZ1bmN0aW9uICgpIHsgZGVidWcoJ3VuY2hva2UnKSB9KVxuICBzZWxmLm9uKCdiaXRmaWVsZCcsIGZ1bmN0aW9uICgpIHsgZGVidWcoJ2JpdGZpZWxkJykgfSlcblxuICBzZWxmLm9uKCdyZXF1ZXN0JywgZnVuY3Rpb24gKHBpZWNlSW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKCdyZXF1ZXN0IHBpZWNlSW5kZXg9JWQgb2Zmc2V0PSVkIGxlbmd0aD0lZCcsIHBpZWNlSW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuICAgIHNlbGYuaHR0cFJlcXVlc3QocGllY2VJbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGNhbGxiYWNrKVxuICB9KVxufVxuXG5XZWJDb25uLnByb3RvdHlwZS5odHRwUmVxdWVzdCA9IGZ1bmN0aW9uIChwaWVjZUluZGV4LCBvZmZzZXQsIGxlbmd0aCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwaWVjZU9mZnNldCA9IHBpZWNlSW5kZXggKiBzZWxmLl90b3JyZW50LnBpZWNlTGVuZ3RoXG4gIHZhciByYW5nZVN0YXJ0ID0gcGllY2VPZmZzZXQgKyBvZmZzZXQgLyogb2Zmc2V0IHdpdGhpbiB3aG9sZSB0b3JyZW50ICovXG4gIHZhciByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyBsZW5ndGggLSAxXG5cbiAgLy8gV2ViIHNlZWQgVVJMIGZvcm1hdDpcbiAgLy8gRm9yIHNpbmdsZS1maWxlIHRvcnJlbnRzLCBtYWtlIEhUVFAgcmFuZ2UgcmVxdWVzdHMgZGlyZWN0bHkgdG8gdGhlIHdlYiBzZWVkIFVSTFxuICAvLyBGb3IgbXVsdGktZmlsZSB0b3JyZW50cywgYWRkIHRoZSB0b3JyZW50IGZvbGRlciBhbmQgZmlsZSBuYW1lIHRvIHRoZSBVUkxcbiAgdmFyIGZpbGVzID0gc2VsZi5fdG9ycmVudC5maWxlc1xuICB2YXIgcmVxdWVzdHNcbiAgaWYgKGZpbGVzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmVxdWVzdHMgPSBbe1xuICAgICAgdXJsOiBzZWxmLnVybCxcbiAgICAgIHN0YXJ0OiByYW5nZVN0YXJ0LFxuICAgICAgZW5kOiByYW5nZUVuZFxuICAgIH1dXG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcXVlc3RlZEZpbGVzID0gZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICByZXR1cm4gZmlsZS5vZmZzZXQgPD0gcmFuZ2VFbmQgJiYgKGZpbGUub2Zmc2V0ICsgZmlsZS5sZW5ndGgpID4gcmFuZ2VTdGFydFxuICAgIH0pXG4gICAgaWYgKHJlcXVlc3RlZEZpbGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGZpbGUgY29ycmVzcG9ubmRpbmcgdG8gd2ViIHNlZWQgcmFuZ2UgcmVxdWVzdCcpKVxuICAgIH1cblxuICAgIHJlcXVlc3RzID0gcmVxdWVzdGVkRmlsZXMubWFwKGZ1bmN0aW9uIChyZXF1ZXN0ZWRGaWxlKSB7XG4gICAgICB2YXIgZmlsZUVuZCA9IHJlcXVlc3RlZEZpbGUub2Zmc2V0ICsgcmVxdWVzdGVkRmlsZS5sZW5ndGggLSAxXG4gICAgICB2YXIgdXJsID0gc2VsZi51cmwgK1xuICAgICAgICAoc2VsZi51cmxbc2VsZi51cmwubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcnIDogJy8nKSArXG4gICAgICAgIHJlcXVlc3RlZEZpbGUucGF0aFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGZpbGVPZmZzZXRJblJhbmdlOiBNYXRoLm1heChyZXF1ZXN0ZWRGaWxlLm9mZnNldCAtIHJhbmdlU3RhcnQsIDApLFxuICAgICAgICBzdGFydDogTWF0aC5tYXgocmFuZ2VTdGFydCAtIHJlcXVlc3RlZEZpbGUub2Zmc2V0LCAwKSxcbiAgICAgICAgZW5kOiBNYXRoLm1pbihmaWxlRW5kLCByYW5nZUVuZCAtIHJlcXVlc3RlZEZpbGUub2Zmc2V0KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBOb3cgbWFrZSBhbGwgdGhlIEhUVFAgcmVxdWVzdHMgd2UgbmVlZCBpbiBvcmRlciB0byBsb2FkIHRoaXMgcGllY2VcbiAgLy8gVXN1YWxseSB0aGF0J3Mgb25lIHJlcXVlc3RzLCBidXQgc29tZXRpbWVzIGl0IHdpbGwgYmUgbXVsdGlwbGVcbiAgLy8gU2VuZCByZXF1ZXN0cyBpbiBwYXJhbGxlbCBhbmQgd2FpdCBmb3IgdGhlbSBhbGwgdG8gY29tZSBiYWNrXG4gIHZhciBudW1SZXF1ZXN0c1N1Y2NlZWRlZCA9IDBcbiAgdmFyIGhhc0Vycm9yID0gZmFsc2VcbiAgaWYgKHJlcXVlc3RzLmxlbmd0aCA+IDEpIHZhciByZXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHZhciB1cmwgPSByZXF1ZXN0LnVybFxuICAgIHZhciBzdGFydCA9IHJlcXVlc3Quc3RhcnRcbiAgICB2YXIgZW5kID0gcmVxdWVzdC5lbmRcbiAgICBkZWJ1ZyhcbiAgICAgICdSZXF1ZXN0aW5nIHVybD0lcyBwaWVjZUluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQgc3RhcnQ9JWQgZW5kPSVkJyxcbiAgICAgIHVybCwgcGllY2VJbmRleCwgb2Zmc2V0LCBsZW5ndGgsIHN0YXJ0LCBlbmRcbiAgICApXG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICd1c2VyLWFnZW50JzogJ1dlYlRvcnJlbnQgKGh0dHA6Ly93ZWJ0b3JyZW50LmlvKScsXG4gICAgICAgICdyYW5nZSc6ICdieXRlcz0nICsgc3RhcnQgKyAnLScgKyBlbmRcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0LmNvbmNhdChvcHRzLCBmdW5jdGlvbiAoZXJyLCByZXMsIGRhdGEpIHtcbiAgICAgIGlmIChoYXNFcnJvcikgcmV0dXJuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGhhc0Vycm9yID0gdHJ1ZVxuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlcy5zdGF0dXNDb2RlID49IDMwMCkge1xuICAgICAgICBoYXNFcnJvciA9IHRydWVcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignVW5leHBlY3RlZCBIVFRQIHN0YXR1cyBjb2RlICcgKyByZXMuc3RhdHVzQ29kZSkpXG4gICAgICB9XG4gICAgICBkZWJ1ZygnR290IGRhdGEgb2YgbGVuZ3RoICVkJywgZGF0YS5sZW5ndGgpXG4gICAgICBpZiAocmVxdWVzdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIENvbW1vbiBjYXNlOiBmZXRjaCBwaWVjZSBpbiBhIHNpbmdsZSBIVFRQIHJlcXVlc3QsIHJldHVybiBkaXJlY3RseVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgZGF0YSlcbiAgICAgIH1cbiAgICAgIC8vIFJhcmUgY2FzZTogcmVjb25zdHJ1Y3QgbXVsdGlwbGUgSFRUUCByZXF1ZXN0cyBhY3Jvc3MgMisgZmlsZXMgaW50byBvbmUgcGllY2UgYnVmZmVyXG4gICAgICBkYXRhLmNvcHkocmV0LCByZXF1ZXN0LmZpbGVPZmZzZXRJblJhbmdlKVxuICAgICAgaWYgKCsrbnVtUmVxdWVzdHNTdWNjZWVkZWQgPT09IHJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgICBjYihudWxsLCByZXQpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuV2ViQ29ubi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgV2lyZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpXG4gIHRoaXMuX3RvcnJlbnQgPSBudWxsXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCJ2ZXJzaW9uXCI6XCIwLjkxLjRcIn0iLCIvLyBSZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB3cmFwcGVkIGNhbGxiYWNrXG4vLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhXG4vLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG93biBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCwgc28gdGhhdFxuLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweVxuZnVuY3Rpb24gd3JhcHB5IChmbiwgY2IpIHtcbiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYilcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpXG5cbiAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB3cmFwcGVyW2tdID0gZm5ba11cbiAgfSlcblxuICByZXR1cm4gd3JhcHBlclxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aC0xXVxuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHtcbiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldFtrXSA9IGNiW2tdXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIi8qIGdsb2JhbCBZICovXG4ndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gZXh0ZW5kIChZKSB7XG4gIGNsYXNzIFlBcnJheSB7XG4gICAgY29uc3RydWN0b3IgKG9zLCBfbW9kZWwsIF9jb250ZW50KSB7XG4gICAgICB0aGlzLm9zID0gb3NcbiAgICAgIHRoaXMuX21vZGVsID0gX21vZGVsXG4gICAgICAvLyBBcnJheSBvZiBhbGwgdGhlIG5lY2Nlc3NhcnkgY29udGVudFxuICAgICAgdGhpcy5fY29udGVudCA9IF9jb250ZW50XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlciA9IG5ldyBZLnV0aWxzLkV2ZW50SGFuZGxlcigob3ApID0+IHtcbiAgICAgICAgaWYgKG9wLnN0cnVjdCA9PT0gJ0luc2VydCcpIHtcbiAgICAgICAgICBsZXQgcG9zXG4gICAgICAgICAgLy8gd2UgY2hlY2sgb3AubGVmdCBvbmx5ISxcbiAgICAgICAgICAvLyBiZWNhdXNlIG9wLnJpZ2h0IG1pZ2h0IG5vdCBiZSBkZWZpbmVkIHdoZW4gdGhpcyBpcyBjYWxsZWRcbiAgICAgICAgICBpZiAob3AubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gMFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSAxICsgdGhpcy5fY29udGVudC5maW5kSW5kZXgoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFkudXRpbHMuY29tcGFyZUlkcyhjLmlkLCBvcC5sZWZ0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmIChwb3MgPD0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb3BlcmF0aW9uIScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWx1ZXNcbiAgICAgICAgICB2YXIgbGVuZ3RoXG4gICAgICAgICAgaWYgKG9wLmhhc093blByb3BlcnR5KCdvcENvbnRlbnQnKSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGVudC5zcGxpY2UocG9zLCAwLCB7XG4gICAgICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICAgICAgdHlwZTogb3Aub3BDb250ZW50XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbGV0IG9wQ29udGVudCA9IG9wLm9wQ29udGVudFxuICAgICAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgICAgICAgdmFsdWVzID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB5aWVsZCogdGhpcy5nZXRUeXBlKG9wQ29udGVudClcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoW3R5cGVdKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50cyA9IG9wLmNvbnRlbnQubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IFtvcC5pZFswXSwgb3AuaWRbMV0gKyBpXSxcbiAgICAgICAgICAgICAgICB2YWw6IGNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIGluc2VydCB2YWx1ZSBpbiBfY29udGVudFxuICAgICAgICAgICAgdGhpcy5fY29udGVudC5zcGxpY2UuYXBwbHkodGhpcy5fY29udGVudCwgW3BvcywgMF0uY29uY2F0KGNvbnRlbnRzKSlcbiAgICAgICAgICAgIHZhbHVlcyA9IG9wLmNvbnRlbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IG9wLmNvbnRlbnQubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmNhbGxFdmVudExpc3RlbmVycyh7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0JyxcbiAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgIGluZGV4OiBwb3MsXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgIC8vIHZhbHVlSWQ6IHZhbHVlSWQsIC8vIFRPRE86IGRvZXMgdGhpcyBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkP1xuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKG9wLnN0cnVjdCA9PT0gJ0RlbGV0ZScpIHtcbiAgICAgICAgICB2YXIgaSA9IDAgLy8gY3VycmVudCBwb3NpdGlvbiBpbiBfY29udGVudFxuICAgICAgICAgIGZvciAoOyBpIDwgdGhpcy5fY29udGVudC5sZW5ndGggJiYgb3AubGVuZ3RoID4gMDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2NvbnRlbnRbaV1cbiAgICAgICAgICAgIGlmIChZLnV0aWxzLmluRGVsZXRpb25SYW5nZShvcCwgYy5pZCkpIHtcbiAgICAgICAgICAgICAgLy8gaXMgaW4gZGVsZXRpb24gcmFuZ2UhXG4gICAgICAgICAgICAgIHZhciBkZWxMZW5ndGhcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaG93IG1hbnkgY2hhcmFjdGVyIHRvIGRlbGV0ZSBpbiBvbmUgZmx1c2hcbiAgICAgICAgICAgICAgZm9yIChkZWxMZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBkZWxMZW5ndGggPCBvcC5sZW5ndGggJiYgaSArIGRlbExlbmd0aCA8IHRoaXMuX2NvbnRlbnQubGVuZ3RoICYmIFkudXRpbHMuaW5EZWxldGlvblJhbmdlKG9wLCB0aGlzLl9jb250ZW50W2kgKyBkZWxMZW5ndGhdLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsTGVuZ3RoKyspIHt9XG4gICAgICAgICAgICAgIC8vIGxhc3Qgb3BlcmF0aW9uIHRoYXMgd2lsbCBiZSBkZWxldGVkXG4gICAgICAgICAgICAgIGMgPSB0aGlzLl9jb250ZW50W2kgKyBkZWxMZW5ndGggLSAxXVxuICAgICAgICAgICAgICAvLyB1cGRhdGUgZGVsZXRlIG9wZXJhdGlvblxuICAgICAgICAgICAgICBvcC5sZW5ndGggLT0gYy5pZFsxXSAtIG9wLnRhcmdldFsxXSArIDFcbiAgICAgICAgICAgICAgb3AudGFyZ2V0ID0gW2MuaWRbMF0sIGMuaWRbMV0gKyAxXVxuICAgICAgICAgICAgICAvLyBhcHBseSBkZWxldGlvbiAmIGZpbmQgc2VuZCBldmVudFxuICAgICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuX2NvbnRlbnQuc3BsaWNlKGksIGRlbExlbmd0aClcbiAgICAgICAgICAgICAgLy8gVE9ETzogaG93IGFib3V0IHJldHVybiB0eXBlc1xuICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gY29udGVudC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmFsIH0pXG4gICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmNhbGxFdmVudExpc3RlbmVycyh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgICAgICAgIF9jb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZGVsTGVuZ3RoXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC8vIHdpdGggdGhlIGZyZXNoIGRlbGV0ZSBvcCwgd2UgY2FuIGNvbnRpbnVlXG4gICAgICAgICAgICAgIC8vIG5vdGU6IHdlIGRvbid0IGhhdmUgdG8gaW5jcmVtZW50IGksIGJlY2F1c2UgdGhlIGktdGggY29udGVudCB3YXMgZGVsZXRlZFxuICAgICAgICAgICAgICAvLyBidXQgb24gdGhlIG90aGVyIGhhZCwgdGhlIChpK2RlbExlbmd0aCktdGggd2FzIG5vdCBpbiBkZWxldGlvbiByYW5nZVxuICAgICAgICAgICAgICAvLyBTbyB3ZSBkb24ndCBkbyBpLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHN0cnVjdCEnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBfZGVzdHJveSAoKSB7XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlci5kZXN0cm95KClcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVyID0gbnVsbFxuICAgICAgdGhpcy5fY29udGVudCA9IG51bGxcbiAgICAgIHRoaXMuX21vZGVsID0gbnVsbFxuICAgICAgdGhpcy5vcyA9IG51bGxcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGhcbiAgICB9XG4gICAgZ2V0IChwb3MpIHtcbiAgICAgIGlmIChwb3MgPT0gbnVsbCB8fCB0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvcyBtdXN0IGJlIGEgbnVtYmVyIScpXG4gICAgICB9XG4gICAgICBpZiAocG9zID49IHRoaXMuX2NvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb250ZW50W3Bvc10udHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50W3Bvc10udmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2lkID0gdGhpcy5fY29udGVudFtwb3NdLnR5cGVcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgdGhpcy5vcy5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0geWllbGQqIHRoaXMuZ2V0VHlwZShvaWQpXG4gICAgICAgICAgICByZXNvbHZlKHR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb25seSByZXR1cm5zIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICB0b0FycmF5ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lm1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICByZXR1cm4geC52YWxcbiAgICAgIH0pXG4gICAgfVxuICAgIHB1c2ggKGNvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnQodGhpcy5fY29udGVudC5sZW5ndGgsIGNvbnRlbnRzKVxuICAgIH1cbiAgICBpbnNlcnQgKHBvcywgY29udGVudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvcyBtdXN0IGJlIGEgbnVtYmVyIScpXG4gICAgICB9XG4gICAgICBpZiAoIShjb250ZW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRlbnRzIG11c3QgYmUgYW4gQXJyYXkgb2Ygb2JqZWN0cyEnKVxuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPiB0aGlzLl9jb250ZW50Lmxlbmd0aCB8fCBwb3MgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwb3NpdGlvbiBleGNlZWRzIHRoZSByYW5nZSBvZiB0aGUgYXJyYXkhJylcbiAgICAgIH1cbiAgICAgIHZhciBtb3N0TGVmdCA9IHBvcyA9PT0gMCA/IG51bGwgOiB0aGlzLl9jb250ZW50W3BvcyAtIDFdLmlkXG5cbiAgICAgIHZhciBvcHMgPSBbXVxuICAgICAgdmFyIG5ld1R5cGVzID0gW11cbiAgICAgIHZhciBwcmV2SWQgPSBtb3N0TGVmdFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50cy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBvcCA9IHtcbiAgICAgICAgICBsZWZ0OiBwcmV2SWQsXG4gICAgICAgICAgb3JpZ2luOiBwcmV2SWQsXG4gICAgICAgICAgLy8gcmlnaHQ6IG1vc3RSaWdodCxcbiAgICAgICAgICAvLyBOT1RFOiBJIGludGVudGlvbmFsbHkgZG8gbm90IGRlZmluZSByaWdodCBoZXJlLCBiZWNhdXNlIGl0IGNvdWxkIGJlIGRlbGV0ZWRcbiAgICAgICAgICAvLyBhdCB0aGUgdGltZSBvZiBpbnNlcnRpbmcgdGhpcyBvcGVyYXRpb24gKHdoZW4gd2UgZ2V0IHRoZSB0cmFuc2FjdGlvbiksXG4gICAgICAgICAgLy8gYW5kIHdvdWxkIHRoZXJlZm9yZSBub3QgZGVmaW5lZCBpbiB0aGlzLl9jb250ZW50XG4gICAgICAgICAgcGFyZW50OiB0aGlzLl9tb2RlbCxcbiAgICAgICAgICBzdHJ1Y3Q6ICdJbnNlcnQnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jb250ZW50ID0gW11cbiAgICAgICAgdmFyIHR5cGVEZWZpbml0aW9uXG4gICAgICAgIHdoaWxlIChpIDwgY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGNvbnRlbnRzW2krK11cbiAgICAgICAgICB0eXBlRGVmaW5pdGlvbiA9IFkudXRpbHMuaXNUeXBlRGVmaW5pdGlvbih2YWwpXG4gICAgICAgICAgaWYgKCF0eXBlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgX2NvbnRlbnQucHVzaCh2YWwpXG4gICAgICAgICAgfSBlbHNlIGlmIChfY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpLS0gLy8gY29tZSBiYWNrIGFnYWluIGxhdGVyXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGNvbnRlbnQgaXMgZGVmaW5lZFxuICAgICAgICAgIG9wLmNvbnRlbnQgPSBfY29udGVudFxuICAgICAgICAgIG9wLmlkID0gdGhpcy5vcy5nZXROZXh0T3BJZChfY29udGVudC5sZW5ndGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0cyBhIHR5cGVcbiAgICAgICAgICB2YXIgdHlwZWlkID0gdGhpcy5vcy5nZXROZXh0T3BJZCgxKVxuICAgICAgICAgIG5ld1R5cGVzLnB1c2goW3R5cGVEZWZpbml0aW9uLCB0eXBlaWRdKVxuICAgICAgICAgIG9wLm9wQ29udGVudCA9IHR5cGVpZFxuICAgICAgICAgIG9wLmlkID0gdGhpcy5vcy5nZXROZXh0T3BJZCgxKVxuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKG9wKVxuICAgICAgICBwcmV2SWQgPSBvcC5pZFxuICAgICAgfVxuICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHRoaXMuZXZlbnRIYW5kbGVyXG4gICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkge1xuICAgICAgICAvLyBub3cgd2UgY2FuIHNldCB0aGUgcmlnaHQgcmVmZXJlbmNlLlxuICAgICAgICB2YXIgbW9zdFJpZ2h0XG4gICAgICAgIGlmIChtb3N0TGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG1sID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uQ2xlYW5FbmQobW9zdExlZnQpXG4gICAgICAgICAgbW9zdFJpZ2h0ID0gbWwucmlnaHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3N0UmlnaHQgPSAoeWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKG9wc1swXS5wYXJlbnQpKS5zdGFydFxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB5aWVsZCogdGhpcy5jcmVhdGVUeXBlLmFwcGx5KHRoaXMsIG5ld1R5cGVzW2ldKVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG9wID0gb3BzW2pdXG4gICAgICAgICAgb3AucmlnaHQgPSBtb3N0UmlnaHRcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogZXZlbnRIYW5kbGVyLmF3YWl0T3BzKHRoaXMsIHRoaXMuYXBwbHlDcmVhdGVkT3BlcmF0aW9ucywgW29wc10pXG4gICAgICB9KVxuICAgICAgZXZlbnRIYW5kbGVyLmF3YWl0QW5kUHJlbWF0dXJlbHlDYWxsKG9wcylcbiAgICB9XG4gICAgZGVsZXRlIChwb3MsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7IGxlbmd0aCA9IDEgfVxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIhJylcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvcyBtdXN0IGJlIGEgbnVtYmVyIScpXG4gICAgICB9XG4gICAgICBpZiAocG9zICsgbGVuZ3RoID4gdGhpcy5fY29udGVudC5sZW5ndGggfHwgcG9zIDwgMCB8fCBsZW5ndGggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlbGV0aW9uIHJhbmdlIGV4Y2VlZHMgdGhlIHJhbmdlIG9mIHRoZSBhcnJheSEnKVxuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBldmVudEhhbmRsZXIgPSB0aGlzLmV2ZW50SGFuZGxlclxuICAgICAgdmFyIGRlbHMgPSBbXVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgPSBpICsgZGVsTGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9IHRoaXMuX2NvbnRlbnRbcG9zICsgaV0uaWRcbiAgICAgICAgdmFyIGRlbExlbmd0aFxuICAgICAgICAvLyBob3cgbWFueSBpbnNlcnRpb25zIGNhbiB3ZSBkZWxldGUgaW4gb25lIGRlbGV0aW9uP1xuICAgICAgICBmb3IgKGRlbExlbmd0aCA9IDE7IGkgKyBkZWxMZW5ndGggPCBsZW5ndGg7IGRlbExlbmd0aCsrKSB7XG4gICAgICAgICAgaWYgKCFZLnV0aWxzLmNvbXBhcmVJZHModGhpcy5fY29udGVudFtwb3MgKyBpICsgZGVsTGVuZ3RoXS5pZCwgW3RhcmdldElkWzBdLCB0YXJnZXRJZFsxXSArIGRlbExlbmd0aF0pKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxzLnB1c2goe1xuICAgICAgICAgIHRhcmdldDogdGFyZ2V0SWQsXG4gICAgICAgICAgc3RydWN0OiAnRGVsZXRlJyxcbiAgICAgICAgICBsZW5ndGg6IGRlbExlbmd0aFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZXZlbnRIYW5kbGVyLmF3YWl0QW5kUHJlbWF0dXJlbHlDYWxsKGRlbHMpXG4gICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkge1xuICAgICAgICB5aWVsZCogZXZlbnRIYW5kbGVyLmF3YWl0T3BzKHRoaXMsIHRoaXMuYXBwbHlDcmVhdGVkT3BlcmF0aW9ucywgW2RlbHNdKVxuICAgICAgfSlcbiAgICB9XG4gICAgb2JzZXJ2ZSAoZikge1xuICAgICAgdGhpcy5ldmVudEhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcihmKVxuICAgIH1cbiAgICB1bm9ic2VydmUgKGYpIHtcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZilcbiAgICB9XG4gICAgKiBfY2hhbmdlZCAodHJhbnNhY3Rpb24sIG9wKSB7XG4gICAgICBpZiAoIW9wLmRlbGV0ZWQpIHtcbiAgICAgICAgaWYgKG9wLnN0cnVjdCA9PT0gJ0luc2VydCcpIHtcbiAgICAgICAgICB2YXIgbCA9IG9wLmxlZnRcbiAgICAgICAgICB2YXIgbGVmdFxuICAgICAgICAgIHdoaWxlIChsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxlZnQgPSB5aWVsZCogdHJhbnNhY3Rpb24uZ2V0SW5zZXJ0aW9uKGwpXG4gICAgICAgICAgICBpZiAoIWxlZnQuZGVsZXRlZCkge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbCA9IGxlZnQubGVmdFxuICAgICAgICAgIH1cbiAgICAgICAgICBvcC5sZWZ0ID0gbFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLnJlY2VpdmVkT3Aob3ApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgWS5leHRlbmQoJ0FycmF5JywgbmV3IFkudXRpbHMuQ3VzdG9tVHlwZSh7XG4gICAgbmFtZTogJ0FycmF5JyxcbiAgICBjbGFzczogWUFycmF5LFxuICAgIHN0cnVjdDogJ0xpc3QnLFxuICAgIGluaXRUeXBlOiBmdW5jdGlvbiAqIFlBcnJheUluaXRpYWxpemVyIChvcywgbW9kZWwpIHtcbiAgICAgIHZhciBfY29udGVudCA9IFtdXG4gICAgICB5aWVsZCogWS5TdHJ1Y3QuTGlzdC5tYXAuY2FsbCh0aGlzLCBtb2RlbCwgZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgIGlmIChvcC5oYXNPd25Qcm9wZXJ0eSgnb3BDb250ZW50JykpIHtcbiAgICAgICAgICBfY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICAgIHR5cGU6IG9wLm9wQ29udGVudFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3AuY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICBfY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IFtvcC5pZFswXSwgb3AuaWRbMV0gKyBpXSxcbiAgICAgICAgICAgICAgdmFsOiBvcC5jb250ZW50W2ldXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gbmV3IFlBcnJheShvcywgbW9kZWwuaWQsIF9jb250ZW50KVxuICAgIH1cbiAgfSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5pZiAodHlwZW9mIFkgIT09ICd1bmRlZmluZWQnKSB7XG4gIGV4dGVuZChZKVxufVxuIiwiLyogZ2xvYmFsIFkgKi9cbid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBleHRlbmQgKFkgLyogOmFueSAqLykge1xuICBjbGFzcyBZTWFwIHtcbiAgICAvKiA6OlxuICAgIF9tb2RlbDogSWQ7XG4gICAgb3M6IFkuQWJzdHJhY3REYXRhYmFzZTtcbiAgICBtYXA6IE9iamVjdDtcbiAgICBjb250ZW50czogYW55O1xuICAgIG9wQ29udGVudHM6IE9iamVjdDtcbiAgICBldmVudEhhbmRsZXI6IEZ1bmN0aW9uO1xuICAgICovXG4gICAgY29uc3RydWN0b3IgKG9zLCBtb2RlbCwgY29udGVudHMsIG9wQ29udGVudHMpIHtcbiAgICAgIHRoaXMuX21vZGVsID0gbW9kZWwuaWRcbiAgICAgIHRoaXMub3MgPSBvc1xuICAgICAgdGhpcy5tYXAgPSBZLnV0aWxzLmNvcHlPYmplY3QobW9kZWwubWFwKVxuICAgICAgdGhpcy5jb250ZW50cyA9IGNvbnRlbnRzXG4gICAgICB0aGlzLm9wQ29udGVudHMgPSBvcENvbnRlbnRzXG4gICAgICB0aGlzLmV2ZW50SGFuZGxlciA9IG5ldyBZLnV0aWxzLkV2ZW50SGFuZGxlcihvcCA9PiB7XG4gICAgICAgIHZhciBvbGRWYWx1ZVxuICAgICAgICAvLyBrZXkgaXMgdGhlIG5hbWUgdG8gdXNlIHRvIGFjY2VzcyAob3ApY29udGVudFxuICAgICAgICB2YXIga2V5ID0gb3Auc3RydWN0ID09PSAnRGVsZXRlJyA/IG9wLmtleSA6IG9wLnBhcmVudFN1YlxuXG4gICAgICAgIC8vIGNvbXB1dGUgb2xkVmFsdWVcbiAgICAgICAgaWYgKHRoaXMub3BDb250ZW50c1trZXldICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgcHJldlR5cGUgPSB0aGlzLm9wQ29udGVudHNba2V5XVxuICAgICAgICAgIG9sZFZhbHVlID0gKCkgPT4gey8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkgey8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHlpZWxkKiB0aGlzLmdldFR5cGUocHJldlR5cGUpXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0eXBlKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkVmFsdWUgPSB0aGlzLmNvbnRlbnRzW2tleV1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIG9wIGV2ZW50XG4gICAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdJbnNlcnQnKSB7XG4gICAgICAgICAgaWYgKG9wLmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVxuICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBpZiBvcC5kZWxldGVkPz8/IEkgcGFydGlhbGx5IGhhbmRsZXMgdGhpcyBjYXNlIGhlcmUuLiAobWF5YmUgZnJvbSB0aGUgcHJldmlvdXMgdmVyc2lvbilcbiAgICAgICAgICAgIGlmIChvcC5vcENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9ICgpID0+IHsvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkgey8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB5aWVsZCogdGhpcy5nZXRUeXBlKG9wLm9wQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0eXBlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRlbnRzW2tleV1cbiAgICAgICAgICAgICAgaWYgKG9wLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vcENvbnRlbnRzW2tleV1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wQ29udGVudHNba2V5XSA9IG9wLm9wQ29udGVudFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG9wLmNvbnRlbnRbMF1cbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3BDb250ZW50c1trZXldXG4gICAgICAgICAgICAgIGlmIChvcC5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGVudHNba2V5XVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudHNba2V5XSA9IG9wLmNvbnRlbnRbMF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXBba2V5XSA9IG9wLmlkXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlci5jYWxsRXZlbnRMaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlci5jYWxsRXZlbnRMaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgaWYgKFkudXRpbHMuY29tcGFyZUlkcyh0aGlzLm1hcFtrZXldLCBvcC50YXJnZXQpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcENvbnRlbnRzW2tleV1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRlbnRzW2tleV1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmNhbGxFdmVudExpc3RlbmVycyh7XG4gICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgT3BlcmF0aW9uIScpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF9kZXN0cm95ICgpIHtcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmRlc3Ryb3koKVxuICAgICAgdGhpcy5ldmVudEhhbmRsZXIgPSBudWxsXG4gICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbFxuICAgICAgdGhpcy5vcENvbnRlbnRzID0gbnVsbFxuICAgICAgdGhpcy5fbW9kZWwgPSBudWxsXG4gICAgICB0aGlzLm9zID0gbnVsbFxuICAgICAgdGhpcy5tYXAgPSBudWxsXG4gICAgfVxuICAgIGdldCAoa2V5KSB7XG4gICAgICAvLyByZXR1cm4gcHJvcGVydHkuXG4gICAgICAvLyBpZiBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCwgcmV0dXJuIG51bGxcbiAgICAgIC8vIGlmIHByb3BlcnR5IGlzIGEgdHlwZSwgcmV0dXJuIGEgcHJvbWlzZVxuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGtleSAoYXMgc3RyaW5nKSEnKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3BDb250ZW50c1trZXldID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHNba2V5XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgdmFyIG9pZCA9IHRoaXMub3BDb250ZW50c1trZXldXG4gICAgICAgICAgdGhpcy5vcy5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0geWllbGQqIHRoaXMuZ2V0VHlwZShvaWQpXG4gICAgICAgICAgICByZXNvbHZlKHR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAga2V5cyAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb250ZW50cykuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMub3BDb250ZW50cykpXG4gICAgfVxuICAgIGtleXNQcmltaXRpdmVzICgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbnRlbnRzKVxuICAgIH1cbiAgICBrZXlzVHlwZXMgKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMub3BDb250ZW50cylcbiAgICB9XG4gICAgLypcbiAgICAgIElmIHRoZXJlIGlzIGEgcHJpbWl0aXZlIChub3QgYSBjdXN0b20gdHlwZSksIHRoZW4gcmV0dXJuIGl0LlxuICAgICAgUmV0dXJucyBhbGwgcHJpbWl0aXZlIHZhbHVlcywgaWYgcHJvcGVydHlOYW1lIGlzIHNwZWNpZmllZCFcbiAgICAgIE5vdGU6IG1vZGlmeWluZyB0aGUgcmV0dXJuIHZhbHVlIGNvdWxkIHJlc3VsdCBpbiBpbmNvbnNpc3RlbmNpZXMhXG4gICAgICAgIC0tIHNvIG1ha2Ugc3VyZSB0byBjb3B5IGl0IGZpcnN0IVxuICAgICovXG4gICAgZ2V0UHJpbWl0aXZlIChrZXkpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gWS51dGlscy5jb3B5T2JqZWN0KHRoaXMuY29udGVudHMpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5IGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RyaW5nIScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50c1trZXldXG4gICAgICB9XG4gICAgfVxuICAgIGdldFR5cGUgKGtleSkge1xuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGtleSAoYXMgc3RyaW5nKSEnKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wQ29udGVudHNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHZhciBvaWQgPSB0aGlzLm9wQ29udGVudHNba2V5XVxuICAgICAgICAgIHRoaXMub3MucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICooKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHlpZWxkKiB0aGlzLmdldFR5cGUob2lkKVxuICAgICAgICAgICAgcmVzb2x2ZSh0eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vIHByb3BlcnR5IHNwZWNpZmllZCBmb3IgdGhpcyBrZXkhJylcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIChrZXkpIHtcbiAgICAgIHZhciByaWdodCA9IHRoaXMubWFwW2tleV1cbiAgICAgIGlmIChyaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkZWwgPSB7XG4gICAgICAgICAgdGFyZ2V0OiByaWdodCxcbiAgICAgICAgICBzdHJ1Y3Q6ICdEZWxldGUnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHRoaXMuZXZlbnRIYW5kbGVyXG4gICAgICAgIHZhciBtb2REZWwgPSBZLnV0aWxzLmNvcHlPYmplY3QoZGVsKVxuICAgICAgICBtb2REZWwua2V5ID0ga2V5XG4gICAgICAgIHRoaXMub3MucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICooKSB7XG4gICAgICAgICAgeWllbGQqIGV2ZW50SGFuZGxlci5hd2FpdE9wcyh0aGlzLCB0aGlzLmFwcGx5Q3JlYXRlZE9wZXJhdGlvbnMsIFtbZGVsXV0pXG4gICAgICAgIH0pXG4gICAgICAgIC8vIGFsd2F5cyByZW1lbWJlciB0byBkbyB0aGF0IGFmdGVyIHRoaXMub3MucmVxdWVzdFRyYW5zYWN0aW9uXG4gICAgICAgIC8vIChvdGhlcndpc2UgdmFsdWVzIG1pZ2h0IGNvbnRhaW4gYSB1bmRlZmluZWQgcmVmZXJlbmNlIHRvIHR5cGUpXG4gICAgICAgIGV2ZW50SGFuZGxlci5hd2FpdEFuZFByZW1hdHVyZWx5Q2FsbChbbW9kRGVsXSlcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgICAvLyBzZXQgcHJvcGVydHkuXG4gICAgICAvLyBpZiBwcm9wZXJ0eSBpcyBhIHR5cGUsIHJldHVybiBhIHByb21pc2VcbiAgICAgIC8vIGlmIG5vdCwgYXBwbHkgaW1tZWRpYXRlbHkgb24gdGhpcyB0eXBlIGFuIGNhbGwgZXZlbnRcblxuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5tYXBba2V5XSB8fCBudWxsXG4gICAgICB2YXIgaW5zZXJ0IC8qIDphbnkgKi8gPSB7XG4gICAgICAgIGlkOiB0aGlzLm9zLmdldE5leHRPcElkKDEpLFxuICAgICAgICBsZWZ0OiBudWxsLFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIG9yaWdpbjogbnVsbCxcbiAgICAgICAgcGFyZW50OiB0aGlzLl9tb2RlbCxcbiAgICAgICAgcGFyZW50U3ViOiBrZXksXG4gICAgICAgIHN0cnVjdDogJ0luc2VydCdcbiAgICAgIH1cbiAgICAgIHZhciBldmVudEhhbmRsZXIgPSB0aGlzLmV2ZW50SGFuZGxlclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHZhciB0eXBlRGVmaW5pdGlvbiA9IFkudXRpbHMuaXNUeXBlRGVmaW5pdGlvbih2YWx1ZSlcbiAgICAgICAgaWYgKHR5cGVEZWZpbml0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZhciB0eXBlaWQgPSB0aGlzLm9zLmdldE5leHRPcElkKDEpXG4gICAgICAgICAgaW5zZXJ0Lm9wQ29udGVudCA9IHR5cGVpZFxuICAgICAgICAgIC8vIGNvbnN0cnVjdCBhIG5ldyB0eXBlXG4gICAgICAgICAgdGhpcy5vcy5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0geWllbGQqIHRoaXMuY3JlYXRlVHlwZSh0eXBlRGVmaW5pdGlvbiwgdHlwZWlkKVxuICAgICAgICAgICAgeWllbGQqIGV2ZW50SGFuZGxlci5hd2FpdE9wcyh0aGlzLCB0aGlzLmFwcGx5Q3JlYXRlZE9wZXJhdGlvbnMsIFtbaW5zZXJ0XV0pXG4gICAgICAgICAgICByZXNvbHZlKHR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyBhbHdheXMgcmVtZW1iZXIgdG8gZG8gdGhhdCBhZnRlciB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvblxuICAgICAgICAgIC8vIChvdGhlcndpc2UgdmFsdWVzIG1pZ2h0IGNvbnRhaW4gYSB1bmRlZmluZWQgcmVmZXJlbmNlIHRvIHR5cGUpXG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmF3YWl0QW5kUHJlbWF0dXJlbHlDYWxsKFtpbnNlcnRdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydC5jb250ZW50ID0gW3ZhbHVlXVxuICAgICAgICAgIHRoaXMub3MucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICogKCkge1xuICAgICAgICAgICAgeWllbGQqIGV2ZW50SGFuZGxlci5hd2FpdE9wcyh0aGlzLCB0aGlzLmFwcGx5Q3JlYXRlZE9wZXJhdGlvbnMsIFtbaW5zZXJ0XV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyBhbHdheXMgcmVtZW1iZXIgdG8gZG8gdGhhdCBhZnRlciB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvblxuICAgICAgICAgIC8vIChvdGhlcndpc2UgdmFsdWVzIG1pZ2h0IGNvbnRhaW4gYSB1bmRlZmluZWQgcmVmZXJlbmNlIHRvIHR5cGUpXG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmF3YWl0QW5kUHJlbWF0dXJlbHlDYWxsKFtpbnNlcnRdKVxuICAgICAgICAgIHJlc29sdmUodmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIG9ic2VydmUgKGYpIHtcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoZilcbiAgICB9XG4gICAgdW5vYnNlcnZlIChmKSB7XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlci5yZW1vdmVFdmVudExpc3RlbmVyKGYpXG4gICAgfVxuICAgIC8qXG4gICAgICBPYnNlcnZlIGEgcGF0aC5cblxuICAgICAgRS5nLlxuICAgICAgYGBgXG4gICAgICBvLnNldCgndGV4dGFyZWEnLCBZLlRleHRCaW5kKVxuICAgICAgby5vYnNlcnZlUGF0aChbJ3RleHRhcmVhJ10sIGZ1bmN0aW9uKHQpe1xuICAgICAgICAvLyBpcyBjYWxsZWQgd2hlbmV2ZXIgdGV4dGFyZWEgaXMgcmVwbGFjZWRcbiAgICAgICAgdC5iaW5kKHRleHRhcmVhKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJucyBhIFByb21pc2UgdGhhdCBjb250YWlucyBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgb2JzZXJ2ZXIgZnJvbSB0aGUgcGF0aC5cbiAgICAqL1xuICAgIG9ic2VydmVQYXRoIChwYXRoLCBmKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIGZ1bmN0aW9uIG9ic2VydmVQcm9wZXJ0eSAoZXZlbnQpIHtcbiAgICAgICAgLy8gY2FsbCBmIHdoZW5ldmVyIHBhdGggY2hhbmdlc1xuICAgICAgICBpZiAoZXZlbnQubmFtZSA9PT0gcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgLy8gY2FsbCB0aGlzIGFsc28gZm9yIGRlbGV0ZSBldmVudHMhXG4gICAgICAgICAgdmFyIHByb3BlcnR5ID0gc2VsZi5nZXQocHJvcGVydHlOYW1lKVxuICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHByb3BlcnR5LnRoZW4oZilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZihwcm9wZXJ0eSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMSkge1xuICAgICAgICBmKHRoaXMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZnVuY3Rpb24gKCkge30pXG4gICAgICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwYXRoWzBdXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHNlbGYuZ2V0KHByb3BlcnR5TmFtZSlcbiAgICAgICAgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHByb3BlcnR5LnRoZW4oZilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmKHByb3BlcnR5KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZShvYnNlcnZlUHJvcGVydHkpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYudW5vYnNlcnZlKGYpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVsZXRlQ2hpbGRPYnNlcnZlcnNcbiAgICAgICAgdmFyIHJlc2V0T2JzZXJ2ZXJQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5nZXQocGF0aFswXSlcbiAgICAgICAgICBpZiAoIXByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBpdHMgZWl0aGVyIG5vdCBkZWZpbmVkIG9yIGEgcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgICAgICBwcm9taXNlID0gc2VsZi5zZXQocGF0aFswXSwgWS5NYXApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcC5vYnNlcnZlUGF0aChwYXRoLnNsaWNlKDEpLCBmKVxuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9kZWxldGVDaGlsZE9ic2VydmVycykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGRlbGV0ZUNoaWxkT2JzZXJ2ZXJzXG4gICAgICAgICAgICBkZWxldGVDaGlsZE9ic2VydmVycyA9IF9kZWxldGVDaGlsZE9ic2VydmVyc1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpIC8vIFByb21pc2UgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQubmFtZSA9PT0gcGF0aFswXSkge1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUNoaWxkT2JzZXJ2ZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZGVsZXRlQ2hpbGRPYnNlcnZlcnMoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdhZGQnIHx8IGV2ZW50LnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICAgIHJlc2V0T2JzZXJ2ZXJQYXRoKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgdGhlIGRlbGV0ZSBldmVudHM/XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYub2JzZXJ2ZShvYnNlcnZlcilcbiAgICAgICAgcmV0dXJuIHJlc2V0T2JzZXJ2ZXJQYXRoKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gdGhpcyBwcm9taXNlIGNvbnRhaW5zIGEgZnVuY3Rpb24gdGhhdCBkZWxldGVzIGFsbCB0aGUgY2hpbGQgb2JzZXJ2ZXJzXG4gICAgICAgICAgLy8gYW5kIGhvdyB0byB1bm9ic2VydmUgdGhlIG9ic2VydmUgZnJvbSB0aGlzIG9iamVjdFxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICBpZiAoZGVsZXRlQ2hpbGRPYnNlcnZlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWxldGVDaGlsZE9ic2VydmVycygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnVub2JzZXJ2ZShvYnNlcnZlcilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICAqIF9jaGFuZ2VkICh0cmFuc2FjdGlvbiwgb3ApIHtcbiAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB5aWVsZCogdHJhbnNhY3Rpb24uZ2V0T3BlcmF0aW9uKG9wLnRhcmdldClcbiAgICAgICAgb3Aua2V5ID0gdGFyZ2V0LnBhcmVudFN1YlxuICAgICAgfVxuICAgICAgdGhpcy5ldmVudEhhbmRsZXIucmVjZWl2ZWRPcChvcClcbiAgICB9XG4gIH1cbiAgWS5leHRlbmQoJ01hcCcsIG5ldyBZLnV0aWxzLkN1c3RvbVR5cGUoe1xuICAgIG5hbWU6ICdNYXAnLFxuICAgIGNsYXNzOiBZTWFwLFxuICAgIHN0cnVjdDogJ01hcCcsXG4gICAgaW5pdFR5cGU6IGZ1bmN0aW9uICogWU1hcEluaXRpYWxpemVyIChvcywgbW9kZWwpIHtcbiAgICAgIHZhciBjb250ZW50cyA9IHt9XG4gICAgICB2YXIgb3BDb250ZW50cyA9IHt9XG4gICAgICB2YXIgbWFwID0gbW9kZWwubWFwXG4gICAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICB2YXIgb3AgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24obWFwW25hbWVdKVxuICAgICAgICBpZiAob3Aub3BDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBvcENvbnRlbnRzW25hbWVdID0gb3Aub3BDb250ZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudHNbbmFtZV0gPSBvcC5jb250ZW50WzBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgWU1hcChvcywgbW9kZWwsIGNvbnRlbnRzLCBvcENvbnRlbnRzKVxuICAgIH1cbiAgfSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5pZiAodHlwZW9mIFkgIT09ICd1bmRlZmluZWQnKSB7XG4gIGV4dGVuZChZKVxufVxuIiwiLyogZ2xvYmFsIFkgKi9cclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5mdW5jdGlvbiBleHRlbmQgKFkpIHtcclxuICByZXF1aXJlKCcuL1JlZEJsYWNrVHJlZS5qcycpKFkpXHJcbiAgY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBZLlRyYW5zYWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yIChzdG9yZSkge1xyXG4gICAgICBzdXBlcihzdG9yZSlcclxuICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlXHJcbiAgICAgIHRoaXMuc3MgPSBzdG9yZS5zc1xyXG4gICAgICB0aGlzLm9zID0gc3RvcmUub3NcclxuICAgICAgdGhpcy5kcyA9IHN0b3JlLmRzXHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBTdG9yZSA9IFkudXRpbHMuUkJUcmVlXHJcbiAgdmFyIEJ1ZmZlcmVkU3RvcmUgPSBZLnV0aWxzLmNyZWF0ZVNtYWxsTG9va3VwQnVmZmVyKFN0b3JlKVxyXG5cclxuICBjbGFzcyBEYXRhYmFzZSBleHRlbmRzIFkuQWJzdHJhY3REYXRhYmFzZSB7XHJcbiAgICBjb25zdHJ1Y3RvciAoeSwgb3B0cykge1xyXG4gICAgICBzdXBlcih5LCBvcHRzKVxyXG4gICAgICB0aGlzLm9zID0gbmV3IEJ1ZmZlcmVkU3RvcmUoKVxyXG4gICAgICB0aGlzLmRzID0gbmV3IFN0b3JlKClcclxuICAgICAgdGhpcy5zcyA9IG5ldyBCdWZmZXJlZFN0b3JlKClcclxuICAgIH1cclxuICAgIGxvZ1RhYmxlICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgIHNlbGYucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICogKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2VyOiAnLCB0aGlzLnN0b3JlLnkuY29ubmVjdG9yLnVzZXJJZCwgXCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIikgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3RhdGUgU2V0IChTUyk6XCIsIHlpZWxkKiB0aGlzLmdldFN0YXRlU2V0KCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk9wZXJhdGlvbiBTdG9yZSAoT1MpOlwiKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgeWllbGQqIHRoaXMub3MubG9nVGFibGUoKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJEZWxldGlvbiBTdG9yZSAoRFMpOlwiKSAvL2VzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICB5aWVsZCogdGhpcy5kcy5sb2dUYWJsZSgpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICBpZiAodGhpcy5zdG9yZS5nYzEubGVuZ3RoID4gMCB8fCB0aGlzLnN0b3JlLmdjMi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0dDMXwyIG5vdCBlbXB0eSEnLCB0aGlzLnN0b3JlLmdjMSwgdGhpcy5zdG9yZS5nYzIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnN0b3JlLmxpc3RlbmVyc0J5SWQpICE9PSAne30nKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2xpc3RlbmVyc0J5SWQgbm90IGVtcHR5IScpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnN0b3JlLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93KSAhPT0gJ1tdJykge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdsaXN0ZW5lcnNCeUlkRXhlY3V0ZU5vdyBub3QgZW1wdHkhJylcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RvcmUudHJhbnNhY3Rpb25JblByb2dyZXNzKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIHN0aWxsIGluIHByb2dyZXNzIScpXHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0cnVlKVxyXG4gICAgfVxyXG4gICAgdHJhbnNhY3QgKG1ha2VHZW4pIHtcclxuICAgICAgdmFyIHQgPSBuZXcgVHJhbnNhY3Rpb24odGhpcylcclxuICAgICAgd2hpbGUgKG1ha2VHZW4gIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgZ2VuID0gbWFrZUdlbi5jYWxsKHQpXHJcbiAgICAgICAgdmFyIHJlcyA9IGdlbi5uZXh0KClcclxuICAgICAgICB3aGlsZSAoIXJlcy5kb25lKSB7XHJcbiAgICAgICAgICByZXMgPSBnZW4ubmV4dChyZXMudmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1ha2VHZW4gPSB0aGlzLmdldE5leHRSZXF1ZXN0KClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKiBkZXN0cm95ICgpIHtcclxuICAgICAgeWllbGQqIHN1cGVyLmRlc3Ryb3koKVxyXG4gICAgICBkZWxldGUgdGhpcy5vc1xyXG4gICAgICBkZWxldGUgdGhpcy5zc1xyXG4gICAgICBkZWxldGUgdGhpcy5kc1xyXG4gICAgfVxyXG4gIH1cclxuICBZLmV4dGVuZCgnbWVtb3J5JywgRGF0YWJhc2UpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXHJcbmlmICh0eXBlb2YgWSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBleHRlbmQoWSlcclxufVxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbi8qXHJcbiAgVGhpcyBmaWxlIGNvbnRhaW5zIGEgbm90IHNvIGZhbmN5IGltcGxlbWFudGlvbiBvZiBhIFJlZCBCbGFjayBUcmVlLlxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZKSB7XHJcbiAgY2xhc3MgTiB7XHJcbiAgICAvLyBBIGNyZWF0ZWQgbm9kZSBpcyBhbHdheXMgcmVkIVxyXG4gICAgY29uc3RydWN0b3IgKHZhbCkge1xyXG4gICAgICB0aGlzLnZhbCA9IHZhbFxyXG4gICAgICB0aGlzLmNvbG9yID0gdHJ1ZVxyXG4gICAgICB0aGlzLl9sZWZ0ID0gbnVsbFxyXG4gICAgICB0aGlzLl9yaWdodCA9IG51bGxcclxuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbFxyXG4gICAgICBpZiAodmFsLmlkID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgaWQhJylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNSZWQgKCkgeyByZXR1cm4gdGhpcy5jb2xvciB9XHJcbiAgICBpc0JsYWNrICgpIHsgcmV0dXJuICF0aGlzLmNvbG9yIH1cclxuICAgIHJlZGRlbiAoKSB7IHRoaXMuY29sb3IgPSB0cnVlOyByZXR1cm4gdGhpcyB9XHJcbiAgICBibGFja2VuICgpIHsgdGhpcy5jb2xvciA9IGZhbHNlOyByZXR1cm4gdGhpcyB9XHJcbiAgICBnZXQgZ3JhbmRwYXJlbnQgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQucGFyZW50XHJcbiAgICB9XHJcbiAgICBnZXQgcGFyZW50ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFxyXG4gICAgfVxyXG4gICAgZ2V0IHNpYmxpbmcgKCkge1xyXG4gICAgICByZXR1cm4gKHRoaXMgPT09IHRoaXMucGFyZW50LmxlZnQpXHJcbiAgICAgICAgPyB0aGlzLnBhcmVudC5yaWdodCA6IHRoaXMucGFyZW50LmxlZnRcclxuICAgIH1cclxuICAgIGdldCBsZWZ0ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2xlZnRcclxuICAgIH1cclxuICAgIGdldCByaWdodCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yaWdodFxyXG4gICAgfVxyXG4gICAgc2V0IGxlZnQgKG4pIHtcclxuICAgICAgaWYgKG4gIT09IG51bGwpIHtcclxuICAgICAgICBuLl9wYXJlbnQgPSB0aGlzXHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fbGVmdCA9IG5cclxuICAgIH1cclxuICAgIHNldCByaWdodCAobikge1xyXG4gICAgICBpZiAobiAhPT0gbnVsbCkge1xyXG4gICAgICAgIG4uX3BhcmVudCA9IHRoaXNcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9yaWdodCA9IG5cclxuICAgIH1cclxuICAgIHJvdGF0ZUxlZnQgKHRyZWUpIHtcclxuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50XHJcbiAgICAgIHZhciBuZXdQYXJlbnQgPSB0aGlzLnJpZ2h0XHJcbiAgICAgIHZhciBuZXdSaWdodCA9IHRoaXMucmlnaHQubGVmdFxyXG4gICAgICBuZXdQYXJlbnQubGVmdCA9IHRoaXNcclxuICAgICAgdGhpcy5yaWdodCA9IG5ld1JpZ2h0XHJcbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICB0cmVlLnJvb3QgPSBuZXdQYXJlbnRcclxuICAgICAgICBuZXdQYXJlbnQuX3BhcmVudCA9IG51bGxcclxuICAgICAgfSBlbHNlIGlmIChwYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgIHBhcmVudC5sZWZ0ID0gbmV3UGFyZW50XHJcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgcGFyZW50LnJpZ2h0ID0gbmV3UGFyZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWxlbWVudHMgYXJlIHdyb25nbHkgY29ubmVjdGVkIScpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG5leHQgKCkge1xyXG4gICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHNlYXJjaCB0aGUgbW9zdCBsZWZ0IG5vZGUgaW4gdGhlIHJpZ2h0IHRyZWVcclxuICAgICAgICB2YXIgbyA9IHRoaXMucmlnaHRcclxuICAgICAgICB3aGlsZSAoby5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBvID0gby5sZWZ0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHAgPSB0aGlzXHJcbiAgICAgICAgd2hpbGUgKHAucGFyZW50ICE9PSBudWxsICYmIHAgIT09IHAucGFyZW50LmxlZnQpIHtcclxuICAgICAgICAgIHAgPSBwLnBhcmVudFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcC5wYXJlbnRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJldiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBzZWFyY2ggdGhlIG1vc3QgcmlnaHQgbm9kZSBpbiB0aGUgbGVmdCB0cmVlXHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLmxlZnRcclxuICAgICAgICB3aGlsZSAoby5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgbyA9IG8ucmlnaHRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgcCA9IHRoaXNcclxuICAgICAgICB3aGlsZSAocC5wYXJlbnQgIT09IG51bGwgJiYgcCAhPT0gcC5wYXJlbnQucmlnaHQpIHtcclxuICAgICAgICAgIHAgPSBwLnBhcmVudFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcC5wYXJlbnRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcm90YXRlUmlnaHQgKHRyZWUpIHtcclxuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50XHJcbiAgICAgIHZhciBuZXdQYXJlbnQgPSB0aGlzLmxlZnRcclxuICAgICAgdmFyIG5ld0xlZnQgPSB0aGlzLmxlZnQucmlnaHRcclxuICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gdGhpc1xyXG4gICAgICB0aGlzLmxlZnQgPSBuZXdMZWZ0XHJcbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICB0cmVlLnJvb3QgPSBuZXdQYXJlbnRcclxuICAgICAgICBuZXdQYXJlbnQuX3BhcmVudCA9IG51bGxcclxuICAgICAgfSBlbHNlIGlmIChwYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgIHBhcmVudC5sZWZ0ID0gbmV3UGFyZW50XHJcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgcGFyZW50LnJpZ2h0ID0gbmV3UGFyZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWxlbWVudHMgYXJlIHdyb25nbHkgY29ubmVjdGVkIScpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFVuY2xlICgpIHtcclxuICAgICAgLy8gd2UgY2FuIGFzc3VtZSB0aGF0IGdyYW5kcGFyZW50IGV4aXN0cyB3aGVuIHRoaXMgaXMgY2FsbGVkIVxyXG4gICAgICBpZiAodGhpcy5wYXJlbnQgPT09IHRoaXMucGFyZW50LnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnBhcmVudC5yaWdodFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wYXJlbnQubGVmdFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGFzcyBSQlRyZWUge1xyXG4gICAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgICB0aGlzLnJvb3QgPSBudWxsXHJcbiAgICAgIHRoaXMubGVuZ3RoID0gMFxyXG4gICAgfVxyXG4gICAgKiBmaW5kTmV4dCAoaWQpIHtcclxuICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmZpbmRXaXRoTG93ZXJCb3VuZChbaWRbMF0sIGlkWzFdICsgMV0pXHJcbiAgICB9XHJcbiAgICAqIGZpbmRQcmV2IChpZCkge1xyXG4gICAgICByZXR1cm4geWllbGQqIHRoaXMuZmluZFdpdGhVcHBlckJvdW5kKFtpZFswXSwgaWRbMV0gLSAxXSlcclxuICAgIH1cclxuICAgIGZpbmROb2RlV2l0aExvd2VyQm91bmQgKGZyb20pIHtcclxuICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgZGVmaW5lIGZyb20hJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgbyA9IHRoaXMucm9vdFxyXG4gICAgICBpZiAobyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgIGlmICgoZnJvbSA9PT0gbnVsbCB8fCBZLnV0aWxzLnNtYWxsZXIoZnJvbSwgby52YWwuaWQpKSAmJiBvLmxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gbyBpcyBpbmNsdWRlZCBpbiB0aGUgYm91bmRcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCB0aGF0IGlzIGNsb3NlciB0byB0aGUgYm91bmRcclxuICAgICAgICAgICAgbyA9IG8ubGVmdFxyXG4gICAgICAgICAgfSBlbHNlIGlmIChmcm9tICE9PSBudWxsICYmIFkudXRpbHMuc21hbGxlcihvLnZhbC5pZCwgZnJvbSkpIHtcclxuICAgICAgICAgICAgLy8gbyBpcyBub3Qgd2l0aGluIHRoZSBib3VuZCwgbWF5YmUgb25lIG9mIHRoZSByaWdodCBlbGVtZW50cyBpcy4uXHJcbiAgICAgICAgICAgIGlmIChvLnJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgbyA9IG8ucmlnaHRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyByaWdodCBlbGVtZW50LiBTZWFyY2ggZm9yIHRoZSBuZXh0IGJpZ2dlciBlbGVtZW50LFxyXG4gICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgICAgICAgcmV0dXJuIG8ubmV4dCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5kTm9kZVdpdGhVcHBlckJvdW5kICh0bykge1xyXG4gICAgICBpZiAodG8gPT09IHZvaWQgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgZGVmaW5lIGZyb20hJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgbyA9IHRoaXMucm9vdFxyXG4gICAgICBpZiAobyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgIGlmICgodG8gPT09IG51bGwgfHwgWS51dGlscy5zbWFsbGVyKG8udmFsLmlkLCB0bykpICYmIG8ucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gbyBpcyBpbmNsdWRlZCBpbiB0aGUgYm91bmRcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCB0aGF0IGlzIGNsb3NlciB0byB0aGUgYm91bmRcclxuICAgICAgICAgICAgbyA9IG8ucmlnaHRcclxuICAgICAgICAgIH0gZWxzZSBpZiAodG8gIT09IG51bGwgJiYgWS51dGlscy5zbWFsbGVyKHRvLCBvLnZhbC5pZCkpIHtcclxuICAgICAgICAgICAgLy8gbyBpcyBub3Qgd2l0aGluIHRoZSBib3VuZCwgbWF5YmUgb25lIG9mIHRoZSBsZWZ0IGVsZW1lbnRzIGlzLi5cclxuICAgICAgICAgICAgaWYgKG8ubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIG8gPSBvLmxlZnRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBsZWZ0IGVsZW1lbnQuIFNlYXJjaCBmb3IgdGhlIHByZXYgc21hbGxlciBlbGVtZW50LFxyXG4gICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgICAgICAgcmV0dXJuIG8ucHJldigpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5kU21hbGxlc3ROb2RlICgpIHtcclxuICAgICAgdmFyIG8gPSB0aGlzLnJvb3RcclxuICAgICAgd2hpbGUgKG8gIT0gbnVsbCAmJiBvLmxlZnQgIT0gbnVsbCkge1xyXG4gICAgICAgIG8gPSBvLmxlZnRcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb1xyXG4gICAgfVxyXG4gICAgKiBmaW5kV2l0aExvd2VyQm91bmQgKGZyb20pIHtcclxuICAgICAgdmFyIG4gPSB0aGlzLmZpbmROb2RlV2l0aExvd2VyQm91bmQoZnJvbSlcclxuICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IG51bGwgOiBuLnZhbFxyXG4gICAgfVxyXG4gICAgKiBmaW5kV2l0aFVwcGVyQm91bmQgKHRvKSB7XHJcbiAgICAgIHZhciBuID0gdGhpcy5maW5kTm9kZVdpdGhVcHBlckJvdW5kKHRvKVxyXG4gICAgICByZXR1cm4gbiA9PSBudWxsID8gbnVsbCA6IG4udmFsXHJcbiAgICB9XHJcbiAgICAqIGl0ZXJhdGUgKHQsIGZyb20sIHRvLCBmKSB7XHJcbiAgICAgIHZhciBvXHJcbiAgICAgIGlmIChmcm9tID09PSBudWxsKSB7XHJcbiAgICAgICAgbyA9IHRoaXMuZmluZFNtYWxsZXN0Tm9kZSgpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbyA9IHRoaXMuZmluZE5vZGVXaXRoTG93ZXJCb3VuZChmcm9tKVxyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChvICE9PSBudWxsICYmICh0byA9PT0gbnVsbCB8fCBZLnV0aWxzLnNtYWxsZXIoby52YWwuaWQsIHRvKSB8fCBZLnV0aWxzLmNvbXBhcmVJZHMoby52YWwuaWQsIHRvKSkpIHtcclxuICAgICAgICB5aWVsZCogZi5jYWxsKHQsIG8udmFsKVxyXG4gICAgICAgIG8gPSBvLm5leHQoKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICAqIGxvZ1RhYmxlIChmcm9tLCB0bywgZmlsdGVyKSB7XHJcbiAgICAgIGlmIChmaWx0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChmcm9tID09IG51bGwpIHsgZnJvbSA9IG51bGwgfVxyXG4gICAgICBpZiAodG8gPT0gbnVsbCkgeyB0byA9IG51bGwgfVxyXG4gICAgICB2YXIgb3MgPSBbXVxyXG4gICAgICB5aWVsZCogdGhpcy5pdGVyYXRlKHRoaXMsIGZyb20sIHRvLCBmdW5jdGlvbiAqIChvKSB7XHJcbiAgICAgICAgaWYgKGZpbHRlcihvKSkge1xyXG4gICAgICAgICAgdmFyIG9fID0ge31cclxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb1trZXldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgIG9fW2tleV0gPSBKU09OLnN0cmluZ2lmeShvW2tleV0pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgb19ba2V5XSA9IG9ba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvcy5wdXNoKG9fKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgaWYgKGNvbnNvbGUudGFibGUgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnNvbGUudGFibGUob3MpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgICogZmluZCAoaWQpIHtcclxuICAgICAgdmFyIG5cclxuICAgICAgcmV0dXJuIChuID0gdGhpcy5maW5kTm9kZShpZCkpID8gbi52YWwgOiBudWxsXHJcbiAgICB9XHJcbiAgICBmaW5kTm9kZSAoaWQpIHtcclxuICAgICAgaWYgKGlkID09IG51bGwgfHwgaWQuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgaWQgdG8gYmUgYW4gYXJyYXkhJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgbyA9IHRoaXMucm9vdFxyXG4gICAgICBpZiAobyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBpZiAobyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChZLnV0aWxzLnNtYWxsZXIoaWQsIG8udmFsLmlkKSkge1xyXG4gICAgICAgICAgICBvID0gby5sZWZ0XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFkudXRpbHMuc21hbGxlcihvLnZhbC5pZCwgaWQpKSB7XHJcbiAgICAgICAgICAgIG8gPSBvLnJpZ2h0XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKiBkZWxldGUgKGlkKSB7XHJcbiAgICAgIGlmIChpZCA9PSBudWxsIHx8IGlkLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gQXJyYXkhJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgZCA9IHRoaXMuZmluZE5vZGUoaWQpXHJcbiAgICAgIGlmIChkID09IG51bGwpIHtcclxuICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgZG9lcyBub3QgZXhpc3QhJylcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxlbmd0aC0tXHJcbiAgICAgIGlmIChkLmxlZnQgIT09IG51bGwgJiYgZC5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHN3aXRjaCBkIHdpdGggdGhlIGdyZWF0ZXMgZWxlbWVudCBpbiB0aGUgbGVmdCBzdWJ0cmVlLlxyXG4gICAgICAgIC8vIG8gc2hvdWxkIGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXHJcbiAgICAgICAgdmFyIG8gPSBkLmxlZnRcclxuICAgICAgICAvLyBmaW5kXHJcbiAgICAgICAgd2hpbGUgKG8ucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgIG8gPSBvLnJpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN3aXRjaFxyXG4gICAgICAgIGQudmFsID0gby52YWxcclxuICAgICAgICBkID0gb1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGQgaGFzIGF0IG1vc3Qgb25lIGNoaWxkXHJcbiAgICAgIC8vIGxldCBuIGJlIHRoZSBub2RlIHRoYXQgcmVwbGFjZXMgZFxyXG4gICAgICB2YXIgaXNGYWtlQ2hpbGRcclxuICAgICAgdmFyIGNoaWxkID0gZC5sZWZ0IHx8IGQucmlnaHRcclxuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XHJcbiAgICAgICAgaXNGYWtlQ2hpbGQgPSB0cnVlXHJcbiAgICAgICAgY2hpbGQgPSBuZXcgTih7aWQ6IDB9KVxyXG4gICAgICAgIGNoaWxkLmJsYWNrZW4oKVxyXG4gICAgICAgIGQucmlnaHQgPSBjaGlsZFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlzRmFrZUNoaWxkID0gZmFsc2VcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGQucGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKCFpc0Zha2VDaGlsZCkge1xyXG4gICAgICAgICAgdGhpcy5yb290ID0gY2hpbGRcclxuICAgICAgICAgIGNoaWxkLmJsYWNrZW4oKVxyXG4gICAgICAgICAgY2hpbGQuX3BhcmVudCA9IG51bGxcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5yb290ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfSBlbHNlIGlmIChkLnBhcmVudC5sZWZ0ID09PSBkKSB7XHJcbiAgICAgICAgZC5wYXJlbnQubGVmdCA9IGNoaWxkXHJcbiAgICAgIH0gZWxzZSBpZiAoZC5wYXJlbnQucmlnaHQgPT09IGQpIHtcclxuICAgICAgICBkLnBhcmVudC5yaWdodCA9IGNoaWxkXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlIScpXHJcbiAgICAgIH1cclxuICAgICAgaWYgKGQuaXNCbGFjaygpKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLmlzUmVkKCkpIHtcclxuICAgICAgICAgIGNoaWxkLmJsYWNrZW4oKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9maXhEZWxldGUoY2hpbGQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucm9vdC5ibGFja2VuKClcclxuICAgICAgaWYgKGlzRmFrZUNoaWxkKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudC5sZWZ0ID09PSBjaGlsZCkge1xyXG4gICAgICAgICAgY2hpbGQucGFyZW50LmxlZnQgPSBudWxsXHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5wYXJlbnQucmlnaHQgPT09IGNoaWxkKSB7XHJcbiAgICAgICAgICBjaGlsZC5wYXJlbnQucmlnaHQgPSBudWxsXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1wb3NzaWJsZSAjMycpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfZml4RGVsZXRlIChuKSB7XHJcbiAgICAgIGZ1bmN0aW9uIGlzQmxhY2sgKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbm9kZSAhPT0gbnVsbCA/IG5vZGUuaXNCbGFjaygpIDogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGlzUmVkIChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgIT09IG51bGwgPyBub2RlLmlzUmVkKCkgOiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChuLnBhcmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBmaXJzdCBpdGVyYXRpb24gb2YgZml4RGVsZXRlLlxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIC8vIGQgd2FzIGFscmVhZHkgcmVwbGFjZWQgYnkgdGhlIGNoaWxkXHJcbiAgICAgIC8vIGQgaXMgbm90IHRoZSByb290XHJcbiAgICAgIC8vIGQgYW5kIGNoaWxkIGFyZSBibGFja1xyXG4gICAgICB2YXIgc2libGluZyA9IG4uc2libGluZ1xyXG4gICAgICBpZiAoaXNSZWQoc2libGluZykpIHtcclxuICAgICAgICAvLyBtYWtlIHNpYmxpbmcgdGhlIGdyYW5kZmF0aGVyXHJcbiAgICAgICAgbi5wYXJlbnQucmVkZGVuKClcclxuICAgICAgICBzaWJsaW5nLmJsYWNrZW4oKVxyXG4gICAgICAgIGlmIChuID09PSBuLnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgICBuLnBhcmVudC5yb3RhdGVMZWZ0KHRoaXMpXHJcbiAgICAgICAgfSBlbHNlIGlmIChuID09PSBuLnBhcmVudC5yaWdodCkge1xyXG4gICAgICAgICAgbi5wYXJlbnQucm90YXRlUmlnaHQodGhpcylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlICMyJylcclxuICAgICAgICB9XHJcbiAgICAgICAgc2libGluZyA9IG4uc2libGluZ1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHBhcmVudCwgc2libGluZywgYW5kIGNoaWxkcmVuIG9mIG4gYXJlIGJsYWNrXHJcbiAgICAgIGlmIChuLnBhcmVudC5pc0JsYWNrKCkgJiZcclxuICAgICAgICBzaWJsaW5nLmlzQmxhY2soKSAmJlxyXG4gICAgICAgIGlzQmxhY2soc2libGluZy5sZWZ0KSAmJlxyXG4gICAgICAgIGlzQmxhY2soc2libGluZy5yaWdodClcclxuICAgICAgKSB7XHJcbiAgICAgICAgc2libGluZy5yZWRkZW4oKVxyXG4gICAgICAgIHRoaXMuX2ZpeERlbGV0ZShuLnBhcmVudClcclxuICAgICAgfSBlbHNlIGlmIChuLnBhcmVudC5pc1JlZCgpICYmXHJcbiAgICAgICAgc2libGluZy5pc0JsYWNrKCkgJiZcclxuICAgICAgICBpc0JsYWNrKHNpYmxpbmcubGVmdCkgJiZcclxuICAgICAgICBpc0JsYWNrKHNpYmxpbmcucmlnaHQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHNpYmxpbmcucmVkZGVuKClcclxuICAgICAgICBuLnBhcmVudC5ibGFja2VuKClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobiA9PT0gbi5wYXJlbnQubGVmdCAmJlxyXG4gICAgICAgICAgc2libGluZy5pc0JsYWNrKCkgJiZcclxuICAgICAgICAgIGlzUmVkKHNpYmxpbmcubGVmdCkgJiZcclxuICAgICAgICAgIGlzQmxhY2soc2libGluZy5yaWdodClcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHNpYmxpbmcucmVkZGVuKClcclxuICAgICAgICAgIHNpYmxpbmcubGVmdC5ibGFja2VuKClcclxuICAgICAgICAgIHNpYmxpbmcucm90YXRlUmlnaHQodGhpcylcclxuICAgICAgICAgIHNpYmxpbmcgPSBuLnNpYmxpbmdcclxuICAgICAgICB9IGVsc2UgaWYgKG4gPT09IG4ucGFyZW50LnJpZ2h0ICYmXHJcbiAgICAgICAgICBzaWJsaW5nLmlzQmxhY2soKSAmJlxyXG4gICAgICAgICAgaXNSZWQoc2libGluZy5yaWdodCkgJiZcclxuICAgICAgICAgIGlzQmxhY2soc2libGluZy5sZWZ0KVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgc2libGluZy5yZWRkZW4oKVxyXG4gICAgICAgICAgc2libGluZy5yaWdodC5ibGFja2VuKClcclxuICAgICAgICAgIHNpYmxpbmcucm90YXRlTGVmdCh0aGlzKVxyXG4gICAgICAgICAgc2libGluZyA9IG4uc2libGluZ1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaWJsaW5nLmNvbG9yID0gbi5wYXJlbnQuY29sb3JcclxuICAgICAgICBuLnBhcmVudC5ibGFja2VuKClcclxuICAgICAgICBpZiAobiA9PT0gbi5wYXJlbnQubGVmdCkge1xyXG4gICAgICAgICAgc2libGluZy5yaWdodC5ibGFja2VuKClcclxuICAgICAgICAgIG4ucGFyZW50LnJvdGF0ZUxlZnQodGhpcylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2libGluZy5sZWZ0LmJsYWNrZW4oKVxyXG4gICAgICAgICAgbi5wYXJlbnQucm90YXRlUmlnaHQodGhpcylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgICogcHV0ICh2KSB7XHJcbiAgICAgIGlmICh2ID09IG51bGwgfHwgdi5pZCA9PSBudWxsIHx8IHYuaWQuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2IGlzIGV4cGVjdGVkIHRvIGhhdmUgYW4gaWQgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkhJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgbm9kZSA9IG5ldyBOKHYpXHJcbiAgICAgIGlmICh0aGlzLnJvb3QgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucm9vdCAvLyBwIGFiYnJldi4gcGFyZW50XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgIGlmIChZLnV0aWxzLnNtYWxsZXIobm9kZS52YWwuaWQsIHAudmFsLmlkKSkge1xyXG4gICAgICAgICAgICBpZiAocC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgcC5sZWZ0ID0gbm9kZVxyXG4gICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcCA9IHAubGVmdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFkudXRpbHMuc21hbGxlcihwLnZhbC5pZCwgbm9kZS52YWwuaWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnJpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgcC5yaWdodCA9IG5vZGVcclxuICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHAgPSBwLnJpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHAudmFsID0gbm9kZS52YWxcclxuICAgICAgICAgICAgcmV0dXJuIHBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZml4SW5zZXJ0KG5vZGUpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbm9kZVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGVuZ3RoKytcclxuICAgICAgdGhpcy5yb290LmJsYWNrZW4oKVxyXG4gICAgICByZXR1cm4gbm9kZVxyXG4gICAgfVxyXG4gICAgX2ZpeEluc2VydCAobikge1xyXG4gICAgICBpZiAobi5wYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICBuLmJsYWNrZW4oKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9IGVsc2UgaWYgKG4ucGFyZW50LmlzQmxhY2soKSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIHZhciB1bmNsZSA9IG4uZ2V0VW5jbGUoKVxyXG4gICAgICBpZiAodW5jbGUgIT09IG51bGwgJiYgdW5jbGUuaXNSZWQoKSkge1xyXG4gICAgICAgIC8vIE5vdGU6IHBhcmVudDogcmVkLCB1bmNsZTogcmVkXHJcbiAgICAgICAgbi5wYXJlbnQuYmxhY2tlbigpXHJcbiAgICAgICAgdW5jbGUuYmxhY2tlbigpXHJcbiAgICAgICAgbi5ncmFuZHBhcmVudC5yZWRkZW4oKVxyXG4gICAgICAgIHRoaXMuX2ZpeEluc2VydChuLmdyYW5kcGFyZW50KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5vdGU6IHBhcmVudDogcmVkLCB1bmNsZTogYmxhY2sgb3IgbnVsbFxyXG4gICAgICAgIC8vIE5vdyB3ZSB0cmFuc2Zvcm0gdGhlIHRyZWUgaW4gc3VjaCBhIHdheSB0aGF0XHJcbiAgICAgICAgLy8gZWl0aGVyIG9mIHRoZXNlIGhvbGRzOlxyXG4gICAgICAgIC8vICAgMSkgZ3JhbmRwYXJlbnQubGVmdC5pc1JlZFxyXG4gICAgICAgIC8vICAgICBhbmQgZ3JhbmRwYXJlbnQubGVmdC5sZWZ0LmlzUmVkXHJcbiAgICAgICAgLy8gICAyKSBncmFuZHBhcmVudC5yaWdodC5pc1JlZFxyXG4gICAgICAgIC8vICAgICBhbmQgZ3JhbmRwYXJlbnQucmlnaHQucmlnaHQuaXNSZWRcclxuICAgICAgICBpZiAobiA9PT0gbi5wYXJlbnQucmlnaHQgJiYgbi5wYXJlbnQgPT09IG4uZ3JhbmRwYXJlbnQubGVmdCkge1xyXG4gICAgICAgICAgbi5wYXJlbnQucm90YXRlTGVmdCh0aGlzKVxyXG4gICAgICAgICAgLy8gU2luY2Ugd2Ugcm90YXRlZCBhbmQgd2FudCB0byB1c2UgdGhlIHByZXZpb3VzXHJcbiAgICAgICAgICAvLyBjYXNlcywgd2UgbmVlZCB0byBzZXQgbiBpbiBzdWNoIGEgd2F5IHRoYXRcclxuICAgICAgICAgIC8vIG4ucGFyZW50LmlzUmVkIGFnYWluXHJcbiAgICAgICAgICBuID0gbi5sZWZ0XHJcbiAgICAgICAgfSBlbHNlIGlmIChuID09PSBuLnBhcmVudC5sZWZ0ICYmIG4ucGFyZW50ID09PSBuLmdyYW5kcGFyZW50LnJpZ2h0KSB7XHJcbiAgICAgICAgICBuLnBhcmVudC5yb3RhdGVSaWdodCh0aGlzKVxyXG4gICAgICAgICAgLy8gc2VlIGFib3ZlXHJcbiAgICAgICAgICBuID0gbi5yaWdodFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYXNlIDEpIG9yIDIpIGhvbGQgZnJvbSBoZXJlIG9uLlxyXG4gICAgICAgIC8vIE5vdyB0cmF2ZXJzZSBncmFuZHBhcmVudCwgbWFrZSBwYXJlbnQgYSBibGFjayBub2RlXHJcbiAgICAgICAgLy8gb24gdGhlIGhpZ2hlc3QgbGV2ZWwgd2hpY2ggaG9sZHMgdHdvIHJlZCBub2Rlcy5cclxuICAgICAgICBuLnBhcmVudC5ibGFja2VuKClcclxuICAgICAgICBuLmdyYW5kcGFyZW50LnJlZGRlbigpXHJcbiAgICAgICAgaWYgKG4gPT09IG4ucGFyZW50LmxlZnQpIHtcclxuICAgICAgICAgIC8vIENhc2UgMVxyXG4gICAgICAgICAgbi5ncmFuZHBhcmVudC5yb3RhdGVSaWdodCh0aGlzKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBDYXNlIDJcclxuICAgICAgICAgIG4uZ3JhbmRwYXJlbnQucm90YXRlTGVmdCh0aGlzKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKiBmbHVzaCAoKSB7fVxyXG4gIH1cclxuXHJcbiAgWS51dGlscy5SQlRyZWUgPSBSQlRyZWVcclxufVxyXG4iLCIvKiBnbG9iYWwgWSwgZ2xvYmFsICovXG4ndXNlIHN0cmljdCdcblxuLy8gc29ja2V0LmlvIHJlcXVpcmVzIHV0ZjguIFRoaXMgcGFja2FnZSBjaGVja3MgaWYgaXQgaXMgcmVxdWlyZWQgYnkgcmVxdWlyZWpzLlxuLy8gSWYgd2luZG93LnJlcXVpcmUgaXMgc2V0LCB0aGVuIGl0IHdpbGwgZGVmaW5lIGl0c2VsZiBhcyBhIG1vZHVsZS4gVGhpcyBpcyBlcnJhdGljIGJlaGF2aW9yIGFuZFxuLy8gcmVzdWx0cyBpbiBzb2NrZXQuaW8gaGF2aW5nIGEgXCJiYWQgcmVxdWVzdFwiLlxuLy8gVGhpcyBpcyB3aHkgd2UgdW5kZWZpbmUgZ2xvYmFsLmRlZmluZSAoaXQgaXMgc2V0IGJ5IHJlcXVpcmVqcykgYmVmb3JlIHdlIHJlcXVpcmUgc29ja2V0LmlvLWNsaWVudC5cbnZhciBkZWZpbmUgPSBnbG9iYWwuZGVmaW5lXG5nbG9iYWwuZGVmaW5lID0gbnVsbFxudmFyIGlvID0gcmVxdWlyZSgnc29ja2V0LmlvLWNsaWVudCcpXG4vLyByZWRlZmluZSBnbG9iYWwuZGVmaW5lXG5nbG9iYWwuZGVmaW5lID0gZGVmaW5lXG5cbmZ1bmN0aW9uIGV4dGVuZCAoWSkge1xuICBjbGFzcyBDb25uZWN0b3IgZXh0ZW5kcyBZLkFic3RyYWN0Q29ubmVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvciAoeSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgbXVzdCBub3QgYmUgdW5kZWZpbmVkIScpXG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5yb29tID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgYSByb29tIG5hbWUhJylcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucm9sZSA9ICdzbGF2ZSdcbiAgICAgIHN1cGVyKHksIG9wdGlvbnMpXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsIHx8ICdodHRwczovL3lqcy5kYmlzLnJ3dGgtYWFjaGVuLmRlOjUwNzInXG4gICAgICB2YXIgc29ja2V0ID0gb3B0aW9ucy5zb2NrZXQgfHwgaW8ob3B0aW9ucy51cmwpXG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICAgIHRoaXMuX29uQ29ubmVjdCA9IGZ1bmN0aW9uIGpvaW5Sb29tICgpIHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5Sb29tJywgb3B0aW9ucy5yb29tKVxuICAgICAgICBzZWxmLnVzZXJKb2luZWQoJ3NlcnZlcicsICdtYXN0ZXInKVxuICAgICAgfVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCB0aGlzLl9vbkNvbm5lY3QpXG4gICAgICBpZiAoc29ja2V0LmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9vbkNvbm5lY3QoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LmNvbm5lY3QoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vbllqc0V2ZW50ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3N5bmMgZG9uZScpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQgPSBzb2NrZXQuaWRcbiAgICAgICAgICAgIGlmIChzb2NrZXQuX3lqc19jb25uZWN0aW9uX2NvdW50ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzb2NrZXQuX3lqc19jb25uZWN0aW9uX2NvdW50ZXIgPSAxXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1c2VySWQgKz0gc29ja2V0Ll95anNfY29ubmVjdGlvbl9jb3VudGVyKytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2V0VXNlcklkKHVzZXJJZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uucm9vbSA9PT0gb3B0aW9ucy5yb29tKSB7XG4gICAgICAgICAgICBzZWxmLnJlY2VpdmVNZXNzYWdlKCdzZXJ2ZXInLCBtZXNzYWdlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc29ja2V0Lm9uKCd5anNFdmVudCcsIHRoaXMuX29uWWpzRXZlbnQpXG5cbiAgICAgIHRoaXMuX29uRGlzY29ubmVjdCA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgICAgIHNlbGYudXNlckxlZnQoJ3NlcnZlcicpXG4gICAgICB9XG4gICAgICBzb2NrZXQub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzLl9vbkRpc2Nvbm5lY3QpXG4gICAgfVxuICAgIGRpc2Nvbm5lY3QgKCkge1xuICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnbGVhdmVSb29tJywgdGhpcy5vcHRpb25zLnJvb20pXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuZGlzY29ubmVjdCgpXG4gICAgICB9XG4gICAgICBzdXBlci5kaXNjb25uZWN0KClcbiAgICB9XG4gICAgZGVzdHJveSAoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5zb2NrZXQub2ZmKCdkaXNjb25uZWN0JywgdGhpcy5fb25EaXNjb25uZWN0KVxuICAgICAgdGhpcy5zb2NrZXQub2ZmKCd5anNFdmVudCcsIHRoaXMuX29uWWpzRXZlbnQpXG4gICAgICB0aGlzLnNvY2tldC5vZmYoJ2Nvbm5lY3QnLCB0aGlzLl9vbkNvbm5lY3QpXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpXG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldCA9IG51bGxcbiAgICB9XG4gICAgcmVjb25uZWN0ICgpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgICAgc3VwZXIucmVjb25uZWN0KClcbiAgICB9XG4gICAgc2VuZCAodWlkLCBtZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlLnJvb20gPSB0aGlzLm9wdGlvbnMucm9vbVxuICAgICAgdGhpcy5zb2NrZXQuZW1pdCgneWpzRXZlbnQnLCBtZXNzYWdlKVxuICAgIH1cbiAgICBicm9hZGNhc3QgKG1lc3NhZ2UpIHtcbiAgICAgIG1lc3NhZ2Uucm9vbSA9IHRoaXMub3B0aW9ucy5yb29tXG4gICAgICB0aGlzLnNvY2tldC5lbWl0KCd5anNFdmVudCcsIG1lc3NhZ2UpXG4gICAgfVxuICAgIGlzRGlzY29ubmVjdGVkICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5kaXNjb25uZWN0ZWRcbiAgICB9XG4gIH1cbiAgQ29ubmVjdG9yLmlvID0gaW9cbiAgWS5leHRlbmQoJ3dlYnNvY2tldHMtY2xpZW50JywgQ29ubmVjdG9yKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuaWYgKHR5cGVvZiBZICE9PSAndW5kZWZpbmVkJykge1xuICBleHRlbmQoWSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4iLCIvKiBAZmxvdyAqL1xuJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFkvKiA6YW55ICovKSB7XG4gIGNsYXNzIEFic3RyYWN0Q29ubmVjdG9yIHtcbiAgICAvKiA6OlxuICAgIHk6IFlDb25maWc7XG4gICAgcm9sZTogU3luY1JvbGU7XG4gICAgY29ubmVjdGlvbnM6IE9iamVjdDtcbiAgICBpc1N5bmNlZDogYm9vbGVhbjtcbiAgICB1c2VyRXZlbnRMaXN0ZW5lcnM6IEFycmF5PEZ1bmN0aW9uPjtcbiAgICB3aGVuU3luY2VkTGlzdGVuZXJzOiBBcnJheTxGdW5jdGlvbj47XG4gICAgY3VycmVudFN5bmNUYXJnZXQ6ID9Vc2VySWQ7XG4gICAgc3luY2luZ0NsaWVudHM6IEFycmF5PFVzZXJJZD47XG4gICAgZm9yd2FyZFRvU3luY2luZ0NsaWVudHM6IGJvb2xlYW47XG4gICAgZGVidWc6IGJvb2xlYW47XG4gICAgYnJvYWRjYXN0ZWRIQjogYm9vbGVhbjtcbiAgICBzeW5jU3RlcDI6IFByb21pc2U7XG4gICAgdXNlcklkOiBVc2VySWQ7XG4gICAgc2VuZDogRnVuY3Rpb247XG4gICAgYnJvYWRjYXN0OiBGdW5jdGlvbjtcbiAgICBicm9hZGNhc3RPcEJ1ZmZlcjogQXJyYXk8T3BlcmF0aW9uPjtcbiAgICBwcm90b2NvbFZlcnNpb246IG51bWJlcjtcbiAgICAqL1xuICAgIC8qXG4gICAgICBvcHRzIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG4gICAgICAgcm9sZSA6IFN0cmluZyBSb2xlIG9mIHRoaXMgY2xpZW50IChcIm1hc3RlclwiIG9yIFwic2xhdmVcIilcbiAgICAgICB1c2VySWQgOiBTdHJpbmcgVW5pcXVlbHkgZGVmaW5lcyB0aGUgdXNlci5cbiAgICAgICBkZWJ1ZzogQm9vbGVhbiBXaGV0aGVyIHRvIHByaW50IGRlYnVnIG1lc3NhZ2VzIChvcHRpb25hbClcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yICh5LCBvcHRzKSB7XG4gICAgICB0aGlzLnkgPSB5XG4gICAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSB7fVxuICAgICAgfVxuICAgICAgaWYgKG9wdHMucm9sZSA9PSBudWxsIHx8IG9wdHMucm9sZSA9PT0gJ21hc3RlcicpIHtcbiAgICAgICAgdGhpcy5yb2xlID0gJ21hc3RlcidcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5yb2xlID09PSAnc2xhdmUnKSB7XG4gICAgICAgIHRoaXMucm9sZSA9ICdzbGF2ZSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvbGUgbXVzdCBiZSBlaXRoZXIgJ21hc3Rlcicgb3IgJ3NsYXZlJyFcIilcbiAgICAgIH1cbiAgICAgIHRoaXMueS5kYi5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgPSBvcHRzLmZvcndhcmRBcHBsaWVkT3BlcmF0aW9ucyB8fCBmYWxzZVxuICAgICAgdGhpcy5yb2xlID0gb3B0cy5yb2xlXG4gICAgICB0aGlzLmNvbm5lY3Rpb25zID0ge31cbiAgICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZVxuICAgICAgdGhpcy51c2VyRXZlbnRMaXN0ZW5lcnMgPSBbXVxuICAgICAgdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzID0gW11cbiAgICAgIHRoaXMuY3VycmVudFN5bmNUYXJnZXQgPSBudWxsXG4gICAgICB0aGlzLnN5bmNpbmdDbGllbnRzID0gW11cbiAgICAgIHRoaXMuZm9yd2FyZFRvU3luY2luZ0NsaWVudHMgPSBvcHRzLmZvcndhcmRUb1N5bmNpbmdDbGllbnRzICE9PSBmYWxzZVxuICAgICAgdGhpcy5kZWJ1ZyA9IG9wdHMuZGVidWcgPT09IHRydWVcbiAgICAgIHRoaXMuYnJvYWRjYXN0ZWRIQiA9IGZhbHNlXG4gICAgICB0aGlzLnN5bmNTdGVwMiA9IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB0aGlzLmJyb2FkY2FzdE9wQnVmZmVyID0gW11cbiAgICAgIHRoaXMucHJvdG9jb2xWZXJzaW9uID0gMTFcbiAgICB9XG4gICAgcmVjb25uZWN0ICgpIHtcbiAgICB9XG4gICAgZGlzY29ubmVjdCAoKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zID0ge31cbiAgICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZVxuICAgICAgdGhpcy5jdXJyZW50U3luY1RhcmdldCA9IG51bGxcbiAgICAgIHRoaXMuYnJvYWRjYXN0ZWRIQiA9IGZhbHNlXG4gICAgICB0aGlzLnN5bmNpbmdDbGllbnRzID0gW11cbiAgICAgIHRoaXMud2hlblN5bmNlZExpc3RlbmVycyA9IFtdXG4gICAgICByZXR1cm4gdGhpcy55LmRiLnN0b3BHYXJiYWdlQ29sbGVjdG9yKClcbiAgICB9XG4gICAgc2V0VXNlcklkICh1c2VySWQpIHtcbiAgICAgIGlmICh0aGlzLnVzZXJJZCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudXNlcklkID0gdXNlcklkXG4gICAgICAgIHJldHVybiB0aGlzLnkuZGIuc2V0VXNlcklkKHVzZXJJZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIG9uVXNlckV2ZW50IChmKSB7XG4gICAgICB0aGlzLnVzZXJFdmVudExpc3RlbmVycy5wdXNoKGYpXG4gICAgfVxuICAgIHVzZXJMZWZ0ICh1c2VyKSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uc1t1c2VyXSAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW3VzZXJdXG4gICAgICAgIGlmICh1c2VyID09PSB0aGlzLmN1cnJlbnRTeW5jVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50U3luY1RhcmdldCA9IG51bGxcbiAgICAgICAgICB0aGlzLmZpbmROZXh0U3luY1RhcmdldCgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jaW5nQ2xpZW50cyA9IHRoaXMuc3luY2luZ0NsaWVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGkpIHtcbiAgICAgICAgICByZXR1cm4gY2xpICE9PSB1c2VyXG4gICAgICAgIH0pXG4gICAgICAgIGZvciAodmFyIGYgb2YgdGhpcy51c2VyRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBmKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3VzZXJMZWZ0JyxcbiAgICAgICAgICAgIHVzZXI6IHVzZXJcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHVzZXJKb2luZWQgKHVzZXIsIHJvbGUpIHtcbiAgICAgIGlmIChyb2xlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IHRoZSByb2xlIG9mIHRoZSBqb2luZWQgdXNlciEnKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbdXNlcl0gIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdXNlciBhbHJlYWR5IGpvaW5lZCEnKVxuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0aW9uc1t1c2VyXSA9IHtcbiAgICAgICAgaXNTeW5jZWQ6IGZhbHNlLFxuICAgICAgICByb2xlOiByb2xlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBmIG9mIHRoaXMudXNlckV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIGYoe1xuICAgICAgICAgIGFjdGlvbjogJ3VzZXJKb2luZWQnLFxuICAgICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgICAgcm9sZTogcm9sZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VycmVudFN5bmNUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZpbmROZXh0U3luY1RhcmdldCgpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgYSBmdW5jdGlvbiBfd2hlbl8gd2UgYXJlIGNvbm5lY3RlZC5cbiAgICAvLyBJZiBub3QgY29ubmVjdGVkLCB3YWl0IHVudGlsIGNvbm5lY3RlZFxuICAgIHdoZW5TeW5jZWQgKGYpIHtcbiAgICAgIGlmICh0aGlzLmlzU3luY2VkKSB7XG4gICAgICAgIGYoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzLnB1c2goZilcbiAgICAgIH1cbiAgICB9XG4gICAgLypcblxuICAgICByZXR1cm5zIGZhbHNlLCBpZiB0aGVyZSBpcyBubyBzeW5jIHRhcmdldFxuICAgICB0cnVlIG90aGVyd2lzZVxuICAgICovXG4gICAgZmluZE5leHRTeW5jVGFyZ2V0ICgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRTeW5jVGFyZ2V0ICE9IG51bGwgfHwgdGhpcy5pc1N5bmNlZCkge1xuICAgICAgICByZXR1cm4gLy8gXCJUaGUgY3VycmVudCBzeW5jIGhhcyBub3QgZmluaXNoZWQhXCJcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmNVc2VyID0gbnVsbFxuICAgICAgZm9yICh2YXIgdWlkIGluIHRoaXMuY29ubmVjdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25zW3VpZF0uaXNTeW5jZWQpIHtcbiAgICAgICAgICBzeW5jVXNlciA9IHVpZFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjb25uID0gdGhpc1xuICAgICAgaWYgKHN5bmNVc2VyICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3luY1RhcmdldCA9IHN5bmNVc2VyXG4gICAgICAgIHRoaXMueS5kYi5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICB2YXIgc3RhdGVTZXQgPSB5aWVsZCogdGhpcy5nZXRTdGF0ZVNldCgpXG4gICAgICAgICAgdmFyIGRlbGV0ZVNldCA9IHlpZWxkKiB0aGlzLmdldERlbGV0ZVNldCgpXG4gICAgICAgICAgY29ubi5zZW5kKHN5bmNVc2VyLCB7XG4gICAgICAgICAgICB0eXBlOiAnc3luYyBzdGVwIDEnLFxuICAgICAgICAgICAgc3RhdGVTZXQ6IHN0YXRlU2V0LFxuICAgICAgICAgICAgZGVsZXRlU2V0OiBkZWxldGVTZXQsXG4gICAgICAgICAgICBwcm90b2NvbFZlcnNpb246IGNvbm4ucHJvdG9jb2xWZXJzaW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueS5kYi5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICAvLyBpdCBpcyBjcnVjaWFsIHRoYXQgaXNTeW5jZWQgaXMgc2V0IGF0IHRoZSB0aW1lIGdhcmJhZ2VDb2xsZWN0QWZ0ZXJTeW5jIGlzIGNhbGxlZFxuICAgICAgICAgIGNvbm4uaXNTeW5jZWQgPSB0cnVlXG4gICAgICAgICAgeWllbGQqIHRoaXMuZ2FyYmFnZUNvbGxlY3RBZnRlclN5bmMoKVxuICAgICAgICAgIC8vIGNhbGwgd2hlbnN5bmNlZCBsaXN0ZW5lcnNcbiAgICAgICAgICBmb3IgKHZhciBmIG9mIGNvbm4ud2hlblN5bmNlZExpc3RlbmVycykge1xuICAgICAgICAgICAgZigpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbm4ud2hlblN5bmNlZExpc3RlbmVycyA9IFtdXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHNlbmQgKHVpZCwgbWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYHNlbmQgJHt0aGlzLnVzZXJJZH0gLT4gJHt1aWR9OiAke21lc3NhZ2UudHlwZX1gLCBtZXNzYWdlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICBCdWZmZXIgb3BlcmF0aW9ucywgYW5kIGJyb2FkY2FzdCB0aGVtIHdoZW4gcmVhZHkuXG4gICAgKi9cbiAgICBicm9hZGNhc3RPcHMgKG9wcykge1xuICAgICAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIFkuU3RydWN0W29wLnN0cnVjdF0uZW5jb2RlKG9wKVxuICAgICAgfSlcbiAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgZnVuY3Rpb24gYnJvYWRjYXN0T3BlcmF0aW9ucyAoKSB7XG4gICAgICAgIGlmIChzZWxmLmJyb2FkY2FzdE9wQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZWxmLmJyb2FkY2FzdCh7XG4gICAgICAgICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgICAgICAgIG9wczogc2VsZi5icm9hZGNhc3RPcEJ1ZmZlclxuICAgICAgICAgIH0pXG4gICAgICAgICAgc2VsZi5icm9hZGNhc3RPcEJ1ZmZlciA9IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJyb2FkY2FzdE9wQnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdE9wQnVmZmVyID0gb3BzXG4gICAgICAgIGlmICh0aGlzLnkuZGIudHJhbnNhY3Rpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgdGhpcy55LmRiLndoZW5UcmFuc2FjdGlvbnNGaW5pc2hlZCgpLnRoZW4oYnJvYWRjYXN0T3BlcmF0aW9ucylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGJyb2FkY2FzdE9wZXJhdGlvbnMsIDApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0T3BCdWZmZXIgPSB0aGlzLmJyb2FkY2FzdE9wQnVmZmVyLmNvbmNhdChvcHMpXG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICBZb3UgcmVjZWl2ZWQgYSByYXcgbWVzc2FnZSwgYW5kIHlvdSBrbm93IHRoYXQgaXQgaXMgaW50ZW5kZWQgZm9yIFlqcy4gVGhlbiBjYWxsIHRoaXMgZnVuY3Rpb24uXG4gICAgKi9cbiAgICByZWNlaXZlTWVzc2FnZSAoc2VuZGVyLyogOlVzZXJJZCAqLywgbWVzc2FnZS8qIDpNZXNzYWdlICovKSB7XG4gICAgICBpZiAoc2VuZGVyID09PSB0aGlzLnVzZXJJZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGByZWNlaXZlICR7c2VuZGVyfSAtPiAke3RoaXMudXNlcklkfTogJHttZXNzYWdlLnR5cGV9YCwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXNzYWdlKSkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnByb3RvY29sVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UucHJvdG9jb2xWZXJzaW9uICE9PSB0aGlzLnByb3RvY29sVmVyc2lvbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBZb3UgdHJpZWQgdG8gc3luYyB3aXRoIGEgeWpzIGluc3RhbmNlIHRoYXQgaGFzIGEgZGlmZmVyZW50IHByb3RvY29sIHZlcnNpb25cbiAgICAgICAgICAoWW91OiAke3RoaXMucHJvdG9jb2xWZXJzaW9ufSwgQ2xpZW50OiAke21lc3NhZ2UucHJvdG9jb2xWZXJzaW9ufSkuXG4gICAgICAgICAgVGhlIHN5bmMgd2FzIHN0b3BwZWQuIFlvdSBuZWVkIHRvIHVwZ3JhZGUgeW91ciBkZXBlbmRlbmNpZXMgKGVzcGVjaWFsbHkgWWpzICYgdGhlIENvbm5lY3RvcikhXG4gICAgICAgICAgYClcbiAgICAgICAgdGhpcy5zZW5kKHNlbmRlciwge1xuICAgICAgICAgIHR5cGU6ICdzeW5jIHN0b3AnLFxuICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogdGhpcy5wcm90b2NvbFZlcnNpb25cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSAnc3luYyBzdGVwIDEnKSB7XG4gICAgICAgIGxldCBjb25uID0gdGhpc1xuICAgICAgICBsZXQgbSA9IG1lc3NhZ2VcbiAgICAgICAgdGhpcy55LmRiLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkge1xuICAgICAgICAgIHZhciBjdXJyZW50U3RhdGVTZXQgPSB5aWVsZCogdGhpcy5nZXRTdGF0ZVNldCgpXG4gICAgICAgICAgeWllbGQqIHRoaXMuYXBwbHlEZWxldGVTZXQobS5kZWxldGVTZXQpXG5cbiAgICAgICAgICB2YXIgZHMgPSB5aWVsZCogdGhpcy5nZXREZWxldGVTZXQoKVxuICAgICAgICAgIHZhciBvcHMgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb25zKG0uc3RhdGVTZXQpXG4gICAgICAgICAgY29ubi5zZW5kKHNlbmRlciwge1xuICAgICAgICAgICAgdHlwZTogJ3N5bmMgc3RlcCAyJyxcbiAgICAgICAgICAgIG9zOiBvcHMsXG4gICAgICAgICAgICBzdGF0ZVNldDogY3VycmVudFN0YXRlU2V0LFxuICAgICAgICAgICAgZGVsZXRlU2V0OiBkcyxcbiAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogdGhpcy5wcm90b2NvbFZlcnNpb25cbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmICh0aGlzLmZvcndhcmRUb1N5bmNpbmdDbGllbnRzKSB7XG4gICAgICAgICAgICBjb25uLnN5bmNpbmdDbGllbnRzLnB1c2goc2VuZGVyKVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbm4uc3luY2luZ0NsaWVudHMgPSBjb25uLnN5bmNpbmdDbGllbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaSAhPT0gc2VuZGVyXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGNvbm4uc2VuZChzZW5kZXIsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3luYyBkb25lJ1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSwgNTAwMCkgLy8gVE9ETzogY29ubi5zeW5jaW5nQ2xpZW50RHVyYXRpb24pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbm4uc2VuZChzZW5kZXIsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N5bmMgZG9uZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbm4uX3NldFN5bmNlZFdpdGgoc2VuZGVyKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzeW5jIHN0ZXAgMicpIHtcbiAgICAgICAgbGV0IGNvbm4gPSB0aGlzXG4gICAgICAgIHZhciBicm9hZGNhc3RIQiA9ICF0aGlzLmJyb2FkY2FzdGVkSEJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RlZEhCID0gdHJ1ZVxuICAgICAgICB2YXIgZGIgPSB0aGlzLnkuZGJcbiAgICAgICAgdmFyIGRlZmVyID0ge31cbiAgICAgICAgZGVmZXIucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5zeW5jU3RlcDIgPSBkZWZlci5wcm9taXNlXG4gICAgICAgIGxldCBtIC8qIDpNZXNzYWdlU3luY1N0ZXAyICovID0gbWVzc2FnZVxuICAgICAgICBkYi5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgICAgeWllbGQqIHRoaXMuYXBwbHlEZWxldGVTZXQobS5kZWxldGVTZXQpXG4gICAgICAgICAgdGhpcy5zdG9yZS5hcHBseShtLm9zKVxuICAgICAgICAgIGRiLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICAgIHZhciBvcHMgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb25zKG0uc3RhdGVTZXQpXG4gICAgICAgICAgICBpZiAob3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKCFicm9hZGNhc3RIQikgeyAvLyBUT0RPOiBjb25zaWRlciB0byBicm9hZGNhc3QgaGVyZS4uXG4gICAgICAgICAgICAgICAgY29ubi5zZW5kKHNlbmRlciwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgICBvcHM6IG9wc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYnJvYWRjYXN0IG9ubHkgb25jZSFcbiAgICAgICAgICAgICAgICBjb25uLmJyb2FkY2FzdE9wcyhvcHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3N5bmMgZG9uZScpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgIHRoaXMuc3luY1N0ZXAyLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX3NldFN5bmNlZFdpdGgoc2VuZGVyKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcndhcmRUb1N5bmNpbmdDbGllbnRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgY2xpZW50IG9mIHRoaXMuc3luY2luZ0NsaWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZChjbGllbnQsIG1lc3NhZ2UpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnkuZGIuZm9yd2FyZEFwcGxpZWRPcGVyYXRpb25zKSB7XG4gICAgICAgICAgdmFyIGRlbG9wcyA9IG1lc3NhZ2Uub3BzLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgcmV0dXJuIG8uc3RydWN0ID09PSAnRGVsZXRlJ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKGRlbG9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE9wcyhkZWxvcHMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMueS5kYi5hcHBseShtZXNzYWdlLm9wcylcbiAgICAgIH1cbiAgICB9XG4gICAgX3NldFN5bmNlZFdpdGggKHVzZXIpIHtcbiAgICAgIHZhciBjb25uID0gdGhpcy5jb25uZWN0aW9uc1t1c2VyXVxuICAgICAgaWYgKGNvbm4gIT0gbnVsbCkge1xuICAgICAgICBjb25uLmlzU3luY2VkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHVzZXIgPT09IHRoaXMuY3VycmVudFN5bmNUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3luY1RhcmdldCA9IG51bGxcbiAgICAgICAgdGhpcy5maW5kTmV4dFN5bmNUYXJnZXQoKVxuICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgICAgQ3VycmVudGx5LCB0aGUgSEIgZW5jb2RlcyBvcGVyYXRpb25zIGFzIEpTT04uIEZvciB0aGUgbW9tZW50IEkgd2FudCB0byBrZWVwIGl0XG4gICAgICB0aGF0IHdheS4gTWF5YmUgd2Ugc3VwcG9ydCBlbmNvZGluZyBpbiB0aGUgSEIgYXMgWE1MIGluIHRoZSBmdXR1cmUsIGJ1dCBmb3Igbm93IEkgZG9uJ3Qgd2FudFxuICAgICAgdG9vIG11Y2ggb3ZlcmhlYWQuIFkgaXMgdmVyeSBsaWtlbHkgdG8gZ2V0IGNoYW5nZWQgYSBsb3QgaW4gdGhlIGZ1dHVyZVxuXG4gICAgICBCZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gZW5jb2RlIEpTT04gYXMgc3RyaW5nICh3aXRoIGNoYXJhY3RlciBlc2NhcGluZywgd2ljaCBtYWtlcyBpdCBwcmV0dHkgbXVjaCB1bnJlYWRhYmxlKVxuICAgICAgd2UgZW5jb2RlIHRoZSBKU09OIGFzIFhNTC5cblxuICAgICAgV2hlbiB0aGUgSEIgc3VwcG9ydCBlbmNvZGluZyBhcyBYTUwsIHRoZSBmb3JtYXQgc2hvdWxkIGxvb2sgcHJldHR5IG11Y2ggbGlrZSB0aGlzLlxuXG4gICAgICBkb2VzIG5vdCBzdXBwb3J0IHByaW1pdGl2ZSB2YWx1ZXMgYXMgYXJyYXkgZWxlbWVudHNcbiAgICAgIGV4cGVjdHMgYW4gbHR4IChsZXNzIHRoYW4geG1sKSBvYmplY3RcbiAgICAqL1xuICAgIHBhcnNlTWVzc2FnZUZyb21YbWwgKG0vKiA6YW55ICovKSB7XG4gICAgICBmdW5jdGlvbiBwYXJzZUFycmF5IChub2RlKSB7XG4gICAgICAgIGZvciAodmFyIG4gb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChuLmdldEF0dHJpYnV0ZSgnaXNBcnJheScpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5KG4pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdChuKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VPYmplY3QgKG5vZGUvKiA6YW55ICovKSB7XG4gICAgICAgIHZhciBqc29uID0ge31cbiAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gbm9kZS5hdHRycykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNbYXR0ck5hbWVdXG4gICAgICAgICAgdmFyIGludCA9IHBhcnNlSW50KHZhbHVlLCAxMClcbiAgICAgICAgICBpZiAoaXNOYU4oaW50KSB8fCAoJycgKyBpbnQpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAganNvblthdHRyTmFtZV0gPSB2YWx1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqc29uW2F0dHJOYW1lXSA9IGludFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBuLyogOmFueSAqLyBpbiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBuLm5hbWVcbiAgICAgICAgICBpZiAobi5nZXRBdHRyaWJ1dGUoJ2lzQXJyYXknKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICBqc29uW25hbWVdID0gcGFyc2VBcnJheShuKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqc29uW25hbWVdID0gcGFyc2VPYmplY3QobilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25cbiAgICAgIH1cbiAgICAgIHBhcnNlT2JqZWN0KG0pXG4gICAgfVxuICAgIC8qXG4gICAgICBlbmNvZGUgbWVzc2FnZSBpbiB4bWxcbiAgICAgIHdlIHVzZSBzdHJpbmcgYmVjYXVzZSBTdHJvcGhlIG9ubHkgYWNjZXB0cyBhbiBcInhtbC1zdHJpbmdcIi4uXG4gICAgICBTbyB7YTo0LGI6e2M6NX19IHdpbGwgbG9vayBsaWtlXG4gICAgICA8eSBhPVwiNFwiPlxuICAgICAgICA8YiBjPVwiNVwiPjwvYj5cbiAgICAgIDwveT5cbiAgICAgIG0gLSBsdHggZWxlbWVudFxuICAgICAganNvbiAtIE9iamVjdFxuICAgICovXG4gICAgZW5jb2RlTWVzc2FnZVRvWG1sIChtc2csIG9iaikge1xuICAgICAgLy8gYXR0cmlidXRlcyBpcyBvcHRpb25hbFxuICAgICAgZnVuY3Rpb24gZW5jb2RlT2JqZWN0IChtLCBqc29uKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ganNvbikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGpzb25bbmFtZV1cbiAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3BcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGVuY29kZU9iamVjdChtLmMobmFtZSksIHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBlbmNvZGVBcnJheShtLmMobmFtZSksIHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuY29kZUFycmF5IChtLCBhcnJheSkge1xuICAgICAgICBtLnNldEF0dHJpYnV0ZSgnaXNBcnJheScsICd0cnVlJylcbiAgICAgICAgZm9yICh2YXIgZSBvZiBhcnJheSkge1xuICAgICAgICAgIGlmIChlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGVuY29kZU9iamVjdChtLmMoJ2FycmF5LWVsZW1lbnQnKSwgZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RlQXJyYXkobS5jKCdhcnJheS1lbGVtZW50JyksIGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgZW5jb2RlT2JqZWN0KG1zZy5jKCd5JywgeyB4bWxuczogJ2h0dHA6Ly95Lm5pbmphL2Nvbm5lY3Rvci1zdGFuemEnIH0pLCBvYmopXG4gICAgICB9IGVsc2UgaWYgKG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgZW5jb2RlQXJyYXkobXNnLmMoJ3knLCB7IHhtbG5zOiAnaHR0cDovL3kubmluamEvY29ubmVjdG9yLXN0YW56YScgfSksIG9iailcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkkgY2FuJ3QgZW5jb2RlIHRoaXMganNvbiFcIilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgWS5BYnN0cmFjdENvbm5lY3RvciA9IEFic3RyYWN0Q29ubmVjdG9yXG59XG4iLCIvKiBnbG9iYWwgZ2V0UmFuZG9tLCBhc3luYyAqL1xuJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFkpIHtcbiAgdmFyIGdsb2JhbFJvb20gPSB7XG4gICAgdXNlcnM6IHt9LFxuICAgIGJ1ZmZlcnM6IHt9LCAvLyBUT0RPOiByZWltcGxlbWVudCB0aGlzIGlkZWEuIFRoaXMgZG9lcyBub3QgY292ZXIgYWxsIGNhc2VzISEgSGVyZSwgeW91IGhhdmUgYSBxdWV1ZSB3aGljaCBpcyB1bnJlYWxpc3RpYyAoaS5lLiB0aGluayBhYm91dCBtdWx0aXBsZSBpbmNvbWluZyBjb25uZWN0aW9ucylcbiAgICByZW1vdmVVc2VyOiBmdW5jdGlvbiAodXNlcikge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnVzZXJzKSB7XG4gICAgICAgIHRoaXMudXNlcnNbaV0udXNlckxlZnQodXNlcilcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLnVzZXJzW3VzZXJdXG4gICAgICBkZWxldGUgdGhpcy5idWZmZXJzW3VzZXJdXG4gICAgfSxcbiAgICBhZGRVc2VyOiBmdW5jdGlvbiAoY29ubmVjdG9yKSB7XG4gICAgICB0aGlzLnVzZXJzW2Nvbm5lY3Rvci51c2VySWRdID0gY29ubmVjdG9yXG4gICAgICB0aGlzLmJ1ZmZlcnNbY29ubmVjdG9yLnVzZXJJZF0gPSB7fVxuICAgICAgZm9yICh2YXIgdW5hbWUgaW4gdGhpcy51c2Vycykge1xuICAgICAgICBpZiAodW5hbWUgIT09IGNvbm5lY3Rvci51c2VySWQpIHtcbiAgICAgICAgICB2YXIgdSA9IHRoaXMudXNlcnNbdW5hbWVdXG4gICAgICAgICAgdS51c2VySm9pbmVkKGNvbm5lY3Rvci51c2VySWQsICdtYXN0ZXInKVxuICAgICAgICAgIGNvbm5lY3Rvci51c2VySm9pbmVkKHUudXNlcklkLCAnbWFzdGVyJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgd2hlblRyYW5zYWN0aW9uc0ZpbmlzaGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHMgPSBbXVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnVzZXJzKSB7XG4gICAgICAgIHBzLnB1c2godGhpcy51c2Vyc1tuYW1lXS55LmRiLndoZW5UcmFuc2FjdGlvbnNGaW5pc2hlZCgpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBzKVxuICAgIH0sXG4gICAgZmx1c2hPbmU6IGZ1bmN0aW9uIGZsdXNoT25lICgpIHtcbiAgICAgIHZhciBidWZzID0gW11cbiAgICAgIGZvciAodmFyIHJlY2VpdmVyIGluIGdsb2JhbFJvb20uYnVmZmVycykge1xuICAgICAgICBsZXQgYnVmZiA9IGdsb2JhbFJvb20uYnVmZmVyc1tyZWNlaXZlcl1cbiAgICAgICAgdmFyIHB1c2ggPSBmYWxzZVxuICAgICAgICBmb3IgKGxldCBzZW5kZXIgaW4gYnVmZikge1xuICAgICAgICAgIGlmIChidWZmW3NlbmRlcl0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcHVzaCA9IHRydWVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwdXNoKSB7XG4gICAgICAgICAgYnVmcy5wdXNoKHJlY2VpdmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB1c2VySWQgPSBnZXRSYW5kb20oYnVmcylcbiAgICAgICAgbGV0IGJ1ZmYgPSBnbG9iYWxSb29tLmJ1ZmZlcnNbdXNlcklkXVxuICAgICAgICBsZXQgc2VuZGVyID0gZ2V0UmFuZG9tKE9iamVjdC5rZXlzKGJ1ZmYpKVxuICAgICAgICB2YXIgbSA9IGJ1ZmZbc2VuZGVyXS5zaGlmdCgpXG4gICAgICAgIGlmIChidWZmW3NlbmRlcl0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIGJ1ZmZbc2VuZGVyXVxuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VyID0gZ2xvYmFsUm9vbS51c2Vyc1t1c2VySWRdXG4gICAgICAgIHVzZXIucmVjZWl2ZU1lc3NhZ2UobVswXSwgbVsxXSlcbiAgICAgICAgcmV0dXJuIHVzZXIueS5kYi53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIC8vIGZsdXNoZXMgbWF5IHJlc3VsdCBpbiBtb3JlIGNyZWF0ZWQgb3BlcmF0aW9ucyxcbiAgICAgICAgLy8gZmx1c2ggdW50aWwgdGhlcmUgaXMgbm90aGluZyBtb3JlIHRvIGZsdXNoXG4gICAgICAgIGZ1bmN0aW9uIG5leHRGbHVzaCAoKSB7XG4gICAgICAgICAgdmFyIGMgPSBnbG9iYWxSb29tLmZsdXNoT25lKClcbiAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgd2hpbGUgKGMpIHtcbiAgICAgICAgICAgICAgYyA9IGdsb2JhbFJvb20uZmx1c2hPbmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xvYmFsUm9vbS53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKS50aGVuKG5leHRGbHVzaClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBjID0gZ2xvYmFsUm9vbS5mbHVzaE9uZSgpXG4gICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgYy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGdsb2JhbFJvb20ud2hlblRyYW5zYWN0aW9uc0ZpbmlzaGVkKCkudGhlbihuZXh0Rmx1c2gpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsUm9vbS53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKS50aGVuKG5leHRGbHVzaClcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIFkudXRpbHMuZ2xvYmFsUm9vbSA9IGdsb2JhbFJvb21cblxuICB2YXIgdXNlcklkQ291bnRlciA9IDBcblxuICBjbGFzcyBUZXN0IGV4dGVuZHMgWS5BYnN0cmFjdENvbm5lY3RvciB7XG4gICAgY29uc3RydWN0b3IgKHksIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIG11c3Qgbm90IGJlIHVuZGVmaW5lZCEnKVxuICAgICAgfVxuICAgICAgb3B0aW9ucy5yb2xlID0gJ21hc3RlcidcbiAgICAgIG9wdGlvbnMuZm9yd2FyZFRvU3luY2luZ0NsaWVudHMgPSBmYWxzZVxuICAgICAgc3VwZXIoeSwgb3B0aW9ucylcbiAgICAgIHRoaXMuc2V0VXNlcklkKCh1c2VySWRDb3VudGVyKyspICsgJycpLnRoZW4oKCkgPT4ge1xuICAgICAgICBnbG9iYWxSb29tLmFkZFVzZXIodGhpcylcbiAgICAgIH0pXG4gICAgICB0aGlzLmdsb2JhbFJvb20gPSBnbG9iYWxSb29tXG4gICAgICB0aGlzLnN5bmNpbmdDbGllbnREdXJhdGlvbiA9IDBcbiAgICB9XG4gICAgcmVjZWl2ZU1lc3NhZ2UgKHNlbmRlciwgbSkge1xuICAgICAgc3VwZXIucmVjZWl2ZU1lc3NhZ2Uoc2VuZGVyLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG0pKSlcbiAgICB9XG4gICAgc2VuZCAodXNlcklkLCBtZXNzYWdlKSB7XG4gICAgICB2YXIgYnVmZmVyID0gZ2xvYmFsUm9vbS5idWZmZXJzW3VzZXJJZF1cbiAgICAgIGlmIChidWZmZXIgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYnVmZmVyW3RoaXMudXNlcklkXSA9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVyW3RoaXMudXNlcklkXSA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyW3RoaXMudXNlcklkXS5wdXNoKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoW3RoaXMudXNlcklkLCBtZXNzYWdlXSkpKVxuICAgICAgfVxuICAgIH1cbiAgICBicm9hZGNhc3QgKG1lc3NhZ2UpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBnbG9iYWxSb29tLmJ1ZmZlcnMpIHtcbiAgICAgICAgdmFyIGJ1ZmYgPSBnbG9iYWxSb29tLmJ1ZmZlcnNba2V5XVxuICAgICAgICBpZiAoYnVmZlt0aGlzLnVzZXJJZF0gPT0gbnVsbCkge1xuICAgICAgICAgIGJ1ZmZbdGhpcy51c2VySWRdID0gW11cbiAgICAgICAgfVxuICAgICAgICBidWZmW3RoaXMudXNlcklkXS5wdXNoKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoW3RoaXMudXNlcklkLCBtZXNzYWdlXSkpKVxuICAgICAgfVxuICAgIH1cbiAgICBpc0Rpc2Nvbm5lY3RlZCAoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsUm9vbS51c2Vyc1t0aGlzLnVzZXJJZF0gPT0gbnVsbFxuICAgIH1cbiAgICByZWNvbm5lY3QgKCkge1xuICAgICAgaWYgKHRoaXMuaXNEaXNjb25uZWN0ZWQoKSkge1xuICAgICAgICBnbG9iYWxSb29tLmFkZFVzZXIodGhpcylcbiAgICAgICAgc3VwZXIucmVjb25uZWN0KClcbiAgICAgIH1cbiAgICAgIHJldHVybiBZLnV0aWxzLmdsb2JhbFJvb20uZmx1c2hBbGwoKVxuICAgIH1cbiAgICBkaXNjb25uZWN0ICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0Rpc2Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIGdsb2JhbFJvb20ucmVtb3ZlVXNlcih0aGlzLnVzZXJJZClcbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdCgpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy55LmRiLndoZW5UcmFuc2FjdGlvbnNGaW5pc2hlZCgpXG4gICAgfVxuICAgIGZsdXNoICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgcmV0dXJuIGFzeW5jKGZ1bmN0aW9uICogKCkge1xuICAgICAgICB2YXIgYnVmZiA9IGdsb2JhbFJvb20uYnVmZmVyc1tzZWxmLnVzZXJJZF1cbiAgICAgICAgd2hpbGUgKE9iamVjdC5rZXlzKGJ1ZmYpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgc2VuZGVyID0gZ2V0UmFuZG9tKE9iamVjdC5rZXlzKGJ1ZmYpKVxuICAgICAgICAgIHZhciBtID0gYnVmZltzZW5kZXJdLnNoaWZ0KClcbiAgICAgICAgICBpZiAoYnVmZltzZW5kZXJdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZbc2VuZGVyXVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlKG1bMF0sIG1bMV0pXG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgc2VsZi53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBZLlRlc3QgPSBUZXN0XG59XG4iLCIvKiBAZmxvdyAqL1xuJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFkgLyogOmFueSAqLykge1xuICAvKlxuICAgIFBhcnRpYWwgZGVmaW5pdGlvbiBvZiBhbiBPcGVyYXRpb25TdG9yZS5cbiAgICBUT0RPOiBuYW1lIGl0IERhdGFiYXNlLCBvcGVyYXRpb24gc3RvcmUgb25seSBob2xkcyBvcGVyYXRpb25zLlxuXG4gICAgQSBkYXRhYmFzZSBkZWZpbml0aW9uIG11c3QgYWxzZSBkZWZpbmUgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgICogbG9nVGFibGUoKSAob3B0aW9uYWwpXG4gICAgICAtIHNob3cgcmVsZXZhbnQgaW5mb3JtYXRpb24gaW5mb3JtYXRpb24gaW4gYSB0YWJsZVxuICAgICogcmVxdWVzdFRyYW5zYWN0aW9uKG1ha2VHZW4pXG4gICAgICAtIHJlcXVlc3QgYSB0cmFuc2FjdGlvblxuICAgICogZGVzdHJveSgpXG4gICAgICAtIGRlc3Ryb3kgdGhlIGRhdGFiYXNlXG4gICovXG4gIGNsYXNzIEFic3RyYWN0RGF0YWJhc2Uge1xuICAgIC8qIDo6XG4gICAgeTogWUNvbmZpZztcbiAgICBmb3J3YXJkQXBwbGllZE9wZXJhdGlvbnM6IGJvb2xlYW47XG4gICAgbGlzdGVuZXJzQnlJZDogT2JqZWN0O1xuICAgIGxpc3RlbmVyc0J5SWRFeGVjdXRlTm93OiBBcnJheTxPYmplY3Q+O1xuICAgIGxpc3RlbmVyc0J5SWRSZXF1ZXN0UGVuZGluZzogYm9vbGVhbjtcbiAgICBpbml0aWFsaXplZFR5cGVzOiBPYmplY3Q7XG4gICAgd2hlblVzZXJJZFNldExpc3RlbmVyOiA/RnVuY3Rpb247XG4gICAgd2FpdGluZ1RyYW5zYWN0aW9uczogQXJyYXk8VHJhbnNhY3Rpb24+O1xuICAgIHRyYW5zYWN0aW9uSW5Qcm9ncmVzczogYm9vbGVhbjtcbiAgICBleGVjdXRlT3JkZXI6IEFycmF5PE9iamVjdD47XG4gICAgZ2MxOiBBcnJheTxTdHJ1Y3Q+O1xuICAgIGdjMjogQXJyYXk8U3RydWN0PjtcbiAgICBnY1RpbWVvdXQ6IG51bWJlcjtcbiAgICBnY0ludGVydmFsOiBhbnk7XG4gICAgZ2FyYmFnZUNvbGxlY3Q6IEZ1bmN0aW9uO1xuICAgIGV4ZWN1dGVPcmRlcjogQXJyYXk8YW55PjsgLy8gZm9yIGRlYnVnZ2luZyBvbmx5XG4gICAgdXNlcklkOiBVc2VySWQ7XG4gICAgb3BDbG9jazogbnVtYmVyO1xuICAgIHRyYW5zYWN0aW9uc0ZpbmlzaGVkOiA/e3Byb21pc2U6IFByb21pc2UsIHJlc29sdmU6IGFueX07XG4gICAgdHJhbnNhY3Q6ICh4OiA/R2VuZXJhdG9yKSA9PiBhbnk7XG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvciAoeSwgb3B0cykge1xuICAgICAgdGhpcy55ID0geVxuICAgICAgdmFyIG9zID0gdGhpc1xuICAgICAgdGhpcy51c2VySWQgPSBudWxsXG4gICAgICB2YXIgcmVzb2x2ZVxuICAgICAgdGhpcy51c2VySWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmVzb2x2ZSA9IHJcbiAgICAgIH0pXG4gICAgICB0aGlzLnVzZXJJZFByb21pc2UucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgIC8vIHdoZXRoZXIgdG8gYnJvYWRjYXN0IGFsbCBhcHBsaWVkIG9wZXJhdGlvbnMgKGluc2VydCAmIGRlbGV0ZSBob29rKVxuICAgICAgdGhpcy5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgPSBmYWxzZVxuICAgICAgLy8gRS5nLiB0aGlzLmxpc3RlbmVyc0J5SWRbaWRdIDogQXJyYXk8TGlzdGVuZXI+XG4gICAgICB0aGlzLmxpc3RlbmVyc0J5SWQgPSB7fVxuICAgICAgLy8gRXhlY3V0ZSB0aGUgbmV4dCB0aW1lIGEgdHJhbnNhY3Rpb24gaXMgcmVxdWVzdGVkXG4gICAgICB0aGlzLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93ID0gW11cbiAgICAgIC8vIEEgdHJhbnNhY3Rpb24gaXMgcmVxdWVzdGVkXG4gICAgICB0aGlzLmxpc3RlbmVyc0J5SWRSZXF1ZXN0UGVuZGluZyA9IGZhbHNlXG4gICAgICAvKiBUbyBtYWtlIHRoaW5ncyBtb3JlIGNsZWFyLCB0aGUgZm9sbG93aW5nIG5hbWluZyBjb252ZW50aW9uczpcbiAgICAgICAgICogbHMgOiB3ZSBwdXQgdGhpcy5saXN0ZW5lcnNCeUlkIG9uIGxzXG4gICAgICAgICAqIGwgOiBBcnJheTxMaXN0ZW5lcj5cbiAgICAgICAgICogaWQgOiBJZCAoY2FuJ3QgdXNlIGFzIHByb3BlcnR5IG5hbWUpXG4gICAgICAgICAqIHNpZCA6IFN0cmluZyAoY29udmVydGVkIGZyb20gaWQgdmlhIEpTT04uc3RyaW5naWZ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgc28gd2UgY2FuIHVzZSBpdCBhcyBhIHByb3BlcnR5IG5hbWUpXG5cbiAgICAgICAgQWx3YXlzIHJlbWVtYmVyIHRvIGZpcnN0IG92ZXJ3cml0ZVxuICAgICAgICBhIHByb3BlcnR5IGJlZm9yZSB5b3UgaXRlcmF0ZSBvdmVyIGl0IVxuICAgICAgKi9cbiAgICAgIC8vIFRPRE86IFVzZSBFUzcgV2VhayBNYXBzLiBUaGlzIHdheSB0eXBlcyB0aGF0IGFyZSBubyBsb25nZXIgdXNlcixcbiAgICAgIC8vIHdvbnQgYmUga2VwdCBpbiBtZW1vcnkuXG4gICAgICB0aGlzLmluaXRpYWxpemVkVHlwZXMgPSB7fVxuICAgICAgdGhpcy53YWl0aW5nVHJhbnNhY3Rpb25zID0gW11cbiAgICAgIHRoaXMudHJhbnNhY3Rpb25JblByb2dyZXNzID0gZmFsc2VcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25Jc0ZsdXNoZWQgPSBmYWxzZVxuICAgICAgaWYgKHR5cGVvZiBZQ29uY3VycmVuY3lfVGVzdGluZ01vZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9yZGVyID0gW11cbiAgICAgIH1cbiAgICAgIHRoaXMuZ2MxID0gW10gLy8gZmlyc3Qgc3RhZ2VcbiAgICAgIHRoaXMuZ2MyID0gW10gLy8gc2Vjb25kIHN0YWdlIC0+IGFmdGVyIHRoYXQsIHJlbW92ZSB0aGUgb3BcbiAgICAgIHRoaXMuZ2NUaW1lb3V0ID0gIW9wdHMuZ2NUaW1lb3V0ID8gNTAwMDAgOiBvcHRzLmdjVGltZW91dHNcbiAgICAgIGZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0ICgpIHtcbiAgICAgICAgcmV0dXJuIG9zLndoZW5UcmFuc2FjdGlvbnNGaW5pc2hlZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvcy5nYzEubGVuZ3RoID4gMCB8fCBvcy5nYzIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFvcy55LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdnYyBzaG91bGQgYmUgZW1wdHkgd2hlbiBkaXNjb25uZWN0ZWQhJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBvcy5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9zLnkuY29ubmVjdG9yICE9IG51bGwgJiYgb3MueS5jb25uZWN0b3IuaXNTeW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3MuZ2MyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvaWQgPSBvcy5nYzJbaV1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZ2FyYmFnZUNvbGxlY3RPcGVyYXRpb24ob2lkKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3MuZ2MyID0gb3MuZ2MxXG4gICAgICAgICAgICAgICAgICBvcy5nYzEgPSBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBVc2Ugc2V0SW50ZXJ2YWwgaGVyZSBpbnN0ZWFkICh3aGVuIGdhcmJhZ2VDb2xsZWN0IGlzIGNhbGxlZCBzZXZlcmFsIHRpbWVzIHRoZXJlIHdpbGwgYmUgc2V2ZXJhbCB0aW1lb3V0cy4uKVxuICAgICAgICAgICAgICAgIGlmIChvcy5nY1RpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcy5nY0ludGVydmFsID0gc2V0VGltZW91dChnYXJiYWdlQ29sbGVjdCwgb3MuZ2NUaW1lb3V0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHNlZSBhYm92ZVxuICAgICAgICAgICAgaWYgKG9zLmdjVGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgb3MuZ2NJbnRlcnZhbCA9IHNldFRpbWVvdXQoZ2FyYmFnZUNvbGxlY3QsIG9zLmdjVGltZW91dClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2FyYmFnZUNvbGxlY3QgPSBnYXJiYWdlQ29sbGVjdFxuICAgICAgaWYgKHRoaXMuZ2NUaW1lb3V0ID4gMCkge1xuICAgICAgICBnYXJiYWdlQ29sbGVjdCgpXG4gICAgICB9XG4gICAgfVxuICAgIHF1ZXVlR2FyYmFnZUNvbGxlY3RvciAoaWQpIHtcbiAgICAgIGlmICh0aGlzLnkuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLmdjMS5wdXNoKGlkKVxuICAgICAgfVxuICAgIH1cbiAgICBlbXB0eUdhcmJhZ2VDb2xsZWN0b3IgKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB2YXIgY2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2MxLmxlbmd0aCA+IDAgfHwgdGhpcy5nYzIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdCgpLnRoZW4oY2hlY2spXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KGNoZWNrLCAwKVxuICAgICAgfSlcbiAgICB9XG4gICAgYWRkVG9EZWJ1ZyAoKSB7XG4gICAgICBpZiAodHlwZW9mIFlDb25jdXJyZW5jeV9UZXN0aW5nTW9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGNvbW1hbmQgLyogOnN0cmluZyAqLyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHMpXG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKCcnKS5yZXBsYWNlKC9cIi9nLCBcIidcIikucmVwbGFjZSgvLC9nLCAnLCAnKS5yZXBsYWNlKC86L2csICc6ICcpXG4gICAgICAgIHRoaXMuZXhlY3V0ZU9yZGVyLnB1c2goY29tbWFuZClcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVidWdEYXRhICgpIHtcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuZXhlY3V0ZU9yZGVyLmpvaW4oJ1xcbicpKVxuICAgIH1cbiAgICBzdG9wR2FyYmFnZUNvbGxlY3RvciAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBzZWxmLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICB2YXIgdW5nYyAvKiA6QXJyYXk8U3RydWN0PiAqLyA9IHNlbGYuZ2MxLmNvbmNhdChzZWxmLmdjMilcbiAgICAgICAgICBzZWxmLmdjMSA9IFtdXG4gICAgICAgICAgc2VsZi5nYzIgPSBbXVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5nYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9wID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKHVuZ2NbaV0pXG4gICAgICAgICAgICBpZiAob3AgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWxldGUgb3AuZ2NcbiAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG9wKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICAgIC8qXG4gICAgICBUcnkgdG8gYWRkIHRvIEdDLlxuXG4gICAgICBUT0RPOiByZW5hbWUgdGhpcyBmdW5jdGlvblxuXG4gICAgICBSdWxlejpcbiAgICAgICogT25seSBnYyBpZiB0aGlzIHVzZXIgaXMgb25saW5lXG4gICAgICAqIFRoZSBtb3N0IGxlZnQgZWxlbWVudCBpbiBhIGxpc3QgbXVzdCBub3QgYmUgZ2MnZC5cbiAgICAgICAgPT4gVGhlcmUgaXMgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGxpc3RcblxuICAgICAgcmV0dXJucyB0cnVlIGlmZiBvcCB3YXMgYWRkZWQgdG8gR0NcbiAgICAqL1xuICAgICogYWRkVG9HYXJiYWdlQ29sbGVjdG9yIChvcCwgbGVmdCkge1xuICAgICAgaWYgKFxuICAgICAgICBvcC5nYyA9PSBudWxsICYmXG4gICAgICAgIG9wLmRlbGV0ZWQgPT09IHRydWVcbiAgICAgICkge1xuICAgICAgICB2YXIgZ2MgPSBmYWxzZVxuICAgICAgICBpZiAobGVmdCAhPSBudWxsICYmIGxlZnQuZGVsZXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGdjID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKG9wLmNvbnRlbnQgIT0gbnVsbCAmJiBvcC5jb250ZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBvcCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuU3RhcnQoW29wLmlkWzBdLCBvcC5pZFsxXSArIDFdKVxuICAgICAgICAgIGdjID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChnYykge1xuICAgICAgICAgIG9wLmdjID0gdHJ1ZVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihvcClcbiAgICAgICAgICB0aGlzLnN0b3JlLnF1ZXVlR2FyYmFnZUNvbGxlY3RvcihvcC5pZClcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmVtb3ZlRnJvbUdhcmJhZ2VDb2xsZWN0b3IgKG9wKSB7XG4gICAgICBmdW5jdGlvbiBmaWx0ZXIgKG8pIHtcbiAgICAgICAgcmV0dXJuICFZLnV0aWxzLmNvbXBhcmVJZHMobywgb3AuaWQpXG4gICAgICB9XG4gICAgICB0aGlzLmdjMSA9IHRoaXMuZ2MxLmZpbHRlcihmaWx0ZXIpXG4gICAgICB0aGlzLmdjMiA9IHRoaXMuZ2MyLmZpbHRlcihmaWx0ZXIpXG4gICAgICBkZWxldGUgb3AuZ2NcbiAgICB9XG4gICAgKiBkZXN0cm95ICgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5nY0ludGVydmFsKVxuICAgICAgdGhpcy5nY0ludGVydmFsID0gbnVsbFxuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuaW5pdGlhbGl6ZWRUeXBlcykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuaW5pdGlhbGl6ZWRUeXBlc1trZXldXG4gICAgICAgIGlmICh0eXBlLl9kZXN0cm95ICE9IG51bGwpIHtcbiAgICAgICAgICB0eXBlLl9kZXN0cm95KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgdHlwZSB5b3UgaW5jbHVkZWQgZG9lcyBub3QgcHJvdmlkZSBkZXN0cm95IGZ1bmN0aW9uYWxpdHksIGl0IHdpbGwgcmVtYWluIGluIG1lbW9yeSAodXBkYXRpbmcgeW91ciBwYWNrYWdlcyB3aWxsIGhlbHApLicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VXNlcklkICh1c2VySWQpIHtcbiAgICAgIGlmICghdGhpcy51c2VySWRQcm9taXNlLmluUHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy51c2VySWRQcm9taXNlLmluUHJvZ3Jlc3MgPSB0cnVlXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICBzZWxmLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICBzZWxmLnVzZXJJZCA9IHVzZXJJZFxuICAgICAgICAgIHZhciBzdGF0ZSA9IHlpZWxkKiB0aGlzLmdldFN0YXRlKHVzZXJJZClcbiAgICAgICAgICBzZWxmLm9wQ2xvY2sgPSBzdGF0ZS5jbG9ja1xuICAgICAgICAgIHNlbGYudXNlcklkUHJvbWlzZS5yZXNvbHZlKHVzZXJJZClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnVzZXJJZFByb21pc2VcbiAgICB9XG4gICAgd2hlblVzZXJJZFNldCAoZikge1xuICAgICAgdGhpcy51c2VySWRQcm9taXNlLnRoZW4oZilcbiAgICB9XG4gICAgZ2V0TmV4dE9wSWQgKG51bWJlck9mSWRzKSB7XG4gICAgICBpZiAobnVtYmVyT2ZJZHMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldE5leHRPcElkIGV4cGVjdHMgdGhlIG51bWJlciBvZiBjcmVhdGVkIGlkcyB0byBjcmVhdGUhJylcbiAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VySWQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvblN0b3JlIG5vdCB5ZXQgaW5pdGlhbGl6ZWQhJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZCA9IFt0aGlzLnVzZXJJZCwgdGhpcy5vcENsb2NrXVxuICAgICAgICB0aGlzLm9wQ2xvY2sgKz0gbnVtYmVyT2ZJZHNcbiAgICAgICAgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICBBcHBseSBhIGxpc3Qgb2Ygb3BlcmF0aW9ucy5cblxuICAgICAgKiBnZXQgYSB0cmFuc2FjdGlvblxuICAgICAgKiBjaGVjayB3aGV0aGVyIGFsbCBTdHJ1Y3QuKi5yZXF1aXJlZE9wcyBhcmUgaW4gdGhlIE9TXG4gICAgICAqIGNoZWNrIGlmIGl0IGlzIGFuIGV4cGVjdGVkIG9wIChvdGhlcndpc2Ugd2FpdCBmb3IgaXQpXG4gICAgICAqIGNoZWNrIGlmIHdhcyBkZWxldGVkLCBhcHBseSBhIGRlbGV0ZSBvcGVyYXRpb24gYWZ0ZXIgb3Agd2FzIGFwcGxpZWRcbiAgICAqL1xuICAgIGFwcGx5IChvcHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvID0gb3BzW2ldXG4gICAgICAgIGlmIChvLmlkID09IG51bGwgfHwgby5pZFswXSAhPT0gdGhpcy55LmNvbm5lY3Rvci51c2VySWQpIHtcbiAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBZLlN0cnVjdFtvLnN0cnVjdF0ucmVxdWlyZWRPcHMobylcbiAgICAgICAgICBpZiAoby5yZXF1aXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXF1aXJlZCA9IHJlcXVpcmVkLmNvbmNhdChvLnJlcXVpcmVzKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndoZW5PcGVyYXRpb25zRXhpc3QocmVxdWlyZWQsIG8pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgIG9wIGlzIGV4ZWN1dGVkIGFzIHNvb24gYXMgZXZlcnkgb3BlcmF0aW9uIHJlcXVlc3RlZCBpcyBhdmFpbGFibGUuXG4gICAgICBOb3RlIHRoYXQgVHJhbnNhY3Rpb24gY2FuIChhbmQgc2hvdWxkKSBidWZmZXIgcmVxdWVzdHMuXG4gICAgKi9cbiAgICB3aGVuT3BlcmF0aW9uc0V4aXN0IChpZHMsIG9wKSB7XG4gICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICAgIG9wOiBvcCxcbiAgICAgICAgICBtaXNzaW5nOiBpZHMubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBpZCA9IGlkc1tpXVxuICAgICAgICAgIGxldCBzaWQgPSBKU09OLnN0cmluZ2lmeShpZClcbiAgICAgICAgICBsZXQgbCA9IHRoaXMubGlzdGVuZXJzQnlJZFtzaWRdXG4gICAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgbCA9IFtdXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc0J5SWRbc2lkXSA9IGxcbiAgICAgICAgICB9XG4gICAgICAgICAgbC5wdXNoKGxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93LnB1c2goe1xuICAgICAgICAgIG9wOiBvcFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnNCeUlkUmVxdWVzdFBlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMubGlzdGVuZXJzQnlJZFJlcXVlc3RQZW5kaW5nID0gdHJ1ZVxuICAgICAgdmFyIHN0b3JlID0gdGhpc1xuXG4gICAgICB0aGlzLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgdmFyIGV4ZU5vdyA9IHN0b3JlLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93XG4gICAgICAgIHN0b3JlLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93ID0gW11cblxuICAgICAgICB2YXIgbHMgPSBzdG9yZS5saXN0ZW5lcnNCeUlkXG4gICAgICAgIHN0b3JlLmxpc3RlbmVyc0J5SWQgPSB7fVxuXG4gICAgICAgIHN0b3JlLmxpc3RlbmVyc0J5SWRSZXF1ZXN0UGVuZGluZyA9IGZhbHNlXG5cbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgZXhlTm93Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBsZXQgbyA9IGV4ZU5vd1trZXldLm9wXG4gICAgICAgICAgeWllbGQqIHN0b3JlLnRyeUV4ZWN1dGUuY2FsbCh0aGlzLCBvKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgc2lkIGluIGxzKSB7XG4gICAgICAgICAgdmFyIGwgPSBsc1tzaWRdXG4gICAgICAgICAgdmFyIGlkID0gSlNPTi5wYXJzZShzaWQpXG4gICAgICAgICAgdmFyIG9wXG4gICAgICAgICAgaWYgKHR5cGVvZiBpZFsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKGlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihpZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0b3JlLmxpc3RlbmVyc0J5SWRbc2lkXSA9IGxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBsaXN0ZW5lciA9IGxbaV1cbiAgICAgICAgICAgICAgbGV0IG8gPSBsaXN0ZW5lci5vcFxuICAgICAgICAgICAgICBpZiAoLS1saXN0ZW5lci5taXNzaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHN0b3JlLnRyeUV4ZWN1dGUuY2FsbCh0aGlzLCBvKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICAvKlxuICAgICAgQWN0dWFsbHkgZXhlY3V0ZSBhbiBvcGVyYXRpb24sIHdoZW4gYWxsIGV4cGVjdGVkIG9wZXJhdGlvbnMgYXJlIGF2YWlsYWJsZS5cbiAgICAqL1xuICAgIC8qIDo6IC8vIFRPRE86IHRoaXMgYmVsb25ncyBzb21laG93IHRvIHRyYW5zYWN0aW9uXG4gICAgc3RvcmU6IE9iamVjdDtcbiAgICBnZXRPcGVyYXRpb246IGFueTtcbiAgICBpc0dhcmJhZ2VDb2xsZWN0ZWQ6IGFueTtcbiAgICBhZGRPcGVyYXRpb246IGFueTtcbiAgICB3aGVuT3BlcmF0aW9uc0V4aXN0OiBhbnk7XG4gICAgKi9cbiAgICAqIHRyeUV4ZWN1dGUgKG9wKSB7XG4gICAgICB0aGlzLnN0b3JlLmFkZFRvRGVidWcoJ3lpZWxkKiB0aGlzLnN0b3JlLnRyeUV4ZWN1dGUuY2FsbCh0aGlzLCAnLCBKU09OLnN0cmluZ2lmeShvcCksICcpJylcbiAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgIHlpZWxkKiBZLlN0cnVjdC5EZWxldGUuZXhlY3V0ZS5jYWxsKHRoaXMsIG9wKVxuICAgICAgICAvLyB0aGlzIGlzIG5vdyBjYWxsZWQgaW4gVHJhbnNhY3Rpb24uZGVsZXRlT3BlcmF0aW9uIVxuICAgICAgICAvLyB5aWVsZCogdGhpcy5zdG9yZS5vcGVyYXRpb25BZGRlZCh0aGlzLCBvcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgb3Agd2FzIGRlZmluZWRcbiAgICAgICAgdmFyIGRlZmluZWQgPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb24ob3AuaWQpXG4gICAgICAgIHdoaWxlIChkZWZpbmVkICE9IG51bGwgJiYgZGVmaW5lZC5jb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIG9wIGhhcyBhIGxvbmdlciBjb250ZW50IGluIHRoZSBjYXNlIGl0IGlzIGRlZmluZWRcbiAgICAgICAgICBpZiAoZGVmaW5lZC5pZFsxXSArIGRlZmluZWQuY29udGVudC5sZW5ndGggPCBvcC5pZFsxXSArIG9wLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcFNpemUgPSBkZWZpbmVkLmNvbnRlbnQubGVuZ3RoIC0gKG9wLmlkWzFdIC0gZGVmaW5lZC5pZFsxXSlcbiAgICAgICAgICAgIG9wLmNvbnRlbnQuc3BsaWNlKDAsIG92ZXJsYXBTaXplKVxuICAgICAgICAgICAgb3AuaWQgPSBbb3AuaWRbMF0sIG9wLmlkWzFdICsgb3ZlcmxhcFNpemVdXG4gICAgICAgICAgICBvcC5sZWZ0ID0gWS51dGlscy5nZXRMYXN0SWQoZGVmaW5lZClcbiAgICAgICAgICAgIG9wLm9yaWdpbiA9IG9wLmxlZnRcbiAgICAgICAgICAgIGRlZmluZWQgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24ob3AuaWQpIC8vIGdldE9wZXJhdGlvbiBzdWZmaWNlcyBoZXJlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZpbmVkID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaXNHYXJiYWdlQ29sbGVjdGVkID0geWllbGQqIHRoaXMuaXNHYXJiYWdlQ29sbGVjdGVkKG9wLmlkKVxuICAgICAgICAgIGlmICghaXNHYXJiYWdlQ29sbGVjdGVkKSB7XG4gICAgICAgICAgICB5aWVsZCogWS5TdHJ1Y3Rbb3Auc3RydWN0XS5leGVjdXRlLmNhbGwodGhpcywgb3ApXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5hZGRPcGVyYXRpb24ob3ApXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5zdG9yZS5vcGVyYXRpb25BZGRlZCh0aGlzLCBvcClcblxuICAgICAgICAgICAgLy8gaWYgaW5zZXJ0aW9uLCB0cnkgdG8gY29tYmluZSB3aXRoIGxlZnRcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnRyeUNvbWJpbmVXaXRoTGVmdChvcClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBDYWxsZWQgYnkgYSB0cmFuc2FjdGlvbiB3aGVuIGFuIG9wZXJhdGlvbiBpcyBhZGRlZC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGVzcGVjaWFsbHkgaW1wb3J0YW50IGZvciB5LWluZGV4ZWRkYiwgd2hlcmUgc2V2ZXJhbCBpbnN0YW5jZXMgbWF5IHNoYXJlIGEgc2luZ2xlIGRhdGFiYXNlLlxuICAgICAqIEV2ZXJ5IHRpbWUgYW4gb3BlcmF0aW9uIGlzIGNyZWF0ZWQgYnkgb25lIGluc3RhbmNlLCBpdCBpcyBzZW5kIHRvIGFsbCBvdGhlciBpbnN0YW5jZXMgYW5kIG9wZXJhdGlvbkFkZGVkIGlzIGNhbGxlZFxuICAgICAqXG4gICAgICogSWYgaXQncyBub3QgYSBEZWxldGUgb3BlcmF0aW9uOlxuICAgICAqICAgKiBDaGVja3MgaWYgYW5vdGhlciBvcGVyYXRpb24gaXMgZXhlY3V0YWJsZSAobGlzdGVuZXJzQnlJZClcbiAgICAgKiAgICogVXBkYXRlIHN0YXRlLCBpZiBwb3NzaWJsZVxuICAgICAqXG4gICAgICogQWx3YXlzOlxuICAgICAqICAgKiBDYWxsIHR5cGVcbiAgICAgKi9cbiAgICAqIG9wZXJhdGlvbkFkZGVkICh0cmFuc2FjdGlvbiwgb3ApIHtcbiAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB5aWVsZCogdHJhbnNhY3Rpb24uZ2V0SW5zZXJ0aW9uKG9wLnRhcmdldClcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmluaXRpYWxpemVkVHlwZXNbSlNPTi5zdHJpbmdpZnkodGFyZ2V0LnBhcmVudCldXG4gICAgICAgIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICB5aWVsZCogdHlwZS5fY2hhbmdlZCh0cmFuc2FjdGlvbiwgb3ApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluY3JlYXNlIFNTXG4gICAgICAgIHlpZWxkKiB0cmFuc2FjdGlvbi51cGRhdGVTdGF0ZShvcC5pZFswXSlcbiAgICAgICAgdmFyIG9wTGVuID0gb3AuY29udGVudCAhPSBudWxsID8gb3AuY29udGVudC5sZW5ndGggOiAxXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BMZW47IGkrKykge1xuICAgICAgICAgIC8vIG5vdGlmeSB3aGVuT3BlcmF0aW9uIGxpc3RlbmVycyAoYnkgaWQpXG4gICAgICAgICAgdmFyIHNpZCA9IEpTT04uc3RyaW5naWZ5KFtvcC5pZFswXSwgb3AuaWRbMV0gKyBpXSlcbiAgICAgICAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzQnlJZFtzaWRdXG4gICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzQnlJZFtzaWRdXG4gICAgICAgICAgaWYgKGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGwpIHtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbFtrZXldXG4gICAgICAgICAgICAgIGlmICgtLWxpc3RlbmVyLm1pc3NpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLndoZW5PcGVyYXRpb25zRXhpc3QoW10sIGxpc3RlbmVyLm9wKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gdGhpcy5pbml0aWFsaXplZFR5cGVzW0pTT04uc3RyaW5naWZ5KG9wLnBhcmVudCldXG5cbiAgICAgICAgLy8gaWYgcGFyZW50IGlzIGRlbGV0ZWQsIG1hcmsgYXMgZ2MnZCBhbmQgcmV0dXJuXG4gICAgICAgIGlmIChvcC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBwYXJlbnRJc0RlbGV0ZWQgPSB5aWVsZCogdHJhbnNhY3Rpb24uaXNEZWxldGVkKG9wLnBhcmVudClcbiAgICAgICAgICBpZiAocGFyZW50SXNEZWxldGVkKSB7XG4gICAgICAgICAgICB5aWVsZCogdHJhbnNhY3Rpb24uZGVsZXRlTGlzdChvcC5pZClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGlmeSBwYXJlbnQsIGlmIGl0IHdhcyBpbnN0YW5jaWF0ZWQgYXMgYSBjdXN0b20gdHlwZVxuICAgICAgICBpZiAodCAhPSBudWxsKSB7XG4gICAgICAgICAgbGV0IG8gPSBZLnV0aWxzLmNvcHlPcGVyYXRpb24ob3ApXG4gICAgICAgICAgeWllbGQqIHQuX2NoYW5nZWQodHJhbnNhY3Rpb24sIG8pXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcC5kZWxldGVkKSB7XG4gICAgICAgICAgLy8gRGVsZXRlIGlmIERTIHNheXMgdGhpcyBpcyBhY3R1YWxseSBkZWxldGVkXG4gICAgICAgICAgdmFyIGxlbiA9IG9wLmNvbnRlbnQgIT0gbnVsbCA/IG9wLmNvbnRlbnQubGVuZ3RoIDogMVxuICAgICAgICAgIHZhciBzdGFydElkID0gb3AuaWQgLy8gWW91IG11c3Qgbm90IHVzZSBvcC5pZCBpbiB0aGUgZm9sbG93aW5nIGxvb3AsIGJlY2F1c2Ugb3Agd2lsbCBjaGFuZ2Ugd2hlbiBkZWxldGVkXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gW3N0YXJ0SWRbMF0sIHN0YXJ0SWRbMV0gKyBpXVxuICAgICAgICAgICAgdmFyIG9wSXNEZWxldGVkID0geWllbGQqIHRyYW5zYWN0aW9uLmlzRGVsZXRlZChpZClcbiAgICAgICAgICAgIGlmIChvcElzRGVsZXRlZCkge1xuICAgICAgICAgICAgICB2YXIgZGVsb3AgPSB7XG4gICAgICAgICAgICAgICAgc3RydWN0OiAnRGVsZXRlJyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeWllbGQqIHRoaXMudHJ5RXhlY3V0ZS5jYWxsKHRyYW5zYWN0aW9uLCBkZWxvcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd2hlblRyYW5zYWN0aW9uc0ZpbmlzaGVkICgpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbnNGaW5pc2hlZCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmVcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXNvbHZlID0gclxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNGaW5pc2hlZCA9IHtcbiAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zRmluaXNoZWQucHJvbWlzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYW5vdGhlciB0cmFuc2FjdGlvbiByZXF1ZXN0LlxuICAgIC8vICogdGhlIGxhc3QgdHJhbnNhY3Rpb24gaXMgYWx3YXlzIGEgZmx1c2ggOilcbiAgICBnZXROZXh0UmVxdWVzdCAoKSB7XG4gICAgICBpZiAodGhpcy53YWl0aW5nVHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbklzRmx1c2hlZCkge1xuICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25JblByb2dyZXNzID0gZmFsc2VcbiAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uSXNGbHVzaGVkID0gZmFsc2VcbiAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbnNGaW5pc2hlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc0ZpbmlzaGVkLnJlc29sdmUoKVxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNGaW5pc2hlZCA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uSXNGbHVzaGVkID0gdHJ1ZVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25Jc0ZsdXNoZWQgPSBmYWxzZVxuICAgICAgICByZXR1cm4gdGhpcy53YWl0aW5nVHJhbnNhY3Rpb25zLnNoaWZ0KClcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFRyYW5zYWN0aW9uIChtYWtlR2VuLyogOmFueSAqLywgY2FsbEltbWVkaWF0ZWx5KSB7XG4gICAgICB0aGlzLndhaXRpbmdUcmFuc2FjdGlvbnMucHVzaChtYWtlR2VuKVxuICAgICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uSW5Qcm9ncmVzcyA9IHRydWVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmFuc2FjdCh0aGlzLmdldE5leHRSZXF1ZXN0KCkpXG4gICAgICAgIH0sIDApXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFkuQWJzdHJhY3REYXRhYmFzZSA9IEFic3RyYWN0RGF0YWJhc2Vcbn1cbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuLypcbiBBbiBvcGVyYXRpb24gYWxzbyBkZWZpbmVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSB0eXBlLiBUaGlzIGlzIHdoeSBvcGVyYXRpb24gYW5kXG4gc3RydWN0dXJlIGFyZSB1c2VkIGludGVyY2hhbmdlYWJseSBoZXJlLlxuXG4gSXQgbXVzdCBiZSBvZiB0aGUgdHlwZSBPYmplY3QuIEkgaG9wZSB0byBhY2hpZXZlIHNvbWUgcGVyZm9ybWFuY2VcbiBpbXByb3ZlbWVudHMgd2hlbiB3b3JraW5nIG9uIGRhdGFiYXNlcyB0aGF0IHN1cHBvcnQgdGhlIGpzb24gZm9ybWF0LlxuXG4gQW4gb3BlcmF0aW9uIG11c3QgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbiAqIGVuY29kZVxuICAgICAtIEVuY29kZSB0aGUgc3RydWN0dXJlIGluIGEgcmVhZGFibGUgZm9ybWF0IChwcmVmZXJhYmx5IHN0cmluZy0gdG9kbylcbiAqIGRlY29kZSAodG9kbylcbiAgICAgLSBkZWNvZGUgc3RydWN0dXJlIHRvIGpzb25cbiAqIGV4ZWN1dGVcbiAgICAgLSBFeGVjdXRlIHRoZSBzZW1hbnRpY3Mgb2YgYW4gb3BlcmF0aW9uLlxuICogcmVxdWlyZWRPcHNcbiAgICAgLSBPcGVyYXRpb25zIHRoYXQgYXJlIHJlcXVpcmVkIHRvIGV4ZWN1dGUgdGhpcyBvcGVyYXRpb24uXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWS8qIDphbnkgKi8pIHtcbiAgdmFyIFN0cnVjdCA9IHtcbiAgICAvKiBUaGlzIGlzIHRoZSBvbmx5IG9wZXJhdGlvbiB0aGF0IGlzIGFjdHVhbGx5IG5vdCBhIHN0cnVjdHVyZSwgYmVjYXVzZVxuICAgIGl0IGlzIG5vdCBzdG9yZWQgaW4gdGhlIE9TLiBUaGlzIGlzIHdoeSBpdCBfZG9lcyBub3RfIGhhdmUgYW4gaWRcblxuICAgIG9wID0ge1xuICAgICAgdGFyZ2V0OiBJZFxuICAgIH1cbiAgICAqL1xuICAgIERlbGV0ZToge1xuICAgICAgZW5jb2RlOiBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIG9wXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWRPcHM6IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICByZXR1cm4gW10gLy8gW29wLnRhcmdldF1cbiAgICAgIH0sXG4gICAgICBleGVjdXRlOiBmdW5jdGlvbiAqIChvcCkge1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZGVsZXRlT3BlcmF0aW9uKG9wLnRhcmdldCwgb3AubGVuZ3RoIHx8IDEpXG4gICAgICB9XG4gICAgfSxcbiAgICBJbnNlcnQ6IHtcbiAgICAgIC8qIHtcbiAgICAgICAgICBjb250ZW50OiBbYW55XSxcbiAgICAgICAgICBvcENvbnRlbnQ6IElkLFxuICAgICAgICAgIGlkOiBJZCxcbiAgICAgICAgICBsZWZ0OiBJZCxcbiAgICAgICAgICBvcmlnaW46IElkLFxuICAgICAgICAgIHJpZ2h0OiBJZCxcbiAgICAgICAgICBwYXJlbnQ6IElkLFxuICAgICAgICAgIHBhcmVudFN1Yjogc3RyaW5nIChvcHRpb25hbCksIC8vIGNoaWxkIG9mIE1hcCB0eXBlXG4gICAgICAgIH1cbiAgICAgICovXG4gICAgICBlbmNvZGU6IGZ1bmN0aW9uIChvcC8qIDpJbnNlcnRpb24gKi8pIC8qIDpJbnNlcnRpb24gKi8ge1xuICAgICAgICAvLyBUT0RPOiB5b3UgY291bGQgbm90IHNlbmQgdGhlIFwibGVmdFwiIHByb3BlcnR5LCB0aGVuIHlvdSBhbHNvIGhhdmUgdG9cbiAgICAgICAgLy8gXCJvcC5sZWZ0ID0gbnVsbFwiIGluICRleGVjdXRlIG9yICRkZWNvZGVcbiAgICAgICAgdmFyIGUvKiA6YW55ICovID0ge1xuICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICBsZWZ0OiBvcC5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBvcC5yaWdodCxcbiAgICAgICAgICBvcmlnaW46IG9wLm9yaWdpbixcbiAgICAgICAgICBwYXJlbnQ6IG9wLnBhcmVudCxcbiAgICAgICAgICBzdHJ1Y3Q6IG9wLnN0cnVjdFxuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5wYXJlbnRTdWIgIT0gbnVsbCkge1xuICAgICAgICAgIGUucGFyZW50U3ViID0gb3AucGFyZW50U3ViXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLmhhc093blByb3BlcnR5KCdvcENvbnRlbnQnKSkge1xuICAgICAgICAgIGUub3BDb250ZW50ID0gb3Aub3BDb250ZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZS5jb250ZW50ID0gb3AuY29udGVudC5zbGljZSgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkT3BzOiBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgdmFyIGlkcyA9IFtdXG4gICAgICAgIGlmIChvcC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICBpZHMucHVzaChvcC5sZWZ0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgaWRzLnB1c2gob3AucmlnaHQpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLm9yaWdpbiAhPSBudWxsICYmICFZLnV0aWxzLmNvbXBhcmVJZHMob3AubGVmdCwgb3Aub3JpZ2luKSkge1xuICAgICAgICAgIGlkcy5wdXNoKG9wLm9yaWdpbilcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAob3AucmlnaHQgPT0gbnVsbCAmJiBvcC5sZWZ0ID09IG51bGwpIHtcbiAgICAgICAgaWRzLnB1c2gob3AucGFyZW50KVxuXG4gICAgICAgIGlmIChvcC5vcENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlkcy5wdXNoKG9wLm9wQ29udGVudClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzXG4gICAgICB9LFxuICAgICAgZ2V0RGlzdGFuY2VUb09yaWdpbjogZnVuY3Rpb24gKiAob3ApIHtcbiAgICAgICAgaWYgKG9wLmxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSAwXG4gICAgICAgICAgdmFyIG8gPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb24ob3AubGVmdClcbiAgICAgICAgICB3aGlsZSAoIVkudXRpbHMubWF0Y2hlc0lkKG8sIG9wLm9yaWdpbikpIHtcbiAgICAgICAgICAgIGQrK1xuICAgICAgICAgICAgaWYgKG8ubGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG8ubGVmdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qXG4gICAgICAjICR0aGlzIGhhcyB0byBmaW5kIGEgdW5pcXVlIHBvc2l0aW9uIGJldHdlZW4gb3JpZ2luIGFuZCB0aGUgbmV4dCBrbm93biBjaGFyYWN0ZXJcbiAgICAgICMgY2FzZSAxOiAkb3JpZ2luIGVxdWFscyAkby5vcmlnaW46IHRoZSAkY3JlYXRvciBwYXJhbWV0ZXIgZGVjaWRlcyBpZiBsZWZ0IG9yIHJpZ2h0XG4gICAgICAjICAgICAgICAgbGV0ICRPTD0gW28xLG8yLG8zLG80XSwgd2hlcmVieSAkdGhpcyBpcyB0byBiZSBpbnNlcnRlZCBiZXR3ZWVuIG8xIGFuZCBvNFxuICAgICAgIyAgICAgICAgIG8yLG8zIGFuZCBvNCBvcmlnaW4gaXMgMSAodGhlIHBvc2l0aW9uIG9mIG8yKVxuICAgICAgIyAgICAgICAgIHRoZXJlIGlzIHRoZSBjYXNlIHRoYXQgJHRoaXMuY3JlYXRvciA8IG8yLmNyZWF0b3IsIGJ1dCBvMy5jcmVhdG9yIDwgJHRoaXMuY3JlYXRvclxuICAgICAgIyAgICAgICAgIHRoZW4gbzIga25vd3MgbzMuIFNpbmNlIG9uIGFub3RoZXIgY2xpZW50ICRPTCBjb3VsZCBiZSBbbzEsbzMsbzRdIHRoZSBwcm9ibGVtIGlzIGNvbXBsZXhcbiAgICAgICMgICAgICAgICB0aGVyZWZvcmUgJHRoaXMgd291bGQgYmUgYWx3YXlzIHRvIHRoZSByaWdodCBvZiBvM1xuICAgICAgIyBjYXNlIDI6ICRvcmlnaW4gPCAkby5vcmlnaW5cbiAgICAgICMgICAgICAgICBpZiBjdXJyZW50ICR0aGlzIGluc2VydF9wb3NpdGlvbiA+ICRvIG9yaWdpbjogJHRoaXMgaW5zXG4gICAgICAjICAgICAgICAgZWxzZSAkaW5zZXJ0X3Bvc2l0aW9uIHdpbGwgbm90IGNoYW5nZVxuICAgICAgIyAgICAgICAgIChtYXliZSB3ZSBlbmNvdW50ZXIgY2FzZSAxIGxhdGVyLCB0aGVuIHRoaXMgd2lsbCBiZSB0byB0aGUgcmlnaHQgb2YgJG8pXG4gICAgICAjIGNhc2UgMzogJG9yaWdpbiA+ICRvLm9yaWdpblxuICAgICAgIyAgICAgICAgICR0aGlzIGluc2VydF9wb3NpdGlvbiBpcyB0byB0aGUgbGVmdCBvZiAkbyAoZm9yZXZlciEpXG4gICAgICAqL1xuICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKiAob3ApIHtcbiAgICAgICAgdmFyIGkgLy8gbG9vcCBjb3VudGVyXG5cbiAgICAgICAgLy8gZHVyaW5nIHRoaXMgZnVuY3Rpb24gc29tZSBvcHMgbWF5IGdldCBzcGxpdCBpbnRvIHR3byBwaWVjZXMgKGUuZy4gd2l0aCBnZXRJbnNlcnRpb25DbGVhbkVuZClcbiAgICAgICAgLy8gV2UgdHJ5IHRvIG1lcmdlIHRoZW0gbGF0ZXIsIGlmIHBvc3NpYmxlXG4gICAgICAgIHZhciB0cnlUb1JlbWVyZ2VMYXRlciA9IFtdXG5cbiAgICAgICAgaWYgKG9wLm9yaWdpbiAhPSBudWxsKSB7IC8vIFRPRE86ICE9PSBpbnN0ZWFkIG9mICE9XG4gICAgICAgICAgLy8gd2Ugc2F2ZSBpbiBvcmlnaW4gdGhhdCBvcCBvcmlnaW5hdGVzIGluIGl0XG4gICAgICAgICAgLy8gd2UgbmVlZCB0aGF0IGxhdGVyIHdoZW4gd2UgZXZlbnR1YWxseSBnYXJiYWdlIGNvbGxlY3Qgb3JpZ2luIChzZWUgdHJhbnNhY3Rpb24pXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuRW5kKG9wLm9yaWdpbilcbiAgICAgICAgICBpZiAob3JpZ2luLm9yaWdpbk9mID09IG51bGwpIHtcbiAgICAgICAgICAgIG9yaWdpbi5vcmlnaW5PZiA9IFtdXG4gICAgICAgICAgfVxuICAgICAgICAgIG9yaWdpbi5vcmlnaW5PZi5wdXNoKG9wLmlkKVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihvcmlnaW4pXG4gICAgICAgICAgaWYgKG9yaWdpbi5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnlUb1JlbWVyZ2VMYXRlci5wdXNoKG9yaWdpbi5yaWdodClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpc3RhbmNlVG9PcmlnaW4gPSBpID0geWllbGQqIFN0cnVjdC5JbnNlcnQuZ2V0RGlzdGFuY2VUb09yaWdpbi5jYWxsKHRoaXMsIG9wKSAvLyBtb3N0IGNhc2VzOiAwIChzdGFydHMgZnJvbSAwKVxuXG4gICAgICAgIC8vIG5vdyB3ZSBiZWdpbiB0byBpbnNlcnQgb3AgaW4gdGhlIGxpc3Qgb2YgaW5zZXJ0aW9ucy4uXG4gICAgICAgIHZhciBvXG4gICAgICAgIHZhciBwYXJlbnRcbiAgICAgICAgdmFyIHN0YXJ0XG5cbiAgICAgICAgLy8gZmluZCBvLiBvIGlzIHRoZSBmaXJzdCBjb25mbGljdGluZyBvcGVyYXRpb25cbiAgICAgICAgaWYgKG9wLmxlZnQgIT0gbnVsbCkge1xuICAgICAgICAgIG8gPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb25DbGVhbkVuZChvcC5sZWZ0KVxuICAgICAgICAgIGlmICghWS51dGlscy5jb21wYXJlSWRzKG9wLmxlZnQsIG9wLm9yaWdpbikgJiYgby5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGlmIG5vdCBhZGRlZCBwcmV2aW91c2x5XG4gICAgICAgICAgICB0cnlUb1JlbWVyZ2VMYXRlci5wdXNoKG8ucmlnaHQpXG4gICAgICAgICAgfVxuICAgICAgICAgIG8gPSAoby5yaWdodCA9PSBudWxsKSA/IG51bGwgOiB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5yaWdodClcbiAgICAgICAgfSBlbHNlIHsgLy8gbGVmdCA9PSBudWxsXG4gICAgICAgICAgcGFyZW50ID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKG9wLnBhcmVudClcbiAgICAgICAgICBsZXQgc3RhcnRJZCA9IG9wLnBhcmVudFN1YiA/IHBhcmVudC5tYXBbb3AucGFyZW50U3ViXSA6IHBhcmVudC5zdGFydFxuICAgICAgICAgIHN0YXJ0ID0gc3RhcnRJZCA9PSBudWxsID8gbnVsbCA6IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihzdGFydElkKVxuICAgICAgICAgIG8gPSBzdGFydFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHNwbGl0IG9wLnJpZ2h0IGlmIG5lY2Vzc2FyeSAoYWxzbyBhZGQgdG8gdHJ5Q29tYmluZVdpdGhMZWZ0KVxuICAgICAgICBpZiAob3AucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgIHRyeVRvUmVtZXJnZUxhdGVyLnB1c2gob3AucmlnaHQpXG4gICAgICAgICAgeWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uQ2xlYW5TdGFydChvcC5yaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBjb25mbGljdHNcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAobyAhPSBudWxsICYmICFZLnV0aWxzLmNvbXBhcmVJZHMoby5pZCwgb3AucmlnaHQpKSB7XG4gICAgICAgICAgICB2YXIgb09yaWdpbkRpc3RhbmNlID0geWllbGQqIFN0cnVjdC5JbnNlcnQuZ2V0RGlzdGFuY2VUb09yaWdpbi5jYWxsKHRoaXMsIG8pXG4gICAgICAgICAgICBpZiAob09yaWdpbkRpc3RhbmNlID09PSBpKSB7XG4gICAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgICBpZiAoby5pZFswXSA8IG9wLmlkWzBdKSB7XG4gICAgICAgICAgICAgICAgb3AubGVmdCA9IFkudXRpbHMuZ2V0TGFzdElkKG8pXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VUb09yaWdpbiA9IGkgKyAxIC8vIGp1c3QgaWdub3JlIG8uY29udGVudC5sZW5ndGgsIGRvZXNuJ3QgbWFrZSBhIGRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvT3JpZ2luRGlzdGFuY2UgPCBpKSB7XG4gICAgICAgICAgICAgIC8vIGNhc2UgMlxuICAgICAgICAgICAgICBpZiAoaSAtIGRpc3RhbmNlVG9PcmlnaW4gPD0gb09yaWdpbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgb3AubGVmdCA9IFkudXRpbHMuZ2V0TGFzdElkKG8pXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VUb09yaWdpbiA9IGkgKyAxIC8vIGp1c3QgaWdub3JlIG8uY29udGVudC5sZW5ndGgsIGRvZXNuJ3QgbWFrZSBhIGRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgaWYgKG8ucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG8ucmlnaHQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY29ubmVjdC4uXG4gICAgICAgIHZhciBsZWZ0ID0gbnVsbFxuICAgICAgICB2YXIgcmlnaHQgPSBudWxsXG4gICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihvcC5wYXJlbnQpXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWNvbm5lY3QgbGVmdCBhbmQgc2V0IHJpZ2h0IG9mIG9wXG4gICAgICAgIGlmIChvcC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICBsZWZ0ID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG9wLmxlZnQpXG4gICAgICAgICAgLy8gbGluayBsZWZ0XG4gICAgICAgICAgb3AucmlnaHQgPSBsZWZ0LnJpZ2h0XG4gICAgICAgICAgbGVmdC5yaWdodCA9IG9wLmlkXG5cbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24obGVmdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZXQgb3AucmlnaHQgZnJvbSBwYXJlbnQsIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIG9wLnJpZ2h0ID0gb3AucGFyZW50U3ViID8gcGFyZW50Lm1hcFtvcC5wYXJlbnRTdWJdIHx8IG51bGwgOiBwYXJlbnQuc3RhcnRcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNvbm5lY3QgcmlnaHRcbiAgICAgICAgaWYgKG9wLnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiB3YW5uYSBjb25uZWN0IHJpZ2h0IHRvbz9cbiAgICAgICAgICByaWdodCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihvcC5yaWdodClcbiAgICAgICAgICByaWdodC5sZWZ0ID0gWS51dGlscy5nZXRMYXN0SWQob3ApXG5cbiAgICAgICAgICAvLyBpZiByaWdodCBleGlzdHMsIGFuZCBpdCBpcyBzdXBwb3NlZCB0byBiZSBnYydkLiBSZW1vdmUgaXQgZnJvbSB0aGUgZ2NcbiAgICAgICAgICBpZiAocmlnaHQuZ2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJpZ2h0LmNvbnRlbnQgIT0gbnVsbCAmJiByaWdodC5jb250ZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb25DbGVhbkVuZChyaWdodC5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmUucmVtb3ZlRnJvbUdhcmJhZ2VDb2xsZWN0b3IocmlnaHQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihyaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnRzIC5tYXAvc3RhcnQvZW5kIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKG9wLnBhcmVudFN1YiAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Lm1hcFtvcC5wYXJlbnRTdWJdID0gb3AuaWRcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihwYXJlbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlzIGEgY2hpbGQgb2YgYSBtYXAgc3RydWN0LlxuICAgICAgICAgIC8vIFRoZW4gYWxzbyBtYWtlIHN1cmUgdGhhdCBvbmx5IHRoZSBtb3N0IGxlZnQgZWxlbWVudCBpcyBub3QgZGVsZXRlZFxuICAgICAgICAgIC8vIFdlIGRvIG5vdCBjYWxsIHRoZSB0eXBlIGluIHRoaXMgY2FzZSAodGhpcyBpcyB3aGF0IHRoZSB0aGlyZCBwYXJhbWV0ZXIgaXMgZm9yKVxuICAgICAgICAgIGlmIChvcC5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24ob3AucmlnaHQsIDEsIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmRlbGV0ZU9wZXJhdGlvbihvcC5pZCwgMSwgdHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJpZ2h0ID09IG51bGwgfHwgbGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJlbnQuZW5kID0gWS51dGlscy5nZXRMYXN0SWQob3ApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5zdGFydCA9IG9wLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24ocGFyZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byBtZXJnZSBvcmlnaW5hbCBvcC5sZWZ0IGFuZCBvcC5vcmlnaW5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cnlUb1JlbWVyZ2VMYXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKHRyeVRvUmVtZXJnZUxhdGVyW2ldKVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnRyeUNvbWJpbmVXaXRoTGVmdChtKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBMaXN0OiB7XG4gICAgICAvKlxuICAgICAge1xuICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICBzdHJ1Y3Q6IFwiTGlzdFwiLFxuICAgICAgICB0eXBlOiBcIlwiLFxuICAgICAgICBpZDogdGhpcy5vcy5nZXROZXh0T3BJZCgxKVxuICAgICAgfVxuICAgICAgKi9cbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgIHN0cnVjdDogJ0xpc3QnLFxuICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5jb2RlOiBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgc3RydWN0OiAnTGlzdCcsXG4gICAgICAgICAgaWQ6IG9wLmlkLFxuICAgICAgICAgIHR5cGU6IG9wLnR5cGVcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AucmVxdWlyZXMgIT0gbnVsbCkge1xuICAgICAgICAgIGUucmVxdWlyZXMgPSBvcC5yZXF1aXJlc1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5pbmZvICE9IG51bGwpIHtcbiAgICAgICAgICBlLmluZm8gPSBvcC5pbmZvXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZE9wczogZnVuY3Rpb24gKCkge1xuICAgICAgICAvKlxuICAgICAgICB2YXIgaWRzID0gW11cbiAgICAgICAgaWYgKG9wLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBpZHMucHVzaChvcC5zdGFydClcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AuZW5kICE9IG51bGwpe1xuICAgICAgICAgIGlkcy5wdXNoKG9wLmVuZClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzXG4gICAgICAgICovXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfSxcbiAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uICogKG9wKSB7XG4gICAgICAgIG9wLnN0YXJ0ID0gbnVsbFxuICAgICAgICBvcC5lbmQgPSBudWxsXG4gICAgICB9LFxuICAgICAgcmVmOiBmdW5jdGlvbiAqIChvcCwgcG9zKSB7XG4gICAgICAgIGlmIChvcC5zdGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gbnVsbFxuICAgICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihvcC5zdGFydClcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmICghby5kZWxldGVkKSB7XG4gICAgICAgICAgICByZXMgPSBvXG4gICAgICAgICAgICBwb3MtLVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zID49IDAgJiYgby5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKG8ucmlnaHQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH0sXG4gICAgICBtYXA6IGZ1bmN0aW9uICogKG8sIGYpIHtcbiAgICAgICAgbyA9IG8uc3RhcnRcbiAgICAgICAgdmFyIHJlcyA9IFtdXG4gICAgICAgIHdoaWxlIChvICE9IG51bGwpIHsgLy8gVE9ETzogY2hhbmdlIHRvICE9IChhdCBsZWFzdCBzb21lIGNvbnZlbnRpb24pXG4gICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihvKVxuICAgICAgICAgIGlmICghb3BlcmF0aW9uLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGYob3BlcmF0aW9uKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgbyA9IG9wZXJhdGlvbi5yaWdodFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH1cbiAgICB9LFxuICAgIE1hcDoge1xuICAgICAgLypcbiAgICAgICAge1xuICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgc3RydWN0OiBcIk1hcFwiLFxuICAgICAgICAgIHR5cGU6IFwiXCIsXG4gICAgICAgICAgaWQ6IHRoaXMub3MuZ2V0TmV4dE9wSWQoMSlcbiAgICAgICAgfVxuICAgICAgKi9cbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgc3RydWN0OiAnTWFwJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5jb2RlOiBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgc3RydWN0OiAnTWFwJyxcbiAgICAgICAgICB0eXBlOiBvcC50eXBlLFxuICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICBtYXA6IHt9IC8vIG92ZXJ3cml0ZSBtYXAhIVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5yZXF1aXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgZS5yZXF1aXJlcyA9IG9wLnJlcXVpcmVzXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLmluZm8gIT0gbnVsbCkge1xuICAgICAgICAgIGUuaW5mbyA9IG9wLmluZm9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkT3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfSxcbiAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uICogKCkge30sXG4gICAgICAvKlxuICAgICAgICBHZXQgYSBwcm9wZXJ0eSBieSBuYW1lXG4gICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiAqIChvcCwgbmFtZSkge1xuICAgICAgICB2YXIgb2lkID0gb3AubWFwW25hbWVdXG4gICAgICAgIGlmIChvaWQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciByZXMgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24ob2lkKVxuICAgICAgICAgIGlmIChyZXMgPT0gbnVsbCB8fCByZXMuZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMFxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzLm9wQ29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmNvbnRlbnRbMF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmdldFR5cGUocmVzLm9wQ29udGVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgWS5TdHJ1Y3QgPSBTdHJ1Y3Rcbn1cbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuLypcbiAgUGFydGlhbCBkZWZpbml0aW9uIG9mIGEgdHJhbnNhY3Rpb25cblxuICBBIHRyYW5zYWN0aW9uIHByb3ZpZGVzIGFsbCB0aGUgdGhlIGFzeW5jIGZ1bmN0aW9uYWxpdHkgb24gYSBkYXRhYmFzZS5cblxuICBCeSBjb252ZW50aW9uLCBhIHRyYW5zYWN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICogc3MgZm9yIFN0YXRlU2V0XG4gICogb3MgZm9yIE9wZXJhdGlvblN0b3JlXG4gICogZHMgZm9yIERlbGV0ZVN0b3JlXG5cbiAgQSB0cmFuc2FjdGlvbiBtdXN0IGFsc28gZGVmaW5lIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgKiBjaGVja0RlbGV0ZVN0b3JlRm9yU3RhdGUoc3RhdGUpXG4gICAgLSBXaGVuIGluY3JlYXNpbmcgdGhlIHN0YXRlIG9mIGEgdXNlciwgYW4gb3BlcmF0aW9uIHdpdGggYW4gaGlnaGVyIGlkXG4gICAgICBtYXkgYWxyZWFkeSBiZSBnYXJiYWdlIGNvbGxlY3RlZCwgYW5kIHRoZXJlZm9yZSBpdCB3aWxsIG5ldmVyIGJlIHJlY2VpdmVkLlxuICAgICAgdXBkYXRlIHRoZSBzdGF0ZSB0byByZWZsZWN0IHRoaXMga25vd2xlZGdlLiBUaGlzIHdvbid0IGNhbGwgYSBtZXRob2QgdG8gc2F2ZSB0aGUgc3RhdGUhXG4gICogZ2V0RGVsZXRlU2V0KGlkKVxuICAgIC0gR2V0IHRoZSBkZWxldGUgc2V0IGluIGEgcmVhZGFibGUgZm9ybWF0OlxuICAgICAge1xuICAgICAgICBcInVzZXJYXCI6IFtcbiAgICAgICAgICBbNSwxXSwgLy8gc3RhcnRpbmcgZnJvbSBwb3NpdGlvbiA1LCBvbmUgb3BlcmF0aW9ucyBpcyBkZWxldGVkXG4gICAgICAgICAgWzksNF0gIC8vIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gOSwgZm91ciBvcGVyYXRpb25zIGFyZSBkZWxldGVkXG4gICAgICAgIF0sXG4gICAgICAgIFwidXNlcllcIjogLi4uXG4gICAgICB9XG4gICogZ2V0T3BzRnJvbURlbGV0ZVNldChkcykgLS0gVE9ETzoganVzdCBjYWxsIHRoaXMuZGVsZXRlT3BlcmF0aW9uKGlkKSBoZXJlXG4gICAgLSBnZXQgYSBzZXQgb2YgZGVsZXRpb25zIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIGluIG9yZGVyIHRvIGdldCB0b1xuICAgICAgYWNoaWV2ZSB0aGUgc3RhdGUgb2YgdGhlIHN1cHBsaWVkIGRzXG4gICogc2V0T3BlcmF0aW9uKG9wKVxuICAgIC0gd3JpdGUgYG9wYCB0byB0aGUgZGF0YWJhc2UuXG4gICAgICBOb3RlOiB0aGlzIGlzIGFsbG93ZWQgdG8gcmV0dXJuIGFuIGluLW1lbW9yeSBvYmplY3QuXG4gICAgICBFLmcuIHRoZSBNZW1vcnkgYWRhcHRlciByZXR1cm5zIHRoZSBvYmplY3QgdGhhdCBpdCBoYXMgaW4tbWVtb3J5LlxuICAgICAgQ2hhbmdpbmcgdmFsdWVzIG9uIHRoaXMgb2JqZWN0IHdpbGwgYmUgc3RvcmVkIGRpcmVjdGx5IGluIHRoZSBkYXRhYmFzZVxuICAgICAgd2l0aG91dCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uIFRoZXJlZm9yZSxcbiAgICAgIHNldE9wZXJhdGlvbiBtYXkgaGF2ZSBubyBmdW5jdGlvbmFsaXR5IGluIHNvbWUgYWRhcHRlcnMuIFRoaXMgYWxzbyBoYXNcbiAgICAgIGltcGxpY2F0aW9ucyBvbiB0aGUgd2F5IHdlIHVzZSBvcGVyYXRpb25zIHRoYXQgd2VyZSBzZXJ2ZWQgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAgICBXZSB0cnkgbm90IHRvIGNhbGwgY29weU9iamVjdCwgaWYgbm90IG5lY2Vzc2FyeS5cbiAgKiBhZGRPcGVyYXRpb24ob3ApXG4gICAgLSBhZGQgYW4gb3BlcmF0aW9uIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAgIFRoaXMgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgZm9yIGV2ZXJ5IG9wLmlkXG4gICAgICBNdXN0IHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBvcGVyYXRpb24gaW4gdGhlIGRhdGFiYXNlIChvcmRlcmVkIGJ5IGlkKVxuICAqIGdldE9wZXJhdGlvbihpZClcbiAgKiByZW1vdmVPcGVyYXRpb24oaWQpXG4gICAgLSByZW1vdmUgYW4gb3BlcmF0aW9uIGZyb20gdGhlIGRhdGFiYXNlLiBUaGlzIGlzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvblxuICAgICAgaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICogc2V0U3RhdGUoc3RhdGUpXG4gICAgLSBgc3RhdGVgIGlzIG9mIHRoZSBmb3JtXG4gICAgICB7XG4gICAgICAgIHVzZXI6IFwiMVwiLFxuICAgICAgICBjbG9jazogNFxuICAgICAgfSA8LSBtZWFuaW5nIHRoYXQgd2UgaGF2ZSBmb3VyIG9wZXJhdGlvbnMgZnJvbSB1c2VyIFwiMVwiXG4gICAgICAgICAgICh3aXRoIHRoZXNlIGlkJ3MgcmVzcGVjdGl2ZWx5OiAwLCAxLCAyLCBhbmQgMylcbiAgKiBnZXRTdGF0ZSh1c2VyKVxuICAqIGdldFN0YXRlVmVjdG9yKClcbiAgICAtIEdldCB0aGUgc3RhdGUgb2YgdGhlIE9TIGluIHRoZSBmb3JtXG4gICAgW3tcbiAgICAgIHVzZXI6IFwidXNlclhcIixcbiAgICAgIGNsb2NrOiAxMVxuICAgIH0sXG4gICAgIC4uXG4gICAgXVxuICAqIGdldFN0YXRlU2V0KClcbiAgICAtIEdldCB0aGUgc3RhdGUgb2YgdGhlIE9TIGluIHRoZSBmb3JtXG4gICAge1xuICAgICAgXCJ1c2VyWFwiOiAxMSxcbiAgICAgIFwidXNlcllcIjogMjJcbiAgICB9XG4gICAqIGdldE9wZXJhdGlvbnMoc3RhcnRTUylcbiAgICAgLSBHZXQgdGhlIGFsbCB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gYWNoaXZlIHRoZVxuICAgICAgIHN0YXRlU2V0IG9mIHRoaXMgdXNlciwgc3RhcnRpbmcgZnJvbSBhIHN0YXRlU2V0IHN1cHBsaWVkIGJ5IGFub3RoZXIgdXNlclxuICAgKiBtYWtlT3BlcmF0aW9uUmVhZHkoc3MsIG9wKVxuICAgICAtIHRoaXMgaXMgY2FsbGVkIG9ubHkgYnkgYGdldE9wZXJhdGlvbnMoc3RhcnRTUylgLiBJdCBtYWtlcyBhbiBvcGVyYXRpb25cbiAgICAgICBhcHBseWFibGUgb24gYSBnaXZlbiBTUy5cbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZLyogOmFueSAqLykge1xuICBjbGFzcyBUcmFuc2FjdGlvbkludGVyZmFjZSB7XG4gICAgLyogOjpcbiAgICBzdG9yZTogWS5BYnN0cmFjdERhdGFiYXNlO1xuICAgIGRzOiBTdG9yZTtcbiAgICBvczogU3RvcmU7XG4gICAgc3M6IFN0b3JlO1xuICAgICovXG4gICAgLypcbiAgICAgIEdldCBhIHR5cGUgYmFzZWQgb24gdGhlIGlkIG9mIGl0cyBtb2RlbC5cbiAgICAgIElmIGl0IGRvZXMgbm90IGV4aXN0IHllcywgY3JlYXRlIGl0LlxuICAgICAgVE9ETzogZGVsZXRlIHR5cGUgZnJvbSBzdG9yZS5pbml0aWFsaXplZFR5cGVzW2lkXSB3aGVuIGNvcnJlc3BvbmRpbmcgaWQgd2FzIGRlbGV0ZWQhXG4gICAgKi9cbiAgICAqIGdldFR5cGUgKGlkLCBhcmdzKSB7XG4gICAgICB2YXIgc2lkID0gSlNPTi5zdHJpbmdpZnkoaWQpXG4gICAgICB2YXIgdCA9IHRoaXMuc3RvcmUuaW5pdGlhbGl6ZWRUeXBlc1tzaWRdXG4gICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBvcC8qIDpNYXBTdHJ1Y3QgfCBMaXN0U3RydWN0ICovID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKGlkKVxuICAgICAgICBpZiAob3AgIT0gbnVsbCkge1xuICAgICAgICAgIHQgPSB5aWVsZCogWVtvcC50eXBlXS50eXBlRGVmaW5pdGlvbi5pbml0VHlwZS5jYWxsKHRoaXMsIHRoaXMuc3RvcmUsIG9wLCBhcmdzKVxuICAgICAgICAgIHRoaXMuc3RvcmUuaW5pdGlhbGl6ZWRUeXBlc1tzaWRdID0gdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdFxuICAgIH1cbiAgICAqIGNyZWF0ZVR5cGUgKHR5cGVkZWZpbml0aW9uLCBpZCkge1xuICAgICAgdmFyIHN0cnVjdG5hbWUgPSB0eXBlZGVmaW5pdGlvblswXS5zdHJ1Y3RcbiAgICAgIGlkID0gaWQgfHwgdGhpcy5zdG9yZS5nZXROZXh0T3BJZCgxKVxuICAgICAgdmFyIG9wXG4gICAgICBpZiAoaWRbMF0gPT09ICdfJykge1xuICAgICAgICBvcCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihpZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wID0gWS5TdHJ1Y3Rbc3RydWN0bmFtZV0uY3JlYXRlKGlkKVxuICAgICAgICBvcC50eXBlID0gdHlwZWRlZmluaXRpb25bMF0ubmFtZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVkZWZpbml0aW9uWzBdLmFwcGVuZEFkZGl0aW9uYWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgeWllbGQqIHR5cGVkZWZpbml0aW9uWzBdLmFwcGVuZEFkZGl0aW9uYWxJbmZvLmNhbGwodGhpcywgb3AsIHR5cGVkZWZpbml0aW9uWzFdKVxuICAgICAgfVxuICAgICAgaWYgKG9wWzBdID09PSAnXycpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG9wKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYXBwbHlDcmVhdGVkT3BlcmF0aW9ucyhbb3BdKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmdldFR5cGUoaWQsIHR5cGVkZWZpbml0aW9uWzFdKVxuICAgIH1cbiAgICAvKiBjcmVhdGVUeXBlICh0eXBlZGVmaW5pdGlvbiwgaWQpIHtcbiAgICAgIHZhciBzdHJ1Y3RuYW1lID0gdHlwZWRlZmluaXRpb25bMF0uc3RydWN0XG4gICAgICBpZCA9IGlkIHx8IHRoaXMuc3RvcmUuZ2V0TmV4dE9wSWQoMSlcbiAgICAgIHZhciBvcCA9IFkuU3RydWN0W3N0cnVjdG5hbWVdLmNyZWF0ZShpZClcbiAgICAgIG9wLnR5cGUgPSB0eXBlZGVmaW5pdGlvblswXS5uYW1lXG4gICAgICBpZiAodHlwZWRlZmluaXRpb25bMF0uYXBwZW5kQWRkaXRpb25hbEluZm8gIT0gbnVsbCkge1xuICAgICAgICB5aWVsZCogdHlwZWRlZmluaXRpb25bMF0uYXBwZW5kQWRkaXRpb25hbEluZm8uY2FsbCh0aGlzLCBvcCwgdHlwZWRlZmluaXRpb25bMV0pXG4gICAgICB9XG4gICAgICAvLyB5aWVsZCogdGhpcy5hcHBseUNyZWF0ZWRPcGVyYXRpb25zKFtvcF0pXG4gICAgICB5aWVsZCogWS5TdHJ1Y3Rbb3Auc3RydWN0XS5leGVjdXRlLmNhbGwodGhpcywgb3ApXG4gICAgICB5aWVsZCogdGhpcy5hZGRPcGVyYXRpb24ob3ApXG4gICAgICB5aWVsZCogdGhpcy5zdG9yZS5vcGVyYXRpb25BZGRlZCh0aGlzLCBvcClcbiAgICAgIHJldHVybiB5aWVsZCogdGhpcy5nZXRUeXBlKGlkLCB0eXBlZGVmaW5pdGlvblsxXSlcbiAgICB9Ki9cbiAgICAvKlxuICAgICAgQXBwbHkgb3BlcmF0aW9ucyB0aGF0IHRoaXMgdXNlciBjcmVhdGVkIChubyByZW1vdGUgb25lcyEpXG4gICAgICAgICogZG9lcyBub3QgY2hlY2sgZm9yIFN0cnVjdC4qLnJlcXVpcmVkT3BzKClcbiAgICAgICAgKiBhbHNvIGJyb2FkY2FzdHMgaXQgdGhyb3VnaCB0aGUgY29ubmVjdG9yXG4gICAgKi9cbiAgICAqIGFwcGx5Q3JlYXRlZE9wZXJhdGlvbnMgKG9wcykge1xuICAgICAgdmFyIHNlbmQgPSBbXVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wID0gb3BzW2ldXG4gICAgICAgIHlpZWxkKiB0aGlzLnN0b3JlLnRyeUV4ZWN1dGUuY2FsbCh0aGlzLCBvcClcbiAgICAgICAgaWYgKG9wLmlkID09IG51bGwgfHwgdHlwZW9mIG9wLmlkWzFdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHNlbmQucHVzaChZLlN0cnVjdFtvcC5zdHJ1Y3RdLmVuY29kZShvcCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdG9yZS55LmNvbm5lY3Rvci5pc0Rpc2Nvbm5lY3RlZCgpICYmIHNlbmQubGVuZ3RoID4gMCkgeyAvLyBUT0RPOiAmJiAhdGhpcy5zdG9yZS5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgKGJ1dCB0aGVuIGkgZG9uJ3Qgc2VuZCBkZWxldGUgb3BzKVxuICAgICAgICAvLyBpcyBjb25uZWN0ZWQsIGFuZCB0aGlzIGlzIG5vdCBnb2luZyB0byBiZSBzZW5kIGluIGFkZE9wZXJhdGlvblxuICAgICAgICB0aGlzLnN0b3JlLnkuY29ubmVjdG9yLmJyb2FkY2FzdE9wcyhzZW5kKVxuICAgICAgfVxuICAgIH1cblxuICAgICogZGVsZXRlTGlzdCAoc3RhcnQpIHtcbiAgICAgIHdoaWxlIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHN0YXJ0ID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKHN0YXJ0KVxuICAgICAgICBpZiAoIXN0YXJ0LmdjKSB7XG4gICAgICAgICAgc3RhcnQuZ2MgPSB0cnVlXG4gICAgICAgICAgc3RhcnQuZGVsZXRlZCA9IHRydWVcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24oc3RhcnQpXG4gICAgICAgICAgdmFyIGRlbExlbmd0aCA9IHN0YXJ0LmNvbnRlbnQgIT0gbnVsbCA/IHN0YXJ0LmNvbnRlbnQubGVuZ3RoIDogMVxuICAgICAgICAgIHlpZWxkKiB0aGlzLm1hcmtEZWxldGVkKHN0YXJ0LmlkLCBkZWxMZW5ndGgpXG4gICAgICAgICAgaWYgKHN0YXJ0Lm9wQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24oc3RhcnQub3BDb250ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0b3JlLnF1ZXVlR2FyYmFnZUNvbGxlY3RvcihzdGFydC5pZClcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHN0YXJ0LnJpZ2h0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgIE1hcmsgYW4gb3BlcmF0aW9uIGFzIGRlbGV0ZWQsIGFuZCBhZGQgaXQgdG8gdGhlIEdDLCBpZiBwb3NzaWJsZS5cbiAgICAqL1xuICAgICogZGVsZXRlT3BlcmF0aW9uICh0YXJnZXRJZCwgbGVuZ3RoLCBwcmV2ZW50Q2FsbFR5cGUpIC8qIDpHZW5lcmF0b3I8YW55LCBhbnksIGFueT4gKi8ge1xuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIGxlbmd0aCA9IDFcbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLm1hcmtEZWxldGVkKHRhcmdldElkLCBsZW5ndGgpXG4gICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY2FsbFR5cGUgPSBmYWxzZVxuICAgICAgICB2YXIgdGFyZ2V0ID0geWllbGQqIHRoaXMub3MuZmluZFdpdGhVcHBlckJvdW5kKFt0YXJnZXRJZFswXSwgdGFyZ2V0SWRbMV0gKyBsZW5ndGggLSAxXSlcbiAgICAgICAgdmFyIHRhcmdldExlbmd0aCA9IHRhcmdldCAhPSBudWxsICYmIHRhcmdldC5jb250ZW50ICE9IG51bGwgPyB0YXJnZXQuY29udGVudC5sZW5ndGggOiAxXG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCB8fCB0YXJnZXQuaWRbMF0gIT09IHRhcmdldElkWzBdIHx8IHRhcmdldC5pZFsxXSArIHRhcmdldExlbmd0aCA8PSB0YXJnZXRJZFsxXSkge1xuICAgICAgICAgIC8vIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBpbiB0aGUgcmFuZ2Ugb2YgdGhlIGRlbGV0aW9uXG4gICAgICAgICAgdGFyZ2V0ID0gbnVsbFxuICAgICAgICAgIGxlbmd0aCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkb2VzIGV4aXN0LCBjaGVjayBpZiBpdCBpcyB0b28gbG9uZ1xuICAgICAgICAgIGlmICghdGFyZ2V0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaWRbMV0gPCB0YXJnZXRJZFsxXSkge1xuICAgICAgICAgICAgICAvLyBzdGFydHMgdG8gdGhlIGxlZnQgb2YgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgICAgICAgIHRhcmdldCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuU3RhcnQodGFyZ2V0SWQpXG4gICAgICAgICAgICAgIHRhcmdldExlbmd0aCA9IHRhcmdldC5jb250ZW50Lmxlbmd0aCAvLyBtdXN0IGhhdmUgY29udGVudCBwcm9wZXJ0eSFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQuaWRbMV0gKyB0YXJnZXRMZW5ndGggPiB0YXJnZXRJZFsxXSArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBlbmRzIHRvIHRoZSByaWdodCBvZiB0aGUgZGVsZXRpb24gcmFuZ2VcbiAgICAgICAgICAgICAgdGFyZ2V0ID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uQ2xlYW5FbmQoW3RhcmdldElkWzBdLCB0YXJnZXRJZFsxXSArIGxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgICB0YXJnZXRMZW5ndGggPSB0YXJnZXQuY29udGVudC5sZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gdGFyZ2V0LmlkWzFdIC0gdGFyZ2V0SWRbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghdGFyZ2V0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGNhbGxUeXBlID0gdHJ1ZVxuICAgICAgICAgICAgLy8gc2V0IGRlbGV0ZWQgJiBub3RpZnkgdHlwZVxuICAgICAgICAgICAgdGFyZ2V0LmRlbGV0ZWQgPSB0cnVlXG4gICAgICAgICAgICAvLyBkZWxldGUgY29udGFpbmluZyBsaXN0c1xuICAgICAgICAgICAgaWYgKHRhcmdldC5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IGRvbid0IGRvIGl0IGxpa2UgdGhpcyAuLiAtLi1cbiAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZGVsZXRlTGlzdCh0YXJnZXQuc3RhcnQpXG4gICAgICAgICAgICAgIC8vIHlpZWxkKiB0aGlzLmRlbGV0ZUxpc3QodGFyZ2V0LmlkKSAtLSBkbyBub3QgZ2MgaXRzZWxmIGJlY2F1c2UgdGhpcyBtYXkgc3RpbGwgZ2V0IHJlZmVyZW5jZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQubWFwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQubWFwKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZGVsZXRlTGlzdCh0YXJnZXQubWFwW25hbWVdKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFRPRE86IGhlcmUgdG8uLiAgKHNlZSBhYm92ZSlcbiAgICAgICAgICAgICAgLy8geWllbGQqIHRoaXMuZGVsZXRlTGlzdCh0YXJnZXQuaWQpIC0tIHNlZSBhYm92ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5vcENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24odGFyZ2V0Lm9wQ29udGVudClcbiAgICAgICAgICAgICAgLy8gdGFyZ2V0Lm9wQ29udGVudCA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQucmVxdWlyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5yZXF1aXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLmRlbGV0ZU9wZXJhdGlvbih0YXJnZXQucmVxdWlyZXNbaV0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxlZnRcbiAgICAgICAgICBpZiAodGFyZ2V0LmxlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGVmdCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbih0YXJnZXQubGVmdClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzZXQgaGVyZSBiZWNhdXNlIGl0IHdhcyBkZWxldGVkIGFuZC9vciBnYydkXG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKHRhcmdldClcblxuICAgICAgICAgIC8qXG4gICAgICAgICAgICBDaGVjayBpZiBpdCBpcyBwb3NzaWJsZSB0byBhZGQgcmlnaHQgdG8gdGhlIGdjLlxuICAgICAgICAgICAgQmVjYXVzZSB0aGlzIGRlbGV0ZSBjYW4ndCBiZSByZXNwb25zaWJsZSBmb3IgbGVmdCBiZWluZyBnYydkLFxuICAgICAgICAgICAgd2UgZG9uJ3QgaGF2ZSB0byBhZGQgbGVmdCB0byB0aGUgZ2MuLlxuICAgICAgICAgICovXG4gICAgICAgICAgdmFyIHJpZ2h0XG4gICAgICAgICAgaWYgKHRhcmdldC5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICByaWdodCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbih0YXJnZXQucmlnaHQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbFR5cGUgJiYgIXByZXZlbnRDYWxsVHlwZSkge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RvcmUub3BlcmF0aW9uQWRkZWQodGhpcywge1xuICAgICAgICAgICAgICBzdHJ1Y3Q6ICdEZWxldGUnLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldC5pZCxcbiAgICAgICAgICAgICAgbGVuZ3RoOiB0YXJnZXRMZW5ndGhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5lZWQgdG8gZ2MgaW4gdGhlIGVuZCFcbiAgICAgICAgICB5aWVsZCogdGhpcy5zdG9yZS5hZGRUb0dhcmJhZ2VDb2xsZWN0b3IuY2FsbCh0aGlzLCB0YXJnZXQsIGxlZnQpXG4gICAgICAgICAgaWYgKHJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0b3JlLmFkZFRvR2FyYmFnZUNvbGxlY3Rvci5jYWxsKHRoaXMsIHJpZ2h0LCB0YXJnZXQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICBNYXJrIGFuIG9wZXJhdGlvbiBhcyBkZWxldGVkJmdjJ2RcbiAgICAqL1xuICAgICogbWFya0dhcmJhZ2VDb2xsZWN0ZWQgKGlkLCBsZW4pIHtcbiAgICAgIC8vIHRoaXMubWVtLnB1c2goW1wiZ2NcIiwgaWRdKTtcbiAgICAgIHRoaXMuc3RvcmUuYWRkVG9EZWJ1ZygneWllbGQqIHRoaXMubWFya0dhcmJhZ2VDb2xsZWN0ZWQoJywgaWQsICcsICcsIGxlbiwgJyknKVxuICAgICAgdmFyIG4gPSB5aWVsZCogdGhpcy5tYXJrRGVsZXRlZChpZCwgbGVuKVxuICAgICAgaWYgKG4uaWRbMV0gPCBpZFsxXSAmJiAhbi5nYykge1xuICAgICAgICAvLyB1bi1leHRlbmQgbGVmdFxuICAgICAgICB2YXIgbmV3bGVuID0gbi5sZW4gLSAoaWRbMV0gLSBuLmlkWzFdKVxuICAgICAgICBuLmxlbiAtPSBuZXdsZW5cbiAgICAgICAgeWllbGQqIHRoaXMuZHMucHV0KG4pXG4gICAgICAgIG4gPSB7aWQ6IGlkLCBsZW46IG5ld2xlbiwgZ2M6IGZhbHNlfVxuICAgICAgICB5aWVsZCogdGhpcy5kcy5wdXQobilcbiAgICAgIH1cbiAgICAgIC8vIGdldCBwcmV2Jm5leHQgYmVmb3JlIGFkZGluZyBhIG5ldyBvcGVyYXRpb25cbiAgICAgIHZhciBwcmV2ID0geWllbGQqIHRoaXMuZHMuZmluZFByZXYoaWQpXG4gICAgICB2YXIgbmV4dCA9IHlpZWxkKiB0aGlzLmRzLmZpbmROZXh0KGlkKVxuXG4gICAgICBpZiAoaWRbMV0gKyBsZW4gPCBuLmlkWzFdICsgbi5sZW4gJiYgIW4uZ2MpIHtcbiAgICAgICAgLy8gdW4tZXh0ZW5kIHJpZ2h0XG4gICAgICAgIHlpZWxkKiB0aGlzLmRzLnB1dCh7aWQ6IFtpZFswXSwgaWRbMV0gKyBsZW5dLCBsZW46IG4ubGVuIC0gbGVuLCBnYzogZmFsc2V9KVxuICAgICAgICBuLmxlbiA9IGxlblxuICAgICAgfVxuICAgICAgLy8gc2V0IGdjJ2RcbiAgICAgIG4uZ2MgPSB0cnVlXG4gICAgICAvLyBjYW4gZXh0ZW5kIGxlZnQ/XG4gICAgICBpZiAoXG4gICAgICAgIHByZXYgIT0gbnVsbCAmJlxuICAgICAgICBwcmV2LmdjICYmXG4gICAgICAgIFkudXRpbHMuY29tcGFyZUlkcyhbcHJldi5pZFswXSwgcHJldi5pZFsxXSArIHByZXYubGVuXSwgbi5pZClcbiAgICAgICkge1xuICAgICAgICBwcmV2LmxlbiArPSBuLmxlblxuICAgICAgICB5aWVsZCogdGhpcy5kcy5kZWxldGUobi5pZClcbiAgICAgICAgbiA9IHByZXZcbiAgICAgICAgLy8gZHMucHV0IG4gaGVyZT9cbiAgICAgIH1cbiAgICAgIC8vIGNhbiBleHRlbmQgcmlnaHQ/XG4gICAgICBpZiAoXG4gICAgICAgIG5leHQgIT0gbnVsbCAmJlxuICAgICAgICBuZXh0LmdjICYmXG4gICAgICAgIFkudXRpbHMuY29tcGFyZUlkcyhbbi5pZFswXSwgbi5pZFsxXSArIG4ubGVuXSwgbmV4dC5pZClcbiAgICAgICkge1xuICAgICAgICBuLmxlbiArPSBuZXh0LmxlblxuICAgICAgICB5aWVsZCogdGhpcy5kcy5kZWxldGUobmV4dC5pZClcbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLmRzLnB1dChuKVxuICAgICAgeWllbGQqIHRoaXMudXBkYXRlU3RhdGUobi5pZFswXSlcbiAgICB9XG4gICAgLypcbiAgICAgIE1hcmsgYW4gb3BlcmF0aW9uIGFzIGRlbGV0ZWQuXG5cbiAgICAgIHJldHVybnMgdGhlIGRlbGV0ZSBub2RlXG4gICAgKi9cbiAgICAqIG1hcmtEZWxldGVkIChpZCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgfVxuICAgICAgLy8gdGhpcy5tZW0ucHVzaChbXCJkZWxcIiwgaWRdKTtcbiAgICAgIHZhciBuID0geWllbGQqIHRoaXMuZHMuZmluZFdpdGhVcHBlckJvdW5kKGlkKVxuICAgICAgaWYgKG4gIT0gbnVsbCAmJiBuLmlkWzBdID09PSBpZFswXSkge1xuICAgICAgICBpZiAobi5pZFsxXSA8PSBpZFsxXSAmJiBpZFsxXSA8PSBuLmlkWzFdICsgbi5sZW4pIHtcbiAgICAgICAgICAvLyBpZCBpcyBpbiBuJ3MgcmFuZ2VcbiAgICAgICAgICB2YXIgZGlmZiA9IGlkWzFdICsgbGVuZ3RoIC0gKG4uaWRbMV0gKyBuLmxlbikgLy8gb3ZlcmxhcHBpbmcgcmlnaHRcbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIC8vIGlkK2xlbmd0aCBvdmVybGFwcyBuXG4gICAgICAgICAgICBpZiAoIW4uZ2MpIHtcbiAgICAgICAgICAgICAgbi5sZW4gKz0gZGlmZlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGlmZiA9IG4uaWRbMV0gKyBuLmxlbiAtIGlkWzFdIC8vIG92ZXJsYXBwaW5nIGxlZnQgKGlkIHRpbGwgbi5lbmQpXG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBwYXJ0aWFsIGRlbGV0aW9uXG4gICAgICAgICAgICAgICAgbiA9IHtpZDogW2lkWzBdLCBpZFsxXSArIGRpZmZdLCBsZW46IGxlbmd0aCAtIGRpZmYsIGdjOiBmYWxzZX1cbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kcy5wdXQobilcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGdjJ2RcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXBwZW4hIChpdCBkaXQgdGhvdWdoLi4gOigpJylcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIG92ZXJsYXBwaW5nLCBhbHJlYWR5IGRlbGV0ZWRcbiAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbm5vdCBleHRlbmQgbGVmdCAodGhlcmUgaXMgbm8gbGVmdCEpXG4gICAgICAgICAgbiA9IHtpZDogaWQsIGxlbjogbGVuZ3RoLCBnYzogZmFsc2V9XG4gICAgICAgICAgeWllbGQqIHRoaXMuZHMucHV0KG4pIC8vIFRPRE86IHlvdSBkb3VibGUtcHV0ICEhXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhbm5vdCBleHRlbmQgbGVmdFxuICAgICAgICBuID0ge2lkOiBpZCwgbGVuOiBsZW5ndGgsIGdjOiBmYWxzZX1cbiAgICAgICAgeWllbGQqIHRoaXMuZHMucHV0KG4pXG4gICAgICB9XG4gICAgICAvLyBjYW4gZXh0ZW5kIHJpZ2h0P1xuICAgICAgdmFyIG5leHQgPSB5aWVsZCogdGhpcy5kcy5maW5kTmV4dChuLmlkKVxuICAgICAgaWYgKFxuICAgICAgICBuZXh0ICE9IG51bGwgJiZcbiAgICAgICAgbi5pZFswXSA9PT0gbmV4dC5pZFswXSAmJlxuICAgICAgICBuLmlkWzFdICsgbi5sZW4gPj0gbmV4dC5pZFsxXVxuICAgICAgKSB7XG4gICAgICAgIGRpZmYgPSBuLmlkWzFdICsgbi5sZW4gLSBuZXh0LmlkWzFdIC8vIGZyb20gbmV4dC5zdGFydCB0byBuLmVuZFxuICAgICAgICB3aGlsZSAoZGlmZiA+PSAwKSB7XG4gICAgICAgICAgLy8gbiBvdmVybGFwcyB3aXRoIG5leHRcbiAgICAgICAgICBpZiAobmV4dC5nYykge1xuICAgICAgICAgICAgLy8gZ2MgaXMgc3Ryb25nZXIsIHNvIHJlZHVjZSBsZW5ndGggb2YgblxuICAgICAgICAgICAgbi5sZW4gLT0gZGlmZlxuICAgICAgICAgICAgaWYgKGRpZmYgPj0gbmV4dC5sZW4pIHtcbiAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBtaXNzaW5nIHJhbmdlIGFmdGVyIG5leHRcbiAgICAgICAgICAgICAgZGlmZiA9IGRpZmYgLSBuZXh0LmxlbiAvLyBtaXNzaW5nIHJhbmdlIGFmdGVyIG5leHRcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZHMucHV0KG4pIC8vIHVubmVjY2Vzc2FyeT8gVE9ETyFcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5tYXJrRGVsZXRlZChbbmV4dC5pZFswXSwgbmV4dC5pZFsxXSArIG5leHQubGVuXSwgZGlmZilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgY2FuIGV4dGVuZCBuIHdpdGggbmV4dFxuICAgICAgICAgICAgaWYgKGRpZmYgPiBuZXh0Lmxlbikge1xuICAgICAgICAgICAgICAvLyBuIGlzIGV2ZW4gbG9uZ2VyIHRoYW4gbmV4dFxuICAgICAgICAgICAgICAvLyBnZXQgbmV4dC5uZXh0LCBhbmQgdHJ5IHRvIGV4dGVuZCBpdFxuICAgICAgICAgICAgICB2YXIgX25leHQgPSB5aWVsZCogdGhpcy5kcy5maW5kTmV4dChuZXh0LmlkKVxuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kcy5kZWxldGUobmV4dC5pZClcbiAgICAgICAgICAgICAgaWYgKF9uZXh0ID09IG51bGwgfHwgbi5pZFswXSAhPT0gX25leHQuaWRbMF0pIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQgPSBfbmV4dFxuICAgICAgICAgICAgICAgIGRpZmYgPSBuLmlkWzFdICsgbi5sZW4gLSBuZXh0LmlkWzFdIC8vIGZyb20gbmV4dC5zdGFydCB0byBuLmVuZFxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBuIGp1c3QgcGFydGlhbGx5IG92ZXJsYXBzIHdpdGggbmV4dC4gZXh0ZW5kIG4sIGRlbGV0ZSBuZXh0LCBhbmQgYnJlYWsgdGhpcyBsb29wXG4gICAgICAgICAgICAgIG4ubGVuICs9IG5leHQubGVuIC0gZGlmZlxuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kcy5kZWxldGUobmV4dC5pZClcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLmRzLnB1dChuKVxuICAgICAgcmV0dXJuIG5cbiAgICB9XG4gICAgLypcbiAgICAgIENhbGwgdGhpcyBtZXRob2Qgd2hlbiB0aGUgY2xpZW50IGlzIGNvbm5lY3RlZCZzeW5jZWQgd2l0aCB0aGVcbiAgICAgIG90aGVyIGNsaWVudHMgKGUuZy4gbWFzdGVyKS4gVGhpcyB3aWxsIHF1ZXJ5IHRoZSBkYXRhYmFzZSBmb3JcbiAgICAgIG9wZXJhdGlvbnMgdGhhdCBjYW4gYmUgZ2MnZCBhbmQgYWRkIHRoZW0gdG8gdGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxuICAgICovXG4gICAgKiBnYXJiYWdlQ29sbGVjdEFmdGVyU3luYyAoKSB7XG4gICAgICBpZiAodGhpcy5zdG9yZS5nYzEubGVuZ3RoID4gMCB8fCB0aGlzLnN0b3JlLmdjMi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZ2Mgc2hvdWxkIGJlIGVtcHR5IGFmdGVyIHN5bmMnKVxuICAgICAgfVxuICAgICAgeWllbGQqIHRoaXMub3MuaXRlcmF0ZSh0aGlzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAqIChvcCkge1xuICAgICAgICBpZiAob3AuZ2MpIHtcbiAgICAgICAgICBkZWxldGUgb3AuZ2NcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24ob3ApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBhcmVudERlbGV0ZWQgPSB5aWVsZCogdGhpcy5pc0RlbGV0ZWQob3AucGFyZW50KVxuICAgICAgICAgIGlmIChwYXJlbnREZWxldGVkKSB7XG4gICAgICAgICAgICBvcC5nYyA9IHRydWVcbiAgICAgICAgICAgIGlmICghb3AuZGVsZXRlZCkge1xuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5tYXJrRGVsZXRlZChvcC5pZCwgb3AuY29udGVudCAhPSBudWxsID8gb3AuY29udGVudC5sZW5ndGggOiAxKVxuICAgICAgICAgICAgICBvcC5kZWxldGVkID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAob3Aub3BDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24ob3Aub3BDb250ZW50KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcC5yZXF1aXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5yZXF1aXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZGVsZXRlT3BlcmF0aW9uKG9wLnJlcXVpcmVzW2ldKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG9wKVxuICAgICAgICAgICAgdGhpcy5zdG9yZS5nYzEucHVzaChvcC5pZCkgLy8gdGhpcyBpcyBvayBiZWNhdWVzIGl0cyBzaG9ydGx5IGJlZm9yZSBzeW5jIChvdGhlcndpc2UgdXNlIHF1ZXVlR2FyYmFnZUNvbGxlY3RvciEpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLmRlbGV0ZWQpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IG51bGxcbiAgICAgICAgICBpZiAob3AubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZWZ0ID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG9wLmxlZnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnN0b3JlLmFkZFRvR2FyYmFnZUNvbGxlY3Rvci5jYWxsKHRoaXMsIG9wLCBsZWZ0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICAvKlxuICAgICAgUmVhbGx5IHJlbW92ZSBhbiBvcCBhbmQgYWxsIGl0cyBlZmZlY3RzLlxuICAgICAgVGhlIGNvbXBsaWNhdGVkIGNhc2UgaGVyZSBpcyB0aGUgSW5zZXJ0IG9wZXJhdGlvbjpcbiAgICAgICogcmVzZXQgbGVmdFxuICAgICAgKiByZXNldCByaWdodFxuICAgICAgKiByZXNldCBwYXJlbnQuc3RhcnRcbiAgICAgICogcmVzZXQgcGFyZW50LmVuZFxuICAgICAgKiByZXNldCBvcmlnaW5zIG9mIGFsbCByaWdodCBvcHNcbiAgICAqL1xuICAgICogZ2FyYmFnZUNvbGxlY3RPcGVyYXRpb24gKGlkKSB7XG4gICAgICB0aGlzLnN0b3JlLmFkZFRvRGVidWcoJ3lpZWxkKiB0aGlzLmdhcmJhZ2VDb2xsZWN0T3BlcmF0aW9uKCcsIGlkLCAnKScpXG4gICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihpZClcbiAgICAgIHlpZWxkKiB0aGlzLm1hcmtHYXJiYWdlQ29sbGVjdGVkKGlkLCAobyAhPSBudWxsICYmIG8uY29udGVudCAhPSBudWxsKSA/IG8uY29udGVudC5sZW5ndGggOiAxKSAvLyBhbHdheXMgbWFyayBnYydkXG4gICAgICAvLyBpZiBvcCBleGlzdHMsIHRoZW4gY2xlYW4gdGhhdCBtZXNzIHVwLi5cbiAgICAgIGlmIChvICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRlcHMgPSBbXVxuICAgICAgICBpZiAoby5vcENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGRlcHMucHVzaChvLm9wQ29udGVudClcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5yZXF1aXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgZGVwcyA9IGRlcHMuY29uY2F0KG8ucmVxdWlyZXMpXG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRlcCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihkZXBzW2ldKVxuICAgICAgICAgIGlmIChkZXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFkZXAuZGVsZXRlZCkge1xuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24oZGVwLmlkKVxuICAgICAgICAgICAgICBkZXAgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oZGVwLmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVwLmdjID0gdHJ1ZVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGRlcClcbiAgICAgICAgICAgIHRoaXMuc3RvcmUucXVldWVHYXJiYWdlQ29sbGVjdG9yKGRlcC5pZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMubWFya0dhcmJhZ2VDb2xsZWN0ZWQoZGVwc1tpXSwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZ2MnZCBvcCBmcm9tIHRoZSBsZWZ0IG9wLCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKG8ubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGxlZnQgPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb24oby5sZWZ0KVxuICAgICAgICAgIGxlZnQucmlnaHQgPSBvLnJpZ2h0XG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGxlZnQpXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGdjJ2Qgb3AgZnJvbSB0aGUgcmlnaHQgb3AsIGlmIGl0IGV4aXN0c1xuICAgICAgICAvLyBhbHNvIHJlc2V0IG9yaWdpbnMgb2YgcmlnaHQgb3BzXG4gICAgICAgIGlmIChvLnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcmlnaHQgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5yaWdodClcbiAgICAgICAgICByaWdodC5sZWZ0ID0gby5sZWZ0XG5cbiAgICAgICAgICBpZiAoby5vcmlnaW5PZiAhPSBudWxsICYmIG8ub3JpZ2luT2YubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gZmluZCBuZXcgb3JpZ2luIG9mIHJpZ2h0IG9wc1xuICAgICAgICAgICAgLy8gb3JpZ2luIGlzIHRoZSBmaXJzdCBsZWZ0IGRlbGV0ZWQgb3BlcmF0aW9uXG4gICAgICAgICAgICB2YXIgbmV3b3JpZ2luID0gby5sZWZ0XG4gICAgICAgICAgICB2YXIgbmV3b3JpZ2luXyA9IG51bGxcbiAgICAgICAgICAgIHdoaWxlIChuZXdvcmlnaW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdvcmlnaW5fID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG5ld29yaWdpbilcbiAgICAgICAgICAgICAgaWYgKG5ld29yaWdpbl8uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV3b3JpZ2luID0gbmV3b3JpZ2luXy5sZWZ0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IG9yaWdpbiBvZiBhbGwgcmlnaHQgb3BzIChleGNlcHQgZmlyc3QgcmlnaHQgLSBkdWghKSxcblxuICAgICAgICAgICAgLyogKiogVGhlIGZvbGxvd2luZyBjb2RlIGRvZXMgbm90IHJlbHkgb24gdGhlIHRoZSBvcmlnaW5PZiBwcm9wZXJ0eSAqKlxuICAgICAgICAgICAgICAgICAgSSByZWNlbnRseSBhZGRlZCBvcmlnaW5PZiB0byBhbGwgSW5zZXJ0IE9wZXJhdGlvbnMgKHNlZSBTdHJ1Y3QuSW5zZXJ0LmV4ZWN1dGUpLFxuICAgICAgICAgICAgICAgICAgd2hpY2ggc2F2ZXMgd2hpY2ggb3BlcmF0aW9ucyBvcmlnaW5hdGUgaW4gYSBJbnNlcnQgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgR2FyYmFnZSBjb2xsZWN0aW5nIHdpdGhvdXQgb3JpZ2luT2YgaXMgbW9yZSBtZW1vcnkgZWZmaWNpZW50LCBidXQgaXMgbmVhcmx5IGltcG9zc2libGUgZm9yIGxhcmdlIHRleHRzLCBvciBsaXN0cyFcbiAgICAgICAgICAgICAgICAgIEJ1dCBJIGtlZXAgdGhpcyBjb2RlIGZvciBub3dcbiAgICAgICAgICAgIGBgYFxuICAgICAgICAgICAgLy8gcmVzZXQgb3JpZ2luIG9mIHJpZ2h0XG4gICAgICAgICAgICByaWdodC5vcmlnaW4gPSBuZXdvcmlnaW5cbiAgICAgICAgICAgIC8vIHNlYXJjaCB1bnRpbCB5b3UgZmluZCBvcmlnaW4gcG9pbnRlciB0byB0aGUgbGVmdCBvZiBvXG4gICAgICAgICAgICBpZiAocmlnaHQucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihyaWdodC5yaWdodClcbiAgICAgICAgICAgICAgdmFyIGlkcyA9IFtvLmlkLCBvLnJpZ2h0XVxuICAgICAgICAgICAgICB3aGlsZSAoaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFkudXRpbHMuY29tcGFyZUlkcyhpZCwgaS5vcmlnaW4pXG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKFkudXRpbHMuY29tcGFyZUlkcyhpLm9yaWdpbiwgby5pZCkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IG9yaWdpbiBvZiBpXG4gICAgICAgICAgICAgICAgICBpLm9yaWdpbiA9IG5ld29yaWdpblxuICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldCBuZXh0IGlcbiAgICAgICAgICAgICAgICBpZiAoaS5yaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZHMucHVzaChpLmlkKVxuICAgICAgICAgICAgICAgICAgaSA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihpLnJpZ2h0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYGBgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gKiogTm93IHRoZSBuZXcgaW1wbGVtZW50YXRpb24gc3RhcnRzICoqXG4gICAgICAgICAgICAvLyByZXNldCBuZXdvcmlnaW4gb2YgYWxsIG9yaWdpbk9mWypdXG4gICAgICAgICAgICBmb3IgKHZhciBfaSBpbiBvLm9yaWdpbk9mKSB7XG4gICAgICAgICAgICAgIHZhciBvcmlnaW5zSW4gPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5vcmlnaW5PZltfaV0pXG4gICAgICAgICAgICAgIGlmIChvcmlnaW5zSW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbnNJbi5vcmlnaW4gPSBuZXdvcmlnaW5cbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24ob3JpZ2luc0luKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3b3JpZ2luICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld29yaWdpbl8ub3JpZ2luT2YgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld29yaWdpbl8ub3JpZ2luT2YgPSBvLm9yaWdpbk9mXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3b3JpZ2luXy5vcmlnaW5PZiA9IG8ub3JpZ2luT2YuY29uY2F0KG5ld29yaWdpbl8ub3JpZ2luT2YpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG5ld29yaWdpbl8pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHNldCByaWdodCBoZXJlLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyByaWdodCBzaG91bGQgYmUgaW4gby5vcmlnaW5PZiA9PiBpdCBpcyBzZXQgaXQgdGhlIHByZXZpb3VzIGZvciBsb29wXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIGRpZG4ndCBuZWVkIHRvIHJlc2V0IHRoZSBvcmlnaW4gb2YgcmlnaHRcbiAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gc2V0IHJpZ2h0IGhlcmVcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihyaWdodClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbyBtYXkgb3JpZ2luYXRlIGluIGFub3RoZXIgb3BlcmF0aW9uLlxuICAgICAgICAvLyBTaW5jZSBvIGlzIGRlbGV0ZWQsIHdlIGhhdmUgdG8gcmVzZXQgby5vcmlnaW4ncyBgb3JpZ2luT2ZgIHByb3BlcnR5XG4gICAgICAgIGlmIChvLm9yaWdpbiAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihvLm9yaWdpbilcbiAgICAgICAgICBvcmlnaW4ub3JpZ2luT2YgPSBvcmlnaW4ub3JpZ2luT2YuZmlsdGVyKGZ1bmN0aW9uIChfaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAhWS51dGlscy5jb21wYXJlSWRzKGlkLCBfaWQpXG4gICAgICAgICAgfSlcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24ob3JpZ2luKVxuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRcbiAgICAgICAgaWYgKG8ucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnQgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5wYXJlbnQpXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGdjJ2Qgb3AgZnJvbSBwYXJlbnQsIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgc2V0UGFyZW50ID0gZmFsc2UgLy8gd2hldGhlciB0byBzYXZlIHBhcmVudCB0byB0aGUgb3NcbiAgICAgICAgICBpZiAoby5wYXJlbnRTdWIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFkudXRpbHMuY29tcGFyZUlkcyhwYXJlbnQubWFwW28ucGFyZW50U3ViXSwgby5pZCkpIHtcbiAgICAgICAgICAgICAgc2V0UGFyZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoby5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lm1hcFtvLnBhcmVudFN1Yl0gPSBvLnJpZ2h0XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudC5tYXBbby5wYXJlbnRTdWJdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFkudXRpbHMuY29tcGFyZUlkcyhwYXJlbnQuc3RhcnQsIG8uaWQpKSB7XG4gICAgICAgICAgICAgIC8vIGdjJ2Qgb3AgaXMgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgIHNldFBhcmVudCA9IHRydWVcbiAgICAgICAgICAgICAgcGFyZW50LnN0YXJ0ID0gby5yaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFkudXRpbHMubWF0Y2hlc0lkKG8sIHBhcmVudC5lbmQpKSB7XG4gICAgICAgICAgICAgIC8vIGdjJ2Qgb3AgaXMgdGhlIGVuZFxuICAgICAgICAgICAgICBzZXRQYXJlbnQgPSB0cnVlXG4gICAgICAgICAgICAgIHBhcmVudC5lbmQgPSBvLmxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNldFBhcmVudCkge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKHBhcmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluYWxseSByZW1vdmUgaXQgZnJvbSB0aGUgb3NcbiAgICAgICAgeWllbGQqIHRoaXMucmVtb3ZlT3BlcmF0aW9uKG8uaWQpXG4gICAgICB9XG4gICAgfVxuICAgICogY2hlY2tEZWxldGVTdG9yZUZvclN0YXRlIChzdGF0ZSkge1xuICAgICAgdmFyIG4gPSB5aWVsZCogdGhpcy5kcy5maW5kV2l0aFVwcGVyQm91bmQoW3N0YXRlLnVzZXIsIHN0YXRlLmNsb2NrXSlcbiAgICAgIGlmIChuICE9IG51bGwgJiYgbi5pZFswXSA9PT0gc3RhdGUudXNlciAmJiBuLmdjKSB7XG4gICAgICAgIHN0YXRlLmNsb2NrID0gTWF0aC5tYXgoc3RhdGUuY2xvY2ssIG4uaWRbMV0gKyBuLmxlbilcbiAgICAgIH1cbiAgICB9XG4gICAgKiB1cGRhdGVTdGF0ZSAodXNlcikge1xuICAgICAgdmFyIHN0YXRlID0geWllbGQqIHRoaXMuZ2V0U3RhdGUodXNlcilcbiAgICAgIHlpZWxkKiB0aGlzLmNoZWNrRGVsZXRlU3RvcmVGb3JTdGF0ZShzdGF0ZSlcbiAgICAgIHZhciBvID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKFt1c2VyLCBzdGF0ZS5jbG9ja10pXG4gICAgICB2YXIgb0xlbmd0aCA9IChvICE9IG51bGwgJiYgby5jb250ZW50ICE9IG51bGwpID8gby5jb250ZW50Lmxlbmd0aCA6IDFcbiAgICAgIHdoaWxlIChvICE9IG51bGwgJiYgdXNlciA9PT0gby5pZFswXSAmJiBvLmlkWzFdIDw9IHN0YXRlLmNsb2NrICYmIG8uaWRbMV0gKyBvTGVuZ3RoID4gc3RhdGUuY2xvY2spIHtcbiAgICAgICAgLy8gZWl0aGVyIGl0cyBhIG5ldyBvcGVyYXRpb24gKDEuIGNhc2UpLCBvciBpdCBpcyBhbiBvcGVyYXRpb24gdGhhdCB3YXMgZGVsZXRlZCwgYnV0IGlzIG5vdCB5ZXQgaW4gdGhlIE9TXG4gICAgICAgIHN0YXRlLmNsb2NrICs9IG9MZW5ndGhcbiAgICAgICAgeWllbGQqIHRoaXMuY2hlY2tEZWxldGVTdG9yZUZvclN0YXRlKHN0YXRlKVxuICAgICAgICBvID0geWllbGQqIHRoaXMub3MuZmluZE5leHQoby5pZClcbiAgICAgICAgb0xlbmd0aCA9IChvICE9IG51bGwgJiYgby5jb250ZW50ICE9IG51bGwpID8gby5jb250ZW50Lmxlbmd0aCA6IDFcbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLnNldFN0YXRlKHN0YXRlKVxuICAgIH1cbiAgICAvKlxuICAgICAgYXBwbHkgYSBkZWxldGUgc2V0IGluIG9yZGVyIHRvIGdldFxuICAgICAgdGhlIHN0YXRlIG9mIHRoZSBzdXBwbGllZCBkc1xuICAgICovXG4gICAgKiBhcHBseURlbGV0ZVNldCAoZHMpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBbXVxuXG4gICAgICBmb3IgKHZhciB1c2VyIGluIGRzKSB7XG4gICAgICAgIHZhciBkdiA9IGRzW3VzZXJdXG4gICAgICAgIHZhciBwb3MgPSAwXG4gICAgICAgIHZhciBkID0gZHZbcG9zXVxuICAgICAgICB5aWVsZCogdGhpcy5kcy5pdGVyYXRlKHRoaXMsIFt1c2VyLCAwXSwgW3VzZXIsIE51bWJlci5NQVhfVkFMVUVdLCBmdW5jdGlvbiAqIChuKSB7XG4gICAgICAgICAgLy8gY2FzZXM6XG4gICAgICAgICAgLy8gMS4gZCBkZWxldGVzIHNvbWV0aGluZyB0byB0aGUgcmlnaHQgb2YgblxuICAgICAgICAgIC8vICA9PiBnbyB0byBuZXh0IG4gKGJyZWFrKVxuICAgICAgICAgIC8vIDIuIGQgZGVsZXRlcyBzb21ldGhpbmcgdG8gdGhlIGxlZnQgb2YgblxuICAgICAgICAgIC8vICA9PiBjcmVhdGUgZGVsZXRpb25zXG4gICAgICAgICAgLy8gID0+IHJlc2V0IGQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAvLyAgKik9PiBpZiBkIGRvZXNuJ3QgZGVsZXRlIGFueXRoaW5nIGFueW1vcmUsIGdvIHRvIG5leHQgZCAoY29udGludWUpXG4gICAgICAgICAgLy8gMy4gbm90IDIpIGFuZCBkIGRlbGV0ZXMgc29tZXRoaW5nIHRoYXQgYWxzbyBuIGRlbGV0ZXNcbiAgICAgICAgICAvLyAgPT4gcmVzZXQgZCBzbyB0aGF0IGl0IGRvZXNuJ3QgY29udGFpbiBuJ3MgZGVsZXRpb25cbiAgICAgICAgICAvLyAgKik9PiBpZiBkIGRvZXMgbm90IGRlbGV0ZSBhbnl0aGluZyBhbnltb3JlLCBnbyB0byBuZXh0IGQgKGNvbnRpbnVlKVxuICAgICAgICAgIHdoaWxlIChkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gMCAvLyBkZXNjcmliZSB0aGUgZGlmZiBvZiBsZW5ndGggaW4gMSkgYW5kIDIpXG4gICAgICAgICAgICBpZiAobi5pZFsxXSArIG4ubGVuIDw9IGRbMF0pIHtcbiAgICAgICAgICAgICAgLy8gMSlcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZFswXSA8IG4uaWRbMV0pIHtcbiAgICAgICAgICAgICAgLy8gMilcbiAgICAgICAgICAgICAgLy8gZGVsZXRlIG1heGltdW0gdGhlIGxlbiBvZiBkXG4gICAgICAgICAgICAgIC8vIGVsc2UgZGVsZXRlIGFzIG11Y2ggYXMgcG9zc2libGVcbiAgICAgICAgICAgICAgZGlmZiA9IE1hdGgubWluKG4uaWRbMV0gLSBkWzBdLCBkWzFdKVxuICAgICAgICAgICAgICBkZWxldGlvbnMucHVzaChbdXNlciwgZFswXSwgZGlmZiwgZFsyXV0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyAzKVxuICAgICAgICAgICAgICBkaWZmID0gbi5pZFsxXSArIG4ubGVuIC0gZFswXSAvLyBuZXZlciBudWxsIChzZWUgMSlcbiAgICAgICAgICAgICAgaWYgKGRbMl0gJiYgIW4uZ2MpIHtcbiAgICAgICAgICAgICAgICAvLyBkIG1hcmtzIGFzIGdjJ2QgYnV0IG4gZG9lcyBub3RcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGRlbGV0ZSBlaXRoZXIgd2F5XG4gICAgICAgICAgICAgICAgZGVsZXRpb25zLnB1c2goW3VzZXIsIGRbMF0sIE1hdGgubWluKGRpZmYsIGRbMV0pLCBkWzJdXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbMV0gPD0gZGlmZikge1xuICAgICAgICAgICAgICAvLyBkIGRvZXNuJ3QgZGVsZXRlIGFueXRoaW5nIGFueW1vcmVcbiAgICAgICAgICAgICAgZCA9IGR2WysrcG9zXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZFswXSA9IGRbMF0gKyBkaWZmIC8vIHJlc2V0IHBvc1xuICAgICAgICAgICAgICBkWzFdID0gZFsxXSAtIGRpZmYgLy8gcmVzZXQgbGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAvLyBmb3IgdGhlIHJlc3QuLiBqdXN0IGFwcGx5IGl0XG4gICAgICAgIGZvciAoOyBwb3MgPCBkdi5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgZCA9IGR2W3Bvc11cbiAgICAgICAgICBkZWxldGlvbnMucHVzaChbdXNlciwgZFswXSwgZFsxXSwgZFsyXV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZWwgPSBkZWxldGlvbnNbaV1cbiAgICAgICAgLy8gYWx3YXlzIHRyeSB0byBkZWxldGUuLlxuICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24oW2RlbFswXSwgZGVsWzFdXSwgZGVsWzJdKVxuICAgICAgICBpZiAoZGVsWzNdKSB7XG4gICAgICAgICAgLy8gZ2MuLlxuICAgICAgICAgIHlpZWxkKiB0aGlzLm1hcmtHYXJiYWdlQ29sbGVjdGVkKFtkZWxbMF0sIGRlbFsxXV0sIGRlbFsyXSkgLy8gYWx3YXlzIG1hcmsgZ2MnZFxuICAgICAgICAgIC8vIHJlbW92ZSBvcGVyYXRpb24uLlxuICAgICAgICAgIHZhciBjb3VudGVyID0gZGVsWzFdICsgZGVsWzJdXG4gICAgICAgICAgd2hpbGUgKGNvdW50ZXIgPj0gZGVsWzFdKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLm9zLmZpbmRXaXRoVXBwZXJCb3VuZChbZGVsWzBdLCBjb3VudGVyIC0gMV0pXG4gICAgICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb0xlbiA9IG8uY29udGVudCAhPSBudWxsID8gby5jb250ZW50Lmxlbmd0aCA6IDFcbiAgICAgICAgICAgIGlmIChvLmlkWzBdICE9PSBkZWxbMF0gfHwgby5pZFsxXSArIG9MZW4gPD0gZGVsWzFdKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBpbiByYW5nZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG8uaWRbMV0gKyBvTGVuID4gZGVsWzFdICsgZGVsWzJdKSB7XG4gICAgICAgICAgICAgIC8vIG92ZXJsYXBzIHJpZ2h0XG4gICAgICAgICAgICAgIG8gPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb25DbGVhbkVuZChbZGVsWzBdLCBkZWxbMV0gKyBkZWxbMl0gLSAxXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvLmlkWzFdIDwgZGVsWzFdKSB7XG4gICAgICAgICAgICAgIC8vIG92ZXJsYXBzIGxlZnRcbiAgICAgICAgICAgICAgbyA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuU3RhcnQoW2RlbFswXSwgZGVsWzFdXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXIgPSBvLmlkWzFdXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5nYXJiYWdlQ29sbGVjdE9wZXJhdGlvbihvLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdG9yZS5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgb3BzID0gW11cbiAgICAgICAgICBvcHMucHVzaCh7c3RydWN0OiAnRGVsZXRlJywgdGFyZ2V0OiBbZFswXSwgZFsxXV0sIGxlbmd0aDogZGVsWzJdfSlcbiAgICAgICAgICB0aGlzLnN0b3JlLnkuY29ubmVjdG9yLmJyb2FkY2FzdE9wcyhvcHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgKiBpc0dhcmJhZ2VDb2xsZWN0ZWQgKGlkKSB7XG4gICAgICB2YXIgbiA9IHlpZWxkKiB0aGlzLmRzLmZpbmRXaXRoVXBwZXJCb3VuZChpZClcbiAgICAgIHJldHVybiBuICE9IG51bGwgJiYgbi5pZFswXSA9PT0gaWRbMF0gJiYgaWRbMV0gPCBuLmlkWzFdICsgbi5sZW4gJiYgbi5nY1xuICAgIH1cbiAgICAvKlxuICAgICAgQSBEZWxldGVTZXQgKGRzKSBkZXNjcmliZXMgYWxsIHRoZSBkZWxldGVkIG9wcyBpbiB0aGUgT1NcbiAgICAqL1xuICAgICogZ2V0RGVsZXRlU2V0ICgpIHtcbiAgICAgIHZhciBkcyA9IHt9XG4gICAgICB5aWVsZCogdGhpcy5kcy5pdGVyYXRlKHRoaXMsIG51bGwsIG51bGwsIGZ1bmN0aW9uICogKG4pIHtcbiAgICAgICAgdmFyIHVzZXIgPSBuLmlkWzBdXG4gICAgICAgIHZhciBjb3VudGVyID0gbi5pZFsxXVxuICAgICAgICB2YXIgbGVuID0gbi5sZW5cbiAgICAgICAgdmFyIGdjID0gbi5nY1xuICAgICAgICB2YXIgZHYgPSBkc1t1c2VyXVxuICAgICAgICBpZiAoZHYgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGR2ID0gW11cbiAgICAgICAgICBkc1t1c2VyXSA9IGR2XG4gICAgICAgIH1cbiAgICAgICAgZHYucHVzaChbY291bnRlciwgbGVuLCBnY10pXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGRzXG4gICAgfVxuICAgICogaXNEZWxldGVkIChpZCkge1xuICAgICAgdmFyIG4gPSB5aWVsZCogdGhpcy5kcy5maW5kV2l0aFVwcGVyQm91bmQoaWQpXG4gICAgICByZXR1cm4gbiAhPSBudWxsICYmIG4uaWRbMF0gPT09IGlkWzBdICYmIGlkWzFdIDwgbi5pZFsxXSArIG4ubGVuXG4gICAgfVxuICAgICogc2V0T3BlcmF0aW9uIChvcCkge1xuICAgICAgeWllbGQqIHRoaXMub3MucHV0KG9wKVxuICAgICAgcmV0dXJuIG9wXG4gICAgfVxuICAgICogYWRkT3BlcmF0aW9uIChvcCkge1xuICAgICAgeWllbGQqIHRoaXMub3MucHV0KG9wKVxuICAgICAgaWYgKCF0aGlzLnN0b3JlLnkuY29ubmVjdG9yLmlzRGlzY29ubmVjdGVkKCkgJiYgdGhpcy5zdG9yZS5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgJiYgdHlwZW9mIG9wLmlkWzFdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBpcyBjb25uZWN0ZWQsIGFuZCB0aGlzIGlzIG5vdCBnb2luZyB0byBiZSBzZW5kIGluIGFkZE9wZXJhdGlvblxuICAgICAgICB0aGlzLnN0b3JlLnkuY29ubmVjdG9yLmJyb2FkY2FzdE9wcyhbb3BdKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBpbnNlcnRpb24sIHRyeSB0byBjb21iaW5lIHdpdGggbGVmdCBpbnNlcnRpb24gKGlmIGJvdGggaGF2ZSBjb250ZW50IHByb3BlcnR5KVxuICAgICogdHJ5Q29tYmluZVdpdGhMZWZ0IChvcCkge1xuICAgICAgaWYgKFxuICAgICAgICBvcCAhPSBudWxsICYmXG4gICAgICAgIG9wLmxlZnQgIT0gbnVsbCAmJlxuICAgICAgICBvcC5jb250ZW50ICE9IG51bGwgJiZcbiAgICAgICAgb3AubGVmdFswXSA9PT0gb3AuaWRbMF0gJiZcbiAgICAgICAgWS51dGlscy5jb21wYXJlSWRzKG9wLmxlZnQsIG9wLm9yaWdpbilcbiAgICAgICkge1xuICAgICAgICB2YXIgbGVmdCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihvcC5sZWZ0KVxuICAgICAgICBpZiAobGVmdC5jb250ZW50ICE9IG51bGwgJiZcbiAgICAgICAgICAgIGxlZnQuaWRbMV0gKyBsZWZ0LmNvbnRlbnQubGVuZ3RoID09PSBvcC5pZFsxXSAmJlxuICAgICAgICAgICAgbGVmdC5vcmlnaW5PZi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICFsZWZ0LmdjICYmICFsZWZ0LmRlbGV0ZWQgJiZcbiAgICAgICAgICAgICFvcC5nYyAmJiAhb3AuZGVsZXRlZFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBjb21iaW5lIVxuICAgICAgICAgIGlmIChvcC5vcmlnaW5PZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZWZ0Lm9yaWdpbk9mID0gb3Aub3JpZ2luT2ZcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGxlZnQub3JpZ2luT2ZcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVmdC5jb250ZW50ID0gbGVmdC5jb250ZW50LmNvbmNhdChvcC5jb250ZW50KVxuICAgICAgICAgIGxlZnQucmlnaHQgPSBvcC5yaWdodFxuICAgICAgICAgIHlpZWxkKiB0aGlzLm9zLmRlbGV0ZShvcC5pZClcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24obGVmdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAqIGdldEluc2VydGlvbiAoaWQpIHtcbiAgICAgIHZhciBpbnMgPSB5aWVsZCogdGhpcy5vcy5maW5kV2l0aFVwcGVyQm91bmQoaWQpXG4gICAgICBpZiAoaW5zID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZW4gPSBpbnMuY29udGVudCAhPSBudWxsID8gaW5zLmNvbnRlbnQubGVuZ3RoIDogMSAvLyBpbiBjYXNlIG9mIG9wQ29udGVudFxuICAgICAgICBpZiAoaWRbMF0gPT09IGlucy5pZFswXSAmJiBpZFsxXSA8IGlucy5pZFsxXSArIGxlbikge1xuICAgICAgICAgIHJldHVybiBpbnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICogZ2V0SW5zZXJ0aW9uQ2xlYW5TdGFydEVuZCAoaWQpIHtcbiAgICAgIHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuU3RhcnQoaWQpXG4gICAgICByZXR1cm4geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uQ2xlYW5FbmQoaWQpXG4gICAgfVxuICAgIC8vIFJldHVybiBhbiBpbnNlcnRpb24gc3VjaCB0aGF0IGlkIGlzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGNvbnRlbnRcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIG1hbmlwdWxhdGVzIGFuIG9wZXJhdGlvbiwgaWYgbmVjZXNzYXJ5XG4gICAgKiBnZXRJbnNlcnRpb25DbGVhblN0YXJ0IChpZCkge1xuICAgICAgdmFyIGlucyA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihpZClcbiAgICAgIGlmIChpbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5zLmlkWzFdID09PSBpZFsxXSkge1xuICAgICAgICAgIHJldHVybiBpbnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IFkudXRpbHMuY29weU9iamVjdChpbnMpXG4gICAgICAgICAgaW5zLmNvbnRlbnQgPSBsZWZ0LmNvbnRlbnQuc3BsaWNlKGlkWzFdIC0gaW5zLmlkWzFdKVxuICAgICAgICAgIGlucy5pZCA9IGlkXG4gICAgICAgICAgdmFyIGxlZnRMaWQgPSBZLnV0aWxzLmdldExhc3RJZChsZWZ0KVxuICAgICAgICAgIGlucy5vcmlnaW4gPSBsZWZ0TGlkXG4gICAgICAgICAgbGVmdC5vcmlnaW5PZiA9IFtpbnMuaWRdXG4gICAgICAgICAgbGVmdC5yaWdodCA9IGlucy5pZFxuICAgICAgICAgIGlucy5sZWZ0ID0gbGVmdExpZFxuICAgICAgICAgIC8vIGRlYnVnZ2VyIC8vIGNoZWNrXG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGxlZnQpXG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGlucylcbiAgICAgICAgICBpZiAobGVmdC5nYykge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5xdWV1ZUdhcmJhZ2VDb2xsZWN0b3IoaW5zLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5zXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybiBhbiBpbnNlcnRpb24gc3VjaCB0aGF0IGlkIGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgY29udGVudFxuICAgIC8vIFRoaXMgZnVuY3Rpb24gbWFuaXB1bGF0ZXMgYW4gb3BlcmF0aW9uLCBpZiBuZWNlc3NhcnlcbiAgICAqIGdldEluc2VydGlvbkNsZWFuRW5kIChpZCkge1xuICAgICAgdmFyIGlucyA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihpZClcbiAgICAgIGlmIChpbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5zLmNvbnRlbnQgPT0gbnVsbCB8fCAoaW5zLmlkWzFdICsgaW5zLmNvbnRlbnQubGVuZ3RoIC0gMSA9PT0gaWRbMV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGluc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByaWdodCA9IFkudXRpbHMuY29weU9iamVjdChpbnMpXG4gICAgICAgICAgcmlnaHQuY29udGVudCA9IGlucy5jb250ZW50LnNwbGljZShpZFsxXSAtIGlucy5pZFsxXSArIDEpIC8vIGN1dCBvZmYgcmVtYWluZGVyXG4gICAgICAgICAgcmlnaHQuaWQgPSBbaWRbMF0sIGlkWzFdICsgMV1cbiAgICAgICAgICB2YXIgaW5zTGlkID0gWS51dGlscy5nZXRMYXN0SWQoaW5zKVxuICAgICAgICAgIHJpZ2h0Lm9yaWdpbiA9IGluc0xpZFxuICAgICAgICAgIGlucy5vcmlnaW5PZiA9IFtyaWdodC5pZF1cbiAgICAgICAgICBpbnMucmlnaHQgPSByaWdodC5pZFxuICAgICAgICAgIHJpZ2h0LmxlZnQgPSBpbnNMaWRcbiAgICAgICAgICAvLyBkZWJ1Z2dlciAvLyBjaGVja1xuICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihyaWdodClcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24oaW5zKVxuICAgICAgICAgIGlmIChpbnMuZ2MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUucXVldWVHYXJiYWdlQ29sbGVjdG9yKHJpZ2h0LmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5zXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgICogZ2V0T3BlcmF0aW9uIChpZC8qIDphbnkgKi8pLyogOlRyYW5zYWN0aW9uPGFueT4gKi8ge1xuICAgICAgdmFyIG8gPSB5aWVsZCogdGhpcy5vcy5maW5kKGlkKVxuICAgICAgaWYgKGlkWzBdICE9PSAnXycgfHwgbyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvXG4gICAgICB9IGVsc2UgeyAvLyB0eXBlIGlzIHN0cmluZ1xuICAgICAgICAvLyBnZW5lcmF0ZSB0aGlzIG9wZXJhdGlvbj9cbiAgICAgICAgdmFyIGNvbXAgPSBpZFsxXS5zcGxpdCgnXycpXG4gICAgICAgIGlmIChjb21wLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgc3RydWN0ID0gY29tcFswXVxuICAgICAgICAgIHZhciBvcCA9IFkuU3RydWN0W3N0cnVjdF0uY3JlYXRlKGlkKVxuICAgICAgICAgIG9wLnR5cGUgPSBjb21wWzFdXG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG9wKVxuICAgICAgICAgIHJldHVybiBvcFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdvbid0IGJlIGNhbGxlZC4gYnV0IGp1c3QgaW4gY2FzZS4uXG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBjYXNlLiBIb3cgY2FuIHRoaXMgaGFwcGVuPycpXG4gICAgICAgICAgZGVidWdnZXIgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgKiByZW1vdmVPcGVyYXRpb24gKGlkKSB7XG4gICAgICB5aWVsZCogdGhpcy5vcy5kZWxldGUoaWQpXG4gICAgfVxuICAgICogc2V0U3RhdGUgKHN0YXRlKSB7XG4gICAgICB2YXIgdmFsID0ge1xuICAgICAgICBpZDogW3N0YXRlLnVzZXJdLFxuICAgICAgICBjbG9jazogc3RhdGUuY2xvY2tcbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLnNzLnB1dCh2YWwpXG4gICAgfVxuICAgICogZ2V0U3RhdGUgKHVzZXIpIHtcbiAgICAgIHZhciBuID0geWllbGQqIHRoaXMuc3MuZmluZChbdXNlcl0pXG4gICAgICB2YXIgY2xvY2sgPSBuID09IG51bGwgPyBudWxsIDogbi5jbG9ja1xuICAgICAgaWYgKGNsb2NrID09IG51bGwpIHtcbiAgICAgICAgY2xvY2sgPSAwXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VyOiB1c2VyLFxuICAgICAgICBjbG9jazogY2xvY2tcbiAgICAgIH1cbiAgICB9XG4gICAgKiBnZXRTdGF0ZVZlY3RvciAoKSB7XG4gICAgICB2YXIgc3RhdGVWZWN0b3IgPSBbXVxuICAgICAgeWllbGQqIHRoaXMuc3MuaXRlcmF0ZSh0aGlzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAqIChuKSB7XG4gICAgICAgIHN0YXRlVmVjdG9yLnB1c2goe1xuICAgICAgICAgIHVzZXI6IG4uaWRbMF0sXG4gICAgICAgICAgY2xvY2s6IG4uY2xvY2tcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gc3RhdGVWZWN0b3JcbiAgICB9XG4gICAgKiBnZXRTdGF0ZVNldCAoKSB7XG4gICAgICB2YXIgc3MgPSB7fVxuICAgICAgeWllbGQqIHRoaXMuc3MuaXRlcmF0ZSh0aGlzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAqIChuKSB7XG4gICAgICAgIHNzW24uaWRbMF1dID0gbi5jbG9ja1xuICAgICAgfSlcbiAgICAgIHJldHVybiBzc1xuICAgIH1cbiAgICAvKlxuICAgICAgSGVyZSwgd2UgbWFrZSBhbGwgbWlzc2luZyBvcGVyYXRpb25zIGV4ZWN1dGFibGUgZm9yIHRoZSByZWNlaXZpbmcgdXNlci5cblxuICAgICAgTm90ZXM6XG4gICAgICAgIHN0YXJ0U1M6IGRlbm90ZXMgdG8gdGhlIFNWIHRoYXQgdGhlIHJlbW90ZSB1c2VyIHNlbnRcbiAgICAgICAgY3VyclNTOiAgZGVub3RlcyB0byB0aGUgc3RhdGUgdmVjdG9yIHRoYXQgdGhlIHVzZXIgc2hvdWxkIGhhdmUgaWYgaGVcbiAgICAgICAgICAgICAgICAgYXBwbGllcyBhbGwgYWxyZWFkeSBzZW50IG9wZXJhdGlvbnMgKGluY3JlYXNlcyBpcyBlYWNoIHN0ZXApXG5cbiAgICAgIFdlIGZhY2Ugc2V2ZXJhbCBwcm9ibGVtczpcbiAgICAgICogRXhlY3V0ZSBvcCBhcyBpcyB3b24ndCB3b3JrIGJlY2F1c2Ugb3BzIGRlcGVuZCBvbiBlYWNoIG90aGVyXG4gICAgICAgLT4gZmluZCBhIHdheSBzbyB0aGF0IHRoZXkgZG8gbm90IGFueW1vcmVcbiAgICAgICogV2hlbiBjaGFuZ2luZyBsZWZ0LCBtdXN0IG5vdCBnbyBtb3JlIHRvIHRoZSBsZWZ0IHRoYW4gdGhlIG9yaWdpblxuICAgICAgKiBXaGVuIGNoYW5naW5nIHJpZ2h0LCB5b3UgaGF2ZSB0byBjb25zaWRlciB0aGF0IG90aGVyIG9wcyBtYXkgaGF2ZSBvcFxuICAgICAgICBhcyB0aGVpciBvcmlnaW4sIHRoaXMgbWVhbnMgdGhhdCB5b3UgbXVzdCBub3Qgc2V0IG9uZSBvZiB0aGVzZSBvcHNcbiAgICAgICAgYXMgdGhlIG5ldyByaWdodCAoaW50ZXJkZXBlbmRlbmNpZXMgb2Ygb3BzKVxuICAgICAgKiBjYW4ndCBqdXN0IGdvIHRvIHRoZSByaWdodCB1bnRpbCB5b3UgZmluZCB0aGUgZmlyc3Qga25vd24gb3BlcmF0aW9uLFxuICAgICAgICBXaXRoIGN1cnJTU1xuICAgICAgICAgIC0+IGludGVyZGVwZW5kZW5jeSBvZiBvcHMgaXMgYSBwcm9ibGVtXG4gICAgICAgIFdpdGggc3RhcnRTU1xuICAgICAgICAgIC0+IGxlYWRzIHRvIGluY29uc2lzdGVuY2llcyB3aGVuIHR3byB1c2VycyBqb2luIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAgVGhlbiB0aGUgcG9zaXRpb24gZGVwZW5kcyBvbiB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uIC0+IGVycm9yIVxuXG4gICAgICAgIFNvbHV0aW9uOlxuICAgICAgICAtPiByZS1jcmVhdGUgb3JpZ2luaWFsIHNpdHVhdGlvblxuICAgICAgICAgIC0+IHNldCBvcC5sZWZ0ID0gb3Aub3JpZ2luICh3aGljaCBuZXZlciBjaGFuZ2VzKVxuICAgICAgICAgIC0+IHNldCBvcC5yaWdodFxuICAgICAgICAgICAgICAgdG8gdGhlIGZpcnN0IG9wZXJhdGlvbiB0aGF0IGlzIGtub3duIChhY2NvcmRpbmcgdG8gc3RhcnRTUylcbiAgICAgICAgICAgICAgIG9yIHRvIHRoZSBmaXJzdCBvcGVyYXRpb24gdGhhdCBoYXMgYW4gb3JpZ2luIHRoYXQgaXMgbm90IHRvIHRoZVxuICAgICAgICAgICAgICAgcmlnaHQgb2Ygb3AuXG4gICAgICAgICAgLT4gRW5mb3JjZXMgdW5pcXVlIGV4ZWN1dGlvbiBvcmRlciAtPiBoYXBweSB1c2VyXG5cbiAgICAgICAgSW1wcm92ZW1lbnRzOiBUT0RPXG4gICAgICAgICAgKiBDb3VsZCBzZXQgbGVmdCB0byBvcmlnaW4sIG9yIHRoZSBmaXJzdCBrbm93biBvcGVyYXRpb25cbiAgICAgICAgICAgIChzdGFydFNTIG9yIGN1cnJTUy4uID8pXG4gICAgICAgICAgICAtPiBDb3VsZCBiZSBuZWNlc3Nhcnkgd2hlbiBJIHR1cm4gR0MgYWdhaW4uXG4gICAgICAgICAgICAtPiBJcyBhIGJhZChpc2gpIGlkZWEgYmVjYXVzZSBpdCByZXF1aXJlcyBtb3JlIGNvbXB1dGF0aW9uXG5cbiAgICAgIFdoYXQgd2UgZG86XG4gICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgbWlzc2luZyBvcGVyYXRpb25zLlxuICAgICAgKiBXaGVuIHRoZXJlIGlzIGFuIG9wZXJhdGlvbiwgd2hlcmUgdGhlIHJpZ2h0IG9wIGlzIGtub3duLCBzZW5kIHRoaXMgb3AgYWxsIG1pc3Npbmcgb3BzIHRvIHRoZSBsZWZ0IHRvIHRoZSB1c2VyXG4gICAgICAqIEkgZXhwbGFpbmVkIGFib3ZlIHdoYXQgd2UgaGF2ZSB0byBkbyB3aXRoIGVhY2ggb3BlcmF0aW9uLiBIZXJlIGlzIGhvdyB3ZSBkbyBpdCBlZmZpY2llbnRseTpcbiAgICAgICAgMS4gR28gdG8gdGhlIGxlZnQgdW50aWwgeW91IGZpbmQgZWl0aGVyIG9wLm9yaWdpbiwgb3IgYSBrbm93biBvcGVyYXRpb24gKGxldCBvIGRlbm90ZSBjdXJyZW50IG9wZXJhdGlvbiBpbiB0aGUgaXRlcmF0aW9uKVxuICAgICAgICAyLiBGb3VuZCBhIGtub3duIG9wZXJhdGlvbiAtPiBzZXQgb3AubGVmdCA9IG8sIGFuZCBzZW5kIGl0IHRvIHRoZSB1c2VyLiBzdG9wXG4gICAgICAgIDMuIEZvdW5kIG8gPSBvcC5vcmlnaW4gLT4gc2V0IG9wLmxlZnQgPSBvcC5vcmlnaW4sIGFuZCBzZW5kIGl0IHRvIHRoZSB1c2VyLiBzdGFydCBhZ2FpbiBmcm9tIDEuIChzZXQgb3AgPSBvKVxuICAgICAgICA0LiBGb3VuZCBzb21lIG8gLT4gc2V0IG8ucmlnaHQgPSBvcCwgby5sZWZ0ID0gby5vcmlnaW4sIHNlbmQgaXQgdG8gdGhlIHVzZXIsIGNvbnRpbnVlXG4gICAgKi9cbiAgICAqIGdldE9wZXJhdGlvbnMgKHN0YXJ0U1MpIHtcbiAgICAgIC8vIFRPRE86IHVzZSBib3VuZHMgaGVyZSFcbiAgICAgIGlmIChzdGFydFNTID09IG51bGwpIHtcbiAgICAgICAgc3RhcnRTUyA9IHt9XG4gICAgICB9XG4gICAgICB2YXIgc2VuZCA9IFtdXG5cbiAgICAgIHZhciBlbmRTViA9IHlpZWxkKiB0aGlzLmdldFN0YXRlVmVjdG9yKClcbiAgICAgIGZvciAodmFyIGVuZFN0YXRlIG9mIGVuZFNWKSB7XG4gICAgICAgIHZhciB1c2VyID0gZW5kU3RhdGUudXNlclxuICAgICAgICBpZiAodXNlciA9PT0gJ18nKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRQb3MgPSBzdGFydFNTW3VzZXJdIHx8IDBcbiAgICAgICAgaWYgKHN0YXJ0UG9zID4gMCkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGEgY2hhbmdlIHRoYXQgW3VzZXIsIHN0YXJ0UG9zXSBpcyBpbiBhIGNvbXBvc2VkIEluc2VydGlvbiAod2l0aCBhIHNtYWxsZXIgY291bnRlcilcbiAgICAgICAgICAvLyBmaW5kIG91dCBpZiB0aGF0IGlzIHRoZSBjYXNlXG4gICAgICAgICAgdmFyIGZpcnN0TWlzc2luZyA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihbdXNlciwgc3RhcnRQb3NdKVxuICAgICAgICAgIGlmIChmaXJzdE1pc3NpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHN0YXJ0UG9zXG4gICAgICAgICAgICBzdGFydFBvcyA9IGZpcnN0TWlzc2luZy5pZFsxXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5vcy5pdGVyYXRlKHRoaXMsIFt1c2VyLCBzdGFydFBvc10sIFt1c2VyLCBOdW1iZXIuTUFYX1ZBTFVFXSwgZnVuY3Rpb24gKiAob3ApIHtcbiAgICAgICAgICBvcCA9IFkuU3RydWN0W29wLnN0cnVjdF0uZW5jb2RlKG9wKVxuICAgICAgICAgIGlmIChvcC5zdHJ1Y3QgIT09ICdJbnNlcnQnKSB7XG4gICAgICAgICAgICBzZW5kLnB1c2gob3ApXG4gICAgICAgICAgfSBlbHNlIGlmIChvcC5yaWdodCA9PSBudWxsIHx8IG9wLnJpZ2h0WzFdIDwgKHN0YXJ0U1Nbb3AucmlnaHRbMF1dIHx8IDApKSB7XG4gICAgICAgICAgICAvLyBjYXNlIDEuIG9wLnJpZ2h0IGlzIGtub3duXG4gICAgICAgICAgICB2YXIgbyA9IG9wXG4gICAgICAgICAgICAvLyBSZW1lbWJlcjogP1xuICAgICAgICAgICAgLy8gLT4gc2V0IG9wLnJpZ2h0XG4gICAgICAgICAgICAvLyAgICAxLiB0byB0aGUgZmlyc3Qgb3BlcmF0aW9uIHRoYXQgaXMga25vd24gKGFjY29yZGluZyB0byBzdGFydFNTKVxuICAgICAgICAgICAgLy8gICAgMi4gb3IgdG8gdGhlIGZpcnN0IG9wZXJhdGlvbiB0aGF0IGhhcyBhbiBvcmlnaW4gdGhhdCBpcyBub3QgdG8gdGhlXG4gICAgICAgICAgICAvLyAgICAgIHJpZ2h0IG9mIG9wLlxuICAgICAgICAgICAgLy8gRm9yIHRoaXMgd2UgbWFpbnRhaW4gYSBsaXN0IG9mIG9wcyB3aGljaCBvcmlnaW5zIGFyZSBub3QgZm91bmQgeWV0LlxuICAgICAgICAgICAgdmFyIG1pc3Npbmdfb3JpZ2lucyA9IFtvcF1cbiAgICAgICAgICAgIHZhciBuZXdyaWdodCA9IG9wLnJpZ2h0XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAoby5sZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcC5sZWZ0ID0gbnVsbFxuICAgICAgICAgICAgICAgIHNlbmQucHVzaChvcClcbiAgICAgICAgICAgICAgICBpZiAoIVkudXRpbHMuY29tcGFyZUlkcyhvLmlkLCBvcC5pZCkpIHtcbiAgICAgICAgICAgICAgICAgIG8gPSBZLlN0cnVjdFtvcC5zdHJ1Y3RdLmVuY29kZShvKVxuICAgICAgICAgICAgICAgICAgby5yaWdodCA9IG1pc3Npbmdfb3JpZ2luc1ttaXNzaW5nX29yaWdpbnMubGVuZ3RoIC0gMV0uaWRcbiAgICAgICAgICAgICAgICAgIHNlbmQucHVzaChvKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG8gPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb24oby5sZWZ0KVxuICAgICAgICAgICAgICAvLyB3ZSBzZXQgYW5vdGhlciBvLCBjaGVjayBpZiB3ZSBjYW4gcmVkdWNlICRtaXNzaW5nX29yaWdpbnNcbiAgICAgICAgICAgICAgd2hpbGUgKG1pc3Npbmdfb3JpZ2lucy5sZW5ndGggPiAwICYmIFkudXRpbHMubWF0Y2hlc0lkKG8sIG1pc3Npbmdfb3JpZ2luc1ttaXNzaW5nX29yaWdpbnMubGVuZ3RoIC0gMV0ub3JpZ2luKSkge1xuICAgICAgICAgICAgICAgIG1pc3Npbmdfb3JpZ2lucy5wb3AoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvLmlkWzFdIDwgKHN0YXJ0U1Nbby5pZFswXV0gfHwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDIuIG8gaXMga25vd25cbiAgICAgICAgICAgICAgICBvcC5sZWZ0ID0gWS51dGlscy5nZXRMYXN0SWQobylcbiAgICAgICAgICAgICAgICBzZW5kLnB1c2gob3ApXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChZLnV0aWxzLm1hdGNoZXNJZChvLCBvcC5vcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSAzLiBvIGlzIG9wLm9yaWdpblxuICAgICAgICAgICAgICAgIG9wLmxlZnQgPSBvcC5vcmlnaW5cbiAgICAgICAgICAgICAgICBzZW5kLnB1c2gob3ApXG4gICAgICAgICAgICAgICAgb3AgPSBZLlN0cnVjdFtvcC5zdHJ1Y3RdLmVuY29kZShvKVxuICAgICAgICAgICAgICAgIG9wLnJpZ2h0ID0gbmV3cmlnaHRcbiAgICAgICAgICAgICAgICBpZiAobWlzc2luZ19vcmlnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuIC4uIDooIHBsZWFzZSByZXBvcnQgdGhpcycpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pc3Npbmdfb3JpZ2lucyA9IFtvcF1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDQuIHNlbmQgbywgY29udGludWUgdG8gZmluZCBvcC5vcmlnaW5cbiAgICAgICAgICAgICAgICB2YXIgcyA9IFkuU3RydWN0W29wLnN0cnVjdF0uZW5jb2RlKG8pXG4gICAgICAgICAgICAgICAgcy5yaWdodCA9IG1pc3Npbmdfb3JpZ2luc1ttaXNzaW5nX29yaWdpbnMubGVuZ3RoIC0gMV0uaWRcbiAgICAgICAgICAgICAgICBzLmxlZnQgPSBzLm9yaWdpblxuICAgICAgICAgICAgICAgIHNlbmQucHVzaChzKVxuICAgICAgICAgICAgICAgIG1pc3Npbmdfb3JpZ2lucy5wdXNoKG8pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VuZC5yZXZlcnNlKClcbiAgICB9XG4gICAgLyogdGhpcyBpcyB3aGF0IHdlIHVzZWQgYmVmb3JlLi4gdXNlIHRoaXMgYXMgYSByZWZlcmVuY2UuLlxuICAgICogbWFrZU9wZXJhdGlvblJlYWR5IChzdGFydFNTLCBvcCkge1xuICAgICAgb3AgPSBZLlN0cnVjdFtvcC5zdHJ1Y3RdLmVuY29kZShvcClcbiAgICAgIG9wID0gWS51dGlscy5jb3B5T2JqZWN0KG9wKSAtLSB1c2UgY29weW9wZXJhdGlvbiBpbnN0ZWFkIG5vdyFcbiAgICAgIHZhciBvID0gb3BcbiAgICAgIHZhciBpZHMgPSBbb3AuaWRdXG4gICAgICAvLyBzZWFyY2ggZm9yIHRoZSBuZXcgb3AucmlnaHRcbiAgICAgIC8vIGl0IGlzIGVpdGhlciB0aGUgZmlyc3Qga25vd24gb3AgKGFjY29yZGluZyB0byBzdGFydFNTKVxuICAgICAgLy8gb3IgdGhlIG8gdGhhdCBoYXMgbm8gb3JpZ2luIHRvIHRoZSByaWdodCBvZiBvcFxuICAgICAgLy8gKHRoaXMgaXMgd2h5IHdlIHVzZSB0aGUgaWRzIGFycmF5KVxuICAgICAgd2hpbGUgKG8ucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgcmlnaHQgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5yaWdodClcbiAgICAgICAgaWYgKG8ucmlnaHRbMV0gPCAoc3RhcnRTU1tvLnJpZ2h0WzBdXSB8fCAwKSB8fCAhaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIFkudXRpbHMuY29tcGFyZUlkcyhpZCwgcmlnaHQub3JpZ2luKVxuICAgICAgICB9KSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWRzLnB1c2goby5yaWdodClcbiAgICAgICAgbyA9IHJpZ2h0XG4gICAgICB9XG4gICAgICBvcC5yaWdodCA9IG8ucmlnaHRcbiAgICAgIG9wLmxlZnQgPSBvcC5vcmlnaW5cbiAgICAgIHJldHVybiBvcFxuICAgIH1cbiAgICAqL1xuICAgICogZmx1c2ggKCkge1xuICAgICAgeWllbGQqIHRoaXMub3MuZmx1c2goKVxuICAgICAgeWllbGQqIHRoaXMuc3MuZmx1c2goKVxuICAgICAgeWllbGQqIHRoaXMuZHMuZmx1c2goKVxuICAgIH1cbiAgfVxuICBZLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb25JbnRlcmZhY2Vcbn1cbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuLypcbiAgRXZlbnRIYW5kbGVyIGlzIGFuIGhlbHBlciBjbGFzcyBmb3IgY29uc3RydWN0aW5nIGN1c3RvbSB0eXBlcy5cblxuICBXaHk6IFdoZW4gY29uc3RydWN0aW5nIGN1c3RvbSB0eXBlcywgeW91IHNvbWV0aW1lcyB3YW50IHlvdXIgdHlwZXMgdG8gd29ya1xuICBzeW5jaHJvbm91czogRS5nLlxuICBgYGAgU3luY2hyb25vdXNcbiAgICBteXR5cGUuc2V0U29tZXRoaW5nKFwieWF5XCIpXG4gICAgbXl0eXBlLmdldFNvbWV0aGluZygpID09PSBcInlheVwiXG4gIGBgYFxuICB2ZXJzdXNcbiAgYGBgIEFzeW5jaHJvbm91c1xuICAgIG15dHlwZS5zZXRTb21ldGhpbmcoXCJ5YXlcIilcbiAgICBteXR5cGUuZ2V0U29tZXRoaW5nKCkgPT09IHVuZGVmaW5lZFxuICAgIG15dHlwZS53YWl0Rm9yU29tZXRoaW5nKCkudGhlbihmdW5jdGlvbigpe1xuICAgICAgbXl0eXBlLmdldFNvbWV0aGluZygpID09PSBcInlheVwiXG4gICAgfSlcbiAgYGBgXG5cbiAgVGhlIHN0cnVjdHVyZXMgdXN1YWxseSB3b3JrIGFzeW5jaHJvbm91c2x5ICh5b3UgaGF2ZSB0byB3YWl0IGZvciB0aGVcbiAgZGF0YWJhc2UgcmVxdWVzdCB0byBmaW5pc2gpLiBFdmVudEhhbmRsZXIgaGVscHMgeW91IHRvIG1ha2UgeW91ciB0eXBlXG4gIHN5bmNocm9ub3VzLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFkgLyogOiBhbnkqLykge1xuICBZLnV0aWxzID0ge31cblxuICBjbGFzcyBFdmVudExpc3RlbmVySGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdXG4gICAgfVxuICAgIGRlc3Ryb3kgKCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG51bGxcbiAgICB9XG4gICAgIC8qXG4gICAgICBCYXNpYyBldmVudCBsaXN0ZW5lciBib2lsZXJwbGF0ZS4uLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lciAoZikge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5wdXNoKGYpXG4gICAgfVxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIgKGYpIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gZiAhPT0gZ1xuICAgICAgfSlcbiAgICB9XG4gICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgKCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdXG4gICAgfVxuICAgIGNhbGxFdmVudExpc3RlbmVycyAoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbaV0oZXZlbnQpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVc2VyIGV2ZW50cyBtdXN0IG5vdCB0aHJvdyBFcnJvcnMhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBZLnV0aWxzLkV2ZW50TGlzdGVuZXJIYW5kbGVyID0gRXZlbnRMaXN0ZW5lckhhbmRsZXJcblxuICBjbGFzcyBFdmVudEhhbmRsZXIgZXh0ZW5kcyBFdmVudExpc3RlbmVySGFuZGxlciB7XG4gICAgLyogOjpcbiAgICB3YWl0aW5nOiBBcnJheTxJbnNlcnRpb24gfCBEZWxldGlvbj47XG4gICAgYXdhaXRpbmc6IG51bWJlcjtcbiAgICBvbmV2ZW50OiBGdW5jdGlvbjtcbiAgICBldmVudExpc3RlbmVyczogQXJyYXk8RnVuY3Rpb24+O1xuICAgICovXG4gICAgLypcbiAgICAgIG9uZXZlbnQ6IGlzIGNhbGxlZCB3aGVuIHRoZSBzdHJ1Y3R1cmUgY2hhbmdlcy5cblxuICAgICAgTm90ZTogXCJhd2FpdGluZyBvcGVydGF0aW9uc1wiIGlzIHVzZWQgdG8gZGVub3RlIG9wZXJhdGlvbnMgdGhhdCB3ZXJlXG4gICAgICBwcmVtYXR1cmVseSBjYWxsZWQuIEV2ZW50cyBmb3IgcmVjZWl2ZWQgb3BlcmF0aW9ucyBjYW4gbm90IGJlIGV4ZWN1dGVkIHVudGlsXG4gICAgICBhbGwgcHJlbWF0dXJlbHkgY2FsbGVkIG9wZXJhdGlvbnMgd2VyZSBleGVjdXRlZCAoXCJ3YWl0aW5nIG9wZXJhdGlvbnNcIilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChvbmV2ZW50IC8qIDogRnVuY3Rpb24gKi8pIHtcbiAgICAgIHN1cGVyKClcbiAgICAgIHRoaXMud2FpdGluZyA9IFtdXG4gICAgICB0aGlzLmF3YWl0aW5nID0gMFxuICAgICAgdGhpcy5vbmV2ZW50ID0gb25ldmVudFxuICAgIH1cbiAgICBkZXN0cm95ICgpIHtcbiAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgICAgdGhpcy53YWl0aW5nID0gbnVsbFxuICAgICAgdGhpcy5hd2FpdGluZyA9IG51bGxcbiAgICAgIHRoaXMub25ldmVudCA9IG51bGxcbiAgICB9XG4gICAgLypcbiAgICAgIENhbGwgdGhpcyB3aGVuIGEgbmV3IG9wZXJhdGlvbiBhcnJpdmVzLiBJdCB3aWxsIGJlIGV4ZWN1dGVkIHJpZ2h0IGF3YXkgaWZcbiAgICAgIHRoZXJlIGFyZSBubyB3YWl0aW5nIG9wZXJhdGlvbnMsIHRoYXQgeW91IHByZW1hdHVyZWx5IGV4ZWN1dGVkXG4gICAgKi9cbiAgICByZWNlaXZlZE9wIChvcCkge1xuICAgICAgaWYgKHRoaXMuYXdhaXRpbmcgPD0gMCkge1xuICAgICAgICB0aGlzLm9uZXZlbnQob3ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhaXRpbmcucHVzaChvcClcbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgIFlvdSBjcmVhdGVkIHNvbWUgb3BlcmF0aW9ucywgYW5kIHlvdSB3YW50IHRoZSBgb25ldmVudGAgZnVuY3Rpb24gdG8gYmVcbiAgICAgIGNhbGxlZCByaWdodCBhd2F5LiBSZWNlaXZlZCBvcGVyYXRpb25zIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHVudGlsbCBhbGxcbiAgICAgIHByZW1hdHVyZWx5IGNhbGxlZCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZFxuICAgICovXG4gICAgYXdhaXRBbmRQcmVtYXR1cmVseUNhbGwgKG9wcykge1xuICAgICAgdGhpcy5hd2FpdGluZysrXG4gICAgICBvcHMubWFwKFkudXRpbHMuY29weU9wZXJhdGlvbikuZm9yRWFjaCh0aGlzLm9uZXZlbnQpXG4gICAgfVxuICAgICogYXdhaXRPcHMgKHRyYW5zYWN0aW9uLCBmLCBhcmdzKSB7XG4gICAgICBmdW5jdGlvbiBub3RTb1NtYXJ0U29ydCAoYXJyYXkpIHtcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBzb3J0cyBpbnNlcnRpb25zIGluIGEgZXhlY3V0YWJsZSBvcmRlclxuICAgICAgICB2YXIgcmVzdWx0ID0gW11cbiAgICAgICAgd2hpbGUgKGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXBlbmRlbnQgPSB0cnVlXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChZLnV0aWxzLm1hdGNoZXNJZChhcnJheVtqXSwgYXJyYXlbaV0ubGVmdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBhcnJheVtpXSBkZXBlbmRzIG9uIGFycmF5W2pdXG4gICAgICAgICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJheS5zcGxpY2UoaSwgMSlbMF0pXG4gICAgICAgICAgICAgIGktLVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICB2YXIgYmVmb3JlID0gdGhpcy53YWl0aW5nLmxlbmd0aFxuICAgICAgLy8gc29tZWhvdyBjcmVhdGUgbmV3IG9wZXJhdGlvbnNcbiAgICAgIHlpZWxkKiBmLmFwcGx5KHRyYW5zYWN0aW9uLCBhcmdzKVxuICAgICAgLy8gcmVtb3ZlIGFsbCBhcHBlbmRlZCBvcHMgLyBhd2FpdGVkIG9wc1xuICAgICAgdGhpcy53YWl0aW5nLnNwbGljZShiZWZvcmUpXG4gICAgICBpZiAodGhpcy5hd2FpdGluZyA+IDApIHRoaXMuYXdhaXRpbmctLVxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGF3YWl0ZWQgb3BzIGFueW1vcmUsIHdlIGNhbiB1cGRhdGUgYWxsIHdhaXRpbmcgb3BzLCBhbmQgc2VuZCBleGVjdXRlIHRoZW0gKGlmIHRoZXJlIGFyZSBzdGlsbCBubyBhd2FpdGVkIG9wcylcbiAgICAgIGlmICh0aGlzLmF3YWl0aW5nID09PSAwICYmIHRoaXMud2FpdGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBhbGwgd2FpdGluZyBvcHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndhaXRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMud2FpdGluZ1tpXVxuICAgICAgICAgIGlmIChvLnN0cnVjdCA9PT0gJ0luc2VydCcpIHtcbiAgICAgICAgICAgIHZhciBfbyA9IHlpZWxkKiB0cmFuc2FjdGlvbi5nZXRJbnNlcnRpb24oby5pZClcbiAgICAgICAgICAgIGlmICghWS51dGlscy5jb21wYXJlSWRzKF9vLmlkLCBvLmlkKSkge1xuICAgICAgICAgICAgICAvLyBvIGdvdCBleHRlbmRlZFxuICAgICAgICAgICAgICBvLmxlZnQgPSBbby5pZFswXSwgby5pZFsxXSAtIDFdXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9vLmxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBvLmxlZnQgPSBudWxsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBmaW5kIG5leHQgdW5kZWxldGVkIG9wXG4gICAgICAgICAgICAgIHZhciBsZWZ0ID0geWllbGQqIHRyYW5zYWN0aW9uLmdldEluc2VydGlvbihfby5sZWZ0KVxuICAgICAgICAgICAgICB3aGlsZSAobGVmdC5kZWxldGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGxlZnQgPSB5aWVsZCogdHJhbnNhY3Rpb24uZ2V0SW5zZXJ0aW9uKGxlZnQubGVmdClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG8ubGVmdCA9IGxlZnQgIT0gbnVsbCA/IFkudXRpbHMuZ2V0TGFzdElkKGxlZnQpIDogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc3R1ZmYgd2FzIGFzeW5jLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIGFnYWluIVxuICAgICAgICAvLyBXZSBhbHNvIHB1bGwgY2hhbmdlcyBmcm9tIHRoZSBiaW5kaW5ncywgaWYgdGhlcmUgZXhpc3RzIHN1Y2ggYSBtZXRob2QsIHRoaXMgY291bGQgaW5jcmVhc2UgYXdhaXRpbmcgdG9vXG4gICAgICAgIGlmICh0aGlzLl9wdWxsQ2hhbmdlcyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fcHVsbENoYW5nZXMoKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF3YWl0aW5nID09PSAwKSB7XG4gICAgICAgICAgLy8gc29ydCBieSB0eXBlLCBleGVjdXRlIGluc2VydHMgZmlyc3RcbiAgICAgICAgICB2YXIgaW5zID0gW11cbiAgICAgICAgICB2YXIgZGVscyA9IFtdXG4gICAgICAgICAgdGhpcy53YWl0aW5nLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGlmIChvLnN0cnVjdCA9PT0gJ0RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgZGVscy5wdXNoKG8pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnMucHVzaChvKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gcHV0IGluIGV4ZWN1dGFibGUgb3JkZXJcbiAgICAgICAgICBpbnMgPSBub3RTb1NtYXJ0U29ydChpbnMpXG4gICAgICAgICAgaW5zLmZvckVhY2godGhpcy5vbmV2ZW50KVxuICAgICAgICAgIGRlbHMuZm9yRWFjaCh0aGlzLm9uZXZlbnQpXG4gICAgICAgICAgdGhpcy53YWl0aW5nID0gW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgYXdhaXRlZEluc2VydHMgYW5kIGF3YWl0ZWREZWxldGVzIGluIGZhdm9yIG9mIGF3YWl0ZWRPcHMsIGFzIHRoZXkgYXJlIGRlcHJlY2F0ZWQgYW5kIGRvIG5vdCBhbHdheXMgd29ya1xuICAgIC8vIERvIHRoaXMgaW4gb25lIG9mIHRoZSBjb21pbmcgcmVsZWFzZXMgdGhhdCBhcmUgYnJlYWtpbmcgYW55d2F5XG4gICAgLypcbiAgICAgIENhbGwgdGhpcyB3aGVuIHlvdSBzdWNjZXNzZnVsbHkgYXdhaXRlZCB0aGUgZXhlY3V0aW9uIG9mIG4gSW5zZXJ0IG9wZXJhdGlvbnNcbiAgICAqL1xuICAgIGF3YWl0ZWRJbnNlcnRzIChuKSB7XG4gICAgICB2YXIgb3BzID0gdGhpcy53YWl0aW5nLnNwbGljZSh0aGlzLndhaXRpbmcubGVuZ3RoIC0gbilcbiAgICAgIGZvciAodmFyIG9pZCA9IDA7IG9pZCA8IG9wcy5sZW5ndGg7IG9pZCsrKSB7XG4gICAgICAgIHZhciBvcCA9IG9wc1tvaWRdXG4gICAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdJbnNlcnQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMud2FpdGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHcgPSB0aGlzLndhaXRpbmdbaV1cbiAgICAgICAgICAgIC8vIFRPRE86IGRvIEkgaGFuZGxlIHNwbGl0IG9wZXJhdGlvbnMgY29ycmVjdGx5IGhlcmU/IFN1cGVyIHVubGlrZWx5LCBidXQgeWVhaC4uXG4gICAgICAgICAgICAvLyBBbHNvOiBjYW4gdGhpcyBjYXNlIGhhcHBlbj8gQ2FuIG9wIGJlIGluc2VydGVkIGluIHRoZSBtaWRkbGUgb2YgYSBsYXJnZXIgb3AgdGhhdCBpcyBpbiAkd2FpdGluZz9cbiAgICAgICAgICAgIGlmICh3LnN0cnVjdCA9PT0gJ0luc2VydCcpIHtcbiAgICAgICAgICAgICAgaWYgKFkudXRpbHMubWF0Y2hlc0lkKHcsIG9wLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkZSB0aGUgZWZmZWN0IG9mIG9wIGluIHdcbiAgICAgICAgICAgICAgICB3LnJpZ2h0ID0gb3AuaWRcbiAgICAgICAgICAgICAgICAvLyBleGNsdWRlIHRoZSBlZmZlY3Qgb2YgdyBpbiBvcFxuICAgICAgICAgICAgICAgIG9wLmxlZnQgPSB3LmxlZnRcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChZLnV0aWxzLmNvbXBhcmVJZHMody5pZCwgb3AucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2ltaWxhci4uXG4gICAgICAgICAgICAgICAgdy5sZWZ0ID0gWS51dGlscy5nZXRMYXN0SWQob3ApXG4gICAgICAgICAgICAgICAgb3AucmlnaHQgPSB3LnJpZ2h0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBJbnNlcnQgT3BlcmF0aW9uIScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyeUNhbGxFdmVudHMobilcbiAgICB9XG4gICAgLypcbiAgICAgIENhbGwgdGhpcyB3aGVuIHlvdSBzdWNjZXNzZnVsbHkgYXdhaXRlZCB0aGUgZXhlY3V0aW9uIG9mIG4gRGVsZXRlIG9wZXJhdGlvbnNcbiAgICAqL1xuICAgIGF3YWl0ZWREZWxldGVzIChuLCBuZXdMZWZ0KSB7XG4gICAgICB2YXIgb3BzID0gdGhpcy53YWl0aW5nLnNwbGljZSh0aGlzLndhaXRpbmcubGVuZ3RoIC0gbilcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBkZWwgPSBvcHNbal1cbiAgICAgICAgaWYgKGRlbC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgaWYgKG5ld0xlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndhaXRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IHcgPSB0aGlzLndhaXRpbmdbaV1cbiAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBqdXN0IGNhcmUgYWJvdXQgdy5sZWZ0XG4gICAgICAgICAgICAgIGlmICh3LnN0cnVjdCA9PT0gJ0luc2VydCcgJiYgWS51dGlscy5jb21wYXJlSWRzKGRlbC50YXJnZXQsIHcubGVmdCkpIHtcbiAgICAgICAgICAgICAgICB3LmxlZnQgPSBuZXdMZWZ0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBEZWxldGUgT3BlcmF0aW9uIScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyeUNhbGxFdmVudHMobilcbiAgICB9XG4gICAgLyogKHByaXZhdGUpXG4gICAgICBUcnkgdG8gZXhlY3V0ZSB0aGUgZXZlbnRzIGZvciB0aGUgd2FpdGluZyBvcGVyYXRpb25zXG4gICAgKi9cbiAgICBfdHJ5Q2FsbEV2ZW50cyAoKSB7XG4gICAgICBmdW5jdGlvbiBub3RTb1NtYXJ0U29ydCAoYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgICAgIHdoaWxlIChhcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGVwZW5kZW50ID0gdHJ1ZVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoWS51dGlscy5tYXRjaGVzSWQoYXJyYXlbal0sIGFycmF5W2ldLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gYXJyYXlbaV0gZGVwZW5kcyBvbiBhcnJheVtqXVxuICAgICAgICAgICAgICAgIGluZGVwZW5kZW50ID0gZmFsc2VcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXBlbmRlbnQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXkuc3BsaWNlKGksIDEpWzBdKVxuICAgICAgICAgICAgICBpLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXdhaXRpbmcgPiAwKSB0aGlzLmF3YWl0aW5nLS1cbiAgICAgIGlmICh0aGlzLmF3YWl0aW5nID09PSAwICYmIHRoaXMud2FpdGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBpbnMgPSBbXVxuICAgICAgICB2YXIgZGVscyA9IFtdXG4gICAgICAgIHRoaXMud2FpdGluZy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgaWYgKG8uc3RydWN0ID09PSAnRGVsZXRlJykge1xuICAgICAgICAgICAgZGVscy5wdXNoKG8pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucy5wdXNoKG8pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBpbnMgPSBub3RTb1NtYXJ0U29ydChpbnMpXG4gICAgICAgIGlucy5mb3JFYWNoKHRoaXMub25ldmVudClcbiAgICAgICAgZGVscy5mb3JFYWNoKHRoaXMub25ldmVudClcbiAgICAgICAgdGhpcy53YWl0aW5nID0gW11cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgWS51dGlscy5FdmVudEhhbmRsZXIgPSBFdmVudEhhbmRsZXJcblxuICAvKlxuICAgIEEgd3JhcHBlciBmb3IgdGhlIGRlZmluaXRpb24gb2YgYSBjdXN0b20gdHlwZS5cbiAgICBFdmVyeSBjdXN0b20gdHlwZSBtdXN0IGhhdmUgdGhyZWUgcHJvcGVydGllczpcblxuICAgICogc3RydWN0XG4gICAgICAtIFN0cnVjdG5hbWUgb2YgdGhpcyB0eXBlXG4gICAgKiBpbml0VHlwZVxuICAgICAgLSBHaXZlbiBhIG1vZGVsLCBjcmVhdGVzIGEgY3VzdG9tIHR5cGVcbiAgICAqIGNsYXNzXG4gICAgICAtIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY3VzdG9tIHR5cGUgKGUuZy4gaW4gb3JkZXIgdG8gaW5oZXJpdCBmcm9tIGEgdHlwZSlcbiAgKi9cbiAgY2xhc3MgQ3VzdG9tVHlwZSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAvKiA6OlxuICAgIHN0cnVjdDogYW55O1xuICAgIGluaXRUeXBlOiBhbnk7XG4gICAgY2xhc3M6IEZ1bmN0aW9uO1xuICAgIG5hbWU6IFN0cmluZztcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChkZWYpIHtcbiAgICAgIGlmIChkZWYuc3RydWN0ID09IG51bGwgfHxcbiAgICAgICAgZGVmLmluaXRUeXBlID09IG51bGwgfHxcbiAgICAgICAgZGVmLmNsYXNzID09IG51bGwgfHxcbiAgICAgICAgZGVmLm5hbWUgPT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIHR5cGUgd2FzIG5vdCBpbml0aWFsaXplZCBjb3JyZWN0bHkhJylcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RydWN0ID0gZGVmLnN0cnVjdFxuICAgICAgdGhpcy5pbml0VHlwZSA9IGRlZi5pbml0VHlwZVxuICAgICAgdGhpcy5jbGFzcyA9IGRlZi5jbGFzc1xuICAgICAgdGhpcy5uYW1lID0gZGVmLm5hbWVcbiAgICAgIGlmIChkZWYuYXBwZW5kQWRkaXRpb25hbEluZm8gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFwcGVuZEFkZGl0aW9uYWxJbmZvID0gZGVmLmFwcGVuZEFkZGl0aW9uYWxJbmZvXG4gICAgICB9XG4gICAgICB0aGlzLnBhcnNlQXJndW1lbnRzID0gKGRlZi5wYXJzZUFyZ3VtZW50cyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpc11cbiAgICAgIH0pLmJpbmQodGhpcylcbiAgICAgIHRoaXMucGFyc2VBcmd1bWVudHMudHlwZURlZmluaXRpb24gPSB0aGlzXG4gICAgfVxuICB9XG4gIFkudXRpbHMuQ3VzdG9tVHlwZSA9IEN1c3RvbVR5cGVcblxuICBZLnV0aWxzLmlzVHlwZURlZmluaXRpb24gPSBmdW5jdGlvbiBpc1R5cGVEZWZpbml0aW9uICh2KSB7XG4gICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBZLnV0aWxzLkN1c3RvbVR5cGUpIHJldHVybiBbdl1cbiAgICAgIGVsc2UgaWYgKHYuY29uc3RydWN0b3IgPT09IEFycmF5ICYmIHZbMF0gaW5zdGFuY2VvZiBZLnV0aWxzLkN1c3RvbVR5cGUpIHJldHVybiB2XG4gICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgdi50eXBlRGVmaW5pdGlvbiBpbnN0YW5jZW9mIFkudXRpbHMuQ3VzdG9tVHlwZSkgcmV0dXJuIFt2LnR5cGVEZWZpbml0aW9uXVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qXG4gICAgTWFrZSBhIGZsYXQgY29weSBvZiBhbiBvYmplY3RcbiAgICAoanVzdCBjb3B5IHByb3BlcnRpZXMpXG4gICovXG4gIGZ1bmN0aW9uIGNvcHlPYmplY3QgKG8pIHtcbiAgICB2YXIgYyA9IHt9XG4gICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgIGNba2V5XSA9IG9ba2V5XVxuICAgIH1cbiAgICByZXR1cm4gY1xuICB9XG4gIFkudXRpbHMuY29weU9iamVjdCA9IGNvcHlPYmplY3RcblxuICAvKlxuICAgIENvcHkgYW4gb3BlcmF0aW9uLCBzbyB0aGF0IGl0IGNhbiBiZSBtYW5pcHVsYXRlZC5cbiAgICBOb3RlOiBZb3UgbXVzdCBub3QgY2hhbmdlIHN1YnByb3BlcnRpZXMgKGV4Y2VwdCBvLmNvbnRlbnQpIVxuICAqL1xuICBmdW5jdGlvbiBjb3B5T3BlcmF0aW9uIChvKSB7XG4gICAgbyA9IGNvcHlPYmplY3QobylcbiAgICBpZiAoby5jb250ZW50ICE9IG51bGwpIHtcbiAgICAgIG8uY29udGVudCA9IG8uY29udGVudC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgfSlcbiAgICB9XG4gICAgcmV0dXJuIG9cbiAgfVxuXG4gIFkudXRpbHMuY29weU9wZXJhdGlvbiA9IGNvcHlPcGVyYXRpb25cblxuICAvKlxuICAgIERlZmluZXMgYSBzbWFsbGVyIHJlbGF0aW9uIG9uIElkJ3NcbiAgKi9cbiAgZnVuY3Rpb24gc21hbGxlciAoYSwgYikge1xuICAgIHJldHVybiBhWzBdIDwgYlswXSB8fCAoYVswXSA9PT0gYlswXSAmJiAoYVsxXSA8IGJbMV0gfHwgdHlwZW9mIGFbMV0gPCB0eXBlb2YgYlsxXSkpXG4gIH1cbiAgWS51dGlscy5zbWFsbGVyID0gc21hbGxlclxuXG4gIGZ1bmN0aW9uIGluRGVsZXRpb25SYW5nZSAoZGVsLCBpbnMpIHtcbiAgICByZXR1cm4gZGVsLnRhcmdldFswXSA9PT0gaW5zWzBdICYmIGRlbC50YXJnZXRbMV0gPD0gaW5zWzFdICYmIGluc1sxXSA8IGRlbC50YXJnZXRbMV0gKyAoZGVsLmxlbmd0aCB8fCAxKVxuICB9XG4gIFkudXRpbHMuaW5EZWxldGlvblJhbmdlID0gaW5EZWxldGlvblJhbmdlXG5cbiAgZnVuY3Rpb24gY29tcGFyZUlkcyAoaWQxLCBpZDIpIHtcbiAgICBpZiAoaWQxID09IG51bGwgfHwgaWQyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpZDEgPT09IGlkMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaWQxWzBdID09PSBpZDJbMF0gJiYgaWQxWzFdID09PSBpZDJbMV1cbiAgICB9XG4gIH1cbiAgWS51dGlscy5jb21wYXJlSWRzID0gY29tcGFyZUlkc1xuXG4gIGZ1bmN0aW9uIG1hdGNoZXNJZCAob3AsIGlkKSB7XG4gICAgaWYgKGlkID09IG51bGwgfHwgb3AgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlkID09PSBvcFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaWRbMF0gPT09IG9wLmlkWzBdKSB7XG4gICAgICAgIGlmIChvcC5jb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gaWRbMV0gPT09IG9wLmlkWzFdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlkWzFdID49IG9wLmlkWzFdICYmIGlkWzFdIDwgb3AuaWRbMV0gKyBvcC5jb250ZW50Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFkudXRpbHMubWF0Y2hlc0lkID0gbWF0Y2hlc0lkXG5cbiAgZnVuY3Rpb24gZ2V0TGFzdElkIChvcCkge1xuICAgIGlmIChvcC5jb250ZW50ID09IG51bGwgfHwgb3AuY29udGVudC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBvcC5pZFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW29wLmlkWzBdLCBvcC5pZFsxXSArIG9wLmNvbnRlbnQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbiAgWS51dGlscy5nZXRMYXN0SWQgPSBnZXRMYXN0SWRcblxuICBmdW5jdGlvbiBjcmVhdGVFbXB0eU9wc0FycmF5IChuKSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkobilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFbaV0gPSB7XG4gICAgICAgIGlkOiBbbnVsbCwgbnVsbF1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNtYWxsTG9va3VwQnVmZmVyIChTdG9yZSkge1xuICAgIC8qXG4gICAgICBUaGlzIGJ1ZmZlciBpbXBsZW1lbnRzIGEgdmVyeSBzbWFsbCBidWZmZXIgdGhhdCB0ZW1wb3JhcmlseSBzdG9yZXMgb3BlcmF0aW9uc1xuICAgICAgYWZ0ZXIgdGhleSBhcmUgcmVhZCAvIGJlZm9yZSB0aGV5IGFyZSB3cml0dGVuLlxuICAgICAgVGhlIGJ1ZmZlciBiYXNpY2FsbHkgaW1wbGVtZW50cyBGSUZPLiBPZnRlbiByZXF1ZXN0ZWQgbG9va3VwcyB3aWxsIGJlIHJlLXF1ZXVlZCBldmVyeSB0aW1lIHRoZXkgYXJlIGxvb2tlZCB1cCAvIHdyaXR0ZW4uXG5cbiAgICAgIEl0IGNhbiBzcGVlZCB1cCBsb29rdXBzIG9uIE9wZXJhdGlvbiBTdG9yZXMgYW5kIFN0YXRlIFN0b3Jlcy4gQnV0IGl0IGRvZXMgbm90IHJlcXVpcmUgbm90YWJsZSB1c2Ugb2YgbWVtb3J5IG9yIHByb2Nlc3NpbmcgcG93ZXIuXG5cbiAgICAgIEdvb2QgZm9yIG9zIGFuZCBzcywgYm90IG5vdCBmb3IgZHMgKGJlY2F1c2UgaXQgb2Z0ZW4gdXNlcyBtZXRob2RzIHRoYXQgcmVxdWlyZSBhIGZsdXNoKVxuXG4gICAgICBJIHRyaWVkIHRvIG9wdGltaXplIHRoaXMgZm9yIHBlcmZvcm1hbmNlLCB0aGVyZWZvcmUgbm8gaGlnaGxldmVsIG9wZXJhdGlvbnMuXG4gICAgKi9cbiAgICBjbGFzcyBTbWFsbExvb2t1cEJ1ZmZlciBleHRlbmRzIFN0b3JlIHtcbiAgICAgIGNvbnN0cnVjdG9yIChhcmcxLCBhcmcyKSB7XG4gICAgICAgIC8vIHN1cGVyKC4uLmFyZ3VtZW50cykgLS0gZG8gdGhpcyB3aGVuIHRoaXMgaXMgc3VwcG9ydGVkIGJ5IHN0YWJsZSBub2RlanNcbiAgICAgICAgc3VwZXIoYXJnMSwgYXJnMilcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IGNyZWF0ZUVtcHR5T3BzQXJyYXkoNSlcbiAgICAgICAgdGhpcy5yZWFkQnVmZmVyID0gY3JlYXRlRW1wdHlPcHNBcnJheSgxMClcbiAgICAgIH1cbiAgICAgICogZmluZCAoaWQsIG5vU3VwZXJDYWxsKSB7XG4gICAgICAgIHZhciBpLCByXG4gICAgICAgIGZvciAoaSA9IHRoaXMucmVhZEJ1ZmZlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHIgPSB0aGlzLnJlYWRCdWZmZXJbaV1cbiAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIHVzZSBjb21wYXJlaWRzLCBiZWNhdXNlIGlkIGlzIGFsd2F5cyBkZWZpbmVkIVxuICAgICAgICAgIGlmIChyLmlkWzFdID09PSBpZFsxXSAmJiByLmlkWzBdID09PSBpZFswXSkge1xuICAgICAgICAgICAgLy8gZm91bmQgclxuICAgICAgICAgICAgLy8gbW92ZSByIHRvIHRoZSBlbmQgb2YgcmVhZEJ1ZmZlclxuICAgICAgICAgICAgZm9yICg7IGkgPCB0aGlzLnJlYWRCdWZmZXIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlcltpXSA9IHRoaXMucmVhZEJ1ZmZlcltpICsgMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlclt0aGlzLnJlYWRCdWZmZXIubGVuZ3RoIC0gMV0gPSByXG4gICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb1xuICAgICAgICBmb3IgKGkgPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgciA9IHRoaXMud3JpdGVCdWZmZXJbaV1cbiAgICAgICAgICBpZiAoci5pZFsxXSA9PT0gaWRbMV0gJiYgci5pZFswXSA9PT0gaWRbMF0pIHtcbiAgICAgICAgICAgIG8gPSByXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDAgJiYgbm9TdXBlckNhbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGRpZCBub3QgcmVhY2ggYnJlYWsgaW4gbGFzdCBsb29wXG4gICAgICAgICAgLy8gcmVhZCBpZCBhbmQgcHV0IGl0IHRvIHRoZSBlbmQgb2YgcmVhZEJ1ZmZlclxuICAgICAgICAgIG8gPSB5aWVsZCogc3VwZXIuZmluZChpZClcbiAgICAgICAgfVxuICAgICAgICBpZiAobyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVhZEJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlcltpXSA9IHRoaXMucmVhZEJ1ZmZlcltpICsgMV1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZWFkQnVmZmVyW3RoaXMucmVhZEJ1ZmZlci5sZW5ndGggLSAxXSA9IG9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb1xuICAgICAgfVxuICAgICAgKiBwdXQgKG8pIHtcbiAgICAgICAgdmFyIGlkID0gby5pZFxuICAgICAgICB2YXIgaSwgciAvLyBoZWxwZXIgdmFyaWFibGVzXG4gICAgICAgIGZvciAoaSA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICByID0gdGhpcy53cml0ZUJ1ZmZlcltpXVxuICAgICAgICAgIGlmIChyLmlkWzFdID09PSBpZFsxXSAmJiByLmlkWzBdID09PSBpZFswXSkge1xuICAgICAgICAgICAgLy8gaXMgYWxyZWFkeSBpbiBidWZmZXJcbiAgICAgICAgICAgIC8vIGZvcmdldCByLCBhbmQgbW92ZSBvIHRvIHRoZSBlbmQgb2Ygd3JpdGVCdWZmZXJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcltpXSA9IHRoaXMud3JpdGVCdWZmZXJbaSArIDFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyW3RoaXMud3JpdGVCdWZmZXIubGVuZ3RoIC0gMV0gPSBvXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAvLyBkaWQgbm90IHJlYWNoIGJyZWFrIGluIGxhc3QgbG9vcFxuICAgICAgICAgIC8vIHdyaXRlIHdyaXRlQnVmZmVyWzBdXG4gICAgICAgICAgdmFyIHdyaXRlID0gdGhpcy53cml0ZUJ1ZmZlclswXVxuICAgICAgICAgIGlmICh3cml0ZS5pZFswXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgeWllbGQqIHN1cGVyLnB1dCh3cml0ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcHV0IG8gdG8gdGhlIGVuZCBvZiB3cml0ZUJ1ZmZlclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcltpXSA9IHRoaXMud3JpdGVCdWZmZXJbaSArIDFdXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXJbdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggLSAxXSA9IG9cbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayByZWFkQnVmZmVyIGZvciBldmVyeSBvY2N1cmVuY2Ugb2Ygby5pZCwgb3ZlcndyaXRlIGlmIGZvdW5kXG4gICAgICAgIC8vIHdoZXRoZXIgZm91bmQgb3Igbm90LCB3ZSdsbCBhcHBlbmQgbyB0byB0aGUgcmVhZGJ1ZmZlclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWFkQnVmZmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHIgPSB0aGlzLnJlYWRCdWZmZXJbaSArIDFdXG4gICAgICAgICAgaWYgKHIuaWRbMV0gPT09IGlkWzFdICYmIHIuaWRbMF0gPT09IGlkWzBdKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRCdWZmZXJbaV0gPSBvXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlcltpXSA9IHJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkQnVmZmVyW3RoaXMucmVhZEJ1ZmZlci5sZW5ndGggLSAxXSA9IG9cbiAgICAgIH1cbiAgICAgICogZGVsZXRlIChpZCkge1xuICAgICAgICB2YXIgaSwgclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWFkQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgciA9IHRoaXMucmVhZEJ1ZmZlcltpXVxuICAgICAgICAgIGlmIChyLmlkWzFdID09PSBpZFsxXSAmJiByLmlkWzBdID09PSBpZFswXSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkQnVmZmVyW2ldID0ge1xuICAgICAgICAgICAgICBpZDogW251bGwsIG51bGxdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgeWllbGQqIHN1cGVyLmRlbGV0ZShpZClcbiAgICAgIH1cbiAgICAgICogZmluZFdpdGhMb3dlckJvdW5kIChpZCkge1xuICAgICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLmZpbmQoaWQsIHRydWUpXG4gICAgICAgIGlmIChvICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgICByZXR1cm4geWllbGQqIHN1cGVyLmZpbmRXaXRoTG93ZXJCb3VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICogZmluZFdpdGhVcHBlckJvdW5kIChpZCkge1xuICAgICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLmZpbmQoaWQsIHRydWUpXG4gICAgICAgIGlmIChvICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgICByZXR1cm4geWllbGQqIHN1cGVyLmZpbmRXaXRoVXBwZXJCb3VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICogZmluZE5leHQgKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5mbHVzaCgpXG4gICAgICAgIHJldHVybiB5aWVsZCogc3VwZXIuZmluZE5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgKiBmaW5kUHJldiAoKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgcmV0dXJuIHlpZWxkKiBzdXBlci5maW5kUHJldi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgICAqIGl0ZXJhdGUgKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5mbHVzaCgpXG4gICAgICAgIHlpZWxkKiBzdXBlci5pdGVyYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgICogZmx1c2ggKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgd3JpdGUgPSB0aGlzLndyaXRlQnVmZmVyW2ldXG4gICAgICAgICAgaWYgKHdyaXRlLmlkWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICB5aWVsZCogc3VwZXIucHV0KHdyaXRlKVxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcltpXSA9IHtcbiAgICAgICAgICAgICAgaWQ6IFtudWxsLCBudWxsXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU21hbGxMb29rdXBCdWZmZXJcbiAgfVxuICBZLnV0aWxzLmNyZWF0ZVNtYWxsTG9va3VwQnVmZmVyID0gY3JlYXRlU21hbGxMb29rdXBCdWZmZXJcbn1cbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi9Db25uZWN0b3IuanMnKShZKVxucmVxdWlyZSgnLi9EYXRhYmFzZS5qcycpKFkpXG5yZXF1aXJlKCcuL1RyYW5zYWN0aW9uLmpzJykoWSlcbnJlcXVpcmUoJy4vU3RydWN0LmpzJykoWSlcbnJlcXVpcmUoJy4vVXRpbHMuanMnKShZKVxucmVxdWlyZSgnLi9Db25uZWN0b3JzL1Rlc3QuanMnKShZKVxuXG52YXIgcmVxdWlyaW5nTW9kdWxlcyA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gWVxuWS5yZXF1aXJpbmdNb2R1bGVzID0gcmVxdWlyaW5nTW9kdWxlc1xuXG5ZLmV4dGVuZCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBZLnV0aWxzLkN1c3RvbVR5cGUpIHtcbiAgICBZW25hbWVdID0gdmFsdWUucGFyc2VBcmd1bWVudHNcbiAgfSBlbHNlIHtcbiAgICBZW25hbWVdID0gdmFsdWVcbiAgfVxuICBpZiAocmVxdWlyaW5nTW9kdWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgcmVxdWlyaW5nTW9kdWxlc1tuYW1lXS5yZXNvbHZlKClcbiAgICBkZWxldGUgcmVxdWlyaW5nTW9kdWxlc1tuYW1lXVxuICB9XG59XG5cblkucmVxdWVzdE1vZHVsZXMgPSByZXF1ZXN0TW9kdWxlc1xuZnVuY3Rpb24gcmVxdWVzdE1vZHVsZXMgKG1vZHVsZXMpIHtcbiAgLy8gZGV0ZXJtaW5lIGlmIHRoaXMgbW9kdWxlIHdhcyBjb21waWxlZCBmb3IgZXM1IG9yIGVzNiAoeS5qcyB2cy4geS5lczYpXG4gIC8vIGlmIEluc2VydC5leGVjdXRlIGlzIGEgRnVuY3Rpb24sIHRoZW4gaXQgaXNudCBhIGdlbmVyYXRvci4uXG4gIC8vIHRoZW4gbG9hZCB0aGUgZXM1KC5qcykgZmlsZXMuLlxuICB2YXIgZXh0ZW50aW9uID0gdHlwZW9mIHJlZ2VuZXJhdG9yUnVudGltZSAhPT0gJ3VuZGVmaW5lZCcgPyAnLmpzJyA6ICcuZXM2J1xuICB2YXIgcHJvbWlzZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1tpXS5zcGxpdCgnKCcpWzBdXG4gICAgdmFyIG1vZHVsZW5hbWUgPSAneS0nICsgbW9kdWxlLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoWVttb2R1bGVdID09IG51bGwpIHtcbiAgICAgIGlmIChyZXF1aXJpbmdNb2R1bGVzW21vZHVsZV0gPT0gbnVsbCkge1xuICAgICAgICAvLyBtb2R1bGUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ZICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciBpbXBvcnRlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICAgICAgaW1wb3J0ZWQuc3JjID0gWS5zb3VyY2VEaXIgKyAnLycgKyBtb2R1bGVuYW1lICsgJy8nICsgbW9kdWxlbmFtZSArIGV4dGVudGlvblxuICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoaW1wb3J0ZWQpXG5cbiAgICAgICAgICBsZXQgcmVxdWlyZU1vZHVsZSA9IHt9XG4gICAgICAgICAgcmVxdWlyaW5nTW9kdWxlc1ttb2R1bGVdID0gcmVxdWlyZU1vZHVsZVxuICAgICAgICAgIHJlcXVpcmVNb2R1bGUucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXF1aXJlTW9kdWxlLnJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHJlcXVpcmVNb2R1bGUucHJvbWlzZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJ1lKUzogUGxlYXNlIGRvIG5vdCBkZXBlbmQgb24gYXV0b21hdGljIHJlcXVpcmluZyBvZiBtb2R1bGVzIGFueW1vcmUhIEV4dGVuZCBtb2R1bGVzIGFzIGZvbGxvd3MgYHJlcXVpcmUoXFwneS1tb2R1bGVuYW1lXFwnKShZKWAnKVxuICAgICAgICAgIHJlcXVpcmUobW9kdWxlbmFtZSkoWSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChyZXF1aXJpbmdNb2R1bGVzW21vZHVsZXNbaV1dLnByb21pc2UpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbn1cblxuLyogOjpcbnR5cGUgTWVtb3J5T3B0aW9ucyA9IHtcbiAgbmFtZTogJ21lbW9yeSdcbn1cbnR5cGUgSW5kZXhlZERCT3B0aW9ucyA9IHtcbiAgbmFtZTogJ2luZGV4ZWRkYicsXG4gIG5hbWVzcGFjZTogc3RyaW5nXG59XG50eXBlIERiT3B0aW9ucyA9IE1lbW9yeU9wdGlvbnMgfCBJbmRleGVkREJPcHRpb25zXG5cbnR5cGUgV2ViUlRDT3B0aW9ucyA9IHtcbiAgbmFtZTogJ3dlYnJ0YycsXG4gIHJvb206IHN0cmluZ1xufVxudHlwZSBXZWJzb2NrZXRzQ2xpZW50T3B0aW9ucyA9IHtcbiAgbmFtZTogJ3dlYnNvY2tldHMtY2xpZW50JyxcbiAgcm9vbTogc3RyaW5nXG59XG50eXBlIENvbm5lY3Rpb25PcHRpb25zID0gV2ViUlRDT3B0aW9ucyB8IFdlYnNvY2tldHNDbGllbnRPcHRpb25zXG5cbnR5cGUgWU9wdGlvbnMgPSB7XG4gIGNvbm5lY3RvcjogQ29ubmVjdGlvbk9wdGlvbnMsXG4gIGRiOiBEYk9wdGlvbnMsXG4gIHR5cGVzOiBBcnJheTxUeXBlTmFtZT4sXG4gIHNvdXJjZURpcjogc3RyaW5nLFxuICBzaGFyZToge1trZXk6IHN0cmluZ106IFR5cGVOYW1lfVxufVxuKi9cblxuZnVuY3Rpb24gWSAob3B0cy8qIDpZT3B0aW9ucyAqLykgLyogOlByb21pc2U8WUNvbmZpZz4gKi8ge1xuICBvcHRzLnR5cGVzID0gb3B0cy50eXBlcyAhPSBudWxsID8gb3B0cy50eXBlcyA6IFtdXG4gIHZhciBtb2R1bGVzID0gW29wdHMuZGIubmFtZSwgb3B0cy5jb25uZWN0b3IubmFtZV0uY29uY2F0KG9wdHMudHlwZXMpXG4gIGZvciAodmFyIG5hbWUgaW4gb3B0cy5zaGFyZSkge1xuICAgIG1vZHVsZXMucHVzaChvcHRzLnNoYXJlW25hbWVdKVxuICB9XG4gIFkuc291cmNlRGlyID0gb3B0cy5zb3VyY2VEaXJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIFkucmVxdWVzdE1vZHVsZXMobW9kdWxlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRzID09IG51bGwpIHJlamVjdCgnQW4gb3B0aW9ucyBvYmplY3QgaXMgZXhwZWN0ZWQhICcpXG4gICAgICAgIGVsc2UgaWYgKG9wdHMuY29ubmVjdG9yID09IG51bGwpIHJlamVjdCgnWW91IG11c3Qgc3BlY2lmeSBhIGNvbm5lY3RvciEgKG1pc3NpbmcgY29ubmVjdG9yIHByb3BlcnR5KScpXG4gICAgICAgIGVsc2UgaWYgKG9wdHMuY29ubmVjdG9yLm5hbWUgPT0gbnVsbCkgcmVqZWN0KCdZb3UgbXVzdCBzcGVjaWZ5IGNvbm5lY3RvciBuYW1lISAobWlzc2luZyBjb25uZWN0b3IubmFtZSBwcm9wZXJ0eSknKVxuICAgICAgICBlbHNlIGlmIChvcHRzLmRiID09IG51bGwpIHJlamVjdCgnWW91IG11c3Qgc3BlY2lmeSBhIGRhdGFiYXNlISAobWlzc2luZyBkYiBwcm9wZXJ0eSknKVxuICAgICAgICBlbHNlIGlmIChvcHRzLmNvbm5lY3Rvci5uYW1lID09IG51bGwpIHJlamVjdCgnWW91IG11c3Qgc3BlY2lmeSBkYiBuYW1lISAobWlzc2luZyBkYi5uYW1lIHByb3BlcnR5KScpXG4gICAgICAgIGVsc2UgaWYgKG9wdHMuc2hhcmUgPT0gbnVsbCkgcmVqZWN0KCdZb3UgbXVzdCBzcGVjaWZ5IGEgc2V0IG9mIHNoYXJlZCB0eXBlcyEnKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgeWNvbmZpZyA9IG5ldyBZQ29uZmlnKG9wdHMpXG4gICAgICAgICAgeWNvbmZpZy5kYi53aGVuVXNlcklkU2V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHljb25maWcuaW5pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoeWNvbmZpZylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2gocmVqZWN0KVxuICAgIH0sIDApXG4gIH0pXG59XG5cbmNsYXNzIFlDb25maWcge1xuICAvKiA6OlxuICBkYjogWS5BYnN0cmFjdERhdGFiYXNlO1xuICBjb25uZWN0b3I6IFkuQWJzdHJhY3RDb25uZWN0b3I7XG4gIHNoYXJlOiB7W2tleTogc3RyaW5nXTogYW55fTtcbiAgb3B0aW9uczogT2JqZWN0O1xuICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRzXG4gICAgdGhpcy5kYiA9IG5ldyBZW29wdHMuZGIubmFtZV0odGhpcywgb3B0cy5kYilcbiAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBZW29wdHMuY29ubmVjdG9yLm5hbWVdKHRoaXMsIG9wdHMuY29ubmVjdG9yKVxuICB9XG4gIGluaXQgKGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnNcbiAgICB2YXIgc2hhcmUgPSB7fVxuICAgIHRoaXMuc2hhcmUgPSBzaGFyZVxuICAgIHRoaXMuZGIucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICogcmVxdWVzdFRyYW5zYWN0aW9uICgpIHtcbiAgICAgIC8vIGNyZWF0ZSBzaGFyZWQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eW5hbWUgaW4gb3B0cy5zaGFyZSkge1xuICAgICAgICB2YXIgdHlwZUNvbnN0cnVjdG9yID0gb3B0cy5zaGFyZVtwcm9wZXJ0eW5hbWVdLnNwbGl0KCcoJylcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdHlwZUNvbnN0cnVjdG9yLnNwbGljZSgwLCAxKVxuICAgICAgICB2YXIgYXJncyA9IFtdXG4gICAgICAgIGlmICh0eXBlQ29uc3RydWN0b3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFyZ3MgPSBKU09OLnBhcnNlKCdbJyArIHR5cGVDb25zdHJ1Y3RvclswXS5zcGxpdCgnKScpWzBdICsgJ10nKVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FzIG5vdCBhYmxlIHRvIHBhcnNlIHR5cGUgZGVmaW5pdGlvbiEgKHNoYXJlLicgKyBwcm9wZXJ0eW5hbWUgKyAnKScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gWVt0eXBlTmFtZV1cbiAgICAgICAgdmFyIHR5cGVkZWYgPSB0eXBlLnR5cGVEZWZpbml0aW9uXG4gICAgICAgIHZhciBpZCA9IFsnXycsIHR5cGVkZWYuc3RydWN0ICsgJ18nICsgdHlwZU5hbWUgKyAnXycgKyBwcm9wZXJ0eW5hbWUgKyAnXycgKyB0eXBlQ29uc3RydWN0b3JdXG4gICAgICAgIHNoYXJlW3Byb3BlcnR5bmFtZV0gPSB5aWVsZCogdGhpcy5jcmVhdGVUeXBlKHR5cGUuYXBwbHkodHlwZWRlZiwgYXJncyksIGlkKVxuICAgICAgfVxuICAgICAgdGhpcy5zdG9yZS53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKVxuICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICB9KVxuICB9XG4gIGlzQ29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IuaXNTeW5jZWRcbiAgfVxuICBkaXNjb25uZWN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpXG4gIH1cbiAgcmVjb25uZWN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IucmVjb25uZWN0KClcbiAgfVxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0b3IuZGVzdHJveSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rvci5kZXN0cm95KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpXG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMuZGIucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICogKCkge1xuICAgICAgeWllbGQqIHNlbGYuZGIuZGVzdHJveSgpXG4gICAgICBzZWxmLmNvbm5lY3RvciA9IG51bGxcbiAgICAgIHNlbGYuZGIgPSBudWxsXG4gICAgfSlcbiAgfVxufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93LlkgPSBZXG59XG4iLCIvKipcbiAqIEdpdmVuIGEgbnVtYmVyLCByZXR1cm4gYSB6ZXJvLWZpbGxlZCBzdHJpbmcuXG4gKiBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI2NzI4My9cbiAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gbnVtYmVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gemVyb0ZpbGwgKHdpZHRoLCBudW1iZXIsIHBhZCkge1xuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG51bWJlciwgcGFkKSB7XG4gICAgICByZXR1cm4gemVyb0ZpbGwod2lkdGgsIG51bWJlciwgcGFkKVxuICAgIH1cbiAgfVxuICBpZiAocGFkID09PSB1bmRlZmluZWQpIHBhZCA9ICcwJ1xuICB3aWR0aCAtPSBudW1iZXIudG9TdHJpbmcoKS5sZW5ndGhcbiAgaWYgKHdpZHRoID4gMCkgcmV0dXJuIG5ldyBBcnJheSh3aWR0aCArICgvXFwuLy50ZXN0KG51bWJlcikgPyAyIDogMSkpLmpvaW4ocGFkKSArIG51bWJlclxuICByZXR1cm4gbnVtYmVyICsgJydcbn1cbiJdfQ==
